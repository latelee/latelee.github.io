<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>迟思堂随笔</title>
  
  <subtitle>李迟的技术主页</subtitle>
  <link href="http://www.latelee.org/atom.xml" rel="self"/>
  
  <link href="http://www.latelee.org/"/>
  <updated>2021-09-06T14:40:30.034Z</updated>
  <id>http://www.latelee.org/</id>
  
  <author>
    <name>李迟</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>李迟2021年8月知识总结</title>
    <link href="http://www.latelee.org/my-library/code-for-2021-08.html"/>
    <id>http://www.latelee.org/my-library/code-for-2021-08.html</id>
    <published>2021-08-31T15:40:00.000Z</published>
    <updated>2021-09-06T14:40:30.034Z</updated>
    
    <content type="html"><![CDATA[<p>本文为 2021 年 8 月知识总结。</p><span id="more"></span><h2 id="编码总结"><a href="#编码总结" class="headerlink" title="编码总结"></a>编码总结</h2><h3 id="C-C"><a href="#C-C" class="headerlink" title="C / C++"></a>C / C++</h3><p>产生随机数示例二则。<br>产生给出范围，并指定数量的随机数。即给定数组（实为向量），其内可预先定义有数值，也可以为空，产生随机数时，需保留原定义的数值（如有），且新的随机数不能与已有的数值相同，已有的值包括原定义的和新产生的。如已有数值 250，则该函数不能再生成 250 这个数。      </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 产生[a~b)之间 n 个随机数，且随机数不同</span><br><span class="line">// 注：包含a本身，但不包含b，当指定数量 n 大于[a~b)范围时，使用范围值</span><br><span class="line">// result可预先设置一些固定的值，即随机数一定包含那些值</span><br><span class="line">int genRandom(std::vector&lt;int&gt;&amp; result, int a, int b, int n)</span><br><span class="line">&#123;</span><br><span class="line">    int total = b - a;</span><br><span class="line">    if (n &gt; total) n = total;</span><br><span class="line"></span><br><span class="line">    int i = 0;</span><br><span class="line">    bool found = false;</span><br><span class="line">    // 注：使用tmp临时保存，如直接用result，得到的容量会多一些</span><br><span class="line">    std::vector&lt;int&gt; tmp;</span><br><span class="line">    tmp.resize(n);</span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        //公式：a + rand() % n，其中n为整数的范围，a为起始值</span><br><span class="line">        tmp[i] =  a + rand() % total;</span><br><span class="line">        // 将生成的值取已有的值对比，如不同，才保存</span><br><span class="line">        found = false;</span><br><span class="line">        for (int j = 0; j &lt; (int)result.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (tmp[i] == result[j])</span><br><span class="line">            &#123;</span><br><span class="line">                found = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!found)</span><br><span class="line">        &#123;</span><br><span class="line">            result.push_back(tmp[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &gt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅产生指定范围内的一个随机数。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int genRandom(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    int total = b - a;</span><br><span class="line"></span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    </span><br><span class="line">    return a + rand() % total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串分割示例。<br>自动去掉字符串前后空格，自动去掉不合法的分隔方式。如：<code>|| 11 |22|33||</code>，原字符串前后分隔符多余，而第字符串有空格。本函数能解析出<code>11、22、33</code>三个有效字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">std::string&amp; trim(std::string &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">    if (s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s.erase(0, s.find_first_not_of(&quot; &quot;));</span><br><span class="line">    s.erase(s.find_last_not_of(&quot; &quot;) + 1);</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line">void splitString(std::vector &lt;std::string&gt; &amp;elems, const std::string &amp; s, const std::string &amp; delim)</span><br><span class="line">&#123;</span><br><span class="line">    // std::vector &lt; std::string &gt; elems;</span><br><span class="line">    size_t pos = 0;</span><br><span class="line">    size_t len = s.length();</span><br><span class="line">    size_t delim_len = delim.length();</span><br><span class="line"></span><br><span class="line">    std::string tmp;</span><br><span class="line">    if (delim_len == 0)</span><br><span class="line">        return;</span><br><span class="line">    while (pos &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        int find_pos = s.find(delim, pos);</span><br><span class="line">        if (find_pos &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = s.substr(pos, len - pos);</span><br><span class="line">            tmp = trim(tmp);</span><br><span class="line">            if(!tmp.empty()) elems.push_back(tmp);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = s.substr(pos, find_pos - pos);</span><br><span class="line">        tmp = trim(tmp);</span><br><span class="line">        if(!tmp.empty()) elems.push_back(tmp);</span><br><span class="line">        pos = find_pos + delim_len;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义打印日志添加 printf 格式检查：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void LogInfo(const char * fmt, ...)  __attribute__((format(printf, 1, 2)));</span><br></pre></td></tr></table></figure><p>添加后，可以防止<code>LogInfo</code>参数类型不匹配或缺少参数情况的发生。</p><h3 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h3><p>着手实现转发功能。</p><h3 id="delphi"><a href="#delphi" class="headerlink" title="delphi"></a>delphi</h3><p>在调试发现提示查询某天日志时，数据库出错。SQL Server 提示<code>[SQL Server]从 varchar 数据类型到 datetime 数据类型的转换产生一个超出范围的值。</code>。oracle 提示<code>ORA-01847: 月份中日的值必须介于 1 和当月最后一日之间</code>。经查，是如下代码出现问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">year:=YearOf(DateTimePicker1.Date);</span><br><span class="line">month:=MonthOfTheYear(DateTimePicker1.Date);</span><br><span class="line">day:=DayOfTheMonth(DateTimePicker1.Date);</span><br><span class="line">datastr:=format(&#x27;%.4d-&#x27;,[year])+format(&#x27;%.2d-&#x27;,[month])+format(&#x27;%.2d&#x27;,[day]);</span><br><span class="line"></span><br><span class="line">datastr1:=format(&#x27;%.4d-&#x27;,[year])+format(&#x27;%.2d-&#x27;,[month])+format(&#x27;%.2d&#x27;,[day-1]);</span><br><span class="line">datastr2:=format(&#x27;%.4d-&#x27;,[year])+format(&#x27;%.2d-&#x27;,[month])+format(&#x27;%.2d&#x27;,[day+1]);</span><br></pre></td></tr></table></figure><p>代码片段先获取当前日期的年、月、日数值，再通过将算术加减计算前一天和后一天，并组装成字符串。当在月初1号或月尾30（或31）时，就出现问题，此时当前日期、前一天、后一天这三个日期值为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2021-08-01 2021-08-00 2021-08-02  </span><br><span class="line">2021-08-31 2021-08-30 2021-08-32  </span><br></pre></td></tr></table></figure><p>可以看到出现了<code>00</code>和<code>32</code>的非法值。日期不能直接用算术的方式加减。而是使用 TDateTime 类型的变量进行加减。如下：</p><pre><code>var tdate, tdate1, tdate2: TDateTime;    tdate := DateTimePicker1.DateTime;    tdate1 := tdate-1;    tdate2 := tdate+1;        // 调用YearOf MonthOfTheYear DayOfTheMonth 函数</code></pre><h3 id="编码其它"><a href="#编码其它" class="headerlink" title="编码其它"></a>编码其它</h3><p>本月对 delphi 工程进行了一次维护，效率较低且无甚好解决方案。一是必须在虚拟机 xp 中使用固定 IDE 进行界面编辑和工程编译；二是 xp 的 IDE 不好用；三是资料较少（年代久远）；四是工程大部分用法为旧式，一时难以理解；五是历经廿载的积累及若干代工程师的维护，在搜索代码时，不时能看到1998、2008、2016、2019字样，一种厚重的历史感扑面而来。在前辈面前不敢造次，改代码时战战兢兢，生怕行差踏错。由于其有较高的使用价值，因此依然要学习并掌握。  </p><h2 id="一般知识"><a href="#一般知识" class="headerlink" title="一般知识"></a>一般知识</h2><h2 id="研发思考"><a href="#研发思考" class="headerlink" title="研发思考"></a>研发思考</h2><p>继续搞 CMMI 5，着重数据，有很多数据还没理解，根据模板填，不知含义。文档工作量比编码还大。    </p><h2 id="本月学习及计划"><a href="#本月学习及计划" class="headerlink" title="本月学习及计划"></a>本月学习及计划</h2><p>没有集中学习。计划抽时间搞一下请求转发方面的东西。  </p><h2 id="其它点滴"><a href="#其它点滴" class="headerlink" title="其它点滴"></a>其它点滴</h2><p>休息严重不足。<br>为了开收入证明，跑了 2 趟集团总部，从南宁东南方向到西北方向，单程1小时间。均为中午时分跑。<br>为评职称，到前前前前单位盖章，单程耗时50分钟。到当前外包单位盖章，单程耗时30分钟。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文为 2021 年 8 月知识总结。&lt;/p&gt;</summary>
    
    
    
    <category term="我的程序代码" scheme="http://www.latelee.org/category/my-library/"/>
    
    
    <category term="代码积累" scheme="http://www.latelee.org/tag/%E4%BB%A3%E7%A0%81%E7%A7%AF%E7%B4%AF/"/>
    
    <category term="知识总结" scheme="http://www.latelee.org/tag/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>我的docker随笔37：使用gitlab和jenkins实现CICD</title>
    <link href="http://www.latelee.org/docker/docker-37-using-gitlab-jenkins-for-cicd.html"/>
    <id>http://www.latelee.org/docker/docker-37-using-gitlab-jenkins-for-cicd.html</id>
    <published>2021-08-27T16:00:00.000Z</published>
    <updated>2021-09-06T14:40:30.086Z</updated>
    
    <content type="html"><![CDATA[<p>本文涉及一种利用容器部署 gitlab 和 jenkins 服务实现持续集成（CICD）的方法，其目的是为了在实际工作中使用代码托管及自动化操作。  </p><span id="more"></span><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>因工作需要，需部署  gitlab 和 jenkins 服务器进行 CICD 测试，换个高大上的名称，叫“组织革新”。本文记录个人的实践，但不涉及部署的具体步骤。  </p><h2 id="二、技术小结"><a href="#二、技术小结" class="headerlink" title="二、技术小结"></a>二、技术小结</h2><ul><li>不同工程，配置不同，本文使用 C++ 工程为例进行实验。</li><li>在配置 jenkins 时，建议经常使用页面下方的“应用”，随时保存设置好的参数，以防不测。</li></ul><h2 id="三、gitlab和jenkins联调"><a href="#三、gitlab和jenkins联调" class="headerlink" title="三、gitlab和jenkins联调"></a>三、gitlab和jenkins联调</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>实现CICD分几个阶段：使用 gitlab 托管代码，使用 jenkins 进行编译、打包以及发布。两个服务器各有项目对应，同时要进行必要的配置。不同项目，配置方式不尽相同。本节的配置原则上按顺序进行，因此会到 gitlab 和 jenkins 之间来回切换，故先行说明。</p><h3 id="3-2-前置条件"><a href="#3-2-前置条件" class="headerlink" title="3.2 前置条件"></a>3.2 前置条件</h3><h4 id="3-2-1-允许本地网络请求"><a href="#3-2-1-允许本地网络请求" class="headerlink" title="3.2.1 允许本地网络请求"></a>3.2.1 允许本地网络请求</h4><p>使用 root 用户登录 gitlab 服务器，在管理员配置选项选择<strong>网络(Setting)**页面，在</strong>外发请求（Outbound requests）<strong>中，选择“</strong>允许Webhook和服务对本地网络的请求(Allow requests to the local network from web hooks and services)**”，保存。如图1所示。</p><p>进行该设置的目的是因为本文的 gitlab 和 jenkins 服务均在同一物理服务器上使用 docker 部署。如果不设置，则在 gitlab 中设置 webhooks 时会提示<code>Url is blocked: Requests to the local network are not allowed</code>。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/1.png" alt="image-20210828022642996"></p><p><strong>说明：如果jenkins和gitlab不在同一服务器，则不需要进行此设置。</strong></p><h4 id="3-2-2-关闭-CSFR"><a href="#3-2-2-关闭-CSFR" class="headerlink" title="3.2.2 关闭 CSFR"></a>3.2.2 关闭 CSFR</h4><p>进入 jenkins 容器，找到<code>/usr/local/bin/jenkins.sh</code>文件，找到 exec java 行，在<code>-Duser.home=&quot;$JENKINS_HOME&quot;</code>后添加<code> -Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION=true</code>，完整的一行语句如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec java -Duser.home=&quot;$JENKINS_HOME&quot; -Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION=true &quot;$&#123;java_opts_array[@]&#125;&quot; -jar $&#123;JENKINS_WAR&#125; &quot;$&#123;jenkins_opts_array[@]&#125;&quot; &quot;$@</span><br></pre></td></tr></table></figure><blockquote><p>说明：在笔者定制的 jenkins 镜像中已经进行该修改了。</p></blockquote><p>进行该设置，是因为高版本 Jenkins 无法在界面关闭跨站请求伪造保护（CSRF），因为在 gitlab 进行 webhooks 时会认证失败。提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hook executed successfully but returned HTTP 403</span><br></pre></td></tr></table></figure><p>关闭之后，再次进行 CSFR 页面，提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This configuration is unavailable because the System property hudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION is set to true.</span><br></pre></td></tr></table></figure><p>说明修改成功。</p><blockquote><p>对于物理机部署的 jenkins，则在 /etc/sysconfig/jenkins 文件中找到 JENKINS_JAVA_OPTIONS， 设置如下：</p><p>JENKINS_JAVA_OPTIONS=”-Djava.awt.headless=true -Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION=true”</p></blockquote><h3 id="3-3-准备-gitlab-仓库"><a href="#3-3-准备-gitlab-仓库" class="headerlink" title="3.3 准备 gitlab 仓库"></a>3.3 准备 gitlab 仓库</h3><p>本文使用仓库地址为 <code>http://10.8.18.168:8888/latelee/ci_test</code>。</p><h3 id="3-4-配置-jenkins-项目"><a href="#3-4-配置-jenkins-项目" class="headerlink" title="3.4 配置 jenkins 项目"></a>3.4 配置 jenkins 项目</h3><h4 id="3-4-1-新建项目"><a href="#3-4-1-新建项目" class="headerlink" title="3.4.1 新建项目"></a>3.4.1 新建项目</h4><p>在 jenkins 首页左侧，点击“新建任务”，输入项目项目，选择第一项“自由风格软件项目”。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/2.png" alt="image-20210828215636723"></p><p>点击“确定”进入配置页面。  </p><h4 id="3-4-2-指定git仓库"><a href="#3-4-2-指定git仓库" class="headerlink" title="3.4.2 指定git仓库"></a>3.4.2 指定git仓库</h4><p>在<strong>源码管理</strong>选项页面中，输入 gitlab 仓库地址，注意，URL 地址后须添加<code>.git</code>后缀。  </p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/3.png" alt="image-20210828215845428"></p><p>点击“添加”-&gt;Jenkins，添加凭据，默认类型为用户名和密码。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/4.png" alt="image-20210828221742298"></p><p>添加后，选择添加的凭据，红色错误提示消失。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/5.png" alt="image-20210828222010281"></p><h4 id="3-4-3-设置触发条件"><a href="#3-4-3-设置触发条件" class="headerlink" title="3.4.3 设置触发条件"></a>3.4.3 设置触发条件</h4><p>在<strong>构建触发器</strong>页面进行触发器的选择。此处有多种方式可选，如定时构建和指定 gitlab 方式。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/6.png" alt="image-20210829110540696"></p><p>勾选“Build when a change is pushed to GitLab.”。注意，该项后面的 URL 地址需要记住，在 gitlab 中将使用。点击“高级”，在“Secret token”处点击“Generate”，生成 token，该 token 亦需要记住。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/7.png" alt="image-20210828222613624"></p><p>进行此设置目的是，当提交代码到 gitlab 仓库时，会自动触发 jenkins 执行 一次构建。触发条件在对应 gitlab 仓库中进行设置。如果不需要自动触发，则可以不触发条件。</p><h4 id="3-4-4-指定构建步骤"><a href="#3-4-4-指定构建步骤" class="headerlink" title="3.4.4 指定构建步骤"></a>3.4.4 指定构建步骤</h4><p>在<strong>构建</strong>页面，点击“增加构建步骤”，选择“执行shell”，输入构建的命令。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/8.png" alt="image-20210829110841729"></p><h4 id="3-4-5-指定构建后的步骤"><a href="#3-4-5-指定构建后的步骤" class="headerlink" title="3.4.5 指定构建后的步骤"></a>3.4.5 指定构建后的步骤</h4><p>在<strong>构建后操作</strong>页面，点击“增加构建后操作步骤”。选择“send build artifacts over SSH”。选择服务器、源目录、目标目录及执行的命令。注意，在本文实践前已经设置好服务器及目标，故只指定源文件和执行命令即可。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/9.png" alt="image-20210829111238088"></p><p>在笔者实践中发现，在“构建环境”、“构建”、“构建后操作”三个页面均可以选择将文件通过 SSH 发送服务器。</p><h3 id="3-5-设置-gitlab-的-webhooks"><a href="#3-5-设置-gitlab-的-webhooks" class="headerlink" title="3.5 设置 gitlab 的 webhooks"></a>3.5 设置 gitlab 的 webhooks</h3><p>在 gitlab 项目<code>http://10.8.18.168:8888/latelee/ci_test</code>页面，    选择“Settings”-&gt;“Webhooks”，输入上小节生成的 URL 和 token。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/10.png" alt="image-20210829105434914"></p><p>点击页面下方“Add webhook”，添加。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/11.png" alt="image-20210829105538566"></p><blockquote><p>注：同一个gitlab仓库，可支持多个 webhook。</p></blockquote><p>点击“Test”，选择“Push events”，进行测试验证。<strong>为保证触发成功，强烈建议在此处先行测试</strong>。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/12.png" alt="image-20210829105744185"></p><p>触发类型有很多种，根据实际情况选择。</p><h3 id="3-4-验证"><a href="#3-4-验证" class="headerlink" title="3.4 验证"></a>3.4 验证</h3><p>提交代码到 gitlab 仓库（此处从略）。稍等片刻，在 jenkins 工程的看到进行了触发。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/13.png" alt="image-20210829111835252"></p><p>输出日志如下：</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/14.png" alt="image-20210829112333720"></p><p>编译、运行、执行ssh远程服务均成功。在远程服务器的<code>/tmp</code>目录出现<code>a.out</code>和<code>log.txt</code>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文涉及一种利用容器部署 gitlab 和 jenkins 服务实现持续集成（CICD）的方法，其目的是为了在实际工作中使用代码托管及自动化操作。  &lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="http://www.latelee.org/category/docker/"/>
    
    
    <category term="docker" scheme="http://www.latelee.org/tag/docker/"/>
    
  </entry>
  
  <entry>
    <title>我的docker随笔36：定制jenkins镜像</title>
    <link href="http://www.latelee.org/docker/docker-36-make-jenkins-docker.html"/>
    <id>http://www.latelee.org/docker/docker-36-make-jenkins-docker.html</id>
    <published>2021-08-26T16:00:00.000Z</published>
    <updated>2021-09-06T14:40:30.086Z</updated>
    
    <content type="html"><![CDATA[<p>本文涉及一种根据实际需求定制 jenkins 镜像的方法及实践。其目的是在官方镜像基础上添加自定义软件、库，以便更加适应项目的开发情况。   </p><span id="more"></span><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>官方镜像基本能实现了常见的持续集成功能，但还有一些不符合要求，因此，有必要研究制作自定义的镜像。  </p><p>官方提供了各版本的脚本和 Dockerfile，可以直接用这些文件生成镜像，笔者认为，可以在官方镜像基础直接修改、新加功能。</p><h2 id="二、技术小结"><a href="#二、技术小结" class="headerlink" title="二、技术小结"></a>二、技术小结</h2><ul><li>根据实际情况选定jenkins版本。在该版本基础上再额外添加自定义功能。</li><li>按需安装软件，如本文的镜像安装了gcc、node、golang等软件。</li><li>如果涉及其它的库，可以直接在 Dockerfile 中拷贝到镜像中。</li></ul><h2 id="三、定制配置"><a href="#三、定制配置" class="headerlink" title="三、定制配置"></a>三、定制配置</h2><p>笔者所涉 Linux 系统，均为 centos7，并且 gcc 编译器版本必须为 4.8.5。在 jenkins 官方提供的众多版本中，恰好有 centos7，镜像名称为 jenkins/jenkins:centos7。  </p><p>在笔者实践中，是先在jenkins 容器中安装、测试软件的，但最终得到的仅有 Dockerfile 及必要的配置文件/脚本。本节记录在容器中安装的过程。</p><p>启动并用root权限进入容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name jenkins_build jenkins/jenkins:centos7 bash</span><br><span class="line"></span><br><span class="line">sudo docker exec -it -u root jenkins_build bash</span><br></pre></td></tr></table></figure><p>安装软件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc gcc-c++</span><br><span class="line"></span><br><span class="line">yum -y install automake autoconf libtool make sshpass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">前端的 node：</span><br><span class="line">curl --silent --location https://rpm.nodesource.com/setup_12.x | bash -</span><br><span class="line">再执行：</span><br><span class="line">yum -y install nodejs</span><br><span class="line"></span><br><span class="line">yarn:</span><br><span class="line">curl -sL https://dl.yarnpkg.com/rpm/yarn.repo | tee /etc/yum.repos.d/yarn.repo</span><br><span class="line">yum -y install yarn</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从容器拿到<code>/usr/local/bin/jenkins.sh</code>文件，编辑之，找到 exec java 行，在 <code>-Duser.home=&quot;$JENKINS_HOME&quot; </code>后添加：<br><code>-Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION=true</code><br>完整的语句为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec java -Duser.home=&quot;$JENKINS_HOME&quot; -Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION=true &quot;$&#123;java_opts_array[@]&#125;&quot; -jar $&#123;JENKINS_WAR&#125; &quot;$&#123;jenkins_opts_array[@]&#125;&quot; &quot;$@&quot;</span><br></pre></td></tr></table></figure><h2 id="四、最终成果"><a href="#四、最终成果" class="headerlink" title="四、最终成果"></a>四、最终成果</h2><p>新建myinit.sh文件，内容：</p><pre><code>cat &gt; myinit.sh &lt;&lt;-EOF#!/bin/bash## set golangexport GOROOT=/usr/local/goexport GOBIN=$GOROOT/binexport PATH=$PATH:$GOBINexport GOPATH=/vagrant/golang_linuxexport GOPROXY=https://goproxy.io,directexport MYGO=$GOPATH/golang/src/github.com/latelee## set my localeexport LANG=en_US.utf8export LANGUAGE=en_US.utf8export LC_ALL=en_US.utf8export LANG=zh_CN.utf8export LANGUAGE=zh_CN.utf8export LC_ALL=zh_CN.utf8EOF</code></pre><p>注：上述myinit.sh暂未测试通过，仅作备档。</p><p>Dockerfile 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; Dockerfile &lt;&lt;-EOF</span><br><span class="line">FROM jenkins/jenkins:centos7</span><br><span class="line"></span><br><span class="line">### I changed jenkins.sh file</span><br><span class="line">COPY --chown=jenkins:jenkins jenkins.sh /usr/local/bin/</span><br><span class="line"></span><br><span class="line"># if we want to install tools</span><br><span class="line">USER root</span><br><span class="line"></span><br><span class="line">RUN echo &quot;Late Lee build&quot; &gt; /my.info &amp;&amp; \</span><br><span class="line">    date &gt;&gt; /my.info</span><br><span class="line"></span><br><span class="line">## C++</span><br><span class="line"># install other tools...</span><br><span class="line">RUN yum -y install gcc gcc-c++ automake autoconf libtool make sshpass wget</span><br><span class="line"></span><br><span class="line">## Node</span><br><span class="line">RUN curl --silent --location https://rpm.nodesource.com/setup_12.x | bash - &amp;&amp; \</span><br><span class="line">    yum -y install nodejs</span><br><span class="line">RUN curl -sL https://dl.yarnpkg.com/rpm/yarn.repo | tee /etc/yum.repos.d/yarn.repo &amp;&amp; \</span><br><span class="line">    yum -y install yarn</span><br><span class="line"></span><br><span class="line">## Golang</span><br><span class="line">RUN wget https://studygolang.com/dl/golang/go1.15.6.linux-amd64.tar.gz &amp;&amp; \</span><br><span class="line">    tar zxf go1.15.6.linux-amd64.tar.gz -C /usr/local/ &amp;&amp; \</span><br><span class="line">    rm -rf go1.15.6.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">## Maven</span><br><span class="line"></span><br><span class="line"># need clean  yum clean all  </span><br><span class="line"></span><br><span class="line">## my compile</span><br><span class="line">RUN tar xf cppcheck-2.5.tar.gz &amp;&amp; cd cppcheck-2.5 &amp;&amp; make -j &amp;&amp; make install &amp;&amp; cd - &amp;&amp; \</span><br><span class="line">truetar xf valgrind-3.17.0.tar.bz2 &amp;&amp; cd valgrind-3.17.0 &amp;&amp; ./configure &amp;&amp; make -j &amp;&amp; make install &amp;&amp; cd -</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># drop back to the regular jenkins user - good practice</span><br><span class="line">USER jenkins</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; Dockerfile_new &lt;&lt;-EOF</span><br><span class="line">FROM latelee/jenkins:centos7</span><br><span class="line"></span><br><span class="line">### I changed jenkins.sh file</span><br><span class="line">COPY --chown=jenkins:jenkins --chmod=755 jenkins.sh /usr/local/bin/</span><br><span class="line">COPY --chown=jenkins:jenkins --chmod=755 myinit.sh /usr/local/bin/</span><br><span class="line">ADD usr.tar.bz2 /</span><br><span class="line"></span><br><span class="line">USER root</span><br><span class="line"></span><br><span class="line">## set my time</span><br><span class="line">RUN rm -rf /etc/localtime &amp;&amp; \</span><br><span class="line">    ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line"></span><br><span class="line">RUN ln -s /usr/lib64/libsqlite3.so.0 /usr/lib64/libsqlite3.so &amp;&amp; \</span><br><span class="line">trueln -s /usr/lib64/libcurl.so.4 /usr/lib64/libcurl.so &amp;&amp; \</span><br><span class="line">trueln -s /usr/lib64/libcrypto.so.10 /usr/lib64/libcrypto.so &amp;&amp; \</span><br><span class="line">trueln -s /usr/lib64/libuuid.so.1 /usr/lib64/libuuid.so &amp;&amp; \</span><br><span class="line">trueln -s /usr/lib64/libz.so.1 /usr/lib64/libz.so &amp;&amp; \</span><br><span class="line">trueecho &quot;/usr/lib64/mysql/&quot; &gt; /etc/ld.so.conf.d/mysql.conf</span><br><span class="line"></span><br><span class="line"># drop back to the regular jenkins user - good practice</span><br><span class="line">USER jenkins</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN yum -y install glibc-common &amp;&amp; \</span><br><span class="line"> yum -y install kde-l10n-Chinese &amp;&amp; \</span><br><span class="line"> localedef -c -f UTF-8 -i zh_CN zh_CN.utf8 &amp;&amp; \</span><br><span class="line"> echo LC_ALL=\&quot;&quot;zh_CN.utf8\&quot;&quot; &gt; /etc/locale.conf</span><br><span class="line"> </span><br><span class="line">docker build -t latelee/jenkins:centos7_new -f Dockerfile_new .</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>构建：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t latelee/jenkins:centos7 .</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">cp -av --parents /usr/local/curl/ /tmp/dataserver_lib/</span><br><span class="line"></span><br><span class="line">cp -av --parents /usr/include/z* /tmp/dataserver_lib/</span><br><span class="line"></span><br><span class="line">cp -av --parents /usr/include/sqlite3* /tmp/dataserver_lib/</span><br><span class="line"></span><br><span class="line">cp -av --parents /usr/include/openssl/ /tmp/dataserver_lib/</span><br><span class="line"></span><br><span class="line">cp -av --parents /usr/lib64/mysql/ /tmp/dataserver_lib/</span><br><span class="line"></span><br><span class="line">scp -r  curl.tar.bz2 lijj@10.0.153.12:/tmp</span><br><span class="line"></span><br><span class="line">scp -r  include.tar.bz2 lijj@10.0.153.12:/tmp</span><br><span class="line"></span><br><span class="line">scp -r  usr.tar.bz2 lijj@10.0.153.12:/tmp</span><br><span class="line"></span><br><span class="line">LDFLAGS += -L/usr/lib64/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">链接：</span><br><span class="line">ln -s /usr/lib64/libsqlite3.so.0 /usr/lib64/libsqlite3.so</span><br><span class="line">ln -s /usr/lib64/libcurl.so.4 /usr/lib64/libcurl.so</span><br><span class="line">ln -s /usr/lib64/libcrypto.so.10 /usr/lib64/libcrypto.so</span><br><span class="line">ln -s /usr/lib64/libuuid.so.1 /usr/lib64/libuuid.so</span><br><span class="line">ln -s /usr/lib64/libz.so.1 /usr/lib64/libz.so</span><br><span class="line"></span><br><span class="line">echo &quot;/usr/lib64/mysql/&quot; &gt; /etc/ld.so.conf.d/mysql.conf</span><br><span class="line"></span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/lib64/mysql/</span><br></pre></td></tr></table></figure><h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>jenkins 控制台中文乱码，未解决。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文涉及一种根据实际需求定制 jenkins 镜像的方法及实践。其目的是在官方镜像基础上添加自定义软件、库，以便更加适应项目的开发情况。   &lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="http://www.latelee.org/category/docker/"/>
    
    
    <category term="docker" scheme="http://www.latelee.org/tag/docker/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：使用gin框架实现文件上传转发功能</title>
    <link href="http://www.latelee.org/golang/golang-notes-print-structure.html"/>
    <id>http://www.latelee.org/golang/golang-notes-print-structure.html</id>
    <published>2021-08-25T15:51:00.000Z</published>
    <updated>2021-09-06T14:40:29.958Z</updated>
    
    <content type="html"><![CDATA[<p>近段时间需要实现一个转发 post 请求到指定后端服务的小工具，由于一直想学习 gin 框架，所以就使用这个框架进行尝试，预计会产生几篇文章。本文先研究如何在 gin 框架中实现上传和转发功能。  </p><span id="more"></span><h2 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h2><p>一后台 web 服务，有众多历史版本，本身运行无问题，但后来需求变更，需将不同的历史版本单独运行，并指定不同端口。对外相当于有众多的服务。在请求 post 的文件中带有日期时间，需要根据时间转发到不同的端口的服务。  </p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>像 nginx，可以根据端口做转发，但本文是根据请求的内容转发的，因此需要实现一个转发工具。即先读取外部请求的文件内容，解析得到时间，再根据时间，转发到不同的端口服务中。要解决的问题：<br>如何做到既解析 post 请求，又要将该请求原封不动地发到后端服务？后端服务返回的数据，如何原封不动地返回请求者？<br>如何管理后端服务？如果使用额外的脚本，则添加了运维部署的步骤，略有麻烦。故考虑在转发工具中实现。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>使用工具进行 post 请求，并且指定文件名。可用 postman 或 curl，本文使用后者。  </li></ul><p>转发函数：    </p><ul><li>利用 ctx.Request.FormFile 得到文件名称、文件内容，此时，可以使用 gin 提供的 SaveUploadedFile 函数保存文件，也可以调用  io.Copy 保存。前者省事。  </li><li>调用再次转发函数。  </li><li>将再次转发函数返回值转换成 json 形式，返回 post 请求工具。  </li></ul><p>再次转发函数：  </p><ul><li>利用 multipart 包创建文件，将上一步得到的文件拷贝进去。  </li><li>再用 http 库发送请求。注意需要设置格式。  </li><li>最后读取请求的返回值，再返回，注意，内容为字节形式。  </li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="主要接口代码"><a href="#主要接口代码" class="headerlink" title="主要接口代码"></a>主要接口代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func RunWebServer(args []string) &#123;</span><br><span class="line">    runWebOnlyPost()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func runWebOnlyPost() &#123;</span><br><span class="line">truerouter := gin.New()</span><br><span class="line">truerouter.Use(gin.Logger())</span><br><span class="line">truerouter.Use(gin.Recovery())</span><br><span class="line"></span><br><span class="line">truetestRouter(router)</span><br><span class="line"></span><br><span class="line">trueklog.Println(&quot;Server started at &quot;, conf.Port)</span><br><span class="line">truerouter.Run(&quot;:&quot; + conf.Port)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func testRouter(r *gin.Engine) &#123;</span><br><span class="line">truefmt.Println(&quot;test post...&quot;)</span><br><span class="line">    </span><br><span class="line">    r.POST(&quot;/foobar/test&quot;, foobar_test)</span><br><span class="line">    r.POST(&quot;/foobar/test_back&quot;, foobar_test_back) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line"> curl http://127.0.0.1:84/foobar/test -X POST -F  &quot;file=@sample.json&quot;</span><br><span class="line"> </span><br><span class="line"> 临时：</span><br><span class="line"> file读取了一次，再读就没有内容了，字节数为0</span><br><span class="line">*/</span><br><span class="line">func foobar_test(ctx *gin.Context) &#123;</span><br><span class="line">    </span><br><span class="line">    // 2种方式都可，但 ctx.Request.FormFile 可以得到文件句柄，可直接拷贝</span><br><span class="line">    //file, err := ctx.FormFile(&quot;file&quot;)</span><br><span class="line">    file, header, err := ctx.Request.FormFile(&quot;file&quot;)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        ctx.JSON(http.StatusBadRequest, gin.H&#123;</span><br><span class="line">        &quot;error&quot;: err,</span><br><span class="line">        &#125;)</span><br><span class="line">        return</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    //fmt.Printf(&quot;Request: %+v\n&quot;, ctx.Request);</span><br><span class="line">    //fmt.Printf(&quot;Formfile: %+v | %+v |||  %v %v\n&quot;, file, header, err, reflect.TypeOf(file));</span><br><span class="line">    </span><br><span class="line">    // 拿到文件和长度，后面使用到</span><br><span class="line">    var jsonfilename string = header.Filename</span><br><span class="line">    mysize := header.Size</span><br><span class="line">    fmt.Printf(&quot;filename: %s size: %d\n&quot;, jsonfilename, mysize);</span><br><span class="line">    </span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        ctx.JSON(http.StatusBadRequest, gin.H&#123;</span><br><span class="line">        &quot;error&quot;: err,</span><br><span class="line">        &#125;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 处理json文件 </span><br><span class="line">    // 注：如果读取了文件，再转发，就没有内容了，所以这里不读取</span><br><span class="line">    </span><br><span class="line">    // 指向后端的服务URL</span><br><span class="line">    url := &quot;http://127.0.0.1:85/foobar/test_back&quot;</span><br><span class="line">    resp := post_data_gin(url, jsonfilename, file);</span><br><span class="line"></span><br><span class="line">    // 解析返回字符切片，得到map，当成json，赋值给gin</span><br><span class="line">    var data1 map[string]interface&#123;&#125;</span><br><span class="line">    err = json.Unmarshal(resp, &amp;data1)</span><br><span class="line">    //fmt.Println(&quot;muti unmarshal: &quot;, err, data1)</span><br><span class="line">    </span><br><span class="line">    ctx.JSON(http.StatusOK, data1)</span><br><span class="line">    </span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> 模拟后台的仅获取file字段的json，不作其它处理</span><br><span class="line"> curl http://127.0.0.1:84/foobar/test_back -X POST -F  &quot;file=@sample.json&quot;</span><br><span class="line">*/</span><br><span class="line">func foobar_test_back(ctx *gin.Context) &#123;</span><br><span class="line">    </span><br><span class="line">    // 2种方式都可，但 ctx.Request.FormFile 可以得到文件句柄，可直接拷贝</span><br><span class="line">    //file, err := ctx.FormFile(&quot;file&quot;)</span><br><span class="line">    _, header, err := ctx.Request.FormFile(&quot;file&quot;)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        ctx.JSON(</span><br><span class="line">            http.StatusBadRequest,</span><br><span class="line">            gin.H&#123;</span><br><span class="line">                &quot;code&quot;: -1,</span><br><span class="line">                &quot;msg&quot;:  &quot;failed&quot;,</span><br><span class="line">                &quot;data&quot;: gin.H&#123;</span><br><span class="line">                    &quot;result&quot;: &quot;failed in back end server&quot;,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 拿到文件和长度，后面使用到</span><br><span class="line">    var myfile string = header.Filename</span><br><span class="line">    mysize := header.Size</span><br><span class="line">    fmt.Printf(&quot;filename: %s size: %d\n&quot;, myfile, mysize);</span><br><span class="line">    </span><br><span class="line">    if mysize &lt;= 0 &#123;</span><br><span class="line">        ctx.JSON(</span><br><span class="line">            http.StatusBadRequest,</span><br><span class="line">            gin.H&#123;</span><br><span class="line">                &quot;code&quot;: -1,</span><br><span class="line">                &quot;msg&quot;:  &quot;failed&quot;,</span><br><span class="line">                &quot;data&quot;: gin.H&#123;</span><br><span class="line">                    &quot;result&quot;: &quot;failed in back end server, json size 0&quot;,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 此处可保存文件</span><br><span class="line"></span><br><span class="line">    //保存成功返回正确的Json数据</span><br><span class="line">    ctx.JSON(</span><br><span class="line">truetruehttp.StatusOK,</span><br><span class="line">truetruegin.H&#123;</span><br><span class="line">truetruetrue&quot;code&quot;: 0,</span><br><span class="line">truetruetrue&quot;msg&quot;:  &quot;ok&quot;,</span><br><span class="line">truetruetrue&quot;data&quot;: gin.H&#123;</span><br><span class="line">truetruetruetrue&quot;result&quot;: &quot;ok in back end server&quot;,</span><br><span class="line">truetruetrue&#125;,</span><br><span class="line">truetrue&#125;,</span><br><span class="line">true)</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为测试方便，文中实现的 gin 框架程序在运行时可指定端口。因此，代码中实现了2个 url 的响应函数。  </p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>本文使用 sample.json 文件测试，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">true&quot;enID&quot;: &quot;ID250&quot;,</span><br><span class="line">true&quot;exID&quot;: &quot;ID251&quot;,</span><br><span class="line">true&quot;type&quot;: 1,</span><br><span class="line">true&quot;money&quot;: 250.44,</span><br><span class="line">true&quot;distance&quot;: 274050</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先运行 84 端口服务（称为 84 服务），此为对外的服务。再运行 85 端口服务（称为 85 服务），此为模拟后端的服务。<br>启动一终端，执行测试命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:84/foobar/ -X POST -F  &quot;file=@sample.json&quot;</span><br></pre></td></tr></table></figure><p>84 服务打印：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[2021-08-25 23:51:19.424 busy.go:79] Server started at  84</span><br><span class="line">[GIN-debug] Listening and serving HTTP on :84</span><br><span class="line">filename: sample.json size: 95</span><br><span class="line">io copy: 95 &lt;nil&gt;</span><br><span class="line">[GIN] 2021/08/25 - 23:53:59 | 200 |      3.0002ms |       127.0.0.1 | POST     &quot;/foobar/test&quot;</span><br></pre></td></tr></table></figure><p>85 服务打印：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[GIN-debug] Listening and serving HTTP on :85</span><br><span class="line">filename: sample.json size: 95</span><br><span class="line">[GIN] 2021/08/25 - 23:53:59 | 200 |            0s |       127.0.0.1 | POST     &quot;/foobar/test_back&quot;</span><br></pre></td></tr></table></figure><p>测试命令返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100   361  100    63  100   298  31500   145k --:--:-- --:--:-- --:--:--  352k&#123;&quot;code&quot;:0,&quot;data&quot;:&#123;&quot;result&quot;:&quot;ok in back end server&quot;&#125;,&quot;msg&quot;:&quot;ok&quot;&#125;</span><br></pre></td></tr></table></figure><p>也可直接向后端服务请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://127.0.0.1:85/fee/test_back -X POST -F  &quot;file=@sample.json&quot;</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100   361  100    63  100   298  63000   291k --:--:-- --:--:-- --:--:--  352k&#123;&quot;code&quot;:0,&quot;data&quot;:&#123;&quot;result&quot;:&quot;ok in back end server&quot;&#125;,&quot;msg&quot;:&quot;ok&quot;&#125;</span><br></pre></td></tr></table></figure><p>2021.8.25 夜</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;近段时间需要实现一个转发 post 请求到指定后端服务的小工具，由于一直想学习 gin 框架，所以就使用这个框架进行尝试，预计会产生几篇文章。本文先研究如何在 gin 框架中实现上传和转发功能。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>我的docker随笔35：jenkins服务部署</title>
    <link href="http://www.latelee.org/docker/docker-35-deploy-jenkins-server.html"/>
    <id>http://www.latelee.org/docker/docker-35-deploy-jenkins-server.html</id>
    <published>2021-08-09T16:00:00.000Z</published>
    <updated>2021-09-06T14:40:30.086Z</updated>
    
    <content type="html"><![CDATA[<p>本文涉及一种在容器中部署 jenkins 服务的方法，后续将其与 gitlab 配合以实现 CICD 功能。其目的是为了在实际工作中使用代码托管及自动化操作。  </p><span id="more"></span><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>因工作需要，需部署  jenkins 服务器进行测试。与网上几分钟即可部署的文章相比，本文更注重个人的实践记录。本文与前面的 gitlab 有一定的关联。</p><h2 id="二、技术小结"><a href="#二、技术小结" class="headerlink" title="二、技术小结"></a>二、技术小结</h2><ul><li>gitlab 有官方的 Docker 镜像。本文直接使用之。</li><li>使用 docker-compose 部署，指定端口。注意挂载 docker.socket文件。</li><li>首次登录会提示输入随机文件，一旦输入并设置成功后，不再提示。</li><li>各种配置慢慢补充。</li></ul><h2 id="三、部署gitlab服务"><a href="#三、部署gitlab服务" class="headerlink" title="三、部署gitlab服务"></a>三、部署gitlab服务</h2><h3 id="3-1-部署脚本"><a href="#3-1-部署脚本" class="headerlink" title="3.1 部署脚本"></a>3.1 部署脚本</h3><p>本文使用 docker-compose 部署，在测试阶段，使用了多个版本。此处是比较简单的版本，用于初次使用。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">jenkins:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">jenkins/jenkins:centos7</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">lljenkins</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="comment"># 使用主机的docker服务(因为要在jenkins容器中运行docker)</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">            <span class="comment"># 使用数据盘的目录作为jenkins的工作目录</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">$PWD/jenkins_home:/var/jenkins_home</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="comment"># 端口映射</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;9999:8080&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;50000:50000&quot;</span></span><br><span class="line">        <span class="attr">networks:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">llgitlab-net</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">    <span class="attr">llgitlab-net:</span></span><br><span class="line">        <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure><p>注意几点：</p><ul><li>脚本中指定了<code>docker.sock</code>的路径，后续可以在jenkins用docker构建。</li><li>jenkins 数据目录在本目录下的<code>jenkins_home</code>目录，其权限修改为1000，命令为<code>sudo chown -R 1000 jenkins_home</code>。</li><li>根据实际环境，选择了 centos7 版本的 jenkins。</li></ul><h3 id="3-2-运行"><a href="#3-2-运行" class="headerlink" title="3.2 运行"></a>3.2 运行</h3><p>运行命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>注：jenkins 的启动比 gitlab 快很多。  </p><p>停止命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose down</span><br></pre></td></tr></table></figure><p>运行过程中会出现初始密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Jenkins initial setup is required. An admin user has been created and a password generated.</span><br><span class="line">Please use the following password to proceed to installation:</span><br><span class="line"></span><br><span class="line">c4365f900e554ff5b8885d8c2975929b</span><br><span class="line"></span><br><span class="line">This may also be found at: /var/jenkins_home/secrets/initialAdminPassword</span><br><span class="line"></span><br><span class="line">*************************************************************</span><br></pre></td></tr></table></figure><h2 id="四、初次配置"><a href="#四、初次配置" class="headerlink" title="四、初次配置"></a>四、初次配置</h2><p>服务启动后，需要进行必要的配置，因此在本文一并给出。</p><h3 id="4-1-登录"><a href="#4-1-登录" class="headerlink" title="4.1 登录"></a>4.1 登录</h3><p>初次登录时，会提示输入管理员密码，如图1所示：</p><p><img src="/docker/docker-35-deploy-jenkins-server/1.png" alt="image-20210804094456510"></p><p>在 docker 启动时出现有密码，也可以直接在页面所示文件中找到。</p><h3 id="4-2-安装插件："><a href="#4-2-安装插件：" class="headerlink" title="4.2 安装插件："></a>4.2 安装插件：</h3><p><img src="/docker/docker-35-deploy-jenkins-server/2.png" alt="image-20210804094542706"><br>选右侧自定义安装，注：默认也勾选了部分插件。</p><p>安装过程图示：</p><p><img src="/docker/docker-35-deploy-jenkins-server/3.png" alt="image-20210804094924177"></p><p>注：笔者在实践中，遇到不可抗拒因素，导致网络不稳定，经常安装不成功，如果尝试多次失败，可以跳过不安装。</p><h2 id="五、一些配置"><a href="#五、一些配置" class="headerlink" title="五、一些配置"></a>五、一些配置</h2><h3 id="5-1-git-仓库地址问题"><a href="#5-1-git-仓库地址问题" class="headerlink" title="5.1 git 仓库地址问题"></a>5.1 git 仓库地址问题</h3><p>配置了项目，构建，提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stderr: error: RPC failed; result=22, HTTP code = 404</span><br></pre></td></tr></table></figure><p>原因及解决：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在设置项目git地址时，必须添加`.git`后缀，否则地址不认。</span><br></pre></td></tr></table></figure><h3 id="5-2-Publish-over-SSH"><a href="#5-2-Publish-over-SSH" class="headerlink" title="5.2 Publish over SSH"></a>5.2 Publish over SSH</h3><p><img src="/docker/docker-35-deploy-jenkins-server/4.png" alt="image-20210829112839117"></p><p>TODO……</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文涉及一种在容器中部署 jenkins 服务的方法，后续将其与 gitlab 配合以实现 CICD 功能。其目的是为了在实际工作中使用代码托管及自动化操作。  &lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="http://www.latelee.org/category/docker/"/>
    
    
    <category term="docker" scheme="http://www.latelee.org/tag/docker/"/>
    
  </entry>
  
  <entry>
    <title>我的docker随笔34：gitlab服务部署</title>
    <link href="http://www.latelee.org/docker/docker-34-deploy-gitlab-server.html"/>
    <id>http://www.latelee.org/docker/docker-34-deploy-gitlab-server.html</id>
    <published>2021-08-08T16:00:00.000Z</published>
    <updated>2021-09-06T14:40:30.082Z</updated>
    
    <content type="html"><![CDATA[<p>本文涉及一种在容器中部署 gitlab 服务的方法，并结合其自带的 gitlab-runner 实现 CICD 功能。其目的是为了在实际工作中使用代码托管及自动化操作。  </p><span id="more"></span><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>因工作需要，需部署 gitlab 服务器进行数据测试。与网上几分钟即可部署的文章相比，本文更注重个人的实践记录，故不会完整地将过程记录下来。</p><h2 id="二、技术小结"><a href="#二、技术小结" class="headerlink" title="二、技术小结"></a>二、技术小结</h2><ul><li>gitlab 有官方的 Docker 镜像。</li><li>建议将数据和配置目录映射到主机上，方便编辑和备份。</li><li>如果使用非默认端口，需要配置自定义端口。</li><li>在首次登录时，需要设置 root 密码，后面不再出现此提示，因此需记住密码。</li><li>gitlab-runner本文未有深入研究，等后续有时间再着手。</li></ul><h2 id="三、部署gitlab服务"><a href="#三、部署gitlab服务" class="headerlink" title="三、部署gitlab服务"></a>三、部署gitlab服务</h2><h3 id="3-1-部署脚本"><a href="#3-1-部署脚本" class="headerlink" title="3.1 部署脚本"></a>3.1 部署脚本</h3><p>本文使用 docker-compose 部署，在测试阶段，使用了多个版本。</p><p>版本一，使用默认端口，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">llgitlab:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">gitlab/gitlab-ce:13.10.0-ce.0</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">llgitlab</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./gitlab_data/config:/etc/gitlab</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./gitlab_data/logs:/var/log/gitlab</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./gitlab_data/data:/var/opt/gitlab</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;8888:80&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;8443:443&quot;</span></span><br><span class="line">            <span class="comment">#- &quot;2222:22&quot;</span></span><br><span class="line">        <span class="attr">hostname:</span> <span class="string">&quot;10.0.10.11&quot;</span></span><br><span class="line">        <span class="comment">#command: /assets/wrapper</span></span><br><span class="line">        <span class="attr">networks:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">llgitlab-net</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">    <span class="attr">llgitlab-net:</span></span><br><span class="line">        <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure><p>脚本中将配置目录和数据目录映射到主机当前目录的<code>gitlab_data</code>目录，方便后续修改。对外提供<code>8888</code>端口。由于部署环境为内网，故设置<code>hostname</code>为部署机器的<code>IP</code>。</p><p>版本二，修改端口：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">llgitlab:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">gitlab/gitlab-ce:13.10.0-ce.0</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">llgitlab</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./gitlab_data/config:/etc/gitlab</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./gitlab_data/logs:/var/log/gitlab</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./gitlab_data/data:/var/opt/gitlab</span></span><br><span class="line">        <span class="attr">environment:</span></span><br><span class="line">            <span class="attr">TZ:</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line">            <span class="attr">GITLAB_OMNIBUS_CONFIG:</span> <span class="string">|</span></span><br><span class="line"><span class="string">                external_url &#x27;http://10.0.153.12:8888&#x27;</span></span><br><span class="line"><span class="string">                nginx[&#x27;listen_port&#x27;]=8888</span></span><br><span class="line"><span class="string">                gitlab_rails[&#x27;gitlab_shell_ssh_port&#x27;]=8822</span></span><br><span class="line"><span class="string">                gitlab_rails[&#x27;time_zone&#x27;]=&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line"><span class="string"></span>        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;8888:8888&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;8443:443&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;8822:8822&quot;</span></span><br><span class="line">        <span class="attr">hostname:</span> <span class="string">&quot;10.0.153.12&quot;</span></span><br><span class="line">        <span class="attr">networks:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">llgitlab-net</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">    <span class="attr">llgitlab-net:</span></span><br><span class="line">        <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure><p>注意几点：</p><ul><li>git 的访问方式，http默认为80，ssh默认为22，版本一未修改，但主机做了映射，此版本将 gitlab 默认端口修改了，分别为8888和8822，再将其映射到相同的主机端口。</li><li>使用 GITLAB_OMNIBUS_CONFIG 环境变量进行一些参数的修改，相当于修改容器内的<code>/etc/gitlab/gitlab.rb</code>文件（当然，本文已经将目录映射到主机上了）。<code>external_url</code>从名称上看，其必须为一个 url 地址，可以是IP或域名，但不能是单纯的 IP，本文加了端口。  </li><li>当已经存在了本地数据时，使用 GITLAB_OMNIBUS_CONFIG 修改参数，也会生效。比如原先没有修改端口，修改端口后重启容器，即可生效。</li><li>虽然设置了 TZ，容器的时间也为 CST，但查看 gitlab 的日志，依旧使用 UTC 时间。或许是一个特性。</li><li>hostname 不能加端口。</li><li></li></ul><h3 id="3-2-运行"><a href="#3-2-运行" class="headerlink" title="3.2 运行"></a>3.2 运行</h3><p>运行命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>注意：启动耗时较长，大概数分钟（笔者使用性能较强的服务器测试，也要3~4分钟），需耐心等待。</p><p>停止命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose down</span><br></pre></td></tr></table></figure><p>初次登录时，会提示设置管理员<code>root</code>密码，如图1所示：</p><p><img src="/docker/docker-34-deploy-gitlab-server/1.png"></p><p>设置完毕后需重新登录。在首页可以看到注册的提醒。默认开放注册，但需管理员确认，如内部使用，则该功能可去掉。如图2所示。</p><p><img src="/docker/docker-34-deploy-gitlab-server/2.png"></p><p>默认情况下，新用户注册，会有如图3的提示：</p><p><img src="/docker/docker-34-deploy-gitlab-server/3.png"></p><p>至此，已经将 gitlab 部署完毕，且已可正常使用。  如使用其 CICD 功能，则需要继续部署 gitlab-runner。</p><h2 id="四、gitlab-runner"><a href="#四、gitlab-runner" class="headerlink" title="四、gitlab-runner"></a>四、gitlab-runner</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>使用管理员登录 gitlab，并获取token，如图4所示：</p><p><img src="/docker/docker-34-deploy-gitlab-server/4.png"></p><p>图4右侧给出了URL地址以及 token，后续将使用到。  </p><p>准备docker-compose文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">llgitlab:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">gitlab/gitlab-ce:13.10.0-ce.0</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">llgitlab</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./gitlab_data/config:/etc/gitlab</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./gitlab_data/logs:/var/log/gitlab</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./gitlab_data/data:/var/opt/gitlab</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;8888:80&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;8443:443&quot;</span></span><br><span class="line">            <span class="comment">#- &quot;2222:22&quot;</span></span><br><span class="line">        <span class="attr">hostname:</span> <span class="string">&quot;10.0.153.12&quot;</span></span><br><span class="line">        <span class="comment">#command: /assets/wrapper</span></span><br><span class="line">        <span class="attr">networks:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">llgitlab-net</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">llgitlab-runner:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">gitlab/gitlab-runner:alpine-v13.10.0</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">llgitlab-runner</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./gitlab-runner/config:/etc/gitlab-runner</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">        <span class="attr">depends_on:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">llgitlab</span></span><br><span class="line">        <span class="attr">networks:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">llgitlab-net</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">    <span class="attr">llgitlab-net:</span></span><br><span class="line">        <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure><p>注意， gitlab-runner 和 gitlab 版本应相近。</p><p>注意，此时查看gitlab-runner容器，会不断提示 config.toml找不到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Runtime platform                                    arch=amd64 os=linux pid=7 revision=54944146 version=13.10.0</span><br><span class="line">Starting multi-runner from /etc/gitlab-runner/config.toml...  builds=0</span><br><span class="line">Running in system-mode.                            </span><br><span class="line">                                                   </span><br><span class="line">Configuration loaded                                builds=0</span><br><span class="line">listen_address not defined, metrics &amp; debug endpoints disabled  builds=0</span><br><span class="line">[session_server].listen_address not defined, session endpoints disabled  builds=0</span><br><span class="line">ERROR: Failed to load config stat /etc/gitlab-runner/config.toml: no such file or directory  builds=0</span><br><span class="line">ERROR: Failed to load config stat /etc/gitlab-runner/config.toml: no such file or directory  builds=0</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>因为未注册原故。注册方法有2种，一是根据提示一一填写，二是直接指定参数。</p><p>手动注册：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -it -v $PWD/gitlab-runner/config:/etc/gitlab-runner gitlab/gitlab-runner:alpine-v13.10.0 register</span><br><span class="line">之后出现提示，根据提示填写内容</span><br><span class="line">下面是示例</span><br><span class="line">Runtime platform                                    arch=amd64 os=linux pid=7 revision=54944146 version=13.10.0</span><br><span class="line">Running in system-mode.                            </span><br><span class="line">                                                   </span><br><span class="line">Enter the GitLab instance URL (for example, https://gitlab.com/):</span><br><span class="line">http://10.0.153.12:8888/</span><br><span class="line">Enter the registration token:</span><br><span class="line">FXKUC2HtxFuICBC9961024</span><br><span class="line">Enter a description for the runner:</span><br><span class="line">[a2d8dbc3c305]: my-gitlab-runner</span><br><span class="line">Enter tags for the runner (comma-separated):</span><br><span class="line">gitlab</span><br><span class="line">Registering runner... succeeded                     runner=FXKUC2H</span><br><span class="line">Enter an executor: parallels, virtualbox, docker+machine, docker-ssh+machine, custom, docker, docker-ssh, shell, ssh, kubernetes:</span><br><span class="line">docker</span><br><span class="line">Enter the default Docker image (for example, ruby:2.6):</span><br><span class="line">latelee/ubuntu</span><br><span class="line">Runner registered successfully. Feel free to start it, but if it&#x27;s running already the config should be automatically reloaded! </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>直接指定参数注册。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -v $PWD/gitlab-runner/config:/etc/gitlab-runner gitlab/gitlab-runner:alpine-v13.10.0 register \</span><br><span class="line">  --non-interactive \</span><br><span class="line">  --executor &quot;docker&quot; \</span><br><span class="line">  --docker-image latelee/ubuntu \</span><br><span class="line">  --url &quot;http://10.0.153.12:8888/&quot; \</span><br><span class="line">  --registration-token &quot;FXKUC2HtxFuICBC9961024&quot; \</span><br><span class="line">  --description &quot;docker-runner&quot; \</span><br><span class="line">  --tag-list &quot;docker,aws&quot; \</span><br><span class="line">  --run-untagged=&quot;true&quot; \</span><br><span class="line">  --locked=&quot;false&quot; \</span><br><span class="line">  --access-level=&quot;not_protected&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>生成的配置在<code>/etc/gitlab-runner/config.toml</code>文件。  </p><p>说明：</p><ul><li>运行器 executor 选择 docker 即可，镜像使用自建的 latelee/ubuntu， 方便后续添加软件。</li></ul><p>成功后，在 Runners 界面（与图4为同一界面）可以看到已注册的实例，如图5所示。</p><p><img src="/docker/docker-34-deploy-gitlab-server/5.png"></p><p>注意，注册之后，还是可以再编辑文件<code>gitlab-runner/config/config.toml</code>的，但需要重启容器。</p><p>过程记录</p><p>管理员登录，在<code>Runners</code>中找到项目，绑定到指定<code>runner</code>。（存疑：只有一个runner，是否不需要一一绑定项目？太麻烦了）</p><p>设置好 ci 脚本，提交，提示<code>This job is stuck, because the project doesn‘t have any runners online assigned to it. </code>。解决：在<code>Settings</code>-&gt;<code>CI/CD</code>找到对应的<code>runner</code>，将<code>Indicates whether this runner can pick jobs without tags</code>打勾。</p><p>执行 CI 后，提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fatal: repository &#x27;http://10.0.153.12/latelee/ci_test.git/&#x27; not found</span><br><span class="line">ERROR: Job failed: exit code 1</span><br></pre></td></tr></table></figure><p>原因：仓库带端口，但此处没有，何解？</p><h3 id="遗留问题-思考"><a href="#遗留问题-思考" class="headerlink" title="遗留问题/思考"></a>遗留问题/思考</h3><p>如果切换 gitlab，如果更新或添加？——由于是 docker 部署，在测试阶段容易重新启动新的 gitlab 服务。  </p><h2 id="五、进阶配置"><a href="#五、进阶配置" class="headerlink" title="五、进阶配置"></a>五、进阶配置</h2><p>这里列出一些配置，有空再研究</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 这个是针对请求钩子的,还有针对Git的这些</span><br><span class="line">gitlab_rails[&#x27;webhook_timeout&#x27;] = 60 #默认是10s</span><br><span class="line"></span><br><span class="line"># 若是大体都需要求延长的,可以配置全局,后者是进程数</span><br><span class="line">unicorn[&#x27;worker_timeout&#x27;] = 100</span><br><span class="line">unicorn[&#x27;worker_processes&#x27;] = 8</span><br><span class="line"></span><br><span class="line"># gitlab_rails[&#x27;smtp_enable&#x27;] = true</span><br><span class="line"># gitlab_rails[&#x27;smtp_address&#x27;] = &quot;smtp.exmail.qq.com&quot;</span><br><span class="line"># gitlab_rails[&#x27;smtp_port&#x27;] = 465</span><br><span class="line"># gitlab_rails[&#x27;smtp_user_name&#x27;] = &quot;xxxx@xx.com&quot;</span><br><span class="line"># gitlab_rails[&#x27;smtp_password&#x27;] = &quot;password&quot;</span><br><span class="line"># gitlab_rails[&#x27;smtp_authentication&#x27;] = &quot;login&quot;</span><br><span class="line"># gitlab_rails[&#x27;smtp_enable_starttls_auto&#x27;] = true</span><br><span class="line"># gitlab_rails[&#x27;smtp_tls&#x27;] = true</span><br><span class="line"># gitlab_rails[&#x27;gitlab_email_from&#x27;] = &#x27;xxxx@xx.com&#x27;</span><br><span class="line"></span><br><span class="line">gitlab_rails[&#x27;smtp_enable&#x27;] = true</span><br><span class="line">        gitlab_rails[&#x27;smtp_address&#x27;] = &quot;smtpdm.aliyun.com&quot;</span><br><span class="line">        gitlab_rails[&#x27;smtp_port&#x27;] = 465</span><br><span class="line">        gitlab_rails[&#x27;smtp_user_name&#x27;] = &quot;crperx@aliyun.com&quot;</span><br><span class="line">        gitlab_rails[&#x27;smtp_password&#x27;] = &quot;Qwe456jkl?Asd789iop?&quot;</span><br><span class="line">        gitlab_rails[&#x27;smtp_domain&#x27;] = &quot;smtpdm.aliyun.com&quot;</span><br><span class="line">        gitlab_rails[&#x27;smtp_authentication&#x27;] = &quot;login&quot;</span><br><span class="line">        gitlab_rails[&#x27;smtp_enable_starttls_auto&#x27;] = true</span><br><span class="line">        gitlab_rails[&#x27;smtp_tls&#x27;] = true</span><br><span class="line">        gitlab_rails[&#x27;gitlab_email_enabled&#x27;] = true</span><br><span class="line">        gitlab_rails[&#x27;gitlab_email_from&#x27;] = &#x27;crperx@aliyun.com&#x27;</span><br><span class="line">        gitlab_rails[&#x27;gitlab_email_display_name&#x27;] = &#x27;noreply@aliyun.com&#x27;</span><br><span class="line">        gitlab_rails[&#x27;gitlab_shell_ssh_port&#x27;] = 22</span><br><span class="line">        user[&#x27;git_user_email&#x27;] = &quot;crperx@aliyun.com&quot;</span><br><span class="line">        nginx[&#x27;enable&#x27;] = true</span><br><span class="line">        nginx[&#x27;client_max_body_size&#x27;] = &#x27;250m&#x27;</span><br><span class="line">        nginx[&#x27;redirect_http_to_https&#x27;] = true</span><br><span class="line">        nginx[&#x27;ssl_certificate&#x27;] = &quot;/etc/gitlab/ssl/gitlab.crt&quot;</span><br><span class="line">        nginx[&#x27;ssl_certificate_key&#x27;] = &quot;/etc/gitlab/ssl/gitlab.key&quot;</span><br><span class="line">        nginx[&#x27;ssl_ciphers&#x27;] = &quot;ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256&quot;</span><br><span class="line">        nginx[&#x27;ssl_prefer_server_ciphers&#x27;] = &quot;on&quot;</span><br><span class="line">        nginx[&#x27;ssl_protocols&#x27;] = &quot;TLSv1.1 TLSv1.2&quot;</span><br><span class="line">        nginx[&#x27;ssl_session_cache&#x27;] = &quot;builtin:1000  shared:SSL:10m&quot;</span><br><span class="line">        nginx[&#x27;listen_addresses&#x27;] = [&quot;0.0.0.0&quot;]</span><br><span class="line">        nginx[&#x27;http2_enabled&#x27;] = true</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.gitlab.com/runner/register/index.html#docker">https://docs.gitlab.com/runner/register/index.html#docker</a>  </p><p><a href="https://docs.gitlab.com/runner/install/docker.html">https://docs.gitlab.com/runner/install/docker.html</a></p><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>使用默认端口时，gitlab 仓库下载地址示例：</p><p><img src="/docker/docker-34-deploy-gitlab-server/10.png" alt="image-20210715100826319"></p><p>容器内部改了端口并做了映射，相应的下载地址示例：</p><p><img src="/docker/docker-34-deploy-gitlab-server/11.png" alt="image-20210715100243798"></p><h2 id="构建基础镜像"><a href="#构建基础镜像" class="headerlink" title="构建基础镜像"></a>构建基础镜像</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc gcc-c++ kernel-devel make bzip2 -y</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文涉及一种在容器中部署 gitlab 服务的方法，并结合其自带的 gitlab-runner 实现 CICD 功能。其目的是为了在实际工作中使用代码托管及自动化操作。  &lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="http://www.latelee.org/category/docker/"/>
    
    
    <category term="docker" scheme="http://www.latelee.org/tag/docker/"/>
    
  </entry>
  
  <entry>
    <title>李迟2021年7月知识总结</title>
    <link href="http://www.latelee.org/my-library/code-for-2021-07.html"/>
    <id>http://www.latelee.org/my-library/code-for-2021-07.html</id>
    <published>2021-07-30T16:00:00.000Z</published>
    <updated>2021-09-06T14:40:30.034Z</updated>
    
    <content type="html"><![CDATA[<p>本文为 2021 年 7 月知识总结。</p><span id="more"></span><h2 id="编码总结"><a href="#编码总结" class="headerlink" title="编码总结"></a>编码总结</h2><h3 id="C-C"><a href="#C-C" class="headerlink" title="C / C++"></a>C / C++</h3><p>读取文件，在得到一行字符串中查找中文：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int readIFile2Map(const char* filename)</span><br><span class="line">&#123;</span><br><span class="line">truestring str;</span><br><span class="line">    ifstream ifs1(filename);</span><br><span class="line"></span><br><span class="line">    if(!ifs1.is_open())&#123;</span><br><span class="line">        printf(&quot;open %s failed\n&quot;, filename);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">trueint flag = 0;</span><br><span class="line">    while(getline(ifs1, str))</span><br><span class="line">    &#123;</span><br><span class="line">        // printf(&quot;str: [%s]\n&quot;, str.c_str());</span><br><span class="line">truetrue// 直接查中文，不知是否一直可行？</span><br><span class="line">truetrueif ((int)str.find(&quot;新增列表，&quot;) &gt; 0) flag = 1;</span><br><span class="line">truetrueif ((int)str.find(&quot;差异列表，&quot;) &gt; 0) flag = 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：当读取的文件格式为UTF8时，C++源码文件亦要UTF8。原则上应保持编码格式一致。细节未深入。</p><p>二维数组引用传递：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test_new.cpp:508:109: 错误：‘diffTypeCount’声明为引用的数组</span><br><span class="line">      std::map&lt;std::string, int&gt; mIntervalDiff, int&amp; diffTypeCount[4], bool needCheck)</span><br><span class="line"></span><br><span class="line">原声明：</span><br><span class="line">void calcDiffSPath(std::map&lt;std::fstd::map&lt;std::string, int&gt; mIntervalDiff, int&amp; diffTypeCount[4], bool needCheck)</span><br><span class="line">现改为：</span><br><span class="line">void calcDiffSPath(std::map&lt;std::fstd::map&lt;std::string, int&gt; mIntervalDiff, int(&amp; diffTypeCount)[4], bool needCheck)</span><br><span class="line">问题解决。</span><br></pre></td></tr></table></figure><h3 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h3><p>切片删除示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">seq := []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;&#125;  </span><br><span class="line">   // 删除第2个索引，即c</span><br><span class="line">   index := 2</span><br><span class="line">   seq = append(seq[:index], seq[index+1:]...)</span><br><span class="line"></span><br><span class="line">// 删除前面4个，即索引0~索引3，a~d</span><br><span class="line">index := 3</span><br><span class="line">   seq = append(seq[:0], seq[index+1:]...)</span><br><span class="line">   </span><br><span class="line">   // 删除最后一个</span><br><span class="line">seq = append(seq[:len(seq)-1])</span><br><span class="line"></span><br><span class="line">结构体切片清空：</span><br><span class="line">fooInfo = []UserInfo&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title></a></h3><h3 id="编码其它"><a href="#编码其它" class="headerlink" title="编码其它"></a>编码其它</h3><h2 id="一般知识"><a href="#一般知识" class="headerlink" title="一般知识"></a>一般知识</h2><h2 id="研发思考"><a href="#研发思考" class="headerlink" title="研发思考"></a>研发思考</h2><p>部门要过CMMI，这个月请老师来培训了CMMI5。后面自己实操，发现除了文档就是文档，代码倒是次要的了。  </p><h2 id="本月学习及计划"><a href="#本月学习及计划" class="headerlink" title="本月学习及计划"></a>本月学习及计划</h2><p>无</p><h2 id="其它点滴"><a href="#其它点滴" class="headerlink" title="其它点滴"></a>其它点滴</h2><p>买房提上日程了，业余写代码时间减少了，陪小孩的时间也少了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文为 2021 年 7 月知识总结。&lt;/p&gt;</summary>
    
    
    
    <category term="我的程序代码" scheme="http://www.latelee.org/category/my-library/"/>
    
    
    <category term="代码积累" scheme="http://www.latelee.org/tag/%E4%BB%A3%E7%A0%81%E7%A7%AF%E7%B4%AF/"/>
    
    <category term="知识总结" scheme="http://www.latelee.org/tag/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>我的docker随笔33：在容器中连接oracle数据库</title>
    <link href="http://www.latelee.org/docker/docker-33-access-oracle-in-docker.html"/>
    <id>http://www.latelee.org/docker/docker-33-access-oracle-in-docker.html</id>
    <published>2021-07-13T16:00:00.000Z</published>
    <updated>2021-09-06T14:40:30.082Z</updated>
    
    <content type="html"><![CDATA[<p>本文涉及一种在容器中连接 oracle 数据库的方法和步骤，最后给出测试结果。至于使用程序的方式连接，则是后续要实施的工作。</p><span id="more"></span><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>之前在 Windows 实现了连接 oracle 数据库，本次尝试在 docker 容器中连接数据库，这样，正在用 Golang 开发软件就可在 Windows 和 Linux 上运行了，部署和使用都方便。  </p><h2 id="二、技术小结"><a href="#二、技术小结" class="headerlink" title="二、技术小结"></a>二、技术小结</h2><ul><li>下载 oci 压缩包</li><li>解压 oci 包，并设置连接参数</li><li>进入容器连接数据库</li></ul><h2 id="三、实践过程"><a href="#三、实践过程" class="headerlink" title="三、实践过程"></a>三、实践过程</h2><h3 id="3-1-linux-OCI下载"><a href="#3-1-linux-OCI下载" class="headerlink" title="3.1 linux OCI下载"></a>3.1 linux OCI下载</h3><p>登录官方下载地址：<a href="https://www.oracle.com/database/technologies/instant-client/linux-x86-64-downloads.html">https://www.oracle.com/database/technologies/instant-client/linux-x86-64-downloads.html</a> ， 需登录才能下载。包名称及校验码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cksum *</span></span><br><span class="line">109893216 63352239 instantclient-basic-linux.x64-12.1.0.2.0.zip</span><br><span class="line">1824795072 1289004 instantclient-odbc-linux.x64-12.1.0.2.0.zip</span><br><span class="line">1047596065 667174 instantclient-sdk-linux.x64-12.1.0.2.0.zip</span><br><span class="line">2255047856 861284 instantclient-sqlplus-linux.x64-12.1.0.2.0.zip</span><br></pre></td></tr></table></figure><h3 id="3-2-oci安装"><a href="#3-2-oci安装" class="headerlink" title="3.2 oci安装"></a>3.2 oci安装</h3><p>将 oci 压缩包拷贝到<code>/home/latelee/tools/oracle/</code>，解压：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unzip instantclient-basic-linux.x64-12.1.0.2.0.zip</span><br><span class="line">unzip instantclient-odbc-linux.x64-12.1.0.2.0.zip</span><br><span class="line">unzip instantclient-sdk-linux.x64-12.1.0.2.0.zip</span><br><span class="line">unzip instantclient-sqlplus-linux.x64-12.1.0.2.0.zip</span><br></pre></td></tr></table></figure><p>解压后得到目录目录为<code>instantclient_12_1</code>，在该目录创建文件<code>tnsnames.ora</code>，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">foo =</span><br><span class="line">  (DESCRIPTION =</span><br><span class="line">    (ADDRESS_LIST =</span><br><span class="line">      (ADDRESS = (PROTOCOL = TCP)(HOST = 172.18.18.18)(PORT = 1521))</span><br><span class="line">    )</span><br><span class="line">    (CONNECT_DATA =</span><br><span class="line">      (SERVICE_NAME = mydb)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">oracle_test =</span><br><span class="line">  (DESCRIPTION =</span><br><span class="line">    (ADDRESS_LIST =</span><br><span class="line">      (ADDRESS = (PROTOCOL = TCP)(HOST = 172.18.18.18)(PORT = 1521))</span><br><span class="line">    )</span><br><span class="line">    (CONNECT_DATA =</span><br><span class="line">      (SERVICE_NAME = ORCLCDB)</span><br><span class="line">    )</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>注：根据实际情况修改 oracle_test(表示链接名）、HOST(主机)、PORT(端口)、SERVICE_NAME(数据库服务名)三字段值。  </p><p>文中将 oci 存储到目录<code>/home/latelee/tools/oracle/instantclient_12_1</code>，是为了方便多个容器映射使用。当然也可以将 oci 的文件放到 docker 镜像中，但笔者认为不太好，故不采用。  </p><h3 id="3-2-在容器中验证"><a href="#3-2-在容器中验证" class="headerlink" title="3.2 在容器中验证"></a>3.2 在容器中验证</h3><p>在主机中拷贝依赖库，本文中使用的<code>sqlplus</code>依赖于动态库<code>libaio.so.1</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /lib64/libaio.so.1.0.1 /home/latelee/tools/oracle/instantclient_12_1</span><br><span class="line">cd /home/latelee/tools/oracle/instantclient_12_1</span><br><span class="line">sudo ln -s libaio.so.1 libaio.so.1.0.1 </span><br></pre></td></tr></table></figure><p>注意，也可将动态库单独拷贝至一 lib 目录，再进行映射，本文图方便直接放到 oci 目录了。  </p><p>使用 <code>latelee/ubuntu</code> 进行实验。进入容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm -v /home/latelee/tools/oracle/instantclient_12_1:/work/instantclient_12_1 --name foo latelee/ubuntu bash</span><br></pre></td></tr></table></figure><p>在容器中设置环境变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export ORACLE_HOME=/work/instantclient_12_1</span><br><span class="line">export TNS_ADMIN=$ORACLE_HOME</span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/work/instantclient_12_1</span><br></pre></td></tr></table></figure><p>在容器中进入<code>/work/instantclient_12_1</code>目录，执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sqlplus my_db/123456@oracle_test </span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connected to:</span><br><span class="line">Oracle Database 19c Enterprise Edition Release 19.0.0.0.0 - Production</span><br></pre></td></tr></table></figure><p>表示连接成功。</p><p>后续将使用 golang 实现程序方式的连接。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文涉及一种在容器中连接 oracle 数据库的方法和步骤，最后给出测试结果。至于使用程序的方式连接，则是后续要实施的工作。&lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="http://www.latelee.org/category/docker/"/>
    
    
    <category term="docker" scheme="http://www.latelee.org/tag/docker/"/>
    
  </entry>
  
  <entry>
    <title>用封装的栈回溯类捕获段错误</title>
    <link href="http://www.latelee.org/my-library/catch-segmentfault-using-backtrace.html"/>
    <id>http://www.latelee.org/my-library/catch-segmentfault-using-backtrace.html</id>
    <published>2021-07-07T16:00:00.000Z</published>
    <updated>2021-09-06T14:40:30.034Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍使用自封装的 backtrace 类对段错误进行捕获，以方便分析运行错误的方法。并给出实现和测试代码。</p><span id="more"></span><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们写程序难免会运行出错，常在河边，哪能不湿鞋。出错不可怕，怕的是无法定位问题，像段错误，在服务端、嵌入式等领域，很多时候都无迹可寻，我们可以用 coredump 进行事后分析，但还是略显麻烦。</p><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>本节介绍<code>CBackTracer</code>类的设计。</p><ul><li>利用<code>backtrace</code>和<code>backtrace_symbols</code>可以获取函数符号和地址。</li><li>可以指定获取的函数数量，本文暂定为10，如果回溯的函数数量少于指定的，则按实际数量显示。</li><li>得到地址后，使用<code>addr2line</code>命令解析出对应的文件行号。由于该命令需要程序名称，因此需要调用者提供程序名称，与信号值一并传递。</li><li>由于<code>sigaction</code>的回调函数不能使用类内的函数，因为单独编写之。</li></ul><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>实现代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">// 头文件 backtraceplus.h</span><br><span class="line">#ifndef BACKTRACEPLUS_H</span><br><span class="line">#define BACKTRACEPLUS_H</span><br><span class="line"></span><br><span class="line">class CBackTracer &#123;</span><br><span class="line">public:</span><br><span class="line">    CBackTracer() &#123;&#125;</span><br><span class="line">    CBackTracer(const char* name, int sig); // argv[0] SIGSEGV</span><br><span class="line">    ~CBackTracer() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    void Setup(const char* name, int sig);</span><br><span class="line">private:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 实现文件 backtraceplus.cpp</span><br><span class="line">#include &lt;execinfo.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;backtraceplus.h&quot;</span><br><span class="line"></span><br><span class="line">// 程序名，用于输出函数行号</span><br><span class="line">static char g_exeName[256] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">// 不能作为了类成员</span><br><span class="line">void fault_trap(int sig, siginfo_t * siginfo, void *myact)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Catch SegmentFault!!\n&quot;);</span><br><span class="line"></span><br><span class="line">    void *array[10] = &#123; 0 &#125;;</span><br><span class="line">    int num = backtrace(array, 10);</span><br><span class="line">    char **calls = backtrace_symbols(array, num);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        char *symbol = calls[i];</span><br><span class="line"></span><br><span class="line">        char addr[64] = &#123; 0 &#125;;</span><br><span class="line">        char *p = strstr(symbol, &quot;[0x&quot;);</span><br><span class="line">        snprintf(addr, sizeof(addr), p + 1);</span><br><span class="line">        *(addr + strlen(addr) - 1) = 0;</span><br><span class="line"></span><br><span class="line">        char cmd[64] = &#123; 0 &#125;;</span><br><span class="line">        snprintf(cmd, sizeof(cmd), &quot;addr2line %s -s -e %s&quot;, addr, g_exeName);</span><br><span class="line"></span><br><span class="line">        FILE *fp = popen(cmd, &quot;r&quot;);</span><br><span class="line"></span><br><span class="line">        char buf[256] = &#123; 0 &#125;;</span><br><span class="line">        fread(buf, sizeof(buf), sizeof(char), fp);</span><br><span class="line"></span><br><span class="line">        printf(&quot;%s %s&quot;, symbol, buf);</span><br><span class="line"></span><br><span class="line">        pclose(fp);</span><br><span class="line">        fp = NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CBackTracer::CBackTracer(const char* name, int sig)</span><br><span class="line">&#123;</span><br><span class="line">    Setup(name, sig);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CBackTracer::Setup(const char* name, int sig)</span><br><span class="line">&#123;</span><br><span class="line">    strncpy(g_exeName, name, sizeof(g_exeName));</span><br><span class="line"></span><br><span class="line">    struct sigaction act;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = SA_SIGINFO;</span><br><span class="line">    act.sa_sigaction = fault_trap;</span><br><span class="line">    sigaction(sig, &amp;act, NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>测试代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;execinfo.h&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;backtraceplus.h&quot;</span><br><span class="line"></span><br><span class="line">void badcall(void)</span><br><span class="line">&#123;</span><br><span class="line">    int a = 250;</span><br><span class="line">    printf(&quot;fault: %s\n&quot;, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void foobar(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;in %s, call bad\n&quot;, __func__);</span><br><span class="line">    </span><br><span class="line">    badcall();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myfunc(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;in %s\n&quot;, __func__);</span><br><span class="line"></span><br><span class="line">    foobar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;test of backtrace...\n&quot;);</span><br><span class="line">    </span><br><span class="line">    //CBackTracer mybt(argv[0], SIGSEGV);</span><br><span class="line">    </span><br><span class="line">    CBackTracer mybt;</span><br><span class="line">    mybt.Setup(argv[0], SIGSEGV);</span><br><span class="line"></span><br><span class="line">    myfunc();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out </span><br><span class="line">test of backtrace...</span><br><span class="line">in myfunc</span><br><span class="line">in foobar, call bad</span><br><span class="line">fault: Catch SegmentFault!!</span><br><span class="line">./a.out(_Z10fault_trapiP9siginfo_tPv+0x57) [0x40159f] backtraceplus.cpp:23</span><br><span class="line">/usr/lib64/libc.so.6(+0x363b0) [0x7f9baac973b0] ??:0</span><br><span class="line">/usr/lib64/libc.so.6(_IO_vfprintf+0x4a79) [0x7f9baacae029] ??:0</span><br><span class="line">/usr/lib64/libc.so.6(_IO_printf+0x99) [0x7f9baacb4459] ??:0</span><br><span class="line">./a.out(_Z7badcallv+0x23) [0x401800] main.cpp:23</span><br><span class="line">./a.out(_Z6foobarv+0x21) [0x401823] main.cpp:31</span><br><span class="line">./a.out(_Z6myfuncv+0x1d) [0x401882] main.cpp:46</span><br><span class="line">./a.out(main+0x50) [0x4018d4] main.cpp:59</span><br><span class="line">/usr/lib64/libc.so.6(__libc_start_main+0xf5) [0x7f9baac83505] ??:0</span><br><span class="line">./a.out() [0x401169] ??:?</span><br></pre></td></tr></table></figure><p>注：已经能捕获到段错误，由于系统库没有源码，因此<code>libc.so.6</code>文件最后显示的是<code>??:0</code>，但我们的测试程序<code>a.out</code>可以显示行号。根据行号，可以逐步排查问题。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文的示例有几个依赖条件：系统需安装有<code>addr2line</code>命令，程序需使用调试版本，不能<code>strip</code>，否则无法分析出程序函数位置。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍使用自封装的 backtrace 类对段错误进行捕获，以方便分析运行错误的方法。并给出实现和测试代码。&lt;/p&gt;</summary>
    
    
    
    <category term="我的程序代码" scheme="http://www.latelee.org/category/my-library/"/>
    
    
    <category term="工程库代码" scheme="http://www.latelee.org/tag/%E5%B7%A5%E7%A8%8B%E5%BA%93%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>李迟2021年6月知识总结</title>
    <link href="http://www.latelee.org/my-library/code-for-2021-06.html"/>
    <id>http://www.latelee.org/my-library/code-for-2021-06.html</id>
    <published>2021-06-29T16:00:00.000Z</published>
    <updated>2021-09-06T14:40:30.034Z</updated>
    
    <content type="html"><![CDATA[<p>本文为 2021 年 6 月知识总结。</p><span id="more"></span><h2 id="编码总结"><a href="#编码总结" class="headerlink" title="编码总结"></a>编码总结</h2><h3 id="C-C"><a href="#C-C" class="headerlink" title="C / C++"></a>C / C++</h3><p>使用<code>sscanf</code>检查不确定的输入参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">char</span> name[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> type = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> threadnum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> total = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 注：先检查多的，再检查少的</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="built_in">sscanf</span>(cmd, <span class="string">&quot;%s %d %d %d&quot;</span>, name, &amp;type, &amp;threadnum, &amp;total); </span><br><span class="line"><span class="keyword">if</span> (num != <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">truenum = <span class="built_in">sscanf</span>(cmd, <span class="string">&quot;%s %d %d&quot;</span>, name, &amp;type, &amp;threadnum);</span><br><span class="line">true<span class="keyword">if</span> (num != <span class="number">3</span>)</span><br><span class="line">true&#123;</span><br><span class="line">truetrue<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：实践中检查参数，建议使用<code>main(argc, argv[])</code>的形式，好修改。</p><h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><p>修改容器的root密码</p><p>场景：下载 centos 镜像，运行之，默认为普通用户，无法切换到 root——因为不知道密码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker exec -id -u root &lt;容器名或ID&gt; bash</span><br></pre></td></tr></table></figure><p>此时进入的容器即为 root 权限。再用<code>passwd root</code>设置密码。此时另起终端进入容器，即可用<code>su root</code>切换权限。当然，也可直接用上述命令进行<code>root</code>权限方面的操作。  </p><h3 id="python脚本创建docker镜像"><a href="#python脚本创建docker镜像" class="headerlink" title="python脚本创建docker镜像"></a>python脚本创建docker镜像</h3><p>知识点：执行命令，执行命令并获取返回值，字符串为空的判断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">SRC_PATH = &#x27;/home/latelee/docker-test/demo&#x27;</span><br><span class="line">DOCKER_ADDRESS = &quot;registry.cn-hangzhou.aliyuncs.com/latleee&quot;</span><br><span class="line">DOCKER_IMAGE_NAME = &quot;busybox&quot;</span><br><span class="line">DOCKER_TAG = &quot;latest&quot;</span><br><span class="line"></span><br><span class="line">def buidDocker():</span><br><span class="line">    # 可切换到目标目录</span><br><span class="line">    #os.chdir(SRC_PATH)</span><br><span class="line"></span><br><span class="line">    # 查询已存在的镜像并删除之，注：用popen获取返回的镜像ID</span><br><span class="line">    cmd = &quot;docker images | grep &quot; + DOCKER_IMAGE_NAME + &quot; | awk &#x27;&#123;print $3&#125;&#x27;&quot;</span><br><span class="line">    imageid = os.popen(cmd).read()</span><br><span class="line">    #print(&quot;cmd %s %s&quot; % (cmd, imageid))</span><br><span class="line"></span><br><span class="line">    if len(imageid) != 0:</span><br><span class="line">        print(&quot;found docker image, remove it&quot;)</span><br><span class="line">        cmd = &#x27;docker rmi &#x27; + imageid</span><br><span class="line">        os.system(cmd)</span><br><span class="line"></span><br><span class="line">    print(&quot;start build  docker in %s&quot; % (SRC_PATH))</span><br><span class="line"></span><br><span class="line">    # 使用绝对路径</span><br><span class="line">    cmd = &quot;docker build -t &quot; + DOCKER_ADDRESS + &quot;/&quot; + DOCKER_IMAGE_NAME + &quot; &quot; + SRC_PATH</span><br><span class="line">    # 前述切换目录，则可用此命令</span><br><span class="line">    #cmd = &quot;docker build -t &quot; + DOCKER_ADDRESS + &quot;/&quot; + DOCKER_IMAGE_NAME + &quot; .&quot;</span><br><span class="line">    #print(&quot;build cmd: %s &quot; % (cmd))</span><br><span class="line">    ret = os.system(cmd)</span><br><span class="line"></span><br><span class="line">    if ret == 0:</span><br><span class="line">        print(&#x27;build docker ok&#x27;)</span><br><span class="line">    else:</span><br><span class="line">        print(&#x27;build docker failed&#x27;)</span><br></pre></td></tr></table></figure><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p>查询 sqlite3 数据库所有表名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> sqlite_master <span class="keyword">where</span> type<span class="operator">=</span><span class="string">&#x27;table&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> name</span><br></pre></td></tr></table></figure><h3 id="编码其它"><a href="#编码其它" class="headerlink" title="编码其它"></a>编码其它</h3><h4 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h4><p>继续总结 Makefile 知识：  </p><p>某工程需编译为 32 位程序和 64 位程序，因为有2套目标系统。原来的工程使用 eclipse 编辑和编译。接手后改为 Makefile 编译，为方便个人使用，研究如何在 Makefile 中自适应 2 种不同位数的系统。</p><p>在 shell 脚本中可如下方法判断系统位数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BITS=`getconf LONG_BIT`</span><br><span class="line">BITS=&quot;  --$BITS&quot;bit</span><br></pre></td></tr></table></figure><p>根据所在系统，上述输出结果为<code>32bit</code>或<code>64bit</code>，此字符串可用于生成版本号头文件。  </p><p>在 Makefile 中如下使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ARCH = $(shell getconf LONG_BIT)</span><br><span class="line"></span><br><span class="line">DEFS    += -DARCH=$(ARCH)</span><br><span class="line"></span><br><span class="line">ifeq ($(ARCH), 32)</span><br><span class="line">CFLAGS += -I/usr/local/sqlite/sqlite-x86/include/</span><br><span class="line">LDFLAGS += -L/usr/local/sqlite/sqlite-x86/lib/ -L/usr/local/uuid/uuid-x86/</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><p>这样就能根据不同的系统使用不同的库目录。</p><p>另外，目标系统中，32 位为 debian 系统，64 位为 centos 系统，本想用 Docker 实现同一虚拟机的编译，但因为版本不好找，放弃之。再者，工程有大量不再使用但未删除的代码，大部分变量、函数近似，只是相差几个字符或日期，如<code>foo</code>、<code>foo_I</code>、<code>foo_2020</code>，导致一定的阅读障碍——刚刚看过的代码段，切换了文件，又看到相同的，过一会，还能看到相同的。目前暂不敢动。  </p><h4 id="版权"><a href="#版权" class="headerlink" title="版权"></a>版权</h4><p>github上有个外国网友在一个几年前的项目上咨询协议，因为当时代码是没有版权声明的——现在大部分代码都没有，看了些帖子，大意是没有声明版权的话，默认是私有不开源的。考虑之后，还是要将自己仓库加上声明的。对其它人友好，对后续维护亦友好。目前暂定是 BSP 协议，限制比较少。  </p><p>BSD：允许商用、私用（共开亦可）。带原有的版权文件，修改后的代码不用做说明。不能用作者名字做推广。</p><h2 id="一般知识"><a href="#一般知识" class="headerlink" title="一般知识"></a>一般知识</h2><h2 id="研发思考"><a href="#研发思考" class="headerlink" title="研发思考"></a>研发思考</h2><p>写代码久了，发现自己不敢突破，不追求编程技巧，而是追求可维护性、可读性。有时候，发现一些问题后自然会去重构，但重构后发现达不到预期，因为有些隐藏得很深的业务点，自己并没有掌握了解，贸然修改，只会浪费时间。所以，只要不出问题，不会主动去改，但像代码风格命名这种影响编程效率的，不在此列。在修改过程中，则根据实际情况**部分重构  **。</p><p>领域设计：先对某领域有一定认知，进行总结概括，理清逻辑，再进行设计。个人见解：应该不合适，编码多年，接触了不同领域的行业，但自己那套学习知识的方法和编写的代码，或多或少都能应用上。——因为会总结积累，从而形成自己的知识库，以应对不同的领域/业务。而且更重要的一个原因，自己并没有在一个领域中深耕。可能自己对<strong>业务</strong>研究不深，沉淀不够，才得出以上结论。  </p><h2 id="本月学习及计划"><a href="#本月学习及计划" class="headerlink" title="本月学习及计划"></a>本月学习及计划</h2><p>无</p><h2 id="其它点滴"><a href="#其它点滴" class="headerlink" title="其它点滴"></a>其它点滴</h2><p>自体检出结果，打完2针疫苗，外包人员取消餐补后，家里那位问什么时候买房，又和老爸老妈小吵一次，工作和生活都没动力了。但并没有耽误公司的事，晚上加了几次小班，上周末加了一整天的班（早上8点到公司至下午6点离开），在百年献礼中也算出了一点微不足道的力。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文为 2021 年 6 月知识总结。&lt;/p&gt;</summary>
    
    
    
    <category term="我的程序代码" scheme="http://www.latelee.org/category/my-library/"/>
    
    
    <category term="代码积累" scheme="http://www.latelee.org/tag/%E4%BB%A3%E7%A0%81%E7%A7%AF%E7%B4%AF/"/>
    
    <category term="知识总结" scheme="http://www.latelee.org/tag/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：利用反射reflect构建通用打印结构体接口</title>
    <link href="http://www.latelee.org/golang/golang-notes-print-structure.html"/>
    <id>http://www.latelee.org/golang/golang-notes-print-structure.html</id>
    <published>2021-06-28T16:01:00.000Z</published>
    <updated>2021-09-06T14:40:29.958Z</updated>
    
    <content type="html"><![CDATA[<p>本文针对 Golang 的结构体字段的打印进行一些研究。其中涉及到一些反射的知识。  </p><span id="more"></span><h2 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h2><p>总结一些实践情况，结构体字段值的输出还是比较常见的，至少笔者目前常用。比如输出某些数据表的数据（代码中会转换为结构体），对比不同版本数据表的数据，对比某些不同版本但格式相同的 json 文件，等。为了优化代码，减少开发维护工作量，需寻找一种高效的方法。打印结构体。需求如下：  </p><ul><li>格式化，目前需迎合 markdown 表格格式。  </li><li>接口可通用于数组、map等结构，原则上直接传递某个变量，即可自行输出格式化后的所需内容。  </li><li>可输出到终端，或文件。  </li></ul><h2 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h2><p>本文使用的测试数据如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">type TestObj struct &#123;</span><br><span class="line">    Name  string</span><br><span class="line">    Value uint64</span><br><span class="line">    Size  int32</span><br><span class="line">    Guard float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var objects []TestObj</span><br><span class="line"></span><br><span class="line">    object1 := TestObj&#123;</span><br><span class="line">        Name:  &quot;Jim | Kent&quot;,</span><br><span class="line">        Value: 128,</span><br><span class="line">        Size:  256,</span><br><span class="line">        Guard: 56.4,</span><br><span class="line">    &#125;</span><br><span class="line">    object2 := TestObj&#123;</span><br><span class="line">        Name:  &quot;James1&quot;,</span><br><span class="line">        Value: 128,</span><br><span class="line">        Size:  259,</span><br><span class="line">        Guard: 56.4,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    objects = append(objects, object1)</span><br><span class="line">    objects = append(objects, object2)</span><br><span class="line">    </span><br><span class="line">    var myMap map[string]TestObj</span><br><span class="line">    myMap = make(map[string]TestObj)</span><br><span class="line">    myMap[&quot;obj3&quot;] = TestObj&#123;&quot;Jim Kent&quot;, 103, 201, 102.56&#125;</span><br><span class="line">    myMap[&quot;obj1&quot;] = TestObj&#123;&quot;Kent&quot;, 101, 201, 102.56&#125;</span><br><span class="line">    myMap[&quot;obj2&quot;] = TestObj&#123;&quot;Kent&quot;, 102, 201, 102.56&#125;</span><br></pre></td></tr></table></figure><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>对于可识别渲染 markdown 的平台来说，输出的如下结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print by line - slice default  </span><br><span class="line">total: 2  </span><br><span class="line"></span><br><span class="line">| Name          | Value | Size | Guard |</span><br><span class="line">| ------------- | ----- | ---- | ----- |</span><br><span class="line">| Jim &lt;br&gt; Kent | 128   | 256  | 56.4  |</span><br><span class="line">| James1        | 128   | 259  | 56.4  |</span><br></pre></td></tr></table></figure><p>就能正常显示表格形式。如下：</p><p>print by line - slice default<br>total: 2  </p><table><thead><tr><th>Name</th><th>Value</th><th>Size</th><th>Guard</th></tr></thead><tbody><tr><td>Jim <br> Kent</td><td>128</td><td>256</td><td>56.4</td></tr><tr><td>James1</td><td>128</td><td>259</td><td>56.4</td></tr></tbody></table><h2 id="简单版本"><a href="#简单版本" class="headerlink" title="简单版本"></a>简单版本</h2><p>遍历结构体数据，并打印之：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for a, b := range objects &#123;</span><br><span class="line">    fmt.Printf(&quot;%v %v\n&quot;, a, b)</span><br><span class="line">    // fmt.Printf(&quot;%v %+v\n&quot;, a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要格式化，需显式给出结构体字段和格式化形式。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for a, b := range objects &#123;</span><br><span class="line">    fmt.Printf(&quot;%d: %v | %v | %v | %v\n&quot;, a, b.Name, b.Value, b.Size, b.Guard)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上结果分别如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 &#123;Jim | Kent 128 256 56.4&#125;</span><br><span class="line">1 &#123;James1 128 259 56.4&#125;</span><br><span class="line"></span><br><span class="line">0: Jim | Kent | 128 | 256 | 56.4</span><br><span class="line">1: James1 | 128 | 259 | 56.4</span><br></pre></td></tr></table></figure><p>由于此版本非吾所用，因此只具大致形式。  </p><p>可以看到，前者简单，不用理会结构体内容，直接使用<code>%v</code>即可打印，如需要输出结构体字段名，则用<code>%+v</code>。但其形式固定的，类似<code>&#123;xx xx xx&#125;</code>这样。后者使用竖线<code>|</code>将各字段隔开，需一一写出字段（当然也可忽略部分字段）。  </p><h2 id="reflect版本"><a href="#reflect版本" class="headerlink" title="reflect版本"></a>reflect版本</h2><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">func checkSkipNames(a string, b []string) bool &#123;</span><br><span class="line">    for _, item := range b &#123;</span><br><span class="line">        if item == a &#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 结构体的字段名称</span><br><span class="line">func GetStructName(myref reflect.Value, names []string) (buffer string) &#123;</span><br><span class="line">    // 注：有可能传递string数组，此时没有“标题”一说，返回</span><br><span class="line">    if myref.Type().Name() == &quot;string&quot; &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    for i := 0; i &lt; myref.NumField(); i++ &#123;</span><br><span class="line">        if ok := checkSkipNames(myref.Type().Field(i).Name, names); ok &#123;</span><br><span class="line">            continue</span><br><span class="line">        &#125;</span><br><span class="line">        buffer += fmt.Sprintf(&quot;| %v &quot;, myref.Type().Field(i).Name)</span><br><span class="line">    &#125;</span><br><span class="line">    buffer += fmt.Sprintf(&quot;|\n&quot;)</span><br><span class="line">    for i := 0; i &lt; myref.NumField(); i++ &#123;</span><br><span class="line">        if ok := checkSkipNames(myref.Type().Field(i).Name, names); ok &#123;</span><br><span class="line">            continue</span><br><span class="line">        &#125;</span><br><span class="line">        buffer += fmt.Sprintf(&quot;| --- &quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    buffer += fmt.Sprintf(&quot;|\n&quot;)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将 | 替换为 &lt;br&gt;</span><br><span class="line">func replaceI(text string) (ret string) &#123;</span><br><span class="line">    // 下面2种方法都可以</span><br><span class="line">    // reg := regexp.MustCompile(`\|`)</span><br><span class="line">    // ret = reg.ReplaceAllString(text, `$&#123;1&#125;&lt;br/&gt;`)</span><br><span class="line">    ret = strings.Replace(text, &quot;|&quot;, &quot;&lt;br&gt;&quot;, -1)</span><br><span class="line">    // fmt.Printf(&quot;!!! %q\n&quot;, ret)</span><br><span class="line">    return ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 结构体的值</span><br><span class="line">func GetStructValue(myref reflect.Value, names []string) (buffer string) &#123;</span><br><span class="line">    // 注：有可能传递string数组，此时没有“字段”一说，返回原本的内容</span><br><span class="line">    if myref.Type().Name() == &quot;string&quot; &#123;</span><br><span class="line">        return myref.Interface().(string)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; myref.NumField(); i++ &#123;</span><br><span class="line">        if ok := checkSkipNames(myref.Type().Field(i).Name, names); ok &#123;</span><br><span class="line">            continue</span><br><span class="line">        &#125;</span><br><span class="line">        // 判断是否包含|，有则替换，其必须是string类型，其它保持原有的</span><br><span class="line">        t := myref.Field(i).Type().Name()</span><br><span class="line">        if t == &quot;string&quot; &#123;</span><br><span class="line">            var str string = myref.Field(i).Interface().(string)</span><br><span class="line">            str = replaceI(str)</span><br><span class="line">            buffer += fmt.Sprintf(&quot;| %v &quot;, str)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            buffer += fmt.Sprintf(&quot;| %v &quot;, myref.Field(i).Interface())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer += fmt.Sprintf(&quot;|\n&quot;)</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func PrintStructTable(data interface&#123;&#125;, title string, skipNames ...string) &#123;</span><br><span class="line">    var w io.Writer</span><br><span class="line">    w = os.Stdout // set to stdout</span><br><span class="line">    buffer, num := PrintStructTable2Buffer(data, title, skipNames...)</span><br><span class="line">    fmt.Fprintf(w, &quot;total: %v\n&quot;, num)</span><br><span class="line">    fmt.Fprintf(w, &quot;%v\n&quot;, buffer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">功能：指定结构体data，其可为slice map 单独结构体</span><br><span class="line">     指定自定义标题，为空则使用结构体字段</span><br><span class="line">     指定忽略的字段名称（即结构体字段的变量）</span><br><span class="line">     按结构体定义的顺序列出，如自定义标题，则必须保证一致。</span><br><span class="line">*/</span><br><span class="line">func PrintStructTable2Buffer(data interface&#123;&#125;, title string, skipNames ...string) (buffer string, num int) &#123;</span><br><span class="line">    buffer = &quot;&quot;</span><br><span class="line"></span><br><span class="line">    t := reflect.TypeOf(data)</span><br><span class="line">    v := reflect.ValueOf(data)</span><br><span class="line"></span><br><span class="line">    var skipNamess []string</span><br><span class="line">    for _, item := range skipNames &#123;</span><br><span class="line">        skipNamess = append(skipNamess, item)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 打印结构体字段标志</span><br><span class="line">    innertitle := false</span><br><span class="line">    printHead := false</span><br><span class="line">    if len(title) == 0 &#123;</span><br><span class="line">        innertitle = true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 不同类型的，其索引方式不同，故一一判断使用</span><br><span class="line">    switch t.Kind() &#123;</span><br><span class="line">    case reflect.Slice, reflect.Array:</span><br><span class="line">        num = v.Len()</span><br><span class="line">        if innertitle &#123;</span><br><span class="line">            buffer += GetStructName(v.Index(0), skipNamess)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            buffer += fmt.Sprintln(title)</span><br><span class="line">        &#125;</span><br><span class="line">        for i := 0; i &lt; v.Len(); i++ &#123;</span><br><span class="line">            buffer += GetStructValue(v.Index(i), skipNamess)</span><br><span class="line">        &#125;</span><br><span class="line">    case reflect.Map:</span><br><span class="line">        num = v.Len()</span><br><span class="line">        iter := v.MapRange()</span><br><span class="line">        for iter.Next() &#123;</span><br><span class="line">            if !printHead &#123;</span><br><span class="line">                if innertitle &#123;</span><br><span class="line">                    buffer += GetStructName(iter.Value(), skipNamess)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    buffer += fmt.Sprintln(title)</span><br><span class="line">                &#125;</span><br><span class="line">                printHead = true</span><br><span class="line">            &#125;</span><br><span class="line">            buffer += GetStructValue(iter.Value(), skipNamess)</span><br><span class="line">        &#125;</span><br><span class="line">    default:</span><br><span class="line">        num = 1 // 单独结构体不能用Len，单独赋值</span><br><span class="line">        if !printHead &#123;</span><br><span class="line">            if innertitle &#123;</span><br><span class="line">                buffer += GetStructName(v, skipNamess)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                buffer += fmt.Sprintln(title)</span><br><span class="line">            &#125;</span><br><span class="line">            printHead = true</span><br><span class="line">        &#125;</span><br><span class="line">        buffer += GetStructValue(v, skipNamess)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码提供的对外接口为<code>PrintStructTable2Buffer</code>和<code>PrintStructTable</code>，因为默认格式为<code>markdown</code>表格形式，故加上<code>Table</code>。前者输出到缓冲区的（可继续写到文件中），后者直接输出终端。真正实现的接口为<code>PrintStructTable2Buffer</code>，其提供了自定义标题，和忽略的字段参数，如果不指定标题，必须将<code>title</code>置为空，因为最后的参数是可变参数，只能有一个，如不写，则输出所有字段。</p><p>至于内部实现，因为需要根据用户输入忽略某些字段，因此定义<code>checkSkipNames</code>检查参数，利用<code>GetStructName</code>获取结构体名称，<code>GetStructValue</code>获取结构体的值。不管获取字段还是值，均使用传递的<code>interface&#123;&#125;</code>，不需额外传递结构体本身。<br>注意，由于默认使用竖线分隔，如果字段值本身有竖线，则使用<code>&lt;br&gt;</code>替换——即让该字段的值换行。  </p><p>测试代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 数组，默认形式</span><br><span class="line">fmt.Println(&quot;print by line - slice default&quot;)</span><br><span class="line">buf, num := PrintStructTable2Buffer(objects, &quot;&quot;)</span><br><span class="line">fmt.Println(&quot;total:&quot;, num)</span><br><span class="line">fmt.Println(buf)</span><br><span class="line"></span><br><span class="line">// 数组，自定义标题 </span><br><span class="line">fmt.Println(&quot;print by line - slice&quot;)</span><br><span class="line">buf, num = PrintStructTable2Buffer(objects, &quot;| Name | Value | Size | Guard |\n| --- | --- | --- | ++++ |&quot;)</span><br><span class="line">fmt.Println(&quot;total:&quot;, num)</span><br><span class="line">fmt.Println(buf)</span><br><span class="line">// 单个对象 </span><br><span class="line">fmt.Println(&quot;print by line - single object&quot;)</span><br><span class="line">buf, num = PrintStructTable2Buffer(object1, &quot;| Name | Value  | Guard |\n| +++ | +++ | +++ |&quot;, &quot;Size&quot;)</span><br><span class="line">fmt.Println(&quot;total:&quot;, num)</span><br><span class="line">fmt.Println(buf)</span><br><span class="line">// map</span><br><span class="line">fmt.Println(&quot;print by line - map&quot;)</span><br><span class="line">buf, num = PrintStructTable2Buffer(myMap, &quot;aaa&quot;)</span><br><span class="line">fmt.Println(buf)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">print by line - slice default</span><br><span class="line">total: 2</span><br><span class="line">| Name | Value | Size | Guard |</span><br><span class="line">| --- | --- | --- | --- |</span><br><span class="line">| Jim &lt;br&gt; Kent | 128 | 256 | 56.4 |</span><br><span class="line">| James1 | 128 | 259 | 56.4 |</span><br><span class="line"></span><br><span class="line">print by line - slice</span><br><span class="line">total: 2</span><br><span class="line">| Name | Value | Size | Guard |</span><br><span class="line">| --- | --- | --- | ++++ |</span><br><span class="line">| Jim &lt;br&gt; Kent | 128 | 256 | 56.4 |</span><br><span class="line">| James1 | 128 | 259 | 56.4 |</span><br><span class="line"></span><br><span class="line">print by line - single object</span><br><span class="line">total: 1</span><br><span class="line">| Name | Value  | Guard |</span><br><span class="line">| +++ | +++ | +++ |</span><br><span class="line">| Jim &lt;br&gt; Kent | 128 | 56.4 |</span><br><span class="line"></span><br><span class="line">print by line - map</span><br><span class="line">aaa</span><br><span class="line">| Jim Kent | 103 | 201 | 102.56 |</span><br><span class="line">| Kent | 101 | 201 | 102.56 |</span><br><span class="line">| Kent | 102 | 201 | 102.56 |</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>观察结果，可达到预期目的。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文针对 Golang 的结构体字段的打印进行一些研究。其中涉及到一些反射的知识。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：反射reflect的一些研究及代码汇总</title>
    <link href="http://www.latelee.org/golang/golang-notes-cmdtool0.html"/>
    <id>http://www.latelee.org/golang/golang-notes-cmdtool0.html</id>
    <published>2021-06-28T16:01:00.000Z</published>
    <updated>2021-09-06T14:40:29.958Z</updated>
    
    <content type="html"><![CDATA[<p>本文汇总一些工程中使用到的和 reflect 有关的代码示例。由于是代码片段，不一定保证完整。  </p><span id="more"></span><h3 id="解析json"><a href="#解析json" class="headerlink" title="解析json"></a>解析json</h3><p>本节介绍解析json的一些方法。json 可来自文件，也可来自字符串，无论哪种，都是先转换成<code>[]byte</code>，再调用<code>json.Unmarshal</code>解析。<br>有时候并不关注完整的 json 格式，我们可以只取其中一部分字段，因此，可使用<code>map[string]interface&#123;&#125;</code>来接收解析结果（注意如是数组，则须使用数组形式）。  </p><h4 id="从json文件解析其字段"><a href="#从json文件解析其字段" class="headerlink" title="从json文件解析其字段"></a>从json文件解析其字段</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.Open(filename)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    fmt.Printf(&quot;open file %s error: %s\n&quot;, filename, err)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">defer file.Close()</span><br><span class="line"></span><br><span class="line">read := io.Reader(file)</span><br><span class="line"></span><br><span class="line">data, _ := ioutil.ReadAll(read)</span><br><span class="line">var v []map[string]interface&#123;&#125;</span><br><span class="line">err = json.Unmarshal(data, &amp;v)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    fmt.Printf(&quot;Unmarshal error: %s\n&quot;, err)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 假定filename里面有很多的json数组，一一遍历</span><br><span class="line">for _, idx := range v &#123;</span><br><span class="line">    fmt.Println(idx[&quot;foo&quot;])</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="从json字符串解析"><a href="#从json字符串解析" class="headerlink" title="从json字符串解析"></a>从json字符串解析</h4><p>一个简单的示例，从字符串组装，到解析，到提取其中某个字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func TestJsonSimple(t *testing.T) &#123;</span><br><span class="line">// 原始json字符串不能格式化，必须转换成[]byte</span><br><span class="line">orgJsonString :=</span><br><span class="line">`&#123;&quot;enID&quot;:&quot;ID250&quot;,&quot;exID&quot;:&quot;ID251&quot;,&quot;type&quot;:1,&quot;money&quot;:250.44,&quot;distance&quot;:274050&#125;`</span><br><span class="line"></span><br><span class="line">    // 虽然不知道具体结构体，但知道json只有一个，不是数组</span><br><span class="line">    var data map[string]interface&#123;&#125;</span><br><span class="line">true// 解析</span><br><span class="line">    err := json.Unmarshal([]byte(orgJsonString), &amp;data)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Println(err.Error())</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;%#v\n&quot;, data);</span><br><span class="line">    fmt.Println(data[&quot;money&quot;]) // 并不关心其它字段，只抽取所需的</span><br><span class="line">    fmt.Println(data[&quot;money1&quot;]) // 不存在，返回nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map[string]interface &#123;&#125;&#123;&quot;distance&quot;:274050, &quot;enID&quot;:&quot;ID250&quot;, &quot;exID&quot;:&quot;ID251&quot;, &quot;money&quot;:250.44, &quot;type&quot;:1&#125;</span><br><span class="line">250.44</span><br><span class="line">&lt;nil&gt;</span><br></pre></td></tr></table></figure><p>json中嵌套数组，并获取数组内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">func showInterface(origin interface&#123;&#125;) &#123;</span><br><span class="line">    switch reflect.TypeOf(origin).Kind() &#123;</span><br><span class="line">    case reflect.Slice, reflect.Array:</span><br><span class="line">        s := reflect.ValueOf(origin)</span><br><span class="line">        for i := 0; i &lt; s.Len(); i++ &#123;</span><br><span class="line">            fmt.Printf(&quot;%d: %v\n&quot;, i, s.Index(i))</span><br><span class="line">        &#125;</span><br><span class="line">    case reflect.String:</span><br><span class="line">        s := reflect.ValueOf(origin)</span><br><span class="line">        fmt.Printf(&quot;only string %v\n&quot;, s.String())</span><br><span class="line">    case reflect.Int:</span><br><span class="line">        s := reflect.ValueOf(origin)</span><br><span class="line">        fmt.Printf(&quot;only int %v\n&quot;, s.Int())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestJsonArray(t *testing.T) &#123;</span><br><span class="line">    orgJsonString :=</span><br><span class="line">`&#123;&quot;enID&quot;:&quot;ID500&quot;,&quot;exID&quot;:&quot;ID501&quot;,&quot;type&quot;:2,&quot;money&quot;:27.00,&quot;distance&quot;:28322,&quot;splitInfo&quot;:[&#123;&quot;index&quot;:1,&quot;pTag&quot;:&quot;11&quot;,&quot;pMoney&quot;:700&#125;,&#123;&quot;index&quot;:2,&quot;pTag&quot;:&quot;12&quot;,&quot;pMoney&quot;:2000&#125;]&#125;`</span><br><span class="line"></span><br><span class="line">    // 解析</span><br><span class="line">    var data map[string]interface&#123;&#125;</span><br><span class="line">trueerr := json.Unmarshal([]byte(orgJsonString), &amp;data)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Println(err.Error())</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;org json:\n%#v\n\n&quot;, data);</span><br><span class="line">    showInterface(data[&quot;enID&quot;])</span><br><span class="line">    showInterface(data[&quot;splitInfo&quot;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>data[&quot;splitInfo&quot;]</code>是一个<code>interface</code>，此刻并不知道具体的内容，因此无法再获取内部的字段或长度。可以利用<code>reflect.TypeOf</code>获取类型，如是数组，需要遍历。详见代码。<br>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">org json:</span><br><span class="line">map[string]interface &#123;&#125;&#123;&quot;distance&quot;:28322, &quot;enID&quot;:&quot;ID500&quot;, &quot;exID&quot;:&quot;ID501&quot;, &quot;money&quot;:27, &quot;splitInfo&quot;:[]interface &#123;&#125;&#123;map[string]interface &#123;&#125;&#123;&quot;index&quot;:1, &quot;pMoney&quot;:700, &quot;pTag&quot;:&quot;11&quot;&#125;, map[string]interface &#123;&#125;&#123;&quot;index&quot;:2, &quot;pMoney&quot;:2000, &quot;pTag&quot;:&quot;12&quot;&#125;&#125;, &quot;type&quot;:2&#125;</span><br><span class="line"></span><br><span class="line">only string ID500</span><br><span class="line">0: map[index:1 pMoney:700 pTag:11]</span><br><span class="line">1: map[index:2 pMoney:2000 pTag:12]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接上，如果只需要获取<code>data[&quot;splitInfo&quot;]</code>的长度。注意，此处是知道该字段是数组，但不知道其内容（或不关注内容），可直接用<code>reflect.ValueOf</code>求出长度，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mylen := reflect.ValueOf(data[&quot;splitInfo&quot;]).Len()</span><br><span class="line">fmt.Println(&quot;splitInfo len: &quot;, mylen)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文汇总一些工程中使用到的和 reflect 有关的代码示例。由于是代码片段，不一定保证完整。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>“命令终端”的实现4-优化之解耦</title>
    <link href="http://www.latelee.org/my-study/my-terminal-4.html"/>
    <id>http://www.latelee.org/my-study/my-terminal-4.html</id>
    <published>2021-06-26T16:00:00.000Z</published>
    <updated>2021-09-06T14:40:30.046Z</updated>
    
    <content type="html"><![CDATA[<p>这段时间一直在做测试的工程（不是测试的工作），为了应付不同的测试场景，代码使用了解释器风格，至于实现，则使用了多年前写的命令终端代码。那会刚毕业不久，写的代码还是有提升空间。现在重新拾起，打破一般认知中的看不懂6个月前写的代码的刻板印象。</p><span id="more"></span><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><p>原来的工程使用C代码编写，并不严格区分测试代码和实现代码，其中最大的问题是将命令列表做成全局变量并依赖于外部的定义，这样耦合程序非常高。因此需要分离出来。  </p><p>原工程的文件命名也不太好，如<code>common.h</code>这样的文件，在与其它工程整合时容易冲突，此次一并修改了。</p><h2 id="命令解耦"><a href="#命令解耦" class="headerlink" title="命令解耦"></a>命令解耦</h2><p>依赖定义全局的命令列表，但只是指针，添加注册命令接口，由外部使用者调用。将默认的帮助命令调整至内部实现，外部直接使用。代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static cmd_tbl_t* cmd_table;</span><br><span class="line">static int cmd_table_len = 0;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> register command</span><br><span class="line">*/</span><br><span class="line">void register_command(cmd_tbl_t* table, int len)</span><br><span class="line">&#123;</span><br><span class="line">    cmd_table = table;</span><br><span class="line">    cmd_table_len = len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int do_help_default(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    _do_help_default(cmd_table, argc, argv);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在原有测试代码基础上，添加初始化命令函数，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/* 定义命令列表 */</span><br><span class="line">cmd_tbl_t my_cmd_table[] = </span><br><span class="line">&#123;</span><br><span class="line">    // do_help_default为默认函数，可重新实现</span><br><span class="line">    &#123;&quot;help&quot;, CONFIG_SYS_MAXARGS, do_help_default, &quot;print help info.&quot;&#125;,</span><br><span class="line">    &#123;&quot;print&quot;, 2, do_print, &quot;print the env.&quot;&#125;,</span><br><span class="line">    &#123;&quot;exit&quot;, 1, do_exit, &quot;exit...&quot;&#125;,</span><br><span class="line">    &#123;&quot;quit&quot;, 1, do_exit, &quot;exit...&quot;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 初始化，注册命令</span><br><span class="line">void cmd_init()</span><br><span class="line">&#123;</span><br><span class="line">    int len = sizeof(my_cmd_table) / sizeof(my_cmd_table[0]);</span><br><span class="line">    register_command(my_cmd_table, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，在主体函数开始处调用<code>cmd_init();</code>即可。如此一来，结构清晰，逻辑也清晰。  </p><h2 id="历史命令优化"><a href="#历史命令优化" class="headerlink" title="历史命令优化"></a>历史命令优化</h2><p>命令终端支持历史命令，由<code>HIST_MAX</code>决定数量。默认为 10 个。历史命令使用<code>hist_list</code>存储，添加命令函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cread_add_to_hist</span><span class="params">(<span class="keyword">char</span> *line)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(hist_list[hist_add_idx], line);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (++hist_add_idx &gt;= HIST_MAX)</span><br><span class="line">        hist_add_idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hist_add_idx &gt; hist_max)</span><br><span class="line">        hist_max = hist_add_idx;</span><br><span class="line"></span><br><span class="line">    hist_num++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现很简单，先添加（因为索引从0开始），再累加并与最大值比较。达到最大值后，替换存储的第0个命令。在实际执行中，有时会出现上下命令相同的情况，此时无须再次保存，以节省空间。</p><p>修改后代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cread_add_to_hist</span><span class="params">(<span class="keyword">char</span> *line)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否为相同的命令（第0条命令没有相同的说法）</span></span><br><span class="line">    <span class="keyword">if</span> (hist_add_idx &gt; <span class="number">1</span> &amp;&amp; !<span class="built_in">strcmp</span>(hist_list[hist_add_idx<span class="number">-1</span>], line)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(hist_list[hist_add_idx], line);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (++hist_add_idx &gt;= HIST_MAX)</span><br><span class="line">        hist_add_idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hist_add_idx &gt; hist_max)</span><br><span class="line">        hist_max = hist_add_idx;</span><br><span class="line"></span><br><span class="line">    hist_num++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非命令行模式"><a href="#非命令行模式" class="headerlink" title="非命令行模式"></a>非命令行模式</h2><p>截至目前，“命令终端”只有命令行模式，即执行程序初始化后，只会进入命令提示符界面，等待用户输入命令，再解析、执行。有时候，某些场景需要直接执行命令，即自动执行用户输入的命令，亦即将用户命令作为程序的参数。比如，将：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NotAShell&gt; print abc</span><br><span class="line">NotAShell&gt; print 100 200 </span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./a_all.out &quot;print abc; print 100 200;&quot;</span><br></pre></td></tr></table></figure><p>的形式，直接执行一次程序即可得到结果，不用手工输入命令。  </p><p>实现源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">// 去掉前后空格——中间的不去掉</span><br><span class="line">std::string&amp; trim(std::string &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">trueif (str.empty())</span><br><span class="line">true&#123;</span><br><span class="line">truetruereturn str;</span><br><span class="line">true&#125;</span><br><span class="line">truestr.erase(0, str.find_first_not_of(&quot; &quot;)); //去除左边空格</span><br><span class="line">truestr.erase(str.find_last_not_of(&quot; &quot;) + 1);//去除右边空格</span><br><span class="line">truereturn str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 分割string，能自动去掉分隔符前后的空格</span><br><span class="line">std::vector &lt;std::string&gt; splitString(const std::string &amp; s, const std::string &amp; delim)</span><br><span class="line">&#123;</span><br><span class="line">    std::vector &lt;std::string&gt; elems;</span><br><span class="line">    std::string tmp;</span><br><span class="line">    size_t pos = 0;</span><br><span class="line">    size_t len = s.length();</span><br><span class="line">    size_t delim_len = delim.length();</span><br><span class="line">    if (delim_len == 0)</span><br><span class="line">        return elems;</span><br><span class="line">    while (pos &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        int find_pos = s.find(delim, pos);</span><br><span class="line">        if (find_pos &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = s.substr(pos, len - pos);</span><br><span class="line">            elems.push_back(trim(tmp));</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = s.substr(pos, find_pos - pos);</span><br><span class="line">        elems.push_back(trim(tmp));</span><br><span class="line">        pos = find_pos + delim_len;</span><br><span class="line">    &#125;</span><br><span class="line">    return elems;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/////////////////////////</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">本函数功能：</span><br><span class="line">用于测试组装命令的场景。</span><br><span class="line">使用如下：</span><br><span class="line">./a_all.out &quot;print abc; print 100 200;&quot;</span><br><span class="line">即只有一个参数。为了复用已有命令终端，将参数分析还原为argc argv形式，再调用</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">int readline_cmd_allone(int argc, char ** argv)</span><br><span class="line">&#123;</span><br><span class="line">    if (argc &lt; 2) return -1;</span><br><span class="line"></span><br><span class="line">// 命令参数最大为10个</span><br><span class="line">#define MAX_ARGC 10</span><br><span class="line">    std::vector&lt;std::string&gt; v = splitString(argv[1], &quot;;&quot;);</span><br><span class="line">truecmd_tbl_t *ptable = NULL;</span><br><span class="line">    char* myargv[MAX_ARGC] = &#123;NULL&#125;;</span><br><span class="line">    int myargc = 0;</span><br><span class="line">truefor(unsigned int i=0; i&lt;v.size(); i++)</span><br><span class="line">true&#123;</span><br><span class="line">        // printf(&quot;split: [%s] %d\n&quot;, v[i].c_str(), v[i].empty());</span><br><span class="line">truetrueif(v[i].empty())</span><br><span class="line">truetrue&#123;</span><br><span class="line">truetruetruecontinue;</span><br><span class="line">truetrue&#125;</span><br><span class="line">        char cmd[128];</span><br><span class="line">truetruememcpy(cmd, v[i].c_str(), 128);</span><br><span class="line"></span><br><span class="line">truetrue// 是否再转成argv的形式？？</span><br><span class="line">truetrue</span><br><span class="line">        std::vector&lt;std::string&gt; vv = splitString(cmd, &quot; &quot;);</span><br><span class="line">        myargc = (int)vv.size();</span><br><span class="line">        myargc = myargc &gt; MAX_ARGC ? MAX_ARGC : myargc;</span><br><span class="line">        for (int j = 0; j &lt; myargc; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            myargv[j] = (char*)vv[j].c_str();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // for (int j = 0; j &lt; myargc; j++)</span><br><span class="line">        // &#123;</span><br><span class="line">        //     printf(&quot;myargv[%d]: %s\n&quot;, j, myargv[j]);</span><br><span class="line">        // &#125;</span><br><span class="line"></span><br><span class="line">        ptable = find_table(myargv[0]);</span><br><span class="line">truetrueif (ptable == NULL)</span><br><span class="line">truetrue&#123;</span><br><span class="line">truetruetrueprintf(&quot;cmd name: [%s] not found\n&quot;, myargv[0]);</span><br><span class="line">truetruetruecontinue;</span><br><span class="line">truetrue&#125;</span><br><span class="line">truetrueprintf(&quot;name: %s\n&quot;, ptable-&gt;name);</span><br><span class="line"></span><br><span class="line">truetrueptable-&gt;cmd(myargc, myargv);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数变更如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    char* p;</span><br><span class="line">truechar* cmdname = *argv;</span><br><span class="line">    if ((p = strrchr (cmdname, &#x27;/&#x27;)) != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">truetruecmdname = p + 1;</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">trueif (strcmp(cmdname, &quot;a.out&quot;) == 0)</span><br><span class="line">    &#123;</span><br><span class="line">truetrueif (readline_cmd(argc, argv) != 0)</span><br><span class="line">truetruetruereturn -1;</span><br><span class="line"></span><br><span class="line">truetruereturn 0;</span><br><span class="line">true&#125;</span><br><span class="line">    else if (strcmp(cmdname, &quot;a_all.out&quot;) == 0)</span><br><span class="line">    &#123;</span><br><span class="line">truetrueif (readline_cmd_allone(argc, argv) != 0)</span><br><span class="line">truetruetruereturn -1;</span><br><span class="line"></span><br><span class="line">truetruereturn 0;</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码以<code>a.out</code>和<code>a_all.out</code>为执行文件名称作为示例。不管哪种形式，都可以直接复用已有的模块。笔者实际使用的场景，是一个用于自测的程序，有时，需要手动修改参数进行测试，有时需要将程序放到后台执行（因为耗时较长）。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这段时间一直在做测试的工程（不是测试的工作），为了应付不同的测试场景，代码使用了解释器风格，至于实现，则使用了多年前写的命令终端代码。那会刚毕业不久，写的代码还是有提升空间。现在重新拾起，打破一般认知中的看不懂6个月前写的代码的刻板印象。&lt;/p&gt;</summary>
    
    
    
    <category term="技术杂铺" scheme="http://www.latelee.org/category/my-study/"/>
    
    
  </entry>
  
  <entry>
    <title>Golang实践录：工程框架实践：汇总</title>
    <link href="http://www.latelee.org/golang/golang-notes-cmdtool0.html"/>
    <id>http://www.latelee.org/golang/golang-notes-cmdtool0.html</id>
    <published>2021-06-06T16:01:00.000Z</published>
    <updated>2021-09-06T14:40:29.958Z</updated>
    
    <content type="html"><![CDATA[<p>面</p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;面&lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>李迟2021年5月知识总结</title>
    <link href="http://www.latelee.org/my-library/code-for-2021-05.html"/>
    <id>http://www.latelee.org/my-library/code-for-2021-05.html</id>
    <published>2021-05-29T16:00:00.000Z</published>
    <updated>2021-09-06T14:40:30.034Z</updated>
    
    <content type="html"><![CDATA[<p>本文为 2021 年 5 月知识总结。</p><span id="more"></span><h2 id="编码总结"><a href="#编码总结" class="headerlink" title="编码总结"></a>编码总结</h2><h3 id="web静态服务器"><a href="#web静态服务器" class="headerlink" title="web静态服务器"></a>web静态服务器</h3><p>测试前端时，可直接在浏览器中进行调试，当需要有数据交互时，可搭建简单后台服务，golang 语言创建 web 服务，并指定 Directory目录：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router := gin.New()</span><br><span class="line">router.StaticFS(<span class="string">&quot;/&quot;</span>, http.Dir(conf.Directory))</span><br><span class="line">router.Run(<span class="string">&quot;:&quot;</span> + conf.Port)</span><br></pre></td></tr></table></figure><p>由 golang 实现的简单的 web 服务镜像为<code>latelee/webdemo</code>，根目录为<code>/dist</code>，为<code>80</code>。</p><p>NodeJS 语言创建 web 服务并指定 staticPath 目录：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line">app.use(koastatic(path.join( __dirname, staticPath)));</span><br><span class="line">app.use(router.g_router.routes());</span><br><span class="line">g_webServer = app.listen(&#123;</span><br><span class="line">        <span class="attr">host</span>:SVR_HOST,</span><br><span class="line">        <span class="attr">port</span>:SVR_PORT,</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h2 id="前端后台一点笔记"><a href="#前端后台一点笔记" class="headerlink" title="前端后台一点笔记"></a>前端后台一点笔记</h2><p>html文件，或由渲染工具（ hexo、vuepress 等）渲染得到的 html 文件，需托管于 web 服务器，如 apache、nginx 或 tomcat 这些现成服务器，不同服务器，其根目录不同，体积亦不同。上面实现的也是 web 服务器，但体积会小很多，并且可以直接和后台服务融合。当然，对于模块分工明确的场景，前端页面和后台服务必须位于不同服务器/地区，则另当别论。    </p><h3 id="编码其它"><a href="#编码其它" class="headerlink" title="编码其它"></a>编码其它</h3><p>继续总结 Makefile 知识：<br>上月仅实践了过滤指定文件的做法。本月研究过滤目录的做法，方法较简单，在 find 中直接用<code>grep -v</code>过滤不需要的目录即可。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SRC_DIRS = .</span><br><span class="line">SRCS := $(shell find $(SRC_DIRS) -maxdepth 2 -name &#x27;*.cpp&#x27; -or -name &#x27;*.c&#x27; | grep -v dir_notneed)</span><br></pre></td></tr></table></figure><p>由于考虑到通用性，之前的 Makefile 均直接使用 find 查看源码的方法，因此，会编译指定目录所有源文件。当然也可手动指定源文件方法，略显麻烦而已。<br>如果先查找目录，再查找源文件，由于<code>find</code>找到的目录包含<code>SRC_DIRS</code>自身，再用<code>find</code>找到，还是会找到过滤目录的文件，目前未想到好办法。  </p><p>又看了一些编码规则（其实是 vue），加之接手了几个祖传代码（保留着大量2015年写的不再使用的函数），对其中提到的点比较认同。比如命名，代码首先给自己看，其次用于团队交流（有的项目始终是一个人维护）。 要点：<br>考虑视觉效果，如大写，固定前缀，空行，注释位置，等。<br>避免不常用缩写，缩写团队内达成一致。如返回值，有的写<code>ret</code>，有的写<code>res</code>。  </p><p>扩展：在软件使用上减少用户认知成本，小的范围，如编码，大家统一一套代码方式。大的范围，如一些对话框的关闭按钮位置，有的左上角，有的右上角；如“确定”、“取消”位置也不固定。不过环境太大，无法统一。  </p><p><strong>大道至简，用简单的方法实现功能/需求，才是最好的方法。</strong> 一些奇技淫巧， 如未必要，除自娱自乐外，有人欣赏，也是不错的，但知音难觅。</p><h2 id="一般知识"><a href="#一般知识" class="headerlink" title="一般知识"></a>一般知识</h2><h2 id="研发思考"><a href="#研发思考" class="headerlink" title="研发思考"></a>研发思考</h2><p>最近看了一些面向对象设计原则，单一职责原则、开闭原则，等。一般举例时，以画图（三角形、圆形）为主。 实际中，并不是如此单纯，对于当前项目。  </p><p>代码模式、设计模式，架构模式。</p><p>业务入侵：有时为了方便调试，或出于某此特殊目的，会将一些特殊值（魔数）赋值某些变量或参数，可能会影响生产环境。比如将ID设置为一个不存在的值，但万一后面会出现在正常业务中，会出问题。  扩展：有些设计时需要考虑后续发展计划，有时又不需要过度设计，这个度不好把握，只能靠经验。实例：比如某省的收费站代号，使用3位数字表示，则最大只能有999个，万一超过，可添加代号位数解决，但如果涉及到根本机制问题，牵一发而动全身，风险大大添加。</p><h2 id="本月学习及计划"><a href="#本月学习及计划" class="headerlink" title="本月学习及计划"></a>本月学习及计划</h2><p>看了一些前端、后台、微服务架构、UML的概念和知识，后续要继续看。</p><p>使用 vuepress 构建了 一个静态网站，已部署内部服务器。  </p><p>兜兜转转，从手写到 bootstrap，到一些框架，到 vue，最后还是决定上 vue，拥抱主流，多学一些，保持大脑正常运转。  </p><h2 id="其它点滴"><a href="#其它点滴" class="headerlink" title="其它点滴"></a>其它点滴</h2><p>熬夜比上月多了一些，一是有很多未接触的东西要学，二是要继续熟悉业务和代码，三是白天晚上时间被其它事占用了。每天感觉刚躺床上又起来了。有时候大锤闹着要我陪睡，则会偷懒多睡一点，但更多是他独立睡。  </p><p>很多个深夜，站在阳台，望着天空，听着对面楼的麻将声和外面的汽车声，我在想，该怎么做才能平衡儿子、丈夫、父亲的角色。我的角色里面需不需要有自己？但我的兴趣爱好，在那些角色面前根本占不了位置。一切的根源其实就是钱，学技术，对工作上心也是为了钱，钱多不多我控制不了，自己勤奋不勤奋，这点能控制。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文为 2021 年 5 月知识总结。&lt;/p&gt;</summary>
    
    
    
    <category term="我的程序代码" scheme="http://www.latelee.org/category/my-library/"/>
    
    
    <category term="代码积累" scheme="http://www.latelee.org/tag/%E4%BB%A3%E7%A0%81%E7%A7%AF%E7%B4%AF/"/>
    
    <category term="知识总结" scheme="http://www.latelee.org/tag/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>我的docker随笔32：sftp服务部署</title>
    <link href="http://www.latelee.org/docker/docker-32-deploy-sftp-server.html"/>
    <id>http://www.latelee.org/docker/docker-32-deploy-sftp-server.html</id>
    <published>2021-05-09T16:00:00.000Z</published>
    <updated>2021-09-06T14:40:30.082Z</updated>
    
    <content type="html"><![CDATA[<p>本文涉及一种在容器中部署 sftp 服务的方法。经验证，可达到预期目标，并能应用在实际工作中。    </p><span id="more"></span><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>因工作需要，需部署 sftp 服务器进行数据测试。</p><h2 id="二、技术小结"><a href="#二、技术小结" class="headerlink" title="二、技术小结"></a>二、技术小结</h2><ul><li><p>dockerhub 上相关镜像，直接拉取可用。  </p></li><li><p>运行时需要注意用户名和<code>home</code>目录，如使用<code>foo</code>用户，则需要挂载到<code>/home/foo</code>目录。  </p></li><li><p>需要手动设置ssh key，否则每次重启都会产生新的key。</p></li><li><p>上传权限问题暂未解决。  </p></li></ul><h2 id="三、实践"><a href="#三、实践" class="headerlink" title="三、实践"></a>三、实践</h2><h3 id="3-1-下载"><a href="#3-1-下载" class="headerlink" title="3.1 下载"></a>3.1 下载</h3><p>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull atmoz/sftp</span><br></pre></td></tr></table></figure><p>测试运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">    -v /tmp/upload:/home/foo/upload \</span><br><span class="line">    --name sftp \</span><br><span class="line">    -p 2222:22 -itd atmoz/sftp \</span><br><span class="line">    foo:pass:1000</span><br></pre></td></tr></table></figure><p>注：挂载 <code>tmp/upload</code>到容器<code>home</code>的同名目录下，账号密码分别为<code>foo</code>、<code>pass</code>，<code>UID</code>与执行此命令的主机用户一样，即<code>1000</code>（可通过<code>/etc/passwd</code>文件查看知）。</p><p>测试连接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sftp -P 2222 foo@localhost</span><br><span class="line">foo@localhost&#x27;s password: </span><br><span class="line">Connected to localhost.</span><br><span class="line"><span class="meta">sftp&gt;</span><span class="bash"> ls</span></span><br><span class="line">upload  </span><br><span class="line"><span class="meta">sftp&gt;</span><span class="bash"> <span class="built_in">cd</span> upload/</span></span><br><span class="line"><span class="meta">sftp&gt;</span><span class="bash"> put webdemo</span></span><br><span class="line">Uploading webdemo to /upload/webdemo</span><br><span class="line">remote open(&quot;/upload/webdemo&quot;): Permission denied</span><br></pre></td></tr></table></figure><p>提示权限不足，在容器中修改 upload 目录权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -it sftp bash</span><br><span class="line">root@35f5c9abeb71:/# cd home/</span><br><span class="line">root@35f5c9abeb71:/home/foo# ls -lh</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x. 2 root root 6 May 10 07:05 upload</span><br><span class="line">root@35f5c9abeb71:/home/foo# chmod 777 upload/ -R</span><br><span class="line">root@35f5c9abeb71:/home/foo# ls -lh</span><br><span class="line">total 0</span><br><span class="line">drwxrwxrwx. 2 root root 21 May 10 07:27 upload</span><br></pre></td></tr></table></figure><p>则可以正常上传</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sftp&gt; put webdemo</span><br><span class="line">Uploading webdemo to /upload/webdemo</span><br><span class="line">webdemo                                       100% 6706KB  53.1MB/s   00:00  </span><br><span class="line">sftp&gt; exit</span><br></pre></td></tr></table></figure><h2 id="四、sftp常用命令"><a href="#四、sftp常用命令" class="headerlink" title="四、sftp常用命令"></a>四、sftp常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">登陆：</span><br><span class="line">sftp -P &lt;端口&gt; &lt;用户名&gt;@&lt;IP&gt;</span><br><span class="line"></span><br><span class="line">?：查看帮助</span><br><span class="line">quit：退出</span><br><span class="line">cd lcd：进入某目录 （注：有l前缀表示是宿主机）</span><br><span class="line">ls lls：查看目录</span><br><span class="line">pwd lpwd：查看当前路径</span><br><span class="line">mdir ：创建目录</span><br><span class="line">put：上传文件（目录：-r）</span><br><span class="line">get：下载文件</span><br></pre></td></tr></table></figure><h2 id="五、指定ssh-key"><a href="#五、指定ssh-key" class="headerlink" title="五、指定ssh key"></a>五、指定ssh key</h2><p>默认情况下，每次重新服务，都会产生新的key，需要用户确认（见附录）。可以手动指定key，解决该问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir ssh</span><br><span class="line">cd ssh</span><br><span class="line">ssh-keygen -t ed25519 -f ssh_host_ed25519_key &lt; /dev/null</span><br><span class="line">ssh-keygen -t rsa -b 4096 -f ssh_host_rsa_key &lt; /dev/null</span><br></pre></td></tr></table></figure><p>在运行添加如下参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-v &lt;host-dir&gt;/ssh_host_ed25519_key:/etc/ssh/ssh_host_ed25519_key \</span><br><span class="line">-v &lt;host-dir&gt;/ssh_host_rsa_key:/etc/ssh/ssh_host_rsa_key \</span><br></pre></td></tr></table></figure><h2 id="六、docker-compose部署"><a href="#六、docker-compose部署" class="headerlink" title="六、docker-compose部署"></a>六、docker-compose部署</h2><p>对应的<code>yaml</code>文件如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">sftp:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">atmoz/sftp</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">sftp</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./upload:/home/aftp/</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./ssh/ssh_host_ed25519_key:/etc/ssh/ssh_host_ed25519_key</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./ssh/ssh_host_rsa_key:/etc/ssh/ssh_host_rsa_key</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;2222:22&quot;</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">aftp:passworld:1000</span></span><br></pre></td></tr></table></figure><p>注：本例中将当前目录的<code>upload</code>目录直接挂载到用户的<code>home</code>目录，不似上述在<code>upload</code>目录。这样客户端连接后的根目录就是宿主机的<code>upload</code>目录，较方便。</p><h2 id="七、参考"><a href="#七、参考" class="headerlink" title="七、参考"></a>七、参考</h2><p>sftp 镜像：<a href="https://hub.docker.com/r/atmoz/sftp">https://hub.docker.com/r/atmoz/sftp</a>  </p><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>网上有文章在运行容器命令时添加<code>--privileged=true</code>参数。  </p><p>首次运行时，用<code>sftp</code>命令连接时，需要确认，提示如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &#x27;[localhost]:2222 ([::1]:2222)&#x27; can&#x27;t be established.</span><br><span class="line">ED25526 key fingerprint is SHA256:FUCkkcufctB3fasdf45sszVCaqRQTY7+Qasjw235A+XwCg.</span><br><span class="line">ED25526 key fingerprint is MD5:17:fu:ck:3d:bb:aa:00:35:79:ac:bc:cc:dc:ec:71:bb.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br><span class="line">Warning: Permanently added &#x27;[localhost]:2222&#x27; (ED25526) to the list of known hosts.</span><br></pre></td></tr></table></figure><p>如果重新启动（这样也算是首次运行），则会提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span><br><span class="line">Someone could be eavesdropping on you right now (man-in-the-middle attack)!</span><br><span class="line">It is also possible that a host key has just been changed.</span><br><span class="line">The fingerprint for the ED25519 key sent by the remote host is</span><br><span class="line">SHA256:FTKtctB6yBQasdfasdfasdf3fasdf7+QSBTLyyasdfasdfasdfCg.</span><br><span class="line">Please contact your system administrator.</span><br><span class="line">Add correct host key in /home/lateee/.ssh/known_hosts to get rid of this message.</span><br><span class="line">Offending ED25526 key in /home/lateee/.ssh/known_hosts:4</span><br></pre></td></tr></table></figure><p>此时，需要编辑<code>/home/lateee/.ssh/known_hosts</code>文件，删除对应的那一行信息（本文中，会带有 2222 字样）。  </p><p>疑问：如果使用程序连接，首次出现上述提示，如何输入<code>yes</code>？待研究。  </p><p>在一次用 docker-compose 运行时，客户端连接出现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sftp -P2222 foo@127.0.0.1</span></span><br><span class="line">Connection closed by 127.0.0.1 port 2222</span><br><span class="line">Couldn&#x27;t read packet: Connection reset by peer</span><br></pre></td></tr></table></figure><p>经查，是因为 sftp 服务器目录在 Windows 系统，改为 Linux 系统，问题解决。（为减少虚拟机空间占用，并方便调试，笔者习惯使用虚拟机的共享目录，在 Linux 中操作 Windows 硬盘。）</p><p>某天运行时，提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose up</span></span><br><span class="line">Creating network &quot;sftp_default&quot; with the default driver</span><br><span class="line">Creating sftp ... done</span><br><span class="line">Attaching to sftp</span><br><span class="line">sftp    | [/usr/local/bin/create-sftp-user] Parsing user data: &quot;aftp:passworld:1000&quot;</span><br><span class="line">sftp    | [/entrypoint] Executing sshd</span><br><span class="line">sftp    | /run/sshd must be owned by root and not group or world-writable.</span><br><span class="line">sftp exited with code 255</span><br></pre></td></tr></table></figure><p>之前工作正常。原因未明。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文涉及一种在容器中部署 sftp 服务的方法。经验证，可达到预期目标，并能应用在实际工作中。    &lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="http://www.latelee.org/category/docker/"/>
    
    
    <category term="docker" scheme="http://www.latelee.org/tag/docker/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：静态资源文件整合：web服务</title>
    <link href="http://www.latelee.org/golang/golang-notes-combine-static-file-1.html"/>
    <id>http://www.latelee.org/golang/golang-notes-combine-static-file-1.html</id>
    <published>2021-05-04T16:01:00.000Z</published>
    <updated>2021-09-06T14:40:29.958Z</updated>
    
    <content type="html"><![CDATA[<p>趁着五一放假，趁着有时间，把欠的一些技术集中研究研究，写写文章，好给自己一个交待。<br>本文研究静态资源文件的在 web 服务器的整合。  </p><span id="more"></span><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>Golang 中的 web 服务框架有很多种，本文选取 gin 实现。gin 实现一个 web 服务仅需几行代码，十分方便。但为了适应更复杂的项目，还需要进行一些改进。<br>web 服务页面的文件，除了 html 外，还有 css、js、图片等文件，为方便管理，将后者放到 static 目录——与前面文章目录保持一致，将前者放到 templates 目录，使用 gin 的 html 模板进行渲染，而且 gin 也支持自定义模板文件，恰好能适合我们的场景。  </p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h3><p>本文使用到的资源文件如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ tree static/</span><br><span class="line">static/</span><br><span class="line">|-- css</span><br><span class="line">|   |-- bootstrap.min.css</span><br><span class="line">|   |-- font-awesome.min.css</span><br><span class="line">|   `-- main.css</span><br><span class="line">|-- favicon.ico</span><br><span class="line">`-- js</span><br><span class="line">    |-- bootstrap.min.js</span><br><span class="line">    |-- jquery-1.8.3.min.js</span><br><span class="line">    |-- jquery-2.0.0.min.js</span><br><span class="line">    `-- main.js</span><br><span class="line"></span><br><span class="line">2 directories, 8 files</span><br><span class="line"></span><br><span class="line">$ tree templates/</span><br><span class="line">templates/</span><br><span class="line">|-- about.html</span><br><span class="line">|-- about.js</span><br><span class="line">|-- index.html</span><br><span class="line">|-- login.html</span><br><span class="line">|-- login.js</span><br><span class="line">`-- nav.js</span><br><span class="line"></span><br><span class="line">0 directories, 6 files</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="通用方式"><a href="#通用方式" class="headerlink" title="通用方式"></a>通用方式</h3><p>为方便对比，先给出通用的 gin 框架，主要代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 直接引用文件形式</span><br><span class="line">func webServerFile() &#123;</span><br><span class="line">    fmt.Println(&quot;gin test...&quot;)</span><br><span class="line">truerouter := gin.Default()</span><br><span class="line">    </span><br><span class="line">    // 似乎这样做，templates下只能有文件，不能有目录</span><br><span class="line">    router.LoadHTMLGlob(&quot;templates/*&quot;)</span><br><span class="line">    </span><br><span class="line">    // 将真实目录做不同前缀，方便引用css js等文件</span><br><span class="line">    // 有些自实现的用html文件或js文件，用html前缀。</span><br><span class="line">    router.StaticFS(&quot;/js&quot;, http.Dir(&quot;static/js&quot;))</span><br><span class="line">    router.StaticFS(&quot;/css&quot;, http.Dir(&quot;static/css&quot;))</span><br><span class="line">    router.StaticFS(&quot;/html&quot;, http.Dir(&quot;templates&quot;))</span><br><span class="line"></span><br><span class="line">    router.GET(&quot;/&quot;, HandleIndex)</span><br><span class="line">    router.GET(&quot;/index&quot;, HandleIndex)</span><br><span class="line">    router.GET(&quot;/about&quot;, HandleAbout)</span><br><span class="line">    router.GET(&quot;/login&quot;, HandleLogin)</span><br><span class="line">    </span><br><span class="line">truerouter.Run(&quot;:8081&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 LoadHTMLGlob 用于加载 html 模板文件，StaticFS 指定静态资源，有两个参数，第一个指定前缀名称（即在 html 或 js 文件中引用时使用的路径，第二个指定真实路径（相对于 web 程序所在目录）。GET 函数用于响应对应的页面，由于响应函数非本文重点，故简单列举如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func HandleIndex(ctx *gin.Context) &#123;</span><br><span class="line">    file := path.Join(gPrefix, &quot;index.html&quot;)</span><br><span class="line">    ctx.HTML(http.StatusOK, file, gin.H&#123;</span><br><span class="line">truetrue&quot;title&quot;:  &quot;Main website&quot;,</span><br><span class="line">true&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：gPrefix 将在下文提及。  </p><h3 id="整合方式"><a href="#整合方式" class="headerlink" title="整合方式"></a>整合方式</h3><p>使用 bindata 方式，与上面示例没有本质区别，只是需要手动设置模板加载规则，指定静态资源文件方式也不同。主要代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 整合文件形式</span><br><span class="line">func webServerBindata() &#123;</span><br><span class="line">    fmt.Println(&quot;gin test.....&quot;)</span><br><span class="line">truerouter := gin.Default()</span><br><span class="line">truet, err := loadTemplate()</span><br><span class="line">trueif err != nil &#123;</span><br><span class="line">truetruepanic(err)</span><br><span class="line">true&#125;</span><br><span class="line">truerouter.SetHTMLTemplate(t)</span><br><span class="line"></span><br><span class="line">    // 下面指定的是静态资源文件，与响应get/post的地址无关系</span><br><span class="line">    fsjs := assetfs.AssetFS&#123;</span><br><span class="line">        Asset:     bindata.Asset,</span><br><span class="line">        AssetDir:  bindata.AssetDir,</span><br><span class="line">        AssetInfo: bindata.AssetInfo,</span><br><span class="line">        Prefix:   &quot;static/js&quot;,</span><br><span class="line">        Fallback: &quot;index.html&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">    router.StaticFS(&quot;/js&quot;, &amp;fsjs)</span><br><span class="line">    </span><br><span class="line">    fscss := assetfs.AssetFS&#123;</span><br><span class="line">        Asset: bindata.Asset, AssetDir: bindata.AssetDir, AssetInfo: bindata.AssetInfo, </span><br><span class="line">        Prefix:   &quot;static/css&quot;,</span><br><span class="line">        Fallback: &quot;index.html&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">    router.StaticFS(&quot;/css&quot;, &amp;fscss)</span><br><span class="line">    </span><br><span class="line">    fshtml := assetfs.AssetFS&#123;</span><br><span class="line">        Asset: bindata.Asset, AssetDir: bindata.AssetDir, AssetInfo: bindata.AssetInfo, </span><br><span class="line">        Prefix:   &quot;templates&quot;,</span><br><span class="line">        Fallback: &quot;index.html&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">    router.StaticFS(&quot;/html&quot;, &amp;fshtml)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    router.StaticFS(&quot;/favicon.ico&quot;, &amp;fshtml)</span><br><span class="line">    </span><br><span class="line">    // 人为添加前缀，因为前面loadTemplate加载的html路径包含有路径前缀，因此加上</span><br><span class="line">    // 如果手动删除，则此处不需要前缀</span><br><span class="line">    //gPrefix = &quot;templates&quot;</span><br><span class="line"></span><br><span class="line">    router.GET(&quot;/&quot;, HandleIndex)</span><br><span class="line">    router.GET(&quot;/index&quot;, HandleIndex)</span><br><span class="line">    router.GET(&quot;/about&quot;, HandleAbout)</span><br><span class="line">    router.GET(&quot;/login&quot;, HandleLogin)</span><br><span class="line"></span><br><span class="line">truerouter.Run(&quot;:8081&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义模板加载函数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func loadTemplate() (*template.Template, error) &#123;</span><br><span class="line">    fmt.Println(&quot;load my template&quot;)</span><br><span class="line">truet := template.New(&quot;&quot;)</span><br><span class="line">    filenames := bindata.AssetNames()</span><br><span class="line">    for _, name := range  filenames &#123;</span><br><span class="line">        if !strings.HasSuffix(name, &quot;.tmpl&quot;) &amp;&amp; !strings.HasSuffix(name, &quot;.html&quot;) &amp;&amp; </span><br><span class="line">           !strings.HasSuffix(name, &quot;.css&quot;) &amp;&amp; !strings.HasSuffix(name, &quot;.js&quot;) &amp;&amp; </span><br><span class="line">           !strings.HasSuffix(name, &quot;.ico&quot;) &#123;</span><br><span class="line">truetruetruecontinue</span><br><span class="line">truetrue&#125;</span><br><span class="line">        //fmt.Println(&quot;got html file: &quot;, name)</span><br><span class="line">        content, err := bindata.Asset(name)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            return nil, err</span><br><span class="line">        &#125;</span><br><span class="line">        t, err = t.New(name).Parse(string(content))</span><br><span class="line">truetrueif err != nil &#123;</span><br><span class="line">truetruetruereturn nil, err</span><br><span class="line">truetrue&#125;</span><br><span class="line">true&#125;</span><br><span class="line">truereturn t, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在生成 bindata.go 时，指定了2处目录，而<code>-prefix</code>选项只能指定一个前缀，于是干脆不加该参数，因此，生成的代码中，前缀也会出现对应的目录，正因为这样，代码才使用了<code>gPrefix = &quot;templates&quot;</code>手动指定前缀。后来手动删除生成代码的前缀，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;s/templates\///g&#x27; bindata/bindata.go</span><br><span class="line">sed -i &#x27;s/static\///g&#x27; bindata/bindata.go</span><br></pre></td></tr></table></figure><p>两者关键代码对比如下图所示（注：左侧为未删除前缀的代码）。<br><img src="/golang/golang-notes-combine-static-file-1/01.png"></p><p>笔者阅读 go-bindata-assetfs 代码尝试添加参数达到目的，未果。  </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://jaycechant.info/2020/go-bindata-golang-static-resources-embedding/">https://jaycechant.info/2020/go-bindata-golang-static-resources-embedding/</a><br><a href="http://blog.hotsun168.com/index.php/archives/18/">http://blog.hotsun168.com/index.php/archives/18/</a><br>1.16 版本新方法：<br><a href="https://www.flysnow.org/2021/02/28/golang-embed-for-web.html">https://www.flysnow.org/2021/02/28/golang-embed-for-web.html</a>  </p><p>2021.5.5 凌晨</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;趁着五一放假，趁着有时间，把欠的一些技术集中研究研究，写写文章，好给自己一个交待。&lt;br&gt;本文研究静态资源文件的在 web 服务器的整合。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：静态资源文件整合：初步使用</title>
    <link href="http://www.latelee.org/golang/golang-notes-combine-static-file-0.html"/>
    <id>http://www.latelee.org/golang/golang-notes-combine-static-file-0.html</id>
    <published>2021-05-04T16:00:00.000Z</published>
    <updated>2021-09-06T14:40:29.958Z</updated>
    
    <content type="html"><![CDATA[<p>趁着五一放假，趁着有时间，把欠的一些技术集中研究研究，写写文章，好给自己一个交待。<br>本文介绍如何在 Golang 中整合静态资源文件，将静态资源文件编译到二进制可执行文件中，这与其它程序的打包可能是一个概念，也可能不是，后续有空研究再补充。  </p><span id="more"></span><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>大概10年前，即2011年，也研究一下这方面的内容，主要针对 C 语言，使用 ARM 板子测试。 那篇文章如下图： </p><p><img src="/golang/golang-notes-combine-static-file-0/1.png"></p><p>当时对技术的兴趣比较浓厚，没想过房子车子的事，现在经常想房子车子，但也被迫对技术感兴趣。因此，使用 Golang 语言重新研究一下。  </p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>经查，有2个类似的工具：go-bindata 和 go-bindata-assetfs。两者可以将文件转换成 golang 语言代码，后者似乎依赖于前者，本着使用的目的，暂未研究细节，看了一下生成的 golang 代码，有对外提供的接口，有文件映射表，有真正存储文件的字节流。  </p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>使用<code>go get</code>命令安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/go-bindata/go-bindata/...</span><br><span class="line">go get -u github.com/elazarl/go-bindata-assetfs/...</span><br></pre></td></tr></table></figure><p>输入对应的命令验证：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go-bindata</span><br><span class="line">go-bindata-assetfs</span><br></pre></td></tr></table></figure><h3 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h3><p>为适合项目目录，本文约定使用 static 目录存放静态资源文件——即需要打包到可执行程序中的文件，生成的代码，存放到 bindata 目录，且其包名亦为 bindata。经研究发现似乎 go-bindata-assetfs 更好一些，因此本文使用该工具，生成命令如下：    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go-bindata-assetfs -o=bindata/bindata.go -pkg=bindata -ignore=&quot;README.md&quot; -prefix=static static/... </span><br></pre></td></tr></table></figure><p><code>-o</code>指定了输出文件，<code>-pkg</code>指定包名（一般与前者保持一致），<code>-ignore</code>指定需忽略的文件，<code>-prefix</code>指定文件路径前缀（本例中，指定了前缀，不需在代码中使用<code>static</code>前缀）。如果不需要如此复杂，可将其生成的文件与包 main 在同一目录，包名亦为 main，可用于简单测试：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go-bindata-assetfs -o=bindata.go -ignore=&quot;README.md&quot; -prefix=static static/...</span><br></pre></td></tr></table></figure><p>为了调试方便——即不需要每次更新文件都要重新编译代码，则可以添加<code>-debug</code>参数，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go-bindata-assetfs -debug -o=bindata.go -ignore=&quot;README.md&quot; -prefix=static static/...</span><br></pre></td></tr></table></figure><p>添加<code>-debug</code>选项后，当修改了原资源文件后，重新运行程序，获取的内容会发生变化，不需要重新生成，方便调试。内部实现原理：在调用 bindataRead 读取文件时，添加文件的绝对路径。如果是非 debug 版本，则不加路径。    </p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>资源文件目录 static 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ tree static/</span><br><span class="line">static/</span><br><span class="line">|-- conf</span><br><span class="line">|   `-- config.toml</span><br><span class="line">|-- html</span><br><span class="line">|   `-- foo.html</span><br><span class="line">`-- libfoo.so</span><br><span class="line"></span><br><span class="line">2 directories, 3 files</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要使用的接口如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 获取所有的文件名称</span><br><span class="line">filenames := bindata.AssetNames()</span><br><span class="line"></span><br><span class="line">// 读取某一文件的内容</span><br><span class="line">filename = &quot;html/foo.html&quot;</span><br><span class="line">content, err = bindata.Asset(filename)</span><br></pre></td></tr></table></figure><p>指定的文件，以<code>static</code>为根目录，其形式与一般的路径无差异。  </p><p>完整测试代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;strings&quot;</span><br><span class="line">    &quot;io/ioutil&quot;</span><br><span class="line">    </span><br><span class="line">    &quot;bindata_test2/bindata&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(&quot;bindata test..&quot;);</span><br><span class="line">    </span><br><span class="line">    // 遍历所有文件，打印文件名，并输出html的内容</span><br><span class="line">    filenames := bindata.AssetNames()</span><br><span class="line">    for _, item := range  filenames &#123;</span><br><span class="line">        fmt.Println(&quot;got file: &quot;, item)</span><br><span class="line"></span><br><span class="line">        if !strings.HasSuffix(item, &quot;.tmpl&quot;) &amp;&amp; !strings.HasSuffix(item, &quot;.html&quot;) &#123;</span><br><span class="line">truetruetruecontinue</span><br><span class="line">truetrue&#125;</span><br><span class="line">        </span><br><span class="line">        content, err := bindata.Asset(item)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            fmt.Printf(&quot;not found file %s: %s\n&quot;, item, err.Error())</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(string(content))</span><br><span class="line">        fmt.Println(&quot;-----------------------------------\n&quot;)</span><br><span class="line">        </span><br><span class="line">true&#125;</span><br><span class="line">    </span><br><span class="line">    // 单独测试</span><br><span class="line">    filename := &quot;assets/foo.html&quot;</span><br><span class="line">    content, err := bindata.Asset(filename)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Printf(&quot;not found file %s: %s\n&quot;, filename, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    filename = &quot;foo.html&quot;</span><br><span class="line">    content, err = bindata.Asset(filename)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Printf(&quot;not found file %s: %s\n&quot;, filename, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    filename = &quot;html/foo.html&quot;</span><br><span class="line">    content, err = bindata.Asset(filename)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Printf(&quot;not found file %s: %s\n&quot;, filename, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    // content 为二进制buf，怎么用？</span><br><span class="line">    </span><br><span class="line">    filename = &quot;conf/config.toml&quot;</span><br><span class="line">    content, err = bindata.Asset(filename)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Printf(&quot;not found file %s: %s\n&quot;, filename, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(string(content))</span><br><span class="line">    </span><br><span class="line">    // 读取so并保存</span><br><span class="line">    filename = &quot;libfoo.so&quot;</span><br><span class="line">    content, err = bindata.Asset(filename)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Printf(&quot;not found file %s: %s\n&quot;, filename, err.Error())</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //filename = &quot;libfoo.so&quot;</span><br><span class="line">    err = ioutil.WriteFile(filename, content, 0755)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Println(&quot;write file error: &quot;, err)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;write file %s ok\n&quot;, filename)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 libfoo.so 文件为例，原文件和保存的文件对比如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ md5sum.exe static/libfoo.so libfoo.so</span><br><span class="line">9416ab261b2867d9acbb563690116885 *static/libfoo.so</span><br><span class="line">9416ab261b2867d9acbb563690116885 *libfoo.so</span><br></pre></td></tr></table></figure><p>两者内容是相同的。  </p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>本文所述方法，有一定范围内可以使用，对于大型项目或多人协作项目，不建议使用。<br>针对该方法，笔者认为可以进行的事有：<br>1、将 web 服务有关的 css、js、html 等整合到可执行二进制文件中，方便部署。在笔者即将实现的 web 服务中，由于功能唯一，又是内部使用，且还只是由笔者个人实现，因此对技术栈拥有完全自主的决定权，通俗地讲，同事和上头不管技术细节，能实现功能即可，为了方便自己，故如此设计。<br>2、动态库整合，如果涉及动态库文件的使用，则可以将动态库打包到可执行文件，在运行时读取并保存到指定目录，再加载。此法将二者绑定一起，无法做到只更新动态库文件，因此需慎重。<br>3、配置文件整合，对于需配置文件的程序而言，在部署时需自带配置文件，或默认首次运行时生成。对于后者，有的直接在代码中固定配置，根据情况写到指定目录，使用本文，则直接将配置文件打包到二进制文件，如不存在，则再写到指定目录。<br>4、其它待探索发现并实施。  </p><p>李迟 2021.5.5 </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;趁着五一放假，趁着有时间，把欠的一些技术集中研究研究，写写文章，好给自己一个交待。&lt;br&gt;本文介绍如何在 Golang 中整合静态资源文件，将静态资源文件编译到二进制可执行文件中，这与其它程序的打包可能是一个概念，也可能不是，后续有空研究再补充。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：调用C++函数的优化</title>
    <link href="http://www.latelee.org/golang/golang-notes-call-cpulsplus-function2.html"/>
    <id>http://www.latelee.org/golang/golang-notes-call-cpulsplus-function2.html</id>
    <published>2021-05-01T16:01:00.000Z</published>
    <updated>2021-09-06T14:40:29.958Z</updated>
    
    <content type="html"><![CDATA[<p>趁着五一放假，趁着有时间，把欠的一些技术集中研究研究，写写文章，好给自己一个交待。<br>本文继续介绍如何在 Golang 中调用 C++ 函数。  </p><span id="more"></span><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>前面文章介绍的方式，在运行时需要指定动态库位置，或将动态库放置系统目录，对笔者而言，还是略有麻烦，本文将使用<code>dl</code>系列函数，在运行时加载动态库，这样就去掉了路径的依赖。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>为减少篇幅，仅摘录必要的源码。  </p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>在动态库版本源码基础上，额外添加封装动态库头文件 c_callso.h：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">int cso_init(char* soname);</span><br><span class="line"></span><br><span class="line">int cso_uninit();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 结构体指针，传入传出</span><br><span class="line">int CSetPointA(Point* point, Point* point1);</span><br><span class="line"></span><br><span class="line">// 调用内部的类</span><br><span class="line">//int FooCall(void);</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>对应实现文件主要代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;dlfcn.h&gt;</span><br><span class="line"></span><br><span class="line">void* g_sohandle = NULL;</span><br><span class="line">    </span><br><span class="line">int cso_init(char* soname)</span><br><span class="line">&#123;</span><br><span class="line">    g_sohandle = dlopen(soname, RTLD_LAZY);</span><br><span class="line">    if (g_sohandle == NULL) return -1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int cso_uninit()</span><br><span class="line">&#123;</span><br><span class="line">    if (g_sohandle != NULL) dlclose(g_sohandle);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int CSetPointA(Point* point, Point* point1)</span><br><span class="line">&#123;</span><br><span class="line">    typedef int (*ptr)(Point*, Point*);</span><br><span class="line"></span><br><span class="line">    printf(&quot;in c file call so\n&quot;);</span><br><span class="line"></span><br><span class="line">    ptr fptr = (ptr)dlsym(g_sohandle, &quot;FooSetPointA&quot;);</span><br><span class="line"></span><br><span class="line">    return (*fptr)(point, point1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，CSetPointA 函数就是对接 FooSetPointA 函数的，仅做简单的封装。  </p><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><p>Golang 测试完整代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">#cgo LDFLAGS: -ldl</span><br><span class="line"></span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &quot;c_callso.h&quot;</span><br><span class="line">#include &quot;c_callso.c&quot;</span><br><span class="line">*/</span><br><span class="line">import &quot;C&quot;</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;unsafe&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    csoname = &quot;./libfoo.so1&quot;</span><br><span class="line">    //csoname = &quot;./aXi3n0fr1.rd&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func so_test() &#123;</span><br><span class="line">    fmt.Println(&quot;go c++ so test&quot;)</span><br><span class="line">    </span><br><span class="line">    soname := C.CString(csoname)</span><br><span class="line">    ret := C.cso_init(soname)</span><br><span class="line">    if ret != 0 &#123;</span><br><span class="line">        fmt.Println(&quot;cso_init failed &quot;, ret)</span><br><span class="line">        return </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    defer C.free(unsafe.Pointer(soname))</span><br><span class="line">    defer C.cso_uninit()</span><br><span class="line"></span><br><span class="line">    // C形式 结构体</span><br><span class="line">    var myPoint, myPoint1 C.Point</span><br><span class="line">    myPoint.x = 100;</span><br><span class="line">    myPoint.y = 200;</span><br><span class="line">    myPoint.pinname = C.CString(&quot;Hello &quot;) // 指针形式</span><br><span class="line"></span><br><span class="line">    defer C.free(unsafe.Pointer(myPoint.pinname))</span><br><span class="line"></span><br><span class="line">    // 固定长度数组，麻烦点</span><br><span class="line">    arr := [16]C.char&#123;&#125;</span><br><span class="line">    mystr := &quot;Hell &quot;</span><br><span class="line">    for i := 0; i &lt; len(mystr) &amp;&amp; i &lt; 15; i++ &#123;</span><br><span class="line">        arr[i] = C.char(mystr[i])</span><br><span class="line">    &#125;</span><br><span class="line">    myPoint.inname = arr // 数组形式</span><br><span class="line"></span><br><span class="line">    fmt.Println(&quot;Golang | org struct &quot;, myPoint, &quot;single: &quot;, myPoint.x, myPoint.y, myPoint.pinname)</span><br><span class="line">    </span><br><span class="line">    // 结构体指针 传入传出</span><br><span class="line">    ret = C.CSetPointA(&amp;myPoint, &amp;myPoint1)</span><br><span class="line">    </span><br><span class="line">    // 注：C++中使用字符串数组形式，转成string</span><br><span class="line">    var carr []byte</span><br><span class="line">    //carr = C.GoBytes(myPoint1.name, 100)</span><br><span class="line">    </span><br><span class="line">    for i := range myPoint1.name &#123;</span><br><span class="line">        if myPoint1.name[i] != 0 &#123;</span><br><span class="line">            carr = append(carr, byte(myPoint1.name[i]))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    gostr := string(carr) // 转成go的string</span><br><span class="line">    fmt.Println(&quot;Golang | c++ call ret: &quot;, ret, myPoint1.x, gostr, myPoint1.name)</span><br><span class="line"></span><br><span class="line">    // 注：直接用指针形式转换，此处的指针值，与在C中申请的值，是一致的</span><br><span class="line">    // 注：如果指针没有分配内存，返回string为空，用unsafe.Pointer返回&lt;nil&gt;</span><br><span class="line">    gostr = C.GoString(myPoint1.pname)</span><br><span class="line">    defer C.free(unsafe.Pointer(myPoint1.pname))</span><br><span class="line">    </span><br><span class="line">    fmt.Println(&quot;Golang | out pointer:&quot;, gostr, unsafe.Pointer(myPoint1.pname))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    so_test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与前面文章示例不同的地方，主要是调用了 C.cso_init 初始化动态库，最终调用 cso_uninit 释放。  </p><h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><p>运行时，只需要保持动态库的位置和名称与 Golang 中指定的一致即可，无须设置 LD_LIBRARY_PATH 环境变量。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">go c++ so test</span><br><span class="line">Golang | org struct  &#123;100 200 [72 101 108 108 32 0 0 0 0 0 0 0 0 0 0 0] 0xe2fc10 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] &lt;nil&gt;&#125; single:  100 200 0xe2fc10</span><br><span class="line">in c file call so</span><br><span class="line">C++ | got buf: Hell </span><br><span class="line">C++ | pname: Hello </span><br><span class="line">C++ | ptr: 0xe2fc30</span><br><span class="line">Golang | c++ call ret:  0 101 name in c++ [110 97 109 101 32 105 110 32 99 43 43 0 0 0 0 0]</span><br><span class="line">Golang | out pointer: Hell  | name in c++ malloc 0xe2fc30</span><br></pre></td></tr></table></figure><h2 id="实践总结"><a href="#实践总结" class="headerlink" title="实践总结"></a>实践总结</h2><p>动态库初始化函数<code>cso_init</code>等保留，动态库对外提供的业务接口，尽量少，这样减少 golang 和 C++ 之间的代码接口数量。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文的方法，却增加了源码级别的复杂度，不一定都符合要求，因此仅作参考。<br>Linux 的动态库，其名称一般为 <code>libXXX.so</code>，但经测试，任意名称也是可以的。    </p><p>李迟 2021.5.2 </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;趁着五一放假，趁着有时间，把欠的一些技术集中研究研究，写写文章，好给自己一个交待。&lt;br&gt;本文继续介绍如何在 Golang 中调用 C++ 函数。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：调用C++函数</title>
    <link href="http://www.latelee.org/golang/golang-notes-call-cpulsplus-function.html"/>
    <id>http://www.latelee.org/golang/golang-notes-call-cpulsplus-function.html</id>
    <published>2021-05-01T16:00:00.000Z</published>
    <updated>2021-09-06T14:40:29.958Z</updated>
    
    <content type="html"><![CDATA[<p>趁着五一放假，趁着有时间，把欠的一些技术集中研究研究，写写文章，好给自己一个交待。<br>本文介绍如何在 Golang 中调用 C++ 函数。  </p><span id="more"></span><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>因工作需求，需要将一个工具由终端行的运行方式迁移到 web 上，核心代码由 c++ 动态库实现，另一部门的同事使用 Java 实现了一个版本，部门同事安排我做部署，由于服务器是离线的，且由专人管理，JDK 和 Tomcat 安装稍麻烦，个人操作自由度不够，——一是没有研究过 Java，二来部署麻烦。因此，决定使用 Golang 实现。预计展开的内容有：Golang 调用 C++ 动态库；Golang Web 服务及整合 html/css资源；(大)前端框架使用。  </p><p>本文主要研究 C++ 动态库及函数的调用。  </p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>Golang 只支持 C 语言的编译，对于 C++ 的编译，有2种方法：<br>1、不使用类，在 C++ 代码头文件添加<code>extern &quot;C&quot; &#123;</code>，将函数声明为 C 格式。<br>2、如出现类的情况，再用另外的文件将其封装成 C 格式函数。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="C-C-代码"><a href="#C-C-代码" class="headerlink" title="C/C++代码"></a>C/C++代码</h3><p>没有类的文件，但后缀名为cpp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// bar.h文件：</span><br><span class="line">#ifndef BAR_H</span><br><span class="line">#define BAR_H</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">int bar();</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">// bar.cpp文件：</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;bar.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int bar()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;C | hell bar\n&quot;);</span><br><span class="line">    </span><br><span class="line">    #ifdef MACRO_TEST</span><br><span class="line">    printf(&quot;C | macro...\n&quot;);</span><br><span class="line">    #endif</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有类的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// foo.h for class</span><br><span class="line"></span><br><span class="line">#ifndef FOO_H</span><br><span class="line">#define FOO_H</span><br><span class="line"></span><br><span class="line">class CFoo</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CFoo(int value): m_value(value)&#123;&#125;;</span><br><span class="line">    ~CFoo()&#123;&#125;;</span><br><span class="line">    void Bar();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int m_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">// foo.cpp</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;foo.h&quot;</span><br><span class="line"></span><br><span class="line">void CFoo::Bar(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;C++ Class | %s(): num: %d\n&quot;, __func__, m_value);</span><br><span class="line">  //std::cout&lt;&lt;this-&gt;a&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>封装代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">// foo.h</span><br><span class="line">#ifndef OUT_H</span><br><span class="line">#define OUT_H</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">typedef  struct Point&#123;</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">    char inname[16]; // 传入buff</span><br><span class="line">    char* pinname; // 传入指针</span><br><span class="line">    char name[16]; // 传出buff</span><br><span class="line">    char* pname; // 传出指针</span><br><span class="line">&#125;Point;</span><br><span class="line"></span><br><span class="line">// 普通类型赋值</span><br><span class="line">int FooSetValue(int a, unsigned int b, float c, char* str);</span><br><span class="line"></span><br><span class="line">void PrintString(char* str);</span><br><span class="line"></span><br><span class="line">// 结构体</span><br><span class="line">int FooSetPointC(Point point);</span><br><span class="line">// 结构体指针</span><br><span class="line">int FooSetPoint(Point* point);</span><br><span class="line">// 结构体指针，传入传出</span><br><span class="line">int FooSetPointA(Point* point, Point* point1);</span><br><span class="line"></span><br><span class="line">// 调用内部的类</span><br><span class="line">int FooCall(int num);</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">// out.cpp</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;out.h&quot;</span><br><span class="line">#include &quot;foo.h&quot;</span><br><span class="line"></span><br><span class="line">int FooSetValue(int a, unsigned int b, float c, char* str)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;C++ | base type: %d %d %.4f %s\n&quot;, a, b, c, str);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">void PrintString(char* str)</span><br><span class="line">&#123;</span><br><span class="line">trueprintf(&quot;C++ | string = %s\n&quot;, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int FooSetPointC(Point point)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;C++ | the point in c for value: %d %d \n&quot;,  point.x, point.y);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int FooSetPoint(Point* point)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;C++ | the point in c: %d %d \n&quot;,  point-&gt;x, point-&gt;y);</span><br><span class="line">    </span><br><span class="line">    point-&gt;x = 250;</span><br><span class="line">    point-&gt;y = 500;</span><br><span class="line">    strcpy(point-&gt;name, &quot;name in c++&quot;);</span><br><span class="line">    return 24;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int FooSetPointA(Point* point, Point* point1)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;C++ | got buf: %s\n&quot;, point-&gt;inname);</span><br><span class="line"></span><br><span class="line">    if (point-&gt;pinname != NULL) printf(&quot;C++ | pname: %s\n&quot;, point-&gt;pinname);</span><br><span class="line"></span><br><span class="line">    point1-&gt;x = point-&gt;x+1;</span><br><span class="line">    point1-&gt;y = point-&gt;y+1;</span><br><span class="line">    strcpy(point1-&gt;name, &quot;name in c++&quot;);</span><br><span class="line">    </span><br><span class="line">    point1-&gt;pname = new char[16];</span><br><span class="line">    sprintf(point1-&gt;pname, &quot;%s | name in c++ malloc&quot;, point-&gt;inname);</span><br><span class="line">    //strcpy(point1-&gt;pname, &quot;name in c++ malloc &quot;);</span><br><span class="line">    printf(&quot;C++ | ptr: %p\n&quot;, point1-&gt;pname);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int FooCall(int num)</span><br><span class="line">&#123;</span><br><span class="line">    CFoo * ret = new CFoo(num);</span><br><span class="line">    ret-&gt;Bar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用 Makefile 将上面文件编译为 libfoo.so 动态库。  </p><h3 id="动态库调用"><a href="#动态库调用" class="headerlink" title="动态库调用"></a>动态库调用</h3><p>完整测试代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">#cgo CFLAGS: -I.</span><br><span class="line">#cgo LDFLAGS: -L. -lfoo</span><br><span class="line"></span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;out.h&quot;</span><br><span class="line">*/</span><br><span class="line">import &quot;C&quot;</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;unsafe&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func so_test() &#123;</span><br><span class="line">    fmt.Println(&quot;go c++ so test&quot;)</span><br><span class="line"></span><br><span class="line">    // 简单函数调用</span><br><span class="line">    cstr := C.CString(&quot;call C func&quot;)</span><br><span class="line">    defer C.free(unsafe.Pointer(cstr))</span><br><span class="line">    var i C.int</span><br><span class="line">    i = 100</span><br><span class="line">    C.FooSetValue(i, C.uint(250), C.float(3.14159), cstr)</span><br><span class="line">    C.PrintString(cstr);</span><br><span class="line"></span><br><span class="line">    // C形式 结构体</span><br><span class="line">    var myPoint, myPoint1 C.Point</span><br><span class="line">    myPoint.x = 100;</span><br><span class="line">    myPoint.y = 200;</span><br><span class="line">    myPoint.pinname = C.CString(&quot;Hello &quot;) // 指针形式</span><br><span class="line"></span><br><span class="line">    defer C.free(unsafe.Pointer(myPoint.pinname))</span><br><span class="line"></span><br><span class="line">    // 固定长度数组，麻烦点</span><br><span class="line">    arr := [16]C.char&#123;&#125;</span><br><span class="line">    mystr := &quot;Hell &quot;</span><br><span class="line">    for i := 0; i &lt; len(mystr) &amp;&amp; i &lt; 15; i++ &#123;</span><br><span class="line">        arr[i] = C.char(mystr[i])</span><br><span class="line">    &#125;</span><br><span class="line">    myPoint.inname = arr // 数组形式</span><br><span class="line"></span><br><span class="line">    fmt.Println(&quot;Golang | org struct &quot;, myPoint, &quot;single: &quot;, myPoint.x, myPoint.y, myPoint.pinname)</span><br><span class="line">    </span><br><span class="line">    // 结构体传值</span><br><span class="line">    C.FooSetPointC(myPoint)</span><br><span class="line">    </span><br><span class="line">    // 结构体指针 传入传出</span><br><span class="line">    ret := C.FooSetPointA(&amp;myPoint, &amp;myPoint1)</span><br><span class="line">    </span><br><span class="line">    // 注：C++中使用字符串数组形式，转成string</span><br><span class="line">    var carr []byte</span><br><span class="line">    //carr = C.GoBytes(myPoint1.name, 16)</span><br><span class="line">    </span><br><span class="line">    for i := range myPoint1.name &#123;</span><br><span class="line">        if myPoint1.name[i] != 0 &#123;</span><br><span class="line">            carr = append(carr, byte(myPoint1.name[i]))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    gostr := string(carr) // 转成go的string</span><br><span class="line">    fmt.Println(&quot;Golang | c++ call ret: &quot;, ret, myPoint1.x, gostr, myPoint1.name)</span><br><span class="line"></span><br><span class="line">    // 注：直接用指针形式转换，此处的指针值，与在C中申请的值，是一致的</span><br><span class="line">    // 注：如果指针没有分配内存，返回string为空，用unsafe.Pointer返回&lt;nil&gt;</span><br><span class="line">    gostr = C.GoString(myPoint1.pname)</span><br><span class="line">    defer C.free(unsafe.Pointer(myPoint1.pname))</span><br><span class="line">    </span><br><span class="line">    fmt.Println(&quot;Golang | out pointer:&quot;, gostr, unsafe.Pointer(myPoint1.pname))</span><br><span class="line"></span><br><span class="line">    C.FooCall(250)</span><br><span class="line">    C.FooCall(C.int(250))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    so_test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码要点如下：<br>1、需设置编译参数 LDFLAGS，指定库位置和名称，本例中是当前目录的 libfoo.so。<br>2、需包含相应的头文件，stdlib.h 为 free 函数所在文件。<br>3、内嵌的 C 源码在包的前面，且<code>import &quot;C&quot;</code>后需空一行。<br>4、传递到 C 函数的内存，使用<code>C.CString</code>申请，C 申请的内存使用<code>C.GoString</code>获取，均需要手动释放。  </p><h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><p>在运行前，需要设置动态库路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$PWD</span><br></pre></td></tr></table></figure><p>否则运行时无法找到动态库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test: error while loading shared libraries: libfoo.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">go c++ so test</span><br><span class="line">C++ | base type: 100 250 3.1416 call C func</span><br><span class="line">C++ | string = call C func</span><br><span class="line">Golang | org struct  &#123;100 200 [72 101 108 108 32 0 0 0 0 0 0 0 0 0 0 0] 0x25b2a30 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] &lt;nil&gt;&#125; single:  100 200 0x25b2a30</span><br><span class="line">C++ | the point in c for value: 100 200 </span><br><span class="line">C++ | got buf: Hell </span><br><span class="line">C++ | pname: Hello </span><br><span class="line">C++ | ptr: 0x25b2a50</span><br><span class="line">Golang | c++ call ret:  0 101 name in c++ [110 97 109 101 32 105 110 32 99 43 43 0 0 0 0 0]</span><br><span class="line">Golang | out pointer: Hell  | name in c++ malloc 0x25b2a50</span><br><span class="line">C++ Class | Bar(): num: 250</span><br><span class="line">C++ Class | Bar(): num: 250</span><br></pre></td></tr></table></figure><p>从上述结果中可看出，C 中申请的内存，其指针与在 Go 中获取的指针是一样的，即 0x25b2a50。结构体中的 nil 是因为字段 pname 未赋值。  </p><h3 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h3><p>前面的动态库代码，不能全部内嵌到 Go 代码中，因此选取其中的 bar.h/cpp，测试代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">#cgo CFLAGS: -I. -DMACRO_TEST</span><br><span class="line"></span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;bar.h&quot;</span><br><span class="line">#include &quot;bar.cpp&quot;</span><br><span class="line">*/</span><br><span class="line">import &quot;C&quot;</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;  </span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func cpp_test() &#123;</span><br><span class="line">    fmt.Println(&quot;go c++ so test&quot;)</span><br><span class="line">    C.bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    cpp_test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码要点：<br>1、可用 CFLAGS 指定头文件，添加宏定义等。<br>2、将所有的 C 源码包含到代码中。（存疑：似乎应该是头文件，在编译过程中自动找对应的实现文件，这里包含进来，相当于所有源码都在 Go 代码中）  </p><h3 id="结果分析-1"><a href="#结果分析-1" class="headerlink" title="结果分析"></a>结果分析</h3><p>运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go c++ so test</span><br><span class="line">C | hell bar</span><br><span class="line">C | macro...</span><br></pre></td></tr></table></figure><p>使用此方法，如果修改 C 代码，还需更新包含 C 代码的 go 文件，否则不会被编译。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面对2种形式的调用进行了实践，在功能和使用上各有千秋，对于简单的 C 语言代码（包含C++形式的简单函数），直接使用内嵌的形式会更高效。<br>本文使用的动态库例子，在运行前还需要设置运行路径，当然可以将动态库放到系统目录的，但笔者认为不是正道，下面将去掉动态库路径的依赖。  </p><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>Go 编译时，如果包含有类的文件，编译失败，出错信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">In file included from ./bar.cpp:2:0,</span><br><span class="line">                 from ./main_one.go:17:</span><br><span class="line">./foo.h:6:1: error: unknown type name &#x27;class&#x27;</span><br><span class="line"> class CFoo</span><br><span class="line"> ^</span><br><span class="line">./foo.h:7:1: error: expected &#x27;=&#x27;, &#x27;,&#x27;, &#x27;;&#x27;, &#x27;asm&#x27; or &#x27;__attribute__&#x27; before &#x27;&#123;&#x27; token</span><br><span class="line"> &#123;</span><br><span class="line"> ^</span><br><span class="line">In file included from ./main_one.go:17:0:</span><br><span class="line">./bar.cpp: In function &#x27;FooCall1&#x27;:</span><br><span class="line">./bar.cpp:18:5: error: unknown type name &#x27;CFoo&#x27;</span><br><span class="line">     CFoo * ret = new CFoo(num);</span><br><span class="line">     ^</span><br><span class="line">./bar.cpp:18:18: error: &#x27;new&#x27; undeclared (first use in this function)</span><br><span class="line">     CFoo * ret = new CFoo(num);</span><br><span class="line">                  ^</span><br><span class="line">./bar.cpp:18:18: note: each undeclared identifier is reported only once for each function it appears in</span><br><span class="line">./bar.cpp:18:22: error: expected &#x27;,&#x27; or &#x27;;&#x27; before &#x27;CFoo&#x27;</span><br><span class="line">     CFoo * ret = new CFoo(num);</span><br><span class="line">                      ^</span><br><span class="line">./bar.cpp:19:8: error: request for member &#x27;Bar&#x27; in something not a structure or union</span><br><span class="line">     ret-&gt;Bar();</span><br></pre></td></tr></table></figure><p>李迟 2021.5.2 </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;趁着五一放假，趁着有时间，把欠的一些技术集中研究研究，写写文章，好给自己一个交待。&lt;br&gt;本文介绍如何在 Golang 中调用 C++ 函数。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：生成版本号和编译时间</title>
    <link href="http://www.latelee.org/golang/golang-notes-generate-version-time.html"/>
    <id>http://www.latelee.org/golang/golang-notes-generate-version-time.html</id>
    <published>2021-04-30T16:00:00.000Z</published>
    <updated>2021-09-06T14:40:29.958Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍如何在 Golang 中生成和管理版本号及编译时间。  </p><span id="more"></span><h2 id="一、起因"><a href="#一、起因" class="headerlink" title="一、起因"></a>一、起因</h2><p>笔者手上有几份祖传代码，最早一份90年代末写，次早是 2012 年写的，最新的代码，也是 2016 年写的，版本号倒有，但没有版本管理，虽然看得头大，但也得看。笔者写的程序一般会添加版本号和编译日期时间，也会加上版本控制，以方便追溯和维护。对于 C/C++ 语言，有<code>__DATE__</code>和<code>__TIME_</code>这两个宏定义，但 Golang 没有，因此加版本号还是额外研究。  </p><h2 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h2><p>本文提供2个方法。一是通过编译时加的 ldflags 参数，对变量进行赋赋值；二是通过内嵌 C 语言函数实现。后者可以使用<code>__DATE__</code>和<code>__TIME_</code>，为了统一，均在脚本中生成日期日期，版本号亦在脚本中指定，因为在脚本中定制方便一些。  </p><h2 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h2><h3 id="方法1：Golang变量"><a href="#方法1：Golang变量" class="headerlink" title="方法1：Golang变量"></a>方法1：Golang变量</h3><p>准备：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Version=&quot;v1.0&quot;</span><br><span class="line">BuildTime=`date +&#x27;%Y-%m-%d %H:%M:%S&#x27;`</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">trueBuildTime string</span><br><span class="line">trueVersion string</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func getVersion1() string &#123;</span><br><span class="line">truereturn fmt.Sprintf(&quot;  %v build: %v\n&quot;, Version, BuildTime)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GO111MODULE=on go build -ldflags &quot;-X &#x27;dbtool/cmd.BuildTime=$&#123;BuildTime&#125;&#x27; -X &#x27;dbtool/cmd.Version=$&#123;Version&#125;&#x27;&quot; -mod vendor -o dbtool.exe main.go || exit 1</span><br></pre></td></tr></table></figure><h3 id="方法2：调用C函数"><a href="#方法2：调用C函数" class="headerlink" title="方法2：调用C函数"></a>方法2：调用C函数</h3><p>准备：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Version=&quot;v1.0&quot;</span><br><span class="line">BuildTime=`date +&#x27;%Y-%m-%d %H:%M:%S&#x27;`</span><br><span class="line"></span><br><span class="line">GIT_VERSION=$Version&quot; build: &quot;$BuildTime</span><br><span class="line"></span><br><span class="line">echo &quot;Generated&quot; $VER_FILE &quot;for version:&quot; $GIT_VERSION</span><br><span class="line"></span><br><span class="line">echo &quot;#ifndef PROJECT_VERSION_H&quot; &gt; $VER_FILE</span><br><span class="line">echo &quot;#define PROJECT_VERSION_H&quot; &gt;&gt; $VER_FILE</span><br><span class="line">echo &quot;&quot; &gt;&gt; $VER_FILE</span><br><span class="line">echo &quot;#define VERSION_NUMBER \&quot;$GIT_VERSION\&quot;&quot; &gt;&gt; $VER_FILE</span><br><span class="line">echo &quot;&quot; &gt;&gt; $VER_FILE</span><br><span class="line">echo &quot;#endif&quot; &gt;&gt; $VER_FILE</span><br><span class="line"></span><br><span class="line">echo &quot;Job done!!&quot;</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;version.h&quot;</span><br><span class="line"></span><br><span class="line">char* GetVersion()</span><br><span class="line">&#123;</span><br><span class="line">    static char buffer[64] = &#123;0&#125;;</span><br><span class="line">    </span><br><span class="line">    // 代码中指定版本信息</span><br><span class="line">    snprintf(buffer, 64, &quot; %s build: %s %s\r\n&quot;, &quot;v1.0&quot;, __DATE__, __TIME__);</span><br><span class="line">    // 由脚本生成到文件</span><br><span class="line">    //snprintf(buffer, 64, &quot; %s\r\n&quot;, VERSION_NUMBER);</span><br><span class="line">    </span><br><span class="line">    return buffer;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">import &quot;C&quot;</span><br><span class="line"></span><br><span class="line">// 注：以上代码必须放到 Goalng 正式语句之前，且import &quot;C&quot;后必须空一行</span><br><span class="line"></span><br><span class="line">func getVersion() string &#123;</span><br><span class="line">    name1 := C.GetVersion()</span><br><span class="line">    name := C.GoString(name1)</span><br><span class="line">truereturn fmt.Sprintf(&quot; %v&quot;, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GO111MODULE=on go build -mod vendor -o dbtool.exe main.go || exit 1</span><br></pre></td></tr></table></figure><h2 id="四、测试"><a href="#四、测试" class="headerlink" title="四、测试"></a>四、测试</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./dbtool.exe --version</span><br><span class="line">dbtool.exe version   v1.0 build: 2021-04-04 22:42:07</span><br></pre></td></tr></table></figure><p>BuildTime 使用 date 命令生成日期，可用默认的形式，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./dbtool.exe --version</span><br><span class="line">dbtool.exe version   v1.0 build: Apr  4 2021 22:47:20</span><br></pre></td></tr></table></figure><h2 id="五、维护"><a href="#五、维护" class="headerlink" title="五、维护"></a>五、维护</h2><p>需在编译脚本中修改版本号，可手动修改，也可根据 SVN 或 GIT 版本迭代自动生成（散见于笔者多年前的文章）。</p><h2 id="六、源码仓库"><a href="#六、源码仓库" class="headerlink" title="六、源码仓库"></a>六、源码仓库</h2><p><a href="https://github.com/latelee/cmdtool">https://github.com/latelee/cmdtool</a>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍如何在 Golang 中生成和管理版本号及编译时间。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>vuepress实践录：初步入门</title>
    <link href="http://www.latelee.org/vue/vuepress-learning1.html"/>
    <id>http://www.latelee.org/vue/vuepress-learning1.html</id>
    <published>2021-04-29T16:00:00.000Z</published>
    <updated>2021-09-06T14:40:29.958Z</updated>
    
    <content type="html"><![CDATA[<p>本文初步介绍vuepress的安装和使用。</p><span id="more"></span><h2 id="初试"><a href="#初试" class="headerlink" title="初试"></a>初试</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>安装 yarn，并添加国内源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yarn</span><br><span class="line"></span><br><span class="line">yarn config set registry &quot;https://registry.npm.taobao.org&quot;</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>创建并进入一个新目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir vuepress-starter &amp;&amp; cd vuepress-starter</span><br></pre></td></tr></table></figure><p>初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn init</span><br></pre></td></tr></table></figure><p>注：在 Windows 下用 cmd 执行。用 git bash 会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error An unexpected error occurred: &quot;Can&#x27;t answer a question unless a user TTY&quot;.</span><br></pre></td></tr></table></figure><p>生成如下 package.json</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;vuepress-starter&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;MIT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：可以只使用 cmd 生成 json 文件，或手动写 json 文件。再用回 git bash。  </p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>（官方当前推荐）本地安装 vuepress：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D vuepress</span><br></pre></td></tr></table></figure><p>会生成 node_modules目录（通过 yarn 安装的插件、主题等在此目录）。  </p><p>创建一篇文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir docs &amp;&amp; echo &#x27;# Hello VuePress&#x27; &gt; docs/README.md</span><br></pre></td></tr></table></figure><p>在 package.json 中添加 scripts，以便执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;vuepress dev docs&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;vuepress build docs&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>启动服务器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn dev</span><br></pre></td></tr></table></figure><p>即可用浏览器访问本地 8080 端口，观看效果。  </p><p>如需构建静态页面，执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn build</span><br></pre></td></tr></table></figure><p>注：构建后在 docs 下有 .vuepress/dist目录，dist 即为静态网站文件所在目录。将其放到其它 web 服务器的资源目录中，即为网站。  </p><p>**注意：官方使用 docs 目录作为工程目录，为了不让目录过深，也可以不使用，此时<code>vuepress dev docs</code>改为<code>vuepress dev</code>即可。  </p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>创建目录和文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p docs/.vuepress docs/.vuepress/public</span><br><span class="line">touch .vuepress/config.js</span><br></pre></td></tr></table></figure><p>注：.vuepress 目录为 vuepress 的配置根目录。所有的配置文件均在其下。public 为公共访问目录，可存放 icon、logo等资源，config.js 是配置文件，非常重要。  </p><p>修改 docs/README.md 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">home: true</span><br><span class="line">heroImage: /hero.png</span><br><span class="line">heroText: Hero 标题</span><br><span class="line">tagline: Hero 副标题</span><br><span class="line">actionText: 快速上手 →</span><br><span class="line">actionLink: /zh/guide/</span><br><span class="line">features:</span><br><span class="line">- title: 简洁至上</span><br><span class="line">  details: 以 Markdown 为中心的项目结构，以最少的配置帮助你专注于写作。</span><br><span class="line">- title: Vue驱动</span><br><span class="line">  details: 享受 Vue + webpack 的开发体验，在 Markdown 中使用 Vue 组件，同时可以使用 Vue 来开发自定义主题。</span><br><span class="line">- title: 高性能</span><br><span class="line">  details: VuePress 为每个页面预渲染生成静态的 HTML，同时在页面被加载的时候，将作为 SPA 运行。</span><br><span class="line">footer: MIT Licensed | Copyright © 2018-present Evan You</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">下面是常规 markdown 文件。</span><br><span class="line"># Hello VuePress theme!</span><br><span class="line">这是中文示例。  </span><br><span class="line">上面这句最后空了2个空格，预期效果应为换行。  </span><br><span class="line"></span><br><span class="line">上上面这句后多了一个窄，预期效果应该是空了一行。  </span><br><span class="line"></span><br><span class="line">## 这是二级header</span><br><span class="line"></span><br><span class="line">### This is 三级标题</span><br></pre></td></tr></table></figure><p>config.js 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  title: &#x27;大锤与大妞&#x27;, // 设置网站标题</span><br><span class="line">  description: &#x27;大锤与大妞的网站&#x27;,</span><br><span class="line">  head: [</span><br><span class="line">      [&#x27;link&#x27;, &#123; rel: &#x27;icon&#x27;, href: &#x27;/favicon.ico&#x27; &#125;], // favicon.ico在public目录</span><br><span class="line">  ],</span><br><span class="line">  // markdown 的配置</span><br><span class="line">  markdown: &#123;</span><br><span class="line">      lineNumbers: false // 代码块显示行号</span><br><span class="line">  &#125;,</span><br><span class="line">  themeConfig: &#123;</span><br><span class="line">    logo: &#x27;/logo.png&#x27;,</span><br><span class="line">    // repo: &#x27;https://github.com/latelee&#x27;, // 不使用</span><br><span class="line">    sidebar: &#x27;auto&#x27;,</span><br><span class="line">    sidebarDepth: 2,</span><br><span class="line">    activeHeaderLinks: false, // 默认值：true 禁用活动的标题链接</span><br><span class="line">    // 默认值是 true 。设置为 false 来禁用所有页面的 下一篇 链接</span><br><span class="line">    nextLinks: true,</span><br><span class="line">    // 默认值是 true 。设置为 false 来禁用所有页面的 上一篇 链接</span><br><span class="line">    prevLinks: true,</span><br><span class="line">    smoothScroll: true,</span><br><span class="line">    nav: [</span><br><span class="line">      &#123; text: &#x27;Home&#x27;, link: &#x27;/&#x27; &#125;,</span><br><span class="line">      &#123; text: &#x27;Guide&#x27;, link: &#x27;/guide/&#x27; &#125;,</span><br><span class="line">      &#123; text: &#x27;External&#x27;, link: &#x27;https://google.com&#x27; &#125;,</span><br><span class="line">      // 子导航条</span><br><span class="line">      &#123;</span><br><span class="line">        text: &#x27;Languages&#x27;,</span><br><span class="line">        ariaLabel: &#x27;Language Menu&#x27;,</span><br><span class="line">        items: [</span><br><span class="line">          &#123; text: &#x27;Chinese&#x27;, link: &#x27;/language/chinese/&#x27; &#125;,</span><br><span class="line">          &#123; text: &#x27;Japanese&#x27;, link: &#x27;/language/japanese/&#x27; &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      // 子导航条的分组</span><br><span class="line">      &#123;</span><br><span class="line">        text: &#x27;Languages&#x27;,</span><br><span class="line">        items: [</span><br><span class="line">          &#123; text: &#x27;Group1&#x27;, items: [</span><br><span class="line">            &#123; text: &#x27;Chinese1&#x27;, link: &#x27;/language/chinese/&#x27; &#125;,</span><br><span class="line">            &#123; text: &#x27;Japanese1&#x27;, link: &#x27;/language/japanese/&#x27; &#125;</span><br><span class="line">            ] &#125;,</span><br><span class="line">          &#123; text: &#x27;Group2&#x27;, items: [</span><br><span class="line">            &#123; text: &#x27;Chinese2&#x27;, link: &#x27;/language/chinese/&#x27; &#125;,</span><br><span class="line">            &#123; text: &#x27;Japanese2&#x27;, link: &#x27;/language/japanese/&#x27; &#125;</span><br><span class="line">            ] &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：favicon.ico、logo.png、hero.png等在 public 目录。  </p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>获取默认主题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn vuepress eject</span><br></pre></td></tr></table></figure><p>在当前目录的 .vuepress 有 theme 目录，其下即为默认主题所有文件。<br>将 theme 目录放到 <code>docs/.vuepress</code> 目录下。  </p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>文章加密插件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D @oak-tree-house/vuepress-plugin-encrypt</span><br></pre></td></tr></table></figure><p>参考：<br><a href="https://www.imaegoo.com/2020/vuepress-encrypt/">https://www.imaegoo.com/2020/vuepress-encrypt/</a> <a href="https://szp15.com/2020/02/04/plugin-encrypt-doc/">https://szp15.com/2020/02/04/plugin-encrypt-doc/</a><br>还不成功</p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>路径路由默认使用目录的 README.md 文件。<br>markdown 有扩展功能。<br>vuepress 大部分文件都支持热更新，但有的配置可能不会，如 config.js，需要重启服务。当修改 markdown 文档时，浏览器会自动刷新。<br>主题可继承，从默认主题继承。<br>执行<code>vuepress</code>无命令，使用<code>yarn vuepress</code>代替。  </p><p>markdown 小记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">站内跳转，/表示从根目录开始</span><br><span class="line">[XXX](/doc/foo/XXX.md) </span><br><span class="line">插入当前目录的图片，默认情况下路径和图片名称不能有中文</span><br><span class="line">![XXX](./01.png) </span><br></pre></td></tr></table></figure><p>内嵌 vue 代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 循环，输出1 2 3</span><br><span class="line">&lt;span v-for=&quot;i in 3&quot;&gt;&#123;&#123; i &#125;&#125; &lt;/span&gt;</span><br></pre></td></tr></table></figure><h2 id="问题及解决"><a href="#问题及解决" class="headerlink" title="问题及解决"></a>问题及解决</h2><h4 id="支持中文名称图片。"><a href="#支持中文名称图片。" class="headerlink" title="支持中文名称图片。"></a>支持中文名称图片。</h4><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add markdown-it-disable-url-encode</span><br></pre></td></tr></table></figure><p>在<code>.vuepress/config.js</code>添加：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// .....</span></span><br><span class="line">  <span class="attr">markdown</span>: &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="attr">extendMarkdown</span>: <span class="function"><span class="params">md</span> =&gt;</span> &#123;</span><br><span class="line">      md.use(<span class="built_in">require</span>(<span class="string">&quot;markdown-it-disable-url-encode&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="另一个主题的安装"><a href="#另一个主题的安装" class="headerlink" title="另一个主题的安装"></a>另一个主题的安装</h2><p>下载新版本node <a href="http://npm.taobao.org/mirrors/node/v16.2.0/%EF%BC%8C%E5%8F%8C%E5%87%BB%E5%AE%89%E8%A3%85%E4%B9%8B%E3%80%82">http://npm.taobao.org/mirrors/node/v16.2.0/，双击安装之。</a></p><p>在某目录执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn create vuepress-theme-hope vue-hope</span><br></pre></td></tr></table></figure><p>一路回车即可。进入<code>vue-hope</code>目录，执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn install</span><br></pre></td></tr></table></figure><p>注：该主题依赖的node版本必须高于13.7。  修改后的package.json：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;vuepress-theme-hope-project&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;A project of vuepress-theme-hope&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;MIT&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;vuepress build&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;clean-dev&quot;</span>: <span class="string">&quot;vuepress dev --no-cache&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;vuepress dev&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;eject-theme&quot;</span>: <span class="string">&quot;vuepress eject-hope&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;vuepress&quot;</span>: <span class="string">&quot;^1.8.2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;vuepress-theme-hope&quot;</span>: <span class="string">&quot;^1.17.2&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">启动服务：</span><br><span class="line">yarn run dev</span><br><span class="line">生成网页：</span><br><span class="line">yarn run build</span><br><span class="line">导出主题（在.vuepress下）：</span><br><span class="line">yarn run eject-theme</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考：<a href="https://vuepress-theme-hope.github.io/zh/guide/">https://vuepress-theme-hope.github.io/zh/guide/</a></p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>参考：<br>快速上手：<a href="https://vuepress.vuejs.org/zh/guide/">https://vuepress.vuejs.org/zh/guide/</a><br>主题：<a href="https://vuepress.vuejs.org/zh/theme/">https://vuepress.vuejs.org/zh/theme/</a><br>资源（主题、插件）：<a href="https://github.com/vuepress/awesome-vuepress">https://github.com/vuepress/awesome-vuepress</a><br>默认主题：<a href="https://github.com/vuejs/vuepress">https://github.com/vuejs/vuepress</a> 仓库 <code>packages/@vuepress</code> 目录<br>主题：<br><a href="https://github.com/xuzhongpeng/vuepress-theme-reform">https://github.com/xuzhongpeng/vuepress-theme-reform</a><br><a href="https://github.com/vuepress-reco/vuepress-theme-reco">https://github.com/vuepress-reco/vuepress-theme-reco</a><br><a href="https://github.com/xugaoyi/vuepress-theme-vdoing">https://github.com/xugaoyi/vuepress-theme-vdoing</a>  </p><p>查看 markdown 中支持语法的语言名称：<a href="https://prismjs.com/#languages-list">https://prismjs.com/#languages-list</a>  </p><p>李迟 2021.4.30</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文初步介绍vuepress的安装和使用。&lt;/p&gt;</summary>
    
    
    
    <category term="vue" scheme="http://www.latelee.org/category/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>李迟2021年4月知识总结</title>
    <link href="http://www.latelee.org/my-library/code-for-2021-04.html"/>
    <id>http://www.latelee.org/my-library/code-for-2021-04.html</id>
    <published>2021-04-29T16:00:00.000Z</published>
    <updated>2021-09-06T14:40:30.034Z</updated>
    
    <content type="html"><![CDATA[<p>前言：<br>上一篇类似的文章，是2011年的3月份，看了下当时写的内容，除了代码外，还有其它思考，但后面越来越少了，年纪大了，想的东西少，也没什么好写了，现在重拾起来，觉得十分有必要，可以将每个月的实践、思考记录下来，否则一年过去了，似乎什么也没有学到。  </p><span id="more"></span><h2 id="编码总结"><a href="#编码总结" class="headerlink" title="编码总结"></a>编码总结</h2><h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><p>研究了如何将一些资源文件整合到二进制可执行文件中，后续将系统发文。  </p><h3 id="Nodejs"><a href="#Nodejs" class="headerlink" title="Nodejs"></a>Nodejs</h3><p>excel解析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var xlsx = require(&#x27;node-xlsx&#x27;);</span><br><span class="line"></span><br><span class="line">    var obj = xlsx.parse(&quot;foo.xlsx&quot;); // 支持xls</span><br><span class="line">    var excelObj=obj[0].data; // 0表示第1张表，1为第2张表</span><br><span class="line">    console.log(excelObj) // 根据规则遍历解析，如只有3列，某列为空，某列名称，等</span><br></pre></td></tr></table></figure><p>其它代码片段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 去掉空格、tab、回车换行等</span><br><span class="line">function trim(s)&#123;</span><br><span class="line">    //return s.replace(/(^\s*)|(\s*$)/g, &quot;&quot;);</span><br><span class="line">    return s.replace(/(^\s*)|(\s*$)|([\t\r\n])/g, &quot;&quot;); // |(\ +)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 截取前2字符</span><br><span class="line">gxcode = code.substring(0, 2)</span><br><span class="line">// 截取前4位、第4位后的字符串</span><br><span class="line">code_1 = code.substring(0, 4)</span><br><span class="line">code_2 = code.substring(4)</span><br><span class="line">code_2.trim() // string自带的的去掉前后空格</span><br><span class="line"></span><br><span class="line">多维数组</span><br><span class="line">var outdata = []; // 形式1</span><br><span class="line">var tmpdata = new Array();  // 形式2</span><br><span class="line">tmpdata.code = code</span><br><span class="line">tmpdata.name = district_name</span><br><span class="line"></span><br><span class="line">outdata.push(tmpdata)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用高德地图API获取地点信息（行政区、经纬度、编码等）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">const superagent = require(&quot;superagent&quot;);</span><br><span class="line"></span><br><span class="line">// nameArray地名数组</span><br><span class="line">function getLocationFromWeb(nameArray)</span><br><span class="line">&#123;</span><br><span class="line">    newname = changeName(nameArray) // 如有多个地名，则添加|</span><br><span class="line">    var needbatch=&quot;&quot;</span><br><span class="line">    if (newname.indexOf(&quot;|&quot;) != -1)</span><br><span class="line">    &#123;</span><br><span class="line">        needbatch = &quot;batch=true&amp;&quot; // 高德API一次最多10个地名，batch为true</span><br><span class="line">    &#125;</span><br><span class="line">    var getstr = &quot;https://restapi.amap.com/v3/geocode/geo?address=&quot;</span><br><span class="line">    getstr += newname + &quot;&amp;&quot;</span><br><span class="line">    getstr += needbatch</span><br><span class="line">    getstr += &quot;key=mykey&quot; // mykey为申请的key</span><br><span class="line">    // console.log(&quot;getting : &quot;, newname)</span><br><span class="line"></span><br><span class="line">    // 包含有中文，转义</span><br><span class="line">    var target = encodeURI(getstr)</span><br><span class="line">    // console.log(target)</span><br><span class="line">    let userAgent = userAgents[parseInt(Math.random() * userAgents.length)];</span><br><span class="line">    superagent</span><br><span class="line">    .get(target)</span><br><span class="line">    .set(&#123;&#x27;User-Agent&#x27;: userAgent&#125;)</span><br><span class="line">    .end(function(error, response) &#123;</span><br><span class="line">        if (error == null) // 成功才处理，有时网络不好会请求失败</span><br><span class="line">        &#123;</span><br><span class="line">            var myHtml = response.text;</span><br><span class="line">            var ret = parseHtml(myHtml);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            console.log(&quot;get url failed: %s&quot;, error.errno)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="编码其它"><a href="#编码其它" class="headerlink" title="编码其它"></a>编码其它</h3><p>Makefile 知识总结：<br>一个工程目录中，既有需要编译成 so 所需的文件，又有测试所用的文件，为了方便测试、版本管理，即：so 文件不掺杂测试文件，测试程序使用所有文件编译（不额外调用 .so 函数），在编译时，使用 2 个 Makefile，其中，只编译 so 文件时，将不必要的文件过滤即可，示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SRCS1 := $(shell find $(SRC_DIRS) -maxdepth 2 -name &#x27;*.cpp&#x27; -or -name &#x27;*.c&#x27;)</span><br><span class="line"></span><br><span class="line">NONEEDFILES := ./test.cpp ./time_utils.c</span><br><span class="line">SRCS = $(filter-out $(NONEEDFILES), $(SRCS1))</span><br></pre></td></tr></table></figure><p>上述示例中，test.cpp 和 time_utils.c 是测试所用文件，使用 Makefile 提供的 filter-out 函数将其过滤掉。  </p><p>说明：将所有文件编译到 so 中也可以，但会多了不必要的函数和变量，也多了 main 函数，如果用 dlopen 方式打开，用 dlsym 查看函数的话，是没有影响的，但如将 so 也编译到测试程序中，则 main 会重复定义。  </p><h2 id="一般知识"><a href="#一般知识" class="headerlink" title="一般知识"></a>一般知识</h2><p>github 可以创建 README.md 文件，用于展示个人信息或风采，可参考：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/nate-lin/github-readme-stats</span><br></pre></td></tr></table></figure><p>github 的 person access tokens 似乎变化了，要重新生成。之前做好的自动化工作，不懂还要不能修改。  </p><h2 id="研发思考"><a href="#研发思考" class="headerlink" title="研发思考"></a>研发思考</h2><p>本月无。</p><h2 id="后续计划"><a href="#后续计划" class="headerlink" title="后续计划"></a>后续计划</h2><p>过年时一直在想知识共享平台的构建，稍研究了<code>hexo + wiki主题</code>，但始终觉得不太好用。主要用于公司内部的共享。需支持的功能：文档加密、pdf预览。  </p><h2 id="其它点滴"><a href="#其它点滴" class="headerlink" title="其它点滴"></a>其它点滴</h2><p>趁清明和“三月三”放假期间，抽了部分时间看了下前端的视频，查了些前端的框架。准备在工作上应用上。<br>大二立志不学 Java，要打破了，作为打工人，干就完了。<br>部门迁移，地方更远了，早上无法送大锤上幼儿园了。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前言：&lt;br&gt;上一篇类似的文章，是2011年的3月份，看了下当时写的内容，除了代码外，还有其它思考，但后面越来越少了，年纪大了，想的东西少，也没什么好写了，现在重拾起来，觉得十分有必要，可以将每个月的实践、思考记录下来，否则一年过去了，似乎什么也没有学到。  &lt;/p&gt;</summary>
    
    
    
    <category term="我的程序代码" scheme="http://www.latelee.org/category/my-library/"/>
    
    
    <category term="代码积累" scheme="http://www.latelee.org/tag/%E4%BB%A3%E7%A0%81%E7%A7%AF%E7%B4%AF/"/>
    
    <category term="知识总结" scheme="http://www.latelee.org/tag/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux cron示例</title>
    <link href="http://www.latelee.org/pkc/linux-cron-sample.html"/>
    <id>http://www.latelee.org/pkc/linux-cron-sample.html</id>
    <published>2021-04-27T16:00:00.000Z</published>
    <updated>2021-09-06T14:40:30.014Z</updated>
    
    <content type="html"><![CDATA[<p>记录、收集一些cron示例。  </p><span id="more"></span><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>ubuntu 16.04 测试。<br>编写脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /home/latelee/test/crontest.sh</span><br><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line">date &gt;&gt; /tmp/cronfile.txt</span><br></pre></td></tr></table></figure><p>执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure><p>选择vim，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0-59/1 * * * * /home/latelee/test/crontest.sh</span><br></pre></td></tr></table></figure><p>保存，提示<code>crontab: installing new crontab</code></p><p>/etc/init.d/cron restart</p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>时间格式如下：<br>f1 f2 f3 f4 f5 program  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期中的第几天。program 表示要执行的程序。</span><br><span class="line">当 f1 为 * 时表示每分钟都要执行 program，f2 为 * 时表示每小时都要执行程序，其馀类推</span><br><span class="line">当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行，f2 为 a-b 时表示从第 a 到第 b 小时都要执行，其馀类推</span><br><span class="line">当 f1 为 */n 时表示每 n 分钟个时间间隔执行一次，f2 为 */n 表示每 n 小时个时间间隔执行一次，其馀类推</span><br><span class="line">当 f1 为 a, b, c,... 时表示第 a, b, c,... 分钟要执行，f2 为 a, b, c,... 时表示第 a, b, c...个小时要执行，其馀类推</span><br><span class="line">*    *    *    *    *</span><br><span class="line">-    -    -    -    -</span><br><span class="line">|    |    |    |    |</span><br><span class="line">|    |    |    |    +----- 星期中星期几 (0 - 6) (星期天 为0)</span><br><span class="line">|    |    |    +---------- 月份 (1 - 12) </span><br><span class="line">|    |    +--------------- 一个月中的第几天 (1 - 31)</span><br><span class="line">|    +-------------------- 小时 (0 - 23)</span><br><span class="line">+------------------------- 分钟 (0 - 59)</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*/5 * * * * a.sh</span><br><span class="line">第一个表示分钟，第二个表示小时，第三个表示日期，第四个表示月份，第五个表示星期</span><br><span class="line">*表示所有,/5表示每5个单位，1-3从1到3，逗号表示离散的数字</span><br></pre></td></tr></table></figure><p>网络收集（不一定正确，验证时再修改）：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">每隔5分钟执行一次：*/5 * * * * cmd</span><br><span class="line">每隔5分钟执行一次  0 0/5 * * * cmd</span><br><span class="line">每隔1小时执行一次：0 */1 * * * cmd</span><br><span class="line"></span><br><span class="line">每天执行 0 0 * * * cmd</span><br><span class="line"></span><br><span class="line">每天23点执行一次：0 0 23 * * cmd</span><br><span class="line"></span><br><span class="line">每天凌晨1点执行一次：0 0 1 * * cmd</span><br><span class="line"></span><br><span class="line">每月1号凌晨1点执行一次：0 0 1 1 * cmd</span><br><span class="line"></span><br><span class="line">每月最后一天23点执行一次：0 0 23 L * cmd</span><br><span class="line"></span><br><span class="line">每周星期天凌晨1点实行一次：0 0 1 cmd * L</span><br><span class="line"></span><br><span class="line">在26分、29分、33分执行一次：0 26,29,33 * * * cmd</span><br><span class="line"></span><br><span class="line">每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 * * cmd</span><br><span class="line"></span><br><span class="line">表示每天00:01分执行一次my_test.sh脚本</span><br><span class="line">01 00 * * * /root/my_test.sh</span><br><span class="line"></span><br><span class="line">每隔一分钟，就做删除一个文件</span><br><span class="line">0-59/1 * * * * rm /root/a.txt</span><br><span class="line">每隔一分钟执行一个脚本</span><br><span class="line">0-59/1 * * * * /home/latelee/test/crontest.sh</span><br><span class="line"></span><br><span class="line">0 */2 * * * /sbin/service httpd restart  意思是每两个小时重启一次apache </span><br><span class="line"></span><br><span class="line">50 7 * * * /sbin/service sshd start  意思是每天7：50开启ssh服务 </span><br><span class="line"></span><br><span class="line">50 22 * * * /sbin/service sshd stop  意思是每天22：50关闭ssh服务 </span><br><span class="line"></span><br><span class="line">0 0 1,15 * * fsck /home  每月1号和15号检查/home 磁盘 </span><br><span class="line"></span><br><span class="line">1 * * * * /home/bruce/backup  每小时的第一分执行 /home/bruce/backup这个文件 </span><br><span class="line"></span><br><span class="line">00 03 * * 1-5 find /home &quot;*.xxx&quot; -mtime +4 -exec rm &#123;&#125; \;  每周一至周五3点钟，在目录/home中，查找文件名为*.xxx的文件，并删除4天前的文件。</span><br><span class="line"></span><br><span class="line">30 6 */10 * * ls  意思是每月的1、11、21、31日的6：30执行一次ls命令</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">crontab每分钟定时执行：</span><br><span class="line">*/1 * * * * service mysqld restart //每隔1分钟执行一次</span><br><span class="line">*/10 * * * * service mysqld restart //每隔10分钟执行一次</span><br><span class="line"></span><br><span class="line">crontab每小时定时执行：</span><br><span class="line">0 */1 * * * service mysqld restart //每1小时执行一次</span><br><span class="line">0 */2 * * * service mysqld restart //每2小时执行一次</span><br><span class="line"></span><br><span class="line">crontab每天定时执行：</span><br><span class="line">0 10 * * * service mysqld restart //每天10点执行</span><br><span class="line">30 19 * * * service mysqld restart //每天19点30分执行</span><br><span class="line"></span><br><span class="line">crontab每周定时执行：</span><br><span class="line">0 10 * * 1 service mysqld restart //每周一10点执行</span><br><span class="line">30 17 * * 5 service mysqld restart //每周五17点30分执行</span><br><span class="line"></span><br><span class="line">crontab每年定时执行：</span><br><span class="line">0 10 1 10 * service mysqld restart //每年的10月1日10点执行</span><br><span class="line">0 20 8 8 * service mysqld restart //每年的8月8日20点执行</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录、收集一些cron示例。  &lt;/p&gt;</summary>
    
    
    
    <category term="个人知识中心" scheme="http://www.latelee.org/category/pkc/"/>
    
    
    <category term="Linux使用" scheme="http://www.latelee.org/tag/Linux%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>nvidia TX2 CUDA yolov5环境搭建</title>
    <link href="http://www.latelee.org/ml/nvidia-building-yolov5-for-tx2.html"/>
    <id>http://www.latelee.org/ml/nvidia-building-yolov5-for-tx2.html</id>
    <published>2021-03-10T16:00:00.000Z</published>
    <updated>2021-09-06T14:40:29.998Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录笔者在 nvidia TX2 系统上搭建 yolov5 环境的过程。<br>注意说明的是，本文在文后的文章基础上进行实践，根据自己的经历进行描述和补充。由于能力有限，对本文涉及的知识和相关问题无法回答。<br>本文不涉及 yolo 深度学习方面的内容。  </p><span id="more"></span><p><img src="/ml/nvidia-building-yolov5-for-tx2/1.png" alt="图1">  </p><h2 id="一、要点"><a href="#一、要点" class="headerlink" title="一、要点"></a>一、要点</h2><p>本节对本文进行技术小结。   </p><ul><li>TX2 刷机后，PYthon版本为 3.7.1。  </li><li>保持T X2 联网，因为需要下载。  </li><li>conda 创建环境，命令行前会有环境名称的提示。  </li><li>文后的尝试及记录，建议看看。  </li></ul><h2 id="二、过程"><a href="#二、过程" class="headerlink" title="二、过程"></a>二、过程</h2><h3 id="准备工程源码"><a href="#准备工程源码" class="headerlink" title="准备工程源码"></a>准备工程源码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /opt/nvidia/deepstream/yolo</span><br><span class="line">cd /opt/nvidia/deepstream/yolo</span><br><span class="line">git clone https://github.com/DanaHan/Yolov5-in-Deepstream-5.0.git</span><br><span class="line">git clone https://github.com/wang-xinyu/tensorrtx.git</span><br><span class="line">git clone https://github.com/ultralytics/yolov5.git</span><br></pre></td></tr></table></figure><h3 id="安装-conda"><a href="#安装-conda" class="headerlink" title="安装 conda"></a>安装 conda</h3><p>如无 conda，则安装之。到 <a href="https://github.com/Archiconda/build-tools/releases">https://github.com/Archiconda/build-tools/releases</a> 下载。本文所用安装脚本为 Archiconda3-0.2.3-Linux-aarch64.sh 。下载到系统，再安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chmod +x Archiconda3-0.2.3-Linux-aarch64.sh</span><br><span class="line"></span><br><span class="line">./Archiconda3-0.2.3-Linux-aarch64.sh</span><br><span class="line"></span><br><span class="line">source ~/tx/.bashrc</span><br></pre></td></tr></table></figure><h3 id="创建-conda-环境"><a href="#创建-conda-环境" class="headerlink" title="创建 conda 环境"></a>创建 conda 环境</h3><p>使用如下命令创建名为 yolov5 的 conda 环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ conda create -n yolov5 python</span><br></pre></td></tr></table></figure><p>此过程需要手动输入 y 以安装软件包。安装时长取决于联网速度。  </p><p>成功后，输入<code>conda activate yolov5</code>激活，使用<code>conda deactivate</code>退出。过程日志信息详见文后附录。<br>进入 conda 环境后，命令行前有环境名称 yolov5，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(yolov5) tx@tx-desktop:/opt/nvidia/deepstream/yolo$ </span><br></pre></td></tr></table></figure><h3 id="安装-yolo-依赖库"><a href="#安装-yolo-依赖库" class="headerlink" title="安装 yolo 依赖库"></a>安装 yolo 依赖库</h3><p>切换分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/nvidia/deepstream/yolo/yolov5</span><br><span class="line">git checkout -b v4.0 v4.0</span><br></pre></td></tr></table></figure><p>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install scikit-build</span><br><span class="line">pip install -r requirements.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行后命令，提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Could not find a version that satisfies the requirement torchvision&gt;=0.8.1</span><br><span class="line">ERROR: No matching distribution found for torchvision&gt;=0.8.1</span><br></pre></td></tr></table></figure><p>安装 torchvision：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install torchvision -c pytorch</span><br></pre></td></tr></table></figure><p>在实践中发现该命令无法从官方途径安装。故从源码安装。<br>到 <a href="https://github.com/pytorch/vision/releases">https://github.com/pytorch/vision/releases</a> 下载源码压缩包，本文所用版本 v0.9.0，下载，并安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar xf vision-0.9.0.tar.gz</span><br><span class="line">cd vision-0.9.0</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><p>安装过程可能提示没有 torch 模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ModuleNotFoundError: No module named &#x27;torch&#x27;</span><br></pre></td></tr></table></figure><p>安装之：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install torch</span><br></pre></td></tr></table></figure><p>torchvision编译需要等待一段时间。  </p><p>依赖包安装完成后提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Successfully installed Cython-0.29.22 PyYAML-5.4.1 absl-py-0.12.0 cachetools-4.2.1 chardet-4.0.0 cycler-0.10.0 google-auth-1.27.1 google-auth-oauthlib-0.4.3 grpcio-1.36.1 idna-2.10 kiwisolver-1.3.1 markdown-3.3.4 matplotlib-3.3.4 oauthlib-3.1.0 opencv-python-4.5.1.48 pandas-1.2.3 protobuf-3.15.6 pyasn1-0.4.8 pyasn1-modules-0.2.8 pycocotools-2.0.2 python-dateutil-2.8.1 pytz-2021.1 requests-2.25.1 requests-oauthlib-1.3.0 rsa-4.7.2 scipy-1.6.1 seaborn-0.11.1 six-1.15.0 tensorboard-2.4.1 tensorboard-plugin-wit-1.8.0 thop-0.0.31.post2005241907 tqdm-4.59.0 urllib3-1.26.3 werkzeug-1.0.1</span><br></pre></td></tr></table></figure><p>在yolov5目录下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/nvidia/deepstream/yolo/yolov5</span><br></pre></td></tr></table></figure><p>下载模型文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash weights/download_weights.sh</span><br></pre></td></tr></table></figure><p>默认下载到yolov5目录，有文件：<code>yolov5l.pt yolov5m.pt yolov5s.pt yolov5x.pt</code>。可根据实际情况选，本文使用默认值，即<code>yolov5s.pt</code>文件。拷贝到 weights 目录。  </p><p>继续在 yolov5 目录下，拷贝 gen_wts.py。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ../tensorrtx/yolov5/gen_wts.py ./</span><br></pre></td></tr></table></figure><p>注意，可修改 gen_wts.py 文件，主要修改<code>&#39;weights/yolov5x.pt&#39; &#39;yolov5x.wts&#39;</code>名称。  </p><p>生成wts文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python gen_wts.py </span><br></pre></td></tr></table></figure><p>最终生成文件：yolov5x.wts。将其拷贝到 Yolov5-in-Deepstream-5.0 目录，并切换到该目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp yolov5s.wts ../Yolov5-in-Deepstream-5.0</span><br><span class="line">cd ../Yolov5-in-Deepstream-5.0</span><br></pre></td></tr></table></figure><p>根据实际情况，修改 yolov5.cpp 文件，将 NET 宏改成自己对应的模型。本文使用默认值 s，无须改动。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define NET s  // s m l x</span><br></pre></td></tr></table></figure><p>编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>生成 yolov5 文件，后面将用该文件生成模型和测试。  </p><p>生成engine文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./yolov5 -s</span><br></pre></td></tr></table></figure><p>注意：程序使用了../yolov5x.wts，所以 yolov5x.wts 要拷贝 Yolov5-in-Deepstream-5.0 目录。成功输出如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$sudo ./yolov5 -s</span><br><span class="line">Loading weights: ../yolov5s.wts</span><br><span class="line">Building engine, please wait for a while...</span><br><span class="line">Build engine successfully!</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir ../samples</span><br></pre></td></tr></table></figure><p>从网上下载两张 coco 数据集图片，放到 samples 上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./yolov5 -d  ../samples</span><br></pre></td></tr></table></figure><p>在build可看到有图片文件生成，且标注了，说明成功。  </p><p>将 libmyplugins.so yolov5s.engine 拷贝到 Deepstream 5.0 目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp yolov5x.engine ../Deepstream\ 5.0/</span><br><span class="line">cp libmyplugins.so ../Deepstream\ 5.0/</span><br></pre></td></tr></table></figure><h2 id="Deepstream-测试"><a href="#Deepstream-测试" class="headerlink" title="Deepstream 测试"></a>Deepstream 测试</h2><p>在 Yolov5-in-Deepstream-5.0\Deepstream 5.0\nvdsinfer_custom_impl_Yolo 目录执行<code>make</code>，生成<code>libnvdsinfer_custom_impl_Yolo.so</code>文件。进入 Yolov5-in-Deepstream-5.0\Deepstream 5.0 目录中，修改 config_infer_primary_yoloV5.tx 文件。主要修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model-engine-file=yolov5s.engine --&gt; model-engine-file=yolov5x.engine</span><br><span class="line"></span><br><span class="line">custom-lib-path=objectDetector_Yolo_V5/nvdsinfer_custom_impl_Yolo/libnvdsinfer_custom_impl_Yolo.so --&gt; custom-lib-path=nvdsinfer_custom_impl_Yolo/libnvdsinfer_custom_impl_Yolo.so</span><br></pre></td></tr></table></figure><p>将 DeepStream 的 label.txt 拷贝到当前目录。修改 deepstream_app_config_yoloV5.txt 文件的视频地址。使用官方 deepstream-app 程序测试，执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD_PRELOAD=./libmyplugins.so deepstream-app -c deepstream_app_config_yoloV5.txt</span><br></pre></td></tr></table></figure><p>可得到识别的结果。  </p><h2 id="三、参考资源"><a href="#三、参考资源" class="headerlink" title="三、参考资源"></a>三、参考资源</h2><p>DeepStream5.0系列之yolov5使用： <a href="https://blog.csdn.net/zong596568821xp/article/details/109444343">https://blog.csdn.net/zong596568821xp/article/details/109444343</a><br>pytorch源码：<a href="https://github.com/pytorch/vision/releases">https://github.com/pytorch/vision/releases</a>    </p><h2 id="附1：尝试"><a href="#附1：尝试" class="headerlink" title="附1：尝试"></a>附1：尝试</h2><h3 id="一般错误"><a href="#一般错误" class="headerlink" title="一般错误"></a>一般错误</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ModuleNotFoundError: No module named &#x27;Cython&#x27;</span><br><span class="line">--&gt; python3.7 -m pip install cython</span><br><span class="line"></span><br><span class="line">Could not find a version that satisfies the requirement cmake</span><br><span class="line"></span><br><span class="line">--&gt; python3.7 -m pip install cmake</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="torchvision"><a href="#torchvision" class="headerlink" title="torchvision"></a>torchvision</h3><p>找不到 torchvision 模块提示如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Could not find a version that satisfies the requirement torchvision&gt;=0.8.1</span><br><span class="line">ERROR: No matching distribution found for torchvision&gt;=0.8.1</span><br></pre></td></tr></table></figure><p>选按通用安装方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3.7 -m pip install torchvision </span><br></pre></td></tr></table></figure><p>但错误提示依旧。按网上说法使用如下命令安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install torchvision==0.8.1 -f https://download.pytorch.org/whl/torch_stable.html</span><br></pre></td></tr></table></figure><p>但依然失败。再用<a href="https://pypi.org/project/torchvision/">官方</a> 提供的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install torchvision -c pytorch</span><br></pre></td></tr></table></figure><p>还是失败。究其原因，可能是没有 aarch64 版本的缘故。所以用源码安装。  </p><h3 id><a href="#" class="headerlink" title></a></h3><p>生成 egine 文件时提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Loading weights: ../yolov5x.wts</span><br><span class="line">[03/10/2021-01:00:59] [E] [TRT] (Unnamed Layer* 14) [Convolution]: kernel weights has count 0 but 12800 was expected</span><br><span class="line">[03/10/2021-01:00:59] [E] [TRT] (Unnamed Layer* 14) [Convolution]: count of 0 weights in kernel, but kernel dimensions (1,1) with 160 input channels, 80 output channels and 1 groups were specified. Expected Weights count is 160 * 1*1 * 80 / 1 = 12800</span><br><span class="line">[03/10/2021-01:00:59] [E] [TRT] Parameter check failed at: ../builder/Network.cpp::addScale::482, condition: shift.count &gt; 0 ? (shift.values != nullptr) : (shift.values == nullptr)</span><br><span class="line">yolov5: /opt/nvidia/deepstream/yolo-in-Deepstream-5.0/common.hpp:190: nvinfer1::IScaleLayer* addBatchNorm2d(nvinfer1::INetworkDefinition*, std::map&lt;std::__cxx11::basic_string&lt;char&gt;, nvinfer1::Weights&gt;&amp;, nvinfer1::ITensor&amp;, std::__cxx11::string, float): Assertion `scale_1&#x27; failed.</span><br><span class="line">Aborted</span><br></pre></td></tr></table></figure><p>原因是使用 yolov5x 版本，改为默认的 yolov5s 不再出现。<br>使用 yolov5s.wts  在 AGX Xavier 平台上出现的错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> sudo ./yolov5 -s</span><br><span class="line">Loading weights: ../yolov5s.wts</span><br><span class="line">[03/12/2021-16:06:07] [E] [TRT] (Unnamed Layer* 14) [Convolution]: kernel weights has count 0 but 2048 was expected</span><br><span class="line">[03/12/2021-16:06:07] [E] [TRT] (Unnamed Layer* 14) [Convolution]: count of 0 weights in kernel, but kernel dimensions (1,1) with 64 input channels, 32 output channels and 1 groups were specified. Expected Weights count is 64 * 1*1 * 32 / 1 = 2048</span><br><span class="line">[03/12/2021-16:06:07] [E] [TRT] Parameter check failed at: ../builder/Network.cpp::addScale::482, condition: shift.count &gt; 0 ? (shift.values != nullptr) : (shift.values == nullptr)</span><br><span class="line">yolov5: /opt/nvidia/deepstream/yolo/Yolov5-in-Deepstream-5.0/common.hpp:190: nvinfer1::IScaleLayer* addBatchNorm2d(nvinfer1::INetworkDefinition*, std::map&lt;std::__cxx11::basic_string&lt;char&gt;, nvinfer1::Weights&gt;&amp;, nvinfer1::ITensor&amp;, std::__cxx11::string, float): Assertion `scale_1&#x27; failed.</span><br><span class="line">Aborted</span><br></pre></td></tr></table></figure><p>使用不同平台的 engine 文件的错误(TX2生成，AGX Xavier运行）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ./yolov5 -d  ../samples</span><br><span class="line">[03/12/2021-16:12:13] [E] [TRT] INVALID_CONFIG: The engine plan file is generated on an incompatible device, expecting compute 7.2 got compute 6.2, please rebuild.</span><br><span class="line">[03/12/2021-16:12:13] [E] [TRT] engine.cpp (1546) - Serialization Error in deserialize: 0 (Core engine deserialization failure)</span><br><span class="line">[03/12/2021-16:12:13] [E] [TRT] INVALID_STATE: std::exception</span><br><span class="line">[03/12/2021-16:12:13] [E] [TRT] INVALID_CONFIG: Deserialize the cuda engine failed.</span><br><span class="line">yolov5: /opt/nvidia/deepstream/yolo/Yolov5-in-Deepstream-5.0/yolov5.cpp:534: int main(int, char**): Assertion `engine != nullptr&#x27; failed.</span><br><span class="line">Aborted</span><br></pre></td></tr></table></figure><p>测试时，如果 samples 目录存在非图片时，会提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">740ms</span><br><span class="line">terminate called after throwing an instance of &#x27;cv::Exception&#x27;</span><br><span class="line">  what():  OpenCV(4.1.1) /home/nvidia/host/build_opencv/nv_opencv/modules/imgcodecs/src/loadsave.cpp:662: error: (-2:Unspecified error) could not find a writer for the specified extension in function &#x27;imwrite_&#x27;</span><br></pre></td></tr></table></figure><p>解决：图片后缀需正确，如jpg、png。</p><h3 id="创建-yolo-环境输出日志"><a href="#创建-yolo-环境输出日志" class="headerlink" title="创建 yolo 环境输出日志"></a>创建 yolo 环境输出日志</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">$ conda create -n yolov5 python</span><br><span class="line">Solving environment: done</span><br><span class="line"></span><br><span class="line">## Package Plan ##</span><br><span class="line"></span><br><span class="line">  environment location: /home/tx/archiconda3/envs/yolov5</span><br><span class="line"></span><br><span class="line">  added / updated specs: </span><br><span class="line">    - python</span><br><span class="line"></span><br><span class="line">The following packages will be downloaded:</span><br><span class="line"></span><br><span class="line">    package                    |            build</span><br><span class="line">    ---------------------------|-----------------</span><br><span class="line">    zlib-1.2.11                |       h7b6447c_2         118 KB  c4aarch64</span><br><span class="line">    openssl-1.0.2p             |       h7b6447c_0         3.1 MB  c4aarch64</span><br><span class="line">    sqlite-3.25.2              |       h7ce4240_0         2.2 MB  c4aarch64</span><br><span class="line">    readline-7.0               |       h7ce4240_5         440 KB  c4aarch64</span><br><span class="line">    pip-10.0.1                 |           py37_0         1.7 MB  c4aarch64</span><br><span class="line">    wheel-0.32.1               |           py37_0          34 KB  c4aarch64</span><br><span class="line">    libgcc-ng-7.3.0            |       h5c90dd9_0         5.9 MB  c4aarch64</span><br><span class="line">    libstdcxx-ng-7.3.0         |       h5c90dd9_0         2.5 MB  c4aarch64</span><br><span class="line">    setuptools-40.4.3          |           py37_0         601 KB  c4aarch64</span><br><span class="line">    xz-5.2.4                   |       h7ce4240_4         345 KB  c4aarch64</span><br><span class="line">    certifi-2018.10.15         |           py37_0         137 KB  c4aarch64</span><br><span class="line">    ncurses-6.1                |       h71b71f5_0         1.0 MB  c4aarch64</span><br><span class="line">    tk-8.6.8                   |       hbc83047_0         3.2 MB  c4aarch64</span><br><span class="line">    ca-certificates-2018.03.07 |                0         123 KB  c4aarch64</span><br><span class="line">    python-3.7.2               |       he90a169_0        36.1 MB  c4aarch64</span><br><span class="line">    libffi-3.2.1               |       h71b71f5_5          51 KB  c4aarch64</span><br><span class="line">    libedit-3.1.20170329       |       hc058e9b_2         188 KB  c4aarch64</span><br><span class="line">    ------------------------------------------------------------</span><br><span class="line">                                           Total:        57.8 MB</span><br><span class="line"></span><br><span class="line">The following NEW packages will be INSTALLED:</span><br><span class="line"></span><br><span class="line">    ca-certificates: 2018.03.07-0            c4aarch64</span><br><span class="line">    certifi:         2018.10.15-py37_0       c4aarch64</span><br><span class="line">    libedit:         3.1.20170329-hc058e9b_2 c4aarch64</span><br><span class="line">    libffi:          3.2.1-h71b71f5_5        c4aarch64</span><br><span class="line">    libgcc-ng:       7.3.0-h5c90dd9_0        c4aarch64</span><br><span class="line">    libstdcxx-ng:    7.3.0-h5c90dd9_0        c4aarch64</span><br><span class="line">    ncurses:         6.1-h71b71f5_0          c4aarch64</span><br><span class="line">    openssl:         1.0.2p-h7b6447c_0       c4aarch64</span><br><span class="line">    pip:             10.0.1-py37_0           c4aarch64</span><br><span class="line">    python:          3.7.2-he90a169_0        c4aarch64</span><br><span class="line">    readline:        7.0-h7ce4240_5          c4aarch64</span><br><span class="line">    setuptools:      40.4.3-py37_0           c4aarch64</span><br><span class="line">    sqlite:          3.25.2-h7ce4240_0       c4aarch64</span><br><span class="line">    tk:              8.6.8-hbc83047_0        c4aarch64</span><br><span class="line">    wheel:           0.32.1-py37_0           c4aarch64</span><br><span class="line">    xz:              5.2.4-h7ce4240_4        c4aarch64</span><br><span class="line">    zlib:            1.2.11-h7b6447c_2       c4aarch64</span><br><span class="line"></span><br><span class="line">Proceed ([y]/n)? y</span><br><span class="line"></span><br><span class="line">Preparing transaction: done</span><br><span class="line">Verifying transaction: done</span><br><span class="line">Executing transaction: done</span><br><span class="line">#</span><br><span class="line"># To activate this environment, use</span><br><span class="line">#</span><br><span class="line">#     $ conda activate yolov5</span><br><span class="line">#</span><br><span class="line"># To deactivate an active environment, use</span><br><span class="line">#</span><br><span class="line">#     $ conda deactivate</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="附2：成果"><a href="#附2：成果" class="headerlink" title="附2：成果"></a>附2：成果</h2><p>1、文中涉及的软件包只在 TX2 测试通过，已整合为 aarch64 系统的 docker 镜像，并上传至阿里云仓库备份。<br>Dockerfile：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM busybox </span><br><span class="line">RUN mkdir /yolotools  </span><br><span class="line">COPY vision-0.9.0.tar.gz  /yolotools</span><br><span class="line">COPY yolo.tar.bz2  /yolotools</span><br><span class="line">COPY Archiconda3-0.2.3-Linux-aarch64.sh  /yolotools</span><br></pre></td></tr></table></figure><p>创建并上传：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t registry.cn-hangzhou.aliyuncs.com/latelee/yoloenv:aarch64 .</span><br><span class="line">docker push registry.cn-hangzhou.aliyuncs.com/latelee/yoloenv:aarch64</span><br></pre></td></tr></table></figure><p>镜像说明：yolo.tar.bz2包含了本文的工程源码。运行后查看容器的 <code>/yolotools</code> 目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name foobar registry.cn-hangzhou.aliyuncs.com/latelee/yoloenv:aarch64 sh</span><br><span class="line">docker exec -it foobar ls /yolotools</span><br></pre></td></tr></table></figure><p>在宿主机拷贝文件出来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir tools</span><br><span class="line">docker cp foobar:/yolotools/vision-0.9.0.tar.gz tools</span><br><span class="line">docker cp foobar:/yolotools/yolo.tar.bz2 tools</span><br><span class="line">docker cp foobar:/yolotools/Archiconda3-0.2.3-Linux-aarch64.sh tools</span><br></pre></td></tr></table></figure><h2 id="再附"><a href="#再附" class="headerlink" title="再附"></a>再附</h2><p>一段时间来，github 和 gitlab 官方经常打不开，在访问网站上较耗时。不知何故。  </p><p>李迟 2021.3.12 周五</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文记录笔者在 nvidia TX2 系统上搭建 yolov5 环境的过程。&lt;br&gt;注意说明的是，本文在文后的文章基础上进行实践，根据自己的经历进行描述和补充。由于能力有限，对本文涉及的知识和相关问题无法回答。&lt;br&gt;本文不涉及 yolo 深度学习方面的内容。  &lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://www.latelee.org/category/ml/"/>
    
    
  </entry>
  
  <entry>
    <title>软考路：高项4流水账</title>
    <link href="http://www.latelee.org/code-life/ruankao-pm4.html"/>
    <id>http://www.latelee.org/code-life/ruankao-pm4.html</id>
    <published>2021-03-08T15:00:00.000Z</published>
    <updated>2021-09-06T14:40:30.098Z</updated>
    
    <content type="html"><![CDATA[<p>高项证书已经拿到手了，没有想象中那样高兴，没有请客吃饭，没有做顿大餐犒劳自己，没有人分享喜悦，只有大锤看着证书上的照片，认得是爸爸。周边通过的同事已经把证书提交给公司了，我也将其束之高阁，与旧的证书、毕业证书、四六级成绩单放一起，顺便记录一下跨越大半年的流水账，把此事了了。    </p><span id="more"></span><h2 id="考证之我见"><a href="#考证之我见" class="headerlink" title="考证之我见"></a>考证之我见</h2><p>是否考证，每个人的态度和观念是不同的（这是废话）。笔者个人是会考的，但会有取舍。<br>1、就笔者所学专业而言，是会软考（虽然目前没有什么用）。如一建，消防这类，虽说得钱多，但能力有限，暂不考虑。<br>2、笔者今年 35 了，考一考，试一试，看看自己能力，促进技术学习。——笔者至今还是一名编码工人且不知写到何时。<br>3、家里有娃，看书做笔记，能给娃一个榜样，间中去趟图书馆，让娃也陶冶情操，也是不错的。<br>4、笔者所在单位正式员工高级证书有补贴。证书是资格，可用于评职称（高级证书可作为高工的一个条件），笔者所在单位正式员工评上工程师会聘用。<br>5、证书目前没有任何作用，但不妨碍我去考。学不学是个人能控制的，补不补是公司的事，个人控制不了。种下了因，能不能得果，还要看缘。    </p><h2 id="备考"><a href="#备考" class="headerlink" title="备考"></a>备考</h2><p>2020.7月中下旬<br>调研、思考、决策。最后决定报考高项。  </p><p>2020.8.3<br>报名缴费 204 元。  </p><p>2020.8/9/10/<br>上班、带娃、做家务、备考。  </p><p>2020.11.1<br>打印准考证。<br><img src="/code-life/ruankao-pm4/1.jpg">  </p><p>2020.11.7 周六<br>考试。<br><img src="/code-life/ruankao-pm4/2.jpg">  </p><h2 id="考后"><a href="#考后" class="headerlink" title="考后"></a>考后</h2><p>2020.12.18<br>查成绩。上午分数符合猜测。论文45分。<br><img src="/code-life/ruankao-pm4/3.png">  </p><p>2021.1.8<br>人社部公布分数线，与往年保持一致。45分及格。<br><img src="/code-life/ruankao-pm4/4.png">  </p><p>2021.1.23<br>可在人事考试中心查证书。<br><a href="http://zs.cpta.com.cn/certMng/loginPage.jsp">http://zs.cpta.com.cn/certMng/loginPage.jsp</a><br><a href="http://zscx.gxpta.com.cn/">http://zscx.gxpta.com.cn/</a>  </p><p>2021.2.8<br>可领取证书<br>公告文件：<a href="http://www.gxpta.com.cn/contents/835/7292.html">http://www.gxpta.com.cn/contents/835/7292.html</a>  </p><p><img src="/code-life/ruankao-pm4/5.png">  </p><p>2021.2.9<br>去领证书（农历廿八）。<br><img src="/code-life/ruankao-pm4/6.png">  </p><p><img src="/code-life/ruankao-pm4/7.png">  </p><p>2021.2.19<br>咨询公司人事，回复外包人员未有相关补贴事宜。  </p><p>2021.3.4<br>调查相关补贴政策。<br><a href="http://www.mohrss.gov.cn/sybxs/SYBXSzhengcewenjian/SYBXSdingfangzhengce/201908/t20190813_329426.html">http://www.mohrss.gov.cn/sybxs/SYBXSzhengcewenjian/SYBXSdingfangzhengce/201908/t20190813_329426.html</a><br><a href="https://ggfw.nn12333.com:8081/nnmh/knode/3053">https://ggfw.nn12333.com:8081/nnmh/knode/3053</a>  </p><p>某机构网站介绍广西有补贴政策：  </p><p><img src="/code-life/ruankao-pm4/8.png">  </p><p><img src="/code-life/ruankao-pm4/9.png">  </p><p>2021.3.5<br>办理<br><img src="/code-life/ruankao-pm4/10.png">  </p><p>2021.3.8<br>收到反馈结果：不在政策范围内。<br><img src="/code-life/ruankao-pm4/11.png">  </p><p>李迟 2021.3.15 </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;高项证书已经拿到手了，没有想象中那样高兴，没有请客吃饭，没有做顿大餐犒劳自己，没有人分享喜悦，只有大锤看着证书上的照片，认得是爸爸。周边通过的同事已经把证书提交给公司了，我也将其束之高阁，与旧的证书、毕业证书、四六级成绩单放一起，顺便记录一下跨越大半年的流水账，把此事了了。    &lt;/p&gt;</summary>
    
    
    
    <category term="代码生活" scheme="http://www.latelee.org/category/code-life/"/>
    
    
    <category term="考证" scheme="http://www.latelee.org/tag/%E8%80%83%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>我的docker随笔31：oracle数据库再次部署</title>
    <link href="http://www.latelee.org/docker/docker-31-deploy-oracle-again.html"/>
    <id>http://www.latelee.org/docker/docker-31-deploy-oracle-again.html</id>
    <published>2021-02-25T17:00:00.000Z</published>
    <updated>2021-09-06T14:40:30.082Z</updated>
    
    <content type="html"><![CDATA[<p>本文涉及一种在容器中部署 oracle 数据库的方法。经验证，可达到预期目标，并能应用在实际工作中。    </p><span id="more"></span><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>去年曾经部署过 oracle，当时使用阿里云仓库上的镜像，版本为 11.2， 但一直解决不了永久存储问题，后因其它工作的事没有继续。过年期间到现在，内网（人为地）一直断开，无法访问数据库，对工作造成一定的影响，所以有必要    完成此事。<br>oracle 官方有创建 docker 的说明（可能是 docker 官方），本文即根据文档进行实践。<br>本文着重实践性，且必须与生产数据库版本、表名尽量保持一致。  </p><h2 id="技术小结"><a href="#技术小结" class="headerlink" title="技术小结"></a>技术小结</h2><ul><li>宿主机挂载的目录必须能让 uid 为 54321 的用户读写。可创建该 uid 的用户，也可直接设置权限为777。  </li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>根据在 github 仓库的 <a href="https://github.com/oracle/docker-images/tree/main/OracleDatabase/SingleInstance">安装说明文档</a> 进行操作。  </p><p>仓库没有提供 oracle 软件（可能是因为太大了），具体的软件下载可访问<a href="https://www.oracle.com/database/technologies/oracle-database-software-downloads.html">此页面</a> ，本文所用版本为 Linux x86-64 ，名称为 LINUX.X64_193000_db_home.zip ，大小为 2.8GB，md5 为 1858bd0d281c60f4ddabd87b1c214a4f。注意，下载需要登录，先进行注册（注册也花了一定时间）。  </p><p>按官方说法需将软件压缩包重命名为：linuxx64_19.3.0_database.zip ，但实际并不需要。将 LINUX.X64_193000_db_home.zip 拷贝到 docker-images/OracleDatabase/SingleInstance/dockerfiles/19.3.0 目录。  </p><h3 id="修改为非CDB方式"><a href="#修改为非CDB方式" class="headerlink" title="修改为非CDB方式"></a>修改为非CDB方式</h3><p>自 12 版本后，默认使用非CDB方式（这个机制暂未研究）。<br>修改文件所有目录：docker-images/OracleDatabase/SingleInstance/dockerfiles/19.3.0。<br>修改文件 dbca.rsp.tmpl：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">createAsContainerDatabase=false</span><br><span class="line">numberOfPDBs=0</span><br><span class="line">## 注释掉</span><br><span class="line">#pdbName=###ORACLE_PDB###</span><br><span class="line">#pdbAdminPassword=###ORACLE_PWD###</span><br><span class="line"></span><br><span class="line"># em关掉</span><br><span class="line">emConfiguration=NONE</span><br></pre></td></tr></table></figure><p>修改文件 createDB.sh 如下语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER PLUGGABLE DATABASE $ORACLE_PDB SAVE STATE;</span><br><span class="line">EXEC DBMS_XDB_CONFIG.SETGLOBALPORTENABLED (TRUE);</span><br></pre></td></tr></table></figure><p>修改文件 checkDBStatus.sh：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v\\$pdbs</span><br><span class="line">改为</span><br><span class="line">v\\$database</span><br></pre></td></tr></table></figure><h3 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h3><p>进入docker-images/OracleDatabase/SingleInstance/dockerfiles 目录，执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./buildContainerImage.sh -e -i -v 19.3.0</span><br></pre></td></tr></table></figure><p>注：-i表示不校验md5（如检验md5提示某文件找不到，故自行检验）。<br>双核4G虚拟机，耗时约40分钟。20核64G服务器耗时约12分钟。  </p><p>打标签并提交阿里云仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag oracle/database:19.3.0-ee registry.cn-hangzhou.aliyuncs.com/latelee/database:19.3.0-ee</span><br><span class="line">docker push registry.cn-hangzhou.aliyuncs.com/latelee/database:19.3.0-ee</span><br></pre></td></tr></table></figure><h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3><p>官方示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run --name &lt;container name&gt; \</span><br><span class="line">-p &lt;host port&gt;:1521 -p &lt;host port&gt;:5500 \</span><br><span class="line">-e ORACLE_SID=&lt;your SID&gt; \</span><br><span class="line">-e ORACLE_PDB=&lt;your PDB name&gt; \</span><br><span class="line">-e ORACLE_PWD=&lt;your database passwords&gt; \</span><br><span class="line">-e INIT_SGA_SIZE=&lt;your database SGA memory in MB&gt; \</span><br><span class="line">-e INIT_PGA_SIZE=&lt;your database PGA memory in MB&gt; \</span><br><span class="line">-e ORACLE_EDITION=&lt;your database edition&gt; \</span><br><span class="line">-e ORACLE_CHARACTERSET=&lt;your character set&gt; \</span><br><span class="line">-v [&lt;host mount point&gt;:]/opt/oracle/oradata \</span><br><span class="line">oracle/database:19.3.0-ee</span><br></pre></td></tr></table></figure><p>说明：<br>挂载 /opt/oracle/oradata 的目录必须可以由 uid 为 54321 的用户（该用户为容器oracle的 uid）访问，否则容器无法创建目录。实际中，挂载目录权限更改为 777 。<br>变量及默认值：<br>ORACLE_SID ORCLCDB<br>ORACLE_PDB ORCLPDB1<br>ORACLE_PWD 自动随机产生<br>ORACLE_CHARACTERSET AL32UTF8<br>实际：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd \</span><br><span class="line">--name oracle \</span><br><span class="line">-p 1521:1521 \</span><br><span class="line">-e ORACLE_SID=ORCLCDB \</span><br><span class="line">-e ORACLE_PDB=ORCLPDB1 \</span><br><span class="line">-e ORACLE_PWD=123456 \</span><br><span class="line">-e ORACLE_CHARACTERSET=ZHS16GBK \</span><br><span class="line">-e TZ=&quot;Asia/Shanghai&quot; \</span><br><span class="line">-v oracledata:/opt/oracle/oradata \</span><br><span class="line">oracle/database:19.3.0-ee</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">最简单的，无任何功能</span><br><span class="line">docker run -it --rm --name oracle registry.cn-hangzhou.aliyuncs.com/latelee/database:19.3.0-ee bash</span><br><span class="line"></span><br><span class="line">加时区的测试：</span><br><span class="line">docker run -it --rm --name oracle -e TZ=&quot;Asia/Shanghai&quot; registry.cn-hangzhou.aliyuncs.com/latelee/database:19.3.0-ee bash</span><br></pre></td></tr></table></figure><p>实际中使用 docker-compose 启动，docker-compose.yml 文件如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;2&#x27;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  lloracle:</span><br><span class="line">    image: registry.cn-hangzhou.aliyuncs.com/latelee/database:19.3.0-ee</span><br><span class="line">    container_name: lloracle</span><br><span class="line">    shm_size: 4gb</span><br><span class="line">    restart: always</span><br><span class="line">    #command: </span><br><span class="line">    volumes:</span><br><span class="line">      - ./oracle_data/oradata:/opt/oracle/oradata</span><br><span class="line">      - ./oracle_data/dbs:/opt/oracle/product/19c/dbhome_1/dbs</span><br><span class="line">      - ./oracle_data/admin:/opt/oracle/admin</span><br><span class="line">    environment:</span><br><span class="line">      - TZ=Asia/Shanghai</span><br><span class="line">      - ORACLE_SID=ORCLCDB</span><br><span class="line">      - ORACLE_PDB=ORCLPDB1</span><br><span class="line">      - ORACLE_PWD=123456</span><br><span class="line">      - ORACLE_CHARACTERSET=ZHS16GBK</span><br><span class="line">    ports:</span><br><span class="line">      - 1521:1521</span><br><span class="line">    networks:</span><br><span class="line">      - lloracle-net</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  lloracle-net:</span><br><span class="line">    driver: bridge</span><br></pre></td></tr></table></figure><p>注1：INIT_SGA_SIZE、INIT_PGA_SIZE未设置。<br>注2：设置共享内容为2GB（相当于docker的 –shm-size 参数），设置了东八区时区，映射1521端口。字符编码设置为 GBK，非 UTF8。<br>注3：在虚拟机耗时约半小时。<br>注4：在 docker-compose.yml 同一目录下创建三个子目录：oradata、dbs、admin，将三个目录权限改为777。  </p><h3 id="验证服务"><a href="#验证服务" class="headerlink" title="验证服务"></a>验证服务</h3><p>进入容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it lloracle bash</span><br></pre></td></tr></table></figure><p>验证：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ sqlplus / as sysdba</span><br><span class="line"></span><br><span class="line">SQL*Plus: Release 19.0.0.0.0 - Production on Wed Mar 24 15:34:16 2021</span><br><span class="line">Version 19.3.0.0.0</span><br><span class="line"></span><br><span class="line">Copyright (c) 1982, 2019, Oracle.  All rights reserved.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Connected to:</span><br><span class="line">Oracle Database 19c Enterprise Edition Release 19.0.0.0.0 - Production</span><br><span class="line">Version 19.3.0.0.0 </span><br><span class="line"></span><br><span class="line">注：此处没有 Connected to an idle instance.</span><br><span class="line"></span><br><span class="line">SQL&gt; show pdbs;</span><br><span class="line">SQL&gt; select CDB from v$database;   # 显示为NO表示非CDB</span><br><span class="line"></span><br><span class="line">CDB</span><br><span class="line">---</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><h3 id="创建表空间和用户"><a href="#创建表空间和用户" class="headerlink" title="创建表空间和用户"></a>创建表空间和用户</h3><h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><p>进入容器，创建目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it lloracle bash</span><br><span class="line">mkdir /opt/oracle/oradata/MY_DATA</span><br></pre></td></tr></table></figure><p>注：此处是为了创建 54321 用户权限的目录，也可以在宿主机上创建，再用 chown 修改。  </p><h4 id="在navicat创建表空间和用户名"><a href="#在navicat创建表空间和用户名" class="headerlink" title="在navicat创建表空间和用户名"></a>在navicat创建表空间和用户名</h4><p>使用 navicat 连接 oracle，本次连接参数为：<br>端口：1521<br>服务名：ORCLCDB<br>用户及密码：system/123456  </p><p>结果如图1所示：<br><img src="/docker/docker-31-deploy-oracle-again/1.png" alt="图1"> </p><p>点击“其它”、“表空间”、“新建表空间”。在默认“常规”：名称：system01.dbf，大小1，单位G，路径：’/opt/oracle/oradata/MY_DATA/‘(注意最后的斜杠)。自动扩展：ON。（疑惑：此处的大小表征的是什么？如果后续数据超过1G会如何？）<br>点击“保存”，输入表空间名: MY_DATA。  </p><p>点击“用户”、“用户”，“新建用户”，输入用户名称 MY_DB (大写)，密码 123456，默认表空间选择刚才创建的表空间。“成员属于”，勾选DBA所有项。“保存”。  </p><h4 id="使用新用户连接"><a href="#使用新用户连接" class="headerlink" title="使用新用户连接"></a>使用新用户连接</h4><p>使用 navicat 连接 oracle，本次连接参数为：<br>端口：1521<br>服务名：ORCLCDB<br>用户及密码：MY_DB/123456  </p><p>结果如图2所示：<br><img src="/docker/docker-31-deploy-oracle-again/2.png" alt="图2"> </p><p>另外，还再次创建另一表空间，另一用户名，再以 MY_DB 连接，依然可访问另一用户名的表空间。  </p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文使用非 CDB 方式以 docker 运行 oracle19.3，经初步验证，可以正常使用，至于是否可经长期考验，等后续观察。  </p><h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><p>本文完成的镜像如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">registry.cn-hangzhou.aliyuncs.com/latelee/database:19.3.0-ee      # 非cdb版本</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/latelee/database:19.3.0-ee-cdb  # cdb版本</span><br></pre></td></tr></table></figure><h2 id="容器探索"><a href="#容器探索" class="headerlink" title="容器探索"></a>容器探索</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">容器的用户名：</span><br><span class="line"></span><br><span class="line">oracle:x:54321:54321::/home/oracle:/bin/bash</span><br><span class="line"></span><br><span class="line">容器中的环境变量：</span><br><span class="line">$ env</span><br><span class="line">ORACLE_SID=ORCLCDB</span><br><span class="line">INSTALL_FILE_1=LINUX.X64_193000_db_home.zip</span><br><span class="line">ORACLE_BASE=/opt/oracle</span><br><span class="line">CHECK_SPACE_FILE=checkSpace.sh</span><br><span class="line">ORACLE_PDB=ORCLPDB1</span><br><span class="line">PWD_FILE=setPassword.sh</span><br><span class="line">TZ=Asia/Shanghai</span><br><span class="line">SLIMMING=true</span><br><span class="line">RUN_FILE=runOracle.sh</span><br><span class="line">CREATE_DB_FILE=createDB.sh</span><br><span class="line">SHLVL=1</span><br><span class="line">ORACLE_PWD=123456</span><br><span class="line">ORACLE_HOME=/opt/oracle/product/19c/dbhome_1</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>官方仓库：<a href="https://github.com/oracle/docker-images">https://github.com/oracle/docker-images</a><br>修改后的仓库：<a href="https://github.com/latelee/docker-images">https://github.com/latelee/docker-images</a><br><a href="https://github.com/oracle/docker-images/tree/main/OracleDatabase/SingleInstance">安装说明文档</a><br>下载软件：<a href="https://www.oracle.com/database/technologies/oracle-database-software-downloads.html">https://www.oracle.com/database/technologies/oracle-database-software-downloads.html</a><br>共享内存参考：<a href="https://blog.csdn.net/weisubao/article/details/108704236">https://blog.csdn.net/weisubao/article/details/108704236</a><br>Docker安装Oracle19c(NONCDB): <a href="https://www.jianshu.com/p/f0139aff1746">https://www.jianshu.com/p/f0139aff1746</a><br>oracle镜像issue：<a href="https://github.com/oracle/docker-images/issues/791">https://github.com/oracle/docker-images/issues/791</a>  </p><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>构建镜像部分日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Removing intermediate container 2bbee773477c</span><br><span class="line"> ---&gt; f6b8442fcfaa</span><br><span class="line">Step 19/22 : USER oracle</span><br><span class="line"> ---&gt; Running in 85995f303fab</span><br><span class="line">Removing intermediate container 85995f303fab</span><br><span class="line"> ---&gt; 14525605ab30</span><br><span class="line">Step 20/22 : WORKDIR /home/oracle</span><br><span class="line"> ---&gt; Running in b6c49a7101ee</span><br><span class="line">Removing intermediate container b6c49a7101ee</span><br><span class="line"> ---&gt; d56853fe77c1</span><br><span class="line">Step 21/22 : HEALTHCHECK --interval=1m --start-period=5m    CMD &quot;$ORACLE_BASE/$CHECK_DB_FILE&quot; &gt;/dev/null || exit 1</span><br><span class="line"> ---&gt; Running in 656e69b54359</span><br><span class="line">Removing intermediate container 656e69b54359</span><br><span class="line"> ---&gt; c717fbcbc80e</span><br><span class="line">Step 22/22 : CMD exec $ORACLE_BASE/$RUN_FILE</span><br><span class="line"> ---&gt; Running in 730cea346f50</span><br><span class="line">Removing intermediate container 730cea346f50</span><br><span class="line"> ---&gt; 492ae2b9dbf8</span><br><span class="line">Successfully built 492ae2b9dbf8</span><br><span class="line">Successfully tagged oracle/database:19.3.0-ee</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Oracle Database container image for &#x27;ee&#x27; version 19.3.0 is ready to be extended: </span><br><span class="line">    </span><br><span class="line">    --&gt; oracle/database:19.3.0-ee</span><br><span class="line"></span><br><span class="line">  Build completed in 2288 seconds.</span><br></pre></td></tr></table></figure><p>正常启动日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"># docker-compose up</span><br><span class="line">Starting oracle ... done</span><br><span class="line">Attaching to oracle</span><br><span class="line">oracle    | ORACLE EDITION: ENTERPRISE   # ！！！ 版本为商业版</span><br><span class="line">oracle    | ORACLE PASSWORD FOR SYS, SYSTEM AND PDBADMIN: 123456  # ！！！ 密码较简单，下面会出现提示</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | LSNRCTL for Linux: Version 19.0.0.0.0 - Production on 02-MAR-2021 15:42:22</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | Copyright (c) 1991, 2019, Oracle.  All rights reserved.</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | Starting /opt/oracle/product/19c/dbhome_1/bin/tnslsnr: please wait...</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | TNSLSNR for Linux: Version 19.0.0.0.0 - Production</span><br><span class="line">oracle    | System parameter file is /opt/oracle/product/19c/dbhome_1/network/admin/listener.ora</span><br><span class="line">oracle    | Log messages written to /opt/oracle/diag/tnslsnr/153722b1c570/listener/alert/log.xml</span><br><span class="line">oracle    | Listening on: (DESCRIPTION=(ADDRESS=(PROTOCOL=ipc)(KEY=EXTPROC1)))</span><br><span class="line">oracle    | Listening on: (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=0.0.0.0)(PORT=1521)))</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | Connecting to (DESCRIPTION=(ADDRESS=(PROTOCOL=IPC)(KEY=EXTPROC1)))</span><br><span class="line">oracle    | STATUS of the LISTENER</span><br><span class="line">oracle    | ------------------------</span><br><span class="line">oracle    | Alias                     LISTENER</span><br><span class="line">oracle    | Version                   TNSLSNR for Linux: Version 19.0.0.0.0 - Production</span><br><span class="line">oracle    | Start Date                02-MAR-2021 15:42:22</span><br><span class="line">oracle    | Uptime                    0 days 0 hr. 0 min. 0 sec</span><br><span class="line">oracle    | Trace Level               off</span><br><span class="line">oracle    | Security                  ON: Local OS Authentication</span><br><span class="line">oracle    | SNMP                      OFF</span><br><span class="line">oracle    | Listener Parameter File   /opt/oracle/product/19c/dbhome_1/network/admin/listener.ora</span><br><span class="line">oracle    | Listener Log File         /opt/oracle/diag/tnslsnr/153722b1c570/listener/alert/log.xml</span><br><span class="line">oracle    | Listening Endpoints Summary...</span><br><span class="line">oracle    |   (DESCRIPTION=(ADDRESS=(PROTOCOL=ipc)(KEY=EXTPROC1)))</span><br><span class="line">oracle    |   (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=0.0.0.0)(PORT=1521)))  # ！！！端口</span><br><span class="line">oracle    | The listener supports no services</span><br><span class="line">oracle    | The command completed successfully</span><br><span class="line">oracle    | [WARNING] [DBT-06208] The &#x27;SYS&#x27; password entered does not conform to the Oracle recommended standards.</span><br><span class="line">oracle    |    CAUSE: </span><br><span class="line">oracle    | a. Oracle recommends that the password entered should be at least 8 characters in length, contain at least 1 uppercase character, 1 lower case character and 1 digit [0-9].</span><br><span class="line">oracle    | b.The password entered is a keyword that Oracle does not recommend to be used as password</span><br><span class="line">oracle    |    ACTION: Specify a strong password. If required refer Oracle documentation for guidelines.</span><br><span class="line">oracle    | [WARNING] [DBT-06208] The &#x27;SYSTEM&#x27; password entered does not conform to the Oracle recommended standards.</span><br><span class="line">oracle    |    CAUSE: </span><br><span class="line">oracle    | a. Oracle recommends that the password entered should be at least 8 characters in length, contain at least 1 uppercase character, 1 lower case character and 1 digit [0-9].</span><br><span class="line">oracle    | b.The password entered is a keyword that Oracle does not recommend to be used as password</span><br><span class="line">oracle    |    ACTION: Specify a strong password. If required refer Oracle documentation for guidelines.</span><br><span class="line">oracle    | [WARNING] [DBT-06208] The &#x27;PDBADMIN&#x27; password entered does not conform to the Oracle recommended standards.</span><br><span class="line">oracle    |    CAUSE: </span><br><span class="line">oracle    | a. Oracle recommends that the password entered should be at least 8 characters in length, contain at least 1 uppercase character, 1 lower case character and 1 digit [0-9].</span><br><span class="line">oracle    | b.The password entered is a keyword that Oracle does not recommend to be used as password</span><br><span class="line">oracle    |    ACTION: Specify a strong password. If required refer Oracle documentation for guidelines.</span><br><span class="line">oracle    | Prepare for db operation</span><br><span class="line">oracle    | 8% complete</span><br><span class="line">oracle    | Copying database files</span><br><span class="line">oracle    | 31% complete</span><br><span class="line">oracle    | Creating and starting Oracle instance</span><br><span class="line">oracle    | 32% complete</span><br><span class="line">oracle    | 36% complete</span><br><span class="line">oracle    | 40% complete</span><br><span class="line">oracle    | 43% complete</span><br><span class="line">oracle    | 46% complete</span><br><span class="line">oracle    | Completing Database Creation</span><br><span class="line">oracle    | 51% complete</span><br><span class="line">oracle    | 54% complete</span><br><span class="line">oracle    | Creating Pluggable Databases</span><br><span class="line">oracle    | 58% complete</span><br><span class="line">oracle    | 77% complete</span><br><span class="line">oracle    | Executing Post Configuration Actions</span><br><span class="line">oracle    | 100% complete</span><br><span class="line">oracle    | Database creation complete. For details check the logfiles at:</span><br><span class="line">oracle    |  /opt/oracle/cfgtoollogs/dbca/TOLLPDB.</span><br><span class="line">oracle    | Database Information:</span><br><span class="line">oracle    | Global Database Name:TOLLPDB</span><br><span class="line">oracle    | System Identifier(SID):TOLLPDB</span><br><span class="line">oracle    | Look at the log file &quot;/opt/oracle/cfgtoollogs/dbca/TOLLPDB/TOLLPDB0.log&quot; for further details.</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | SQL*Plus: Release 19.0.0.0.0 - Production on Tue Mar 2 16:09:31 2021</span><br><span class="line">oracle    | Version 19.3.0.0.0</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | Copyright (c) 1982, 2019, Oracle.  All rights reserved.</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | </span><br><span class="line">oracle    | Connected to:</span><br><span class="line">oracle    | Oracle Database 19c Enterprise Edition Release 19.0.0.0.0 - Production</span><br><span class="line">oracle    | Version 19.3.0.0.0</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | SQL&gt; </span><br><span class="line">oracle    | System altered.</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | SQL&gt; </span><br><span class="line">oracle    | System altered.</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | SQL&gt; </span><br><span class="line">oracle    | Pluggable database altered.</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | SQL&gt; </span><br><span class="line">oracle    | PL/SQL procedure successfully completed.</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | SQL&gt; Disconnected from Oracle Database 19c Enterprise Edition Release 19.0.0.0.0 - Production</span><br><span class="line">oracle    | Version 19.3.0.0.0</span><br><span class="line">oracle    | The Oracle base remains unchanged with value /opt/oracle</span><br><span class="line">oracle    | #########################</span><br><span class="line">oracle    | DATABASE IS READY TO USE! # ！！！ 数据库可用</span><br><span class="line">oracle    | #########################</span><br><span class="line">oracle    | The following output is now a tail of the alert.log:</span><br><span class="line">oracle    | MY_DB(3):Completed: ALTER DATABASE DEFAULT TABLESPACE &quot;USERS&quot;</span><br><span class="line">oracle    | 2021-03-02T16:09:31.874025+08:00</span><br><span class="line">oracle    | ALTER SYSTEM SET control_files=&#x27;/opt/oracle/oradata/TOLLPDB/control01.ctl&#x27; SCOPE=SPFILE;</span><br><span class="line">oracle    | 2021-03-02T16:09:31.898097+08:00</span><br><span class="line">oracle    | ALTER SYSTEM SET local_listener=&#x27;&#x27; SCOPE=BOTH;</span><br><span class="line">oracle    |    ALTER PLUGGABLE DATABASE MY_DB SAVE STATE</span><br><span class="line">oracle    | Completed:    ALTER PLUGGABLE DATABASE MY_DB SAVE STATE</span><br><span class="line">oracle    | 2021-03-02T16:09:33.007808+08:00</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | XDB initialized.</span><br></pre></td></tr></table></figure><p>停止后第二次启动的日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">Attaching to oracle</span><br><span class="line">oracle    | ORACLE EDITION: ENTERPRISE</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | LSNRCTL for Linux: Version 19.0.0.0.0 - Production on 02-MAR-2021 16:21:58</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | Copyright (c) 1991, 2019, Oracle.  All rights reserved.</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | Starting /opt/oracle/product/19c/dbhome_1/bin/tnslsnr: please wait...</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | TNSLSNR for Linux: Version 19.0.0.0.0 - Production</span><br><span class="line">oracle    | System parameter file is /opt/oracle/product/19c/dbhome_1/network/admin/listener.ora</span><br><span class="line">oracle    | Log messages written to /opt/oracle/diag/tnslsnr/11585b67b20f/listener/alert/log.xml</span><br><span class="line">oracle    | Listening on: (DESCRIPTION=(ADDRESS=(PROTOCOL=ipc)(KEY=EXTPROC1)))</span><br><span class="line">oracle    | Listening on: (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=0.0.0.0)(PORT=1521)))</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | Connecting to (DESCRIPTION=(ADDRESS=(PROTOCOL=IPC)(KEY=EXTPROC1)))</span><br><span class="line">oracle    | STATUS of the LISTENER</span><br><span class="line">oracle    | ------------------------</span><br><span class="line">oracle    | Alias                     LISTENER</span><br><span class="line">oracle    | Version                   TNSLSNR for Linux: Version 19.0.0.0.0 - Production</span><br><span class="line">oracle    | Start Date                02-MAR-2021 16:21:58</span><br><span class="line">oracle    | Uptime                    0 days 0 hr. 0 min. 0 sec</span><br><span class="line">oracle    | Trace Level               off</span><br><span class="line">oracle    | Security                  ON: Local OS Authentication</span><br><span class="line">oracle    | SNMP                      OFF</span><br><span class="line">oracle    | Listener Parameter File   /opt/oracle/product/19c/dbhome_1/network/admin/listener.ora</span><br><span class="line">oracle    | Listener Log File         /opt/oracle/diag/tnslsnr/11585b67b20f/listener/alert/log.xml</span><br><span class="line">oracle    | Listening Endpoints Summary...</span><br><span class="line">oracle    |   (DESCRIPTION=(ADDRESS=(PROTOCOL=ipc)(KEY=EXTPROC1)))</span><br><span class="line">oracle    |   (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=0.0.0.0)(PORT=1521)))</span><br><span class="line">oracle    | The listener supports no services</span><br><span class="line">oracle    | The command completed successfully</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | SQL*Plus: Release 19.0.0.0.0 - Production on Tue Mar 2 16:21:58 2021</span><br><span class="line">oracle    | Version 19.3.0.0.0</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | Copyright (c) 1982, 2019, Oracle.  All rights reserved.</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | Connected to an idle instance.</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | SQL&gt; ORACLE instance started.</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | Total System Global Area 1610609888 bytes</span><br><span class="line">oracle    | Fixed Size                    9135328 bytes</span><br><span class="line">oracle    | Variable Size               402653184 bytes</span><br><span class="line">oracle    | Database Buffers   1191182336 bytes</span><br><span class="line">oracle    | Redo Buffers                  7639040 bytes</span><br><span class="line">oracle    | Database mounted.</span><br><span class="line">oracle    | Database opened.</span><br><span class="line">oracle    | SQL&gt; Disconnected from Oracle Database 19c Enterprise Edition Release 19.0.0.0.0 - Production</span><br><span class="line">oracle    | Version 19.3.0.0.0</span><br><span class="line">oracle    | The Oracle base remains unchanged with value /opt/oracle</span><br><span class="line">oracle    | #########################</span><br><span class="line">oracle    | DATABASE IS READY TO USE!</span><br><span class="line">oracle    | #########################</span><br><span class="line">oracle    | The following output is now a tail of the alert.log:</span><br><span class="line">oracle    | QPI: qopiprep.bat file present</span><br><span class="line">oracle    | 2021-03-02T16:22:33.798020+08:00</span><br><span class="line">oracle    | MY_DB(3):Opening pdb with no Resource Manager plan active</span><br><span class="line">oracle    | MY_DB(3):joxcsys_required_dirobj_exists: directory object exists with required path /opt/oracle/product/19c/dbhome_1/javavm/admin/, pid 119 cid 3</span><br><span class="line">oracle    | Pluggable database MY_DB opened read write</span><br><span class="line">oracle    | 2021-03-02T16:22:35.449498+08:00</span><br><span class="line">oracle    | Starting background process CJQ0</span><br><span class="line">oracle    | 2021-03-02T16:22:35.469509+08:00</span><br><span class="line">oracle    | CJQ0 started with pid=54, OS id=303 </span><br><span class="line">oracle    | Completed: ALTER DATABASE OPEN</span><br><span class="line">oracle    | 2021-03-02T16:22:40.261727+08:00</span><br><span class="line">oracle    | ===========================================================</span><br><span class="line">oracle    | Dumping current patch information</span><br><span class="line">oracle    | ===========================================================</span><br><span class="line">oracle    | Patch Id: 29517242</span><br><span class="line">oracle    | Patch Description: Database Release Update : 19.3.0.0.190416 (29517242)</span><br><span class="line">oracle    | Patch Apply Time: 2019-04-18T15:21:17+08:00</span><br><span class="line">oracle    | Bugs Fixed: 14735102,19697993,20313356,21965541,25806201,25883179,25986062,</span><br><span class="line">oracle    | 26476244,26611353,26872233,27369515,27423500,27666312,27710072,27846298,</span><br><span class="line">oracle    | 27957203,28064977,28072567,28129791,28181021,28210681,28279456,28313275,</span><br></pre></td></tr></table></figure><p>oracledata目录权限不足提示的信息：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> mkdir: cannot create directory &#x27;/opt/oracle/oradata/dbconfig&#x27;: Permission denied</span><br><span class="line">oracle    | mv: cannot stat &#x27;/opt/oracle/product/19c/dbhome_1/dbs/spfileTOLLPDB.ora&#x27;: No such file or directory</span><br><span class="line">oracle    | mv: cannot stat &#x27;/opt/oracle/product/19c/dbhome_1/dbs/orapwTOLLPDB&#x27;: No such file or directory</span><br><span class="line">oracle    | mv: cannot move &#x27;/opt/oracle/product/19c/dbhome_1/network/admin/sqlnet.ora&#x27; to &#x27;/opt/oracle/oradata/dbconfig/TOLLPDB/&#x27;: No such file or directory</span><br><span class="line">oracle    | mv: cannot move &#x27;/opt/oracle/product/19c/dbhome_1/network/admin/listener.ora&#x27; to &#x27;/opt/oracle/oradata/dbconfig/TOLLPDB/&#x27;: No such file or directory</span><br><span class="line">oracle    | mv: cannot move &#x27;/opt/oracle/product/19c/dbhome_1/network/admin/tnsnames.ora&#x27; to &#x27;/opt/oracle/oradata/dbconfig/TOLLPDB/&#x27;: No such file or directory</span><br><span class="line">oracle    | mv: cannot move &#x27;/opt/oracle/product/19c/dbhome_1/install/.docker_enterprise&#x27; to &#x27;/opt/oracle/oradata/dbconfig/TOLLPDB/&#x27;: No such file or directory</span><br><span class="line">oracle    | cp: cannot create regular file &#x27;/opt/oracle/oradata/dbconfig/TOLLPDB/&#x27;: No such file or directory</span><br><span class="line">oracle    | ln: failed to create symbolic link &#x27;/opt/oracle/product/19c/dbhome_1/network/admin/sqlnet.ora&#x27;: File exists</span><br><span class="line">oracle    | ln: failed to create symbolic link &#x27;/opt/oracle/product/19c/dbhome_1/network/admin/listener.ora&#x27;: File exists</span><br><span class="line">oracle    | ln: failed to create symbolic link &#x27;/opt/oracle/product/19c/dbhome_1/network/admin/tnsnames.ora&#x27;: File exists</span><br><span class="line">oracle    | cp: cannot stat &#x27;/opt/oracle/oradata/dbconfig/TOLLPDB/oratab&#x27;: No such file or directory</span><br><span class="line">oracle    | ORACLE_HOME = [/home/oracle] ? ORACLE_BASE environment variable is not being set since this</span><br><span class="line">oracle    | information is not available for the current user ID .</span><br><span class="line">oracle    | You can set ORACLE_BASE manually if it is required.</span><br><span class="line">oracle    | Resetting ORACLE_BASE to its previous value or ORACLE_HOME</span><br><span class="line">oracle    | The Oracle base remains unchanged with value /opt/oracle</span><br><span class="line">oracle    | /opt/oracle/checkDBStatus.sh: line 26: sqlplus: command not found</span><br><span class="line">oracle    | #####################################</span><br><span class="line">oracle    | ########### E R R O R ###############</span><br><span class="line">oracle    | DATABASE SETUP WAS NOT SUCCESSFUL!</span><br><span class="line">oracle    | Please check output for further info!</span><br><span class="line">oracle    | ########### E R R O R ###############</span><br><span class="line">oracle    | #####################################</span><br><span class="line">oracle    | The following output is now a tail of the alert.log:</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="曾经的尝试"><a href="#曾经的尝试" class="headerlink" title="曾经的尝试"></a>曾经的尝试</h2><p><strong>仅备档记录</strong>。 <strong>仅备档记录</strong>。 <strong>仅备档记录</strong>。 </p><p>进入容器，可用如下命令连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sqlplus /nolog</span><br><span class="line"></span><br><span class="line">sqlplus sys/123456@//localhost:1521/tollpdb as sysdba</span><br><span class="line">sqlplus system/123456@//localhost:1521/tollpdb</span><br><span class="line">sqlplus pdbadmin/123456@//localhost:1521/MY_DB  # 注：修改密码，会登录失败，说明已经生效，但用navicat登录不了。</span><br><span class="line"></span><br><span class="line">select * from all_users;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用 navicat 使用 system/123456 可登录（此时应该是cbd)。但用MY_DB和sysdba无法登录。原因未明。  </p><p>查看pdb：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sqlplus sys/123456@//localhost:1521/tollpdb as sysdba</span><br><span class="line"></span><br><span class="line">SQL&gt; show pdbs;</span><br><span class="line"></span><br><span class="line">    CON_ID CON_NAME                       OPEN MODE  RESTRICTED</span><br><span class="line">---------- ------------------------------ ---------- ----------</span><br><span class="line">         2 PDB$SEED                       READ ONLY  NO</span><br><span class="line">         3 MY_DB                          READ WRITE NO</span><br></pre></td></tr></table></figure><p>注：必须以sysdba登录，system查看提示<code>SP2-0382: The SHOW PDBS command is not available</code>。  </p><p>使用 sysdba 登录做一些操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">sqlplus / as sysdba</span><br><span class="line"></span><br><span class="line">SQL*Plus: Release 19.0.0.0.0 - Production on Wed Mar 3 10:11:26 2021</span><br><span class="line">Version 19.3.0.0.0</span><br><span class="line"></span><br><span class="line">Copyright (c) 1982, 2019, Oracle.  All rights reserved.</span><br><span class="line"></span><br><span class="line">Connected to an idle instance.   # ！！这里应该有错了</span><br><span class="line"></span><br><span class="line">SQL&gt; grant sysdba to system;  # ！！ 执行，但不可用</span><br><span class="line">grant sysdba to system</span><br><span class="line">*</span><br><span class="line">ERROR at line 1:</span><br><span class="line">ORA-01034: ORACLE not available  </span><br><span class="line">Process ID: 0</span><br><span class="line">Session ID: 0 Serial number: 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SQL&gt; show pdbs;               # ！！ 执行，但不可用</span><br><span class="line">ERROR:</span><br><span class="line">ORA-01034: ORACLE not available</span><br><span class="line">Process ID: 0</span><br><span class="line">Session ID: 0 Serial number: 0</span><br><span class="line"></span><br><span class="line">SP2-1545: This feature requires Database availability.</span><br><span class="line"></span><br><span class="line">SQL&gt; startup                  # ！！ 启动，但失败</span><br><span class="line">ORA-01078: failure in processing system parameters</span><br><span class="line">LRM-00109: could not open parameter file &#x27;/opt/oracle/product/19c/dbhome_1/dbs/inittollpdb.ora&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>拷贝一个inittollpdb.ora文件。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ORA-00845: MEMORY_TARGET not supported on this system</span><br><span class="line">共享内存太小了</span><br><span class="line"></span><br><span class="line">默认的init.ora中：memory_target=1G。</span><br><span class="line"></span><br><span class="line">ORA-01102: cannot mount database in EXCLUSIVE mode</span><br></pre></td></tr></table></figure><p>查看数据库是否为 CDB：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select CDB from v$database; -- 如果得到的结果为YES，那么就是CDB的数据库，否则，则不是。</span><br><span class="line">切入要操作的pdb</span><br><span class="line">show pdbs; -- 展示pdb数据库集合</span><br><span class="line">alter session set container=MY_DB; -- 切入到PDB 数据库</span><br><span class="line">alter session set container=CDB$ROOT; -- 切回到CDB 容器数据库</span><br></pre></td></tr></table></figure><p>2021年2月 开始着手研究，3月完成 李迟</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文涉及一种在容器中部署 oracle 数据库的方法。经验证，可达到预期目标，并能应用在实际工作中。    &lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="http://www.latelee.org/category/docker/"/>
    
    
    <category term="docker" scheme="http://www.latelee.org/tag/docker/"/>
    
  </entry>
  
  <entry>
    <title>nvidia TX2 DeepStream示例</title>
    <link href="http://www.latelee.org/ml/nvidia-deepstream-sample.html"/>
    <id>http://www.latelee.org/ml/nvidia-deepstream-sample.html</id>
    <published>2021-02-06T05:20:00.000Z</published>
    <updated>2021-09-06T14:40:30.010Z</updated>
    
    <content type="html"><![CDATA[<p>nvidia示例。</p><span id="more"></span><p><a href="https://github.com/NVIDIA-AI-IOT/redaction_with_deepstream/">https://github.com/NVIDIA-AI-IOT/redaction_with_deepstream/</a>  </p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例地址：<a href="https://github.com/NVIDIA-AI-IOT/deepstream_reference_apps">https://github.com/NVIDIA-AI-IOT/deepstream_reference_apps</a> 。克隆其到 `/opt/nvidia/deepstream/deepstream_reference_apps 。   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">模型文件：/opt/nvidia/deepstream/deepstream-5.0/samples/models</span><br><span class="line"></span><br><span class="line">示例文档：https://docs.nvidia.com/metropolis/deepstream/dev-guide/text/DS_ref_app_github.html  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">安装依赖：</span><br><span class="line">查看：/opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-app/README  </span><br><span class="line">命令：   </span><br><span class="line">sudo apt-get install libgstreamer-plugins-base1.0-dev libgstreamer1.0-dev \</span><br><span class="line">   libgstrtspserver-1.0-dev libx11-dev libjson-glib-dev</span><br><span class="line">编译：make （验证SDK、依赖是否完备）。  </span><br><span class="line"></span><br><span class="line">将 anomaly 拷贝到 /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/ ：</span><br><span class="line">cp  /opt/nvidia/deepstream/deepstream_reference_apps/anomaly/ /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/ </span><br><span class="line"></span><br><span class="line">进入目录：</span><br><span class="line">cd /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/anomaly</span><br><span class="line">编译库：</span><br><span class="line">cd plugins/gst-dsdirection/</span><br><span class="line">make &amp;&amp; sudo make install</span><br><span class="line"></span><br><span class="line">编辑 ./anomaly/apps/deepstream-anomaly-detection-test/dsanomaly_pgie_config.txt 文件。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2个示例：</span><br><span class="line">cd /opt/nvidia/deepstream/deepstream_reference_apps/anomaly/apps/deepstream-anomaly-detection-test</span><br><span class="line">./deepstream-anomaly-detection-app  /opt/nvidia/deepstream/deepstream/samples/streams/sample_720p.h264</span><br><span class="line"></span><br><span class="line">cd /opt/nvidia/deepstream/deepstream_reference_a</span><br><span class="line">-to-back-detectors</span><br><span class="line">./back-to-back-detectors /opt/nvidia/deepstream/deepstream/samples/streams/sample_720p.h264</span><br></pre></td></tr></table></figure><p>出错及解决：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">nvbuf_utils: Could not get EGL display connection：</span><br><span class="line">临时设置环境环境： export DISPLAY=:0</span><br><span class="line"></span><br><span class="line">One element could not be created. Exiting.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其他Github上的APP例子：</p><p>360度智能停车App</p><p> 演示了一个或者多个360度视角的视频流的矫正功能。从一个CSV文件中读取摄像机矫正参数，然后将矫正后的过道和区域画面，呈现在屏幕上。</p><p><a href="https://github.com/NVIDIA-AI-IOT/deepstream_360_d_smart_parking_application">https://github.com/NVIDIA-AI-IOT/deepstream_360_d_smart_parking_application</a></p><p>DeepStream SDK for Redaction </p><p>重点展示如何在DeepStream里，对一个视频流，同时对人脸区域和车牌区域进行模糊， 也展示了当该DeepStream流水线风格的应用程序在运行的时候，动态的添加删除视频流通道。</p><p><a href="https://github.com/NVIDIA-AI-IOT/redaction_with_deepstream">https://github.com/NVIDIA-AI-IOT/redaction_with_deepstream</a></p><p>异常检测参考应用</p><p>使用并行管道处理2个流的示例应用程序。</p><p><a href="https://github.com/NVIDIA-AI-IOT/deepstream_reference_apps/tree/master/anomaly">https://github.com/NVIDIA-AI-IOT/deepstream_reference_apps/tree/master/anomaly</a></p><p>是否有关于动态流管理的例子吗?</p><p><a href="https://github.com/NVIDIA-AI-IOT/deepstream_reference_apps/tree/master/anomaly">https://github.com/NVIDIA-AI-IOT/deepstream_reference_apps/tree/master/anomaly</a></p><p>里面包括了在管道运行时动态添加或删除通道。</p><p><a href="https://github.com/NVIDIA-AI-IOT/redaction_with_deepstream/">https://github.com/NVIDIA-AI-IOT/redaction_with_deepstream/</a>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;nvidia示例。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://www.latelee.org/category/ml/"/>
    
    
  </entry>
  
  <entry>
    <title>nvidia TX2 使用 SDK Manager工具刷机记录</title>
    <link href="http://www.latelee.org/ml/nvidia-flash-to-tx2-using-sdkmanager.html"/>
    <id>http://www.latelee.org/ml/nvidia-flash-to-tx2-using-sdkmanager.html</id>
    <published>2021-02-05T16:00:00.000Z</published>
    <updated>2021-09-06T14:40:29.998Z</updated>
    
    <content type="html"><![CDATA[<p>本文为使用 nvidia 提供的 SDK Manager（本文称 sdkmanager） 工具下载、烧写 Jetson TX2 的记录。本文根据笔者长时间的摸索经历，以有限的经验对刷机过程及要点进行描述，由于历时较长，<strong>本文所述步骤不保证是完完全全的实际操作顺序，仅供参考。</strong><br>本文不涉及 TX2 特性或功能或深度学习方面内容。<br>笔者仅以本文作记录，由于能力有限，对本文涉及的问题无法回答。  </p><span id="more"></span><h2 id="一、要点"><a href="#一、要点" class="headerlink" title="一、要点"></a>一、要点</h2><p>一些基础要点或要注意的事在此节说明。  </p><ul><li>TX2只支持HDMI接口，只有一个 usb 接口（要用 usbhub扩展）。使用 nvidia 原装 usb 线连接烧写。    </li><li>TX2有四个红色并排的按键，电源键标有POWER BTN，开机需要按稍长时间，板上有绿灯亮时松开即可。由开机键向左分别是强制恢复键 Force Recovery Button、用户定义键 User Defined Button 和复位键 Reset Button。在手动刷机情况下，要分别操作 Force Recovery Button 和 POWER BTN。见后文。  </li><li>sdkmanager 目前只有 Linux 版本，支持 ubuntu16.04 和 ubuntu18.04。使用大屏幕、大内存的好的机器，最好是物理机安装 ubuntu。如是虚拟机，连 usb 线时需要让虚拟机识别到 TX2。   </li><li>sdkmanager 集下载（系统镜像，软件包）、烧写（系统镜像，软件包）、卸载（软件包）、修复（软件包）功能。</li><li>sdkmanager 下载需要使用 nvidia 开发者账号，（免费）注册即可。  </li><li>sdkmanager 有 HOST 端和 TARGET 端之分，可按需下载烧写。如只烧写系统镜像或只安装软件。  </li><li>烧写 Linux 镜像后，需要在板子上做一些设置，如设置账号密码，连接WiFi等，进入系统后，有一网络设备默认IP为 192.168.55.1，该IP在 sdkmanager 中被使用。    </li></ul><h2 id="二、过程"><a href="#二、过程" class="headerlink" title="二、过程"></a>二、过程</h2><h3 id="2-1-环境准备"><a href="#2-1-环境准备" class="headerlink" title="2.1 环境准备"></a>2.1 环境准备</h3><p>sdkmanager 目前只有 Linux 版本。可用 ubuntu16.04 和 ubuntu18.04 发行版。内存最低为8GB，屏幕分辨率 1440x900 以上。内存过小会卡，分辨率过低则界面显示不完整，经测试，在 ubuntu16.04 系统中运行时可点击”View”-&gt;”Zoom Out”缩小界面。<br>需要联网，因为要从 nvidia 官网下载软件包。<br>如果要烧写，则需要使用原装 usb 线连接板子和PC。  </p><h3 id="2-2-注册账号"><a href="#2-2-注册账号" class="headerlink" title="2.2 注册账号"></a>2.2 注册账号</h3><p>下载软件需要注册，地址：<a href="https://developer.nvidia.com/login">https://developer.nvidia.com/login</a> 。<br>注：登录时需要输入账号密码，并点击符合要求的图案（如飞机，车之类的），以证明登录者是人类。  </p><h3 id="2-3-安装运行-sdkmanager"><a href="#2-3-安装运行-sdkmanager" class="headerlink" title="2.3 安装运行 sdkmanager"></a>2.3 安装运行 sdkmanager</h3><p>之前使用 jetpack 工具下载烧写的，目前是使用 sdkmanager，下载地址为：<a href="https://developer.nvidia.com/embedded/jetpack">https://developer.nvidia.com/embedded/jetpack</a> 。安装方式有两种，一是用 SD 卡镜像，二是使用 sdkmanager，即<code>NVIDIA SDK Manager method</code>，TX2 使用方法二。<br>本文使用的文件为<code>sdkmanager_1.4.0-7363_amd64.deb</code>，md5为<code>535b9b2b41248e89b839b6f5a3acb185</code>。安装命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install ./sdkmanager_1.4.0-7363_amd64.deb </span><br></pre></td></tr></table></figure><p>sdkmanager <strong>必须使用普通用户</strong>运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sdkmanager</span><br></pre></td></tr></table></figure><p>稍等片刻即可看到启动界面。如系统系统不满足最低要求会弹出提示框，如图1所示。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/1.png" alt="图1"><br>点击Yes进入登录界面。如图2所示。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/2.png" alt="图2"><br>第三个页面为离线包方式，适用已下载软件包情况，不用登录，选择已经下载好软件包的目录，点击“START”即可开始。第一页面为即本文所用的方式。点击Login，在自动打开的浏览器中输入账号，再输入密码，点击图案验证。建议保存密码减少操作。图3为已经验证即将登录的界面。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/3.png" alt="图3">  </p><p>登录过程中，可能会遇到一些问题，如下：<br>1、提示<code>no SDKs available for your account</code>，网上有说法执行<code>sudo updatedb</code>可解决，笔者验证未成功。<br>2、提示<code>Failed to get client token</code>，重试多次未能解决，未知原因。<br>3、卡在<code>Loading and processing available products...</code>，重试多次可解决。  </p><h3 id="2-4-下载软件"><a href="#2-4-下载软件" class="headerlink" title="2.4 下载软件"></a>2.4 下载软件</h3><p>成功登录后进入第一步骤配置，如图4所示。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/4.png" alt="图4"><br>主要有四项内容，第一为产品目录，即 Jetson，第二为硬件配置，分为主机端和目标板端，本文不使用主机端配置（目前没有需要在主机做开发），由于笔者连接了板子，故图4中已检测到 TX2。也可以手动点击右下角的<code>...</code>选择实际板子型号。第三为系统版本，目前为 4.5 版本。最后是 deepstream，版本为5.0，为可选项，笔者不想在后续单独安装，因此也选上了。  </p><p>点击“CONTINUE”进入第二步骤。如图5所示。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/5.png" alt="图5"><br>软件包括了系统镜像和SDK两大类软件，默认全选，也可分别安装。页面底部有默认下载和安装目录，也可手动指定，默认目录不存在，会提示创建目录。勾选接受协议。如果只希望下载软件，则勾选<code>Download now, Install later.</code>。笔者建议勾选。因为下载十分耗时，且容易出错。<br>点击“CONTINUE”进入第三步骤。图6为即将下载的界面。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/6.png" alt="图6">  </p><p>此时可在 TERMINAL 中查看日志，如图7所示。也可查看<code>~/.nvsdkm/sdkm.log</code>文件（<code>~/.nvsdkm</code>是 sdkmanager 日志所在目录）。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/7.png" alt="图7">  </p><p>经过十分漫长的等待，完成下载，如图8所示。点击 FINISH 退出。<strong>如果下载、安装一并进行，下载完成后进入安装步骤，FINISH 表示最终的完成</strong>。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/8.png" alt="图8">  </p><p>注：<br>1、下载十分耗时，而且容易出错，所以板子不用开机，也不用连接PC。<br>2、sdkmanager 下载速度与网络有关。<br>3、关于下载失败的终极解决方法：<strong>重试，多重试，多次重试，换台电脑试，换个网络再试，隔一段时间重试。</strong><br>4、笔者经过多次尝试，在 sdkmanager 中均无法完整下载，后想到一种笨方法。当 sdkmanager 下载失败时，在默认的下载目录 <code>/home/latelee/Downloads/nvidia/sdkm_downloads</code><br>中查看下载的软件包（有deb包、zip包等，未下载完成的以mtd结尾），再在 sdkmanager 日志中查看软件包的下载地址，一一列出。然后在 Windows 的浏览器中登录 nvidia官网，再粘贴下载地址下载（运行了某种工具以保证官方网站连接畅通）。共63个文件，大的有1.8GB，小的有数十KB。 </p><p>另外，在不同时候下载，个别软件包的版本不同，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NsightSystems-linux-public-2020.5.3.17-0256620.deb</span><br><span class="line">NsightSystems-linux-public-2020.4.2.18-f0b18f6.deb</span><br><span class="line"></span><br><span class="line">nvidia-l4t-jetson-multimedia-api_32.4.4-20201016123640_arm64.deb</span><br><span class="line">nvidia-l4t-jetson-multimedia-api_32.5.0-20210115151051_arm64.deb</span><br></pre></td></tr></table></figure><p>从软件包日期也可看到笔者进行较长时间的尝试。  </p><p>如有兴趣，可到<strong>附3：提示及日志</strong>的<strong>部分下载失败日志</strong>处查看失败日志。  </p><h3 id="2-5-安装软件"><a href="#2-5-安装软件" class="headerlink" title="2.5 安装软件"></a>2.5 安装软件</h3><p>这里的“软件”包括了系统（和驱动）以及 sdk 软件。对于系统而言，实际应该是“烧写”而不是安装。<br>系统镜像（OS镜像）和sdk可分开安装，如果在安装sdk出错，下次重试时，可取消系统的安装，节省时间。本文完全刷机，所以两者均安装。<br>执行之前，sdkmanager 会弹出对话框输入密码，因为有些操作需要 root 权限。<br>真正烧写镜像前，sdkmanager 会创建OS镜像，默认位于<code>~/nvidia/nvidia_sdk</code>目录，如图9所示，第一进度条表示正在创建 Jetson OS 镜像。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/9.png" alt="图9"><br>在此过程，也可点击 TERMINAL 查看日志，如图10所示。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/10.png" alt="图10"><br>注意，从图10可看到下载目录为非默认目录，该目录就是笔者手动下载并拷贝到 Linux 虚拟机中的目录。<br>当 OS 镜像准备完毕后，出现烧写提示。方式有二，图11所示为自动方式，TX2 板子要开机，并且联网，输入 TX2 正在使用的账号密码，注意，IP地址不需要修改，使用默认的即可。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/11.png" alt="图11"><br>当系统损坏无法启动时，可选择手动模式，手动模式需要在板子上按键操作，按键操作为：按住恢复键，再按一次电源键，最后松开恢复键。其界面如图12所示。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/12.png" alt="图12"><br>本文选择自动方式（实际也尝试了手动方式），烧写过程比较耗时。如果超过时间，sdkmanager 会提示，如图13所示。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/13.png" alt="图13"><br>烧写结束之后 TX2 会关机。如果使用虚拟机，此过程要保持鼠标在虚拟机内，以保证 TX2 总能被虚拟机识别。<br>TX2 重新启动后板子显示器出现系统配置界面，第一个界面为接受协议，如图14所示。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/14.png" alt="图14"> </p><p>后续界面依次为：选择语言，选择键盘，连接WiFi（笔者手上没有多余网线，只能用WiFi），选择时区，账号密码（可选自动登录），Nvpmodel模式，除WiFi和账号密码要输入信息外，其它用默认即可。等待片刻自动重启，之后进入系统，此时已经有了基本可用的系统（当然还用不了cuda）。  </p><p>此时可在 TX2 系统中查看板子IP，网络设备 l4tbr0 的 IP 为 192.168.55.1，对应的，PC端网络设备 ens35u1i5 IP 为 192.168.55.100。两系统可互相 ping 通。  </p><p>系统镜像烧写成功后，sdkmanager 进入安装 sdk 阶段（sdk 可单独安装，过程相同）。如图15所示。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/15.png" alt="图15"> </p><p>输入刚才设置的账号和密码。图16为正在安装sdk包界面。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/16.png" alt="图16"> </p><p>再经过一段时间等待，安装成功，如图17所示，点击 FINISH 完成任务。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/17.png" alt="图17"> </p><p>TX2 系统默认桌面如图18所示。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/18.png" alt="图18">   </p><p>注：<br>本节步骤不一定反映实际情况，因为会经常中断。<br>烧写系统镜像过程如果断开，会从头开始，如果已经进行一半，此时系统可能会损坏，如是则要用手动模式。<br>耗时：在下载好软件包情况下，晚8点开始，至12点前结束，期间中断了3次。  </p><h3 id="2-6-验证程序"><a href="#2-6-验证程序" class="headerlink" title="2.6 验证程序"></a>2.6 验证程序</h3><p>前面刷机已经勾选了 DeepStream，可直接使用。进入 TX2 系统，查看 DeepStream 版本信息：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ deepstream-app --version-all</span><br><span class="line">2021-02-04 23:51:41.044864: I tensorflow/stream_executor/platform/default/dso_loader.cc:48] Successfully opened dynamic library libcudart.so.10.2</span><br><span class="line">deepstream-app version 5.0.0</span><br><span class="line">DeepStreamSDK 5.0.0</span><br><span class="line">CUDA Driver Version: 10.2</span><br><span class="line">CUDA Runtime Version: 10.2</span><br><span class="line">TensorRT Version: 7.1</span><br><span class="line">cuDNN Version: 8.0</span><br><span class="line">libNVWarp360 Version: 2.0.1d3</span><br></pre></td></tr></table></figure><p>可用如下命令查看和nvidia有关的插件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gst-inspect-1.0 -a | grep -i nvidia</span><br></pre></td></tr></table></figure><p>编译、运行自带的示例工程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-test1</span><br><span class="line">make</span><br><span class="line">./deepstream-test1-app /opt/nvidia/deepstream/deepstream/samples/streams/sample_720p.h264 </span><br></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Now playing: /opt/nvidia/deepstream/deepstream/samples/streams/sample_720p.h264</span><br><span class="line"></span><br><span class="line">Using winsys: x11 </span><br><span class="line">Opening in BLOCKING MODE</span><br><span class="line">Opening in BLOCKING MODE </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>效果如图19所示。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/19.png" alt="图19">  </p><h2 id="三、参考资源"><a href="#三、参考资源" class="headerlink" title="三、参考资源"></a>三、参考资源</h2><p>sdkmanager官方使用说明： <a href="https://docs.nvidia.com/sdk-manager/install-with-sdkm-jetson/index.html">https://docs.nvidia.com/sdk-manager/install-with-sdkm-jetson/index.html</a><br>sdkmanager配置：<a href="https://docs.nvidia.com/sdk-manager/sdkm-settings/index.html">https://docs.nvidia.com/sdk-manager/sdkm-settings/index.html</a><br>NVIDIA Jetson TX2 上手指南：<a href="https://blog.csdn.net/qq_36782182/article/details/91488284">https://blog.csdn.net/qq_36782182/article/details/91488284</a>  </p><h2 id="附1：尝试"><a href="#附1：尝试" class="headerlink" title="附1：尝试"></a>附1：尝试</h2><p>本节记录个人的尝试，流行话叫“踩坑”。<br>无物理机，故使用虚拟机，但内存不够大，屏幕不够大（本本是7、8年前买的），分辨率和内存满足不了 sdkmanager 最低要求。<br>先安装使用ubuntu18.04，但 sdkmanager 无法缩小，操作不便，找不到同意协议选项，无法执行。<br>改用之前在 VirtualBox 上安装的 lubuntu1604，其资源占用稍少，但亦无缩小，多次重启，提示<code>The virtual machine &#39;lubuntu1604&#39; has terminated unexpectedly during startup with exit code 1</code>，所有 VirtualBox 虚拟机系统损坏无法使用。<br>最后用 ubuntu16.04，点击标题<code>View</code>中进行缩小。可顺利进行。  </p><h2 id="附2：成果"><a href="#附2：成果" class="headerlink" title="附2：成果"></a>附2：成果</h2><p>1、刷机过程生成的日志已存放 github 备份。<br>2、下载的软件包只在 TX2 测试通过，约6GB，已整合为 docker 镜像，并上传至阿里云仓库备份。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t registry.cn-hangzhou.aliyuncs.com/latelee/deepstream:tx2 .</span><br><span class="line">docker push registry.cn-hangzhou.aliyuncs.com/latelee/deepstream:tx2</span><br></pre></td></tr></table></figure><p>镜像说明：包括 TAEGET 端所有的包以及部分 HOST 端的包。运行后在容器的 <code>/nvidia</code> 目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name foobar registry.cn-hangzhou.aliyuncs.com/latelee/deepstream:tx2 sh</span><br><span class="line">docker exec -it foobar sh</span><br><span class="line">ls /nvidia</span><br></pre></td></tr></table></figure><p>逐一拷贝：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir my_download</span><br><span class="line">docker cp foobar:/nvidia/Tegra_Linux_Sample-Root-Filesystem_R32.5.0_aarch64.tbz2 my_download</span><br><span class="line">docker cp foobar:/nvidia/cuda-repo-l4t-10-2-local-10.2.89_1.0-1_arm64.deb my_download</span><br><span class="line">其它文件类似</span><br></pre></td></tr></table></figure><p>Dockerfile：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM latelee/busybox </span><br><span class="line">RUN mkdir /nvidia  </span><br><span class="line">COPY cuda-repo-cross-aarch64-10-2-local-10.2.89_1.0-1_all.deb  /nvidia</span><br><span class="line">COPY cuda-repo-l4t-10-2-local-10.2.89_1.0-1_arm64.deb  /nvidia</span><br><span class="line">其它文件类似</span><br></pre></td></tr></table></figure><h3 id="附3：提示及日志"><a href="#附3：提示及日志" class="headerlink" title="附3：提示及日志"></a>附3：提示及日志</h3><p>启动显示系统最低要求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Warning</span><br><span class="line">Could not detect SDK Manager&#x27;s minimal system requirement(s):</span><br><span class="line"> - Minimum of 7.5GB of RAM (4.74GB detected)</span><br><span class="line"> - Screen resolution equal or larger than 1440x900 (800x600 detected)</span><br><span class="line"></span><br><span class="line">Do you wish to continue?</span><br></pre></td></tr></table></figure><p>部分下载失败日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">未授权的（一般是之前已经登录，但过期了）</span><br><span class="line">01:49:33 : CUDA on Host: download https://developer.nvidia.com/assets/embedded/secure/tools/files/jetpack-sdks/jetpack-4.4.1/JETPACK_441_b50/ubuntu1604/cuda-repo-ubuntu1604-10-2-local-10.2.89-440.40_1.0-1_amd64.deb failed, retrying 1...</span><br><span class="line">01:49:33 INFO: CUDA on Host: start to download https://developer.nvidia.com/assets/embedded/secure/tools/files/jetpack-sdks/jetpack-4.4.1/JETPACK_441_b50/ubuntu1604/cuda-repo-ubuntu1604-10-2-local-10.2.89-440.40_1.0-1_amd64.deb to /home/ubuntu/Downloads/nvidia/sdkm_downloads/cuda-repo-ubuntu1604-10-2-local-10.2.89-440.40_1.0-1_amd64.deb</span><br><span class="line">01:49:36 ERROR: CUDA on Host: DevZone get download url failed: HTTPError: Response code 401 (Unauthorized).</span><br><span class="line">01:49:36 ERROR: CUDA on Host: Download &#x27;CUDA on Host&#x27; failure</span><br><span class="line">01:49:36 ERROR: CUDA on Host: DevZone get download url failed: HTTPError: Response code 401 (Unauthorized).</span><br><span class="line">01:49:36 ERROR: CUDA on Host: Download &#x27;CUDA on Host&#x27; failure</span><br><span class="line">01:49:36 ERROR: CUDA on Host: download failed</span><br><span class="line"></span><br><span class="line">网络断开的</span><br><span class="line">22:02:21 : CUDA on Host: download https://developer.nvidia.com/assets/embedded/secure/tools/files/jetpack-sdks/jetpack-4.4.1/JETPACK_441_b50/ubuntu1604/cuda-repo-ubuntu1604-10-2-local-10.2.89-440.40_1.0-1_amd64.deb failed, retrying 1...</span><br><span class="line">22:02:21 INFO: CUDA on Host: start to download https://developer.nvidia.com/assets/embedded/secure/tools/files/jetpack-sdks/jetpack-4.4.1/JETPACK_441_b50/ubuntu1604/cuda-repo-ubuntu1604-10-2-local-10.2.89-440.40_1.0-1_amd64.deb to /home/ubuntu/Downloads/nvidia/sdkm_downloads/cuda-repo-ubuntu1604-10-2-local-10.2.89-440.40_1.0-1_amd64.deb</span><br><span class="line">22:02:37 ERROR: CUDA on Host: DevZone get download url failed: RequestError: Client network socket disconnected before secure TLS connection was established.</span><br><span class="line">22:02:37 ERROR: CUDA on Host: Download &#x27;CUDA on Host&#x27; failure</span><br><span class="line">22:02:37 ERROR: CUDA on Host: DevZone get download url failed: RequestError: Client network socket disconnected before secure TLS connection was established.</span><br><span class="line">22:02:37 ERROR: CUDA on Host: Download &#x27;CUDA on Host&#x27; failure</span><br><span class="line">22:02:37 ERROR: CUDA on Host: download failed</span><br><span class="line"></span><br><span class="line">网络有问题的</span><br><span class="line">22:42:24 INFO: DeepStream: start to download https://developer.nvidia.com/assets/embedded/secure/tools/files/jetpack-sdks/jetpack-4.4.1/JETPACK_441_b50_DEEPSTREAM/deepstream-5.0_5.0.1-1_arm64.deb to /home/ubuntu/Downloads/nvidia/sdkm_downloads/deepstream-5.0_5.0.1-1_arm64.deb</span><br><span class="line">22:43:31 ERROR: DeepStream: Head request failed on host: ECONNRESET. Error: socket hang uphttps://developer.download.nvidia.com/assets/embedded/secure/tools/files/jetpack-sdks/jetpack-4.4.1/JETPACK_441_b50_DEEPSTREAM/deepstream-5.0_5.0.1-1_arm64.deb?IQOvXtJ6q2h7wEVW_SUReWVsdQk8i0duzlCSFmayyqE8duPuyZPhND_O1S6yd6hoXuobjaYpB8MKsg-8fadWWALJQBs8m_SAwYpFD9-XvCrw1tt1CCtlt7547_3c0P3GoXqi85jW_LogPq06flT9gCxtYNxjhENTzdQA80uZeV3ZEKh4PUJO9Gvtl1aqWzBugJ1W1T6PwrLIM-GWXQQR3p3idZlx-OltlatQEFGv2cyhXv-Ty2l8dg</span><br><span class="line">22:43:31 ERROR: DeepStream: Download &#x27;DeepStream&#x27; failure</span><br><span class="line">22:43:31 ERROR: DeepStream: Head request failed on host: ECONNRESET. Error: socket hang uphttps://developer.download.nvidia.com/assets/embedded/secure/tools/files/jetpack-sdks/jetpack-4.4.1/JETPACK_441_b50_DEEPSTREAM/deepstream-5.0_5.0.1-1_arm64.deb?IQOvXtJ6q2h7wEVW_SUReWVsdQk8i0duzlCSFmayyqE8duPuyZPhND_O1S6yd6hoXuobjaYpB8MKsg-8fadWWALJQBs8m_SAwYpFD9-XvCrw1tt1CCtlt7547_3c0P3GoXqi85jW_LogPq06flT9gCxtYNxjhENTzdQA80uZeV3ZEKh4PUJO9Gvtl1aqWzBugJ1W1T6PwrLIM-GWXQQR3p3idZlx-OltlatQEFGv2cyhXv-Ty2l8dg</span><br><span class="line">22:43:31 ERROR: DeepStream: Download &#x27;DeepStream&#x27; failure</span><br><span class="line">22:43:31 ERROR: DeepStream: download failed</span><br><span class="line">22:43:31 ERROR: DeepStream: Download &#x27;DeepStream&#x27; failure</span><br><span class="line">22:43:31 ERROR: DeepStream: download failed</span><br><span class="line"></span><br><span class="line">拒绝连接的</span><br><span class="line">22:55:51 INFO: CUDA on Host: start to download https://developer.nvidia.com/assets/embedded/secure/tools/files/jetpack-sdks/jetpack-4.4.1/JETPACK_441_b50/ubuntu1604/cuda-repo-ubuntu1604-10-2-local-10.2.89-440.40_1.0-1_amd64.deb to /home/ubuntu/Downloads/nvidia/sdkm_downloads/cuda-repo-ubuntu1604-10-2-local-10.2.89-440.40_1.0-1_amd64.deb</span><br><span class="line">22:55:51 ERROR: CUDA on Host: The .mtd file is corrupt. Start a new download.</span><br><span class="line">22:55:51 ERROR: CUDA on Host: Download &#x27;CUDA on Host&#x27; failure</span><br><span class="line">22:55:51 ERROR: CUDA on Host: The .mtd file is corrupt. Start a new download.</span><br><span class="line">22:55:51 ERROR: CUDA on Host: Download &#x27;CUDA on Host&#x27; failure</span><br><span class="line">22:55:51 ERROR: CUDA on Host: download failed</span><br><span class="line"></span><br><span class="line">22:57:14 ERROR: DeepStream: DevZone get download url failed: RequestError: connect ECONNREFUSED 128.1.83.20:443.</span><br><span class="line">22:57:14 ERROR: DeepStream: Download &#x27;DeepStream&#x27; failure</span><br><span class="line">22:57:14 ERROR: DeepStream: DevZone get download url failed: RequestError: connect ECONNREFUSED 128.1.83.20:443.</span><br><span class="line">22:57:14 ERROR: DeepStream: Download &#x27;DeepStream&#x27; failure</span><br><span class="line">22:57:14 ERROR: DeepStream: download failed</span><br><span class="line"></span><br><span class="line">连接重置的</span><br><span class="line">00:05:35 ERROR: DeepStream: Head request failed on host: ECONNRESET. Error: read ECONNRESEThttps://developer.download.nvidia.com/assets/embedded/secure/tools/files/jetpack-sdks/jetpack-4.4.1/JETPACK_441_b50_DEEPSTREAM/deepstream-5.0_5.0.1-1_arm64.deb?FlpOvCmigTA5N-TqbXBm-hfRtR6pMsu_xxBikJ2lu_xusmVBC6WA4nupxDJwHA3jAjOiheJW8KuUzRs5xGE-u4HwBi98x5Xc_2pdtZURC-MmgH4a48ptyI0Xy9xkMayuLRdKXdK8hdINsiIlgUGf8uZbtkvFE_KJHO54WgiuyEPLdeoCE3K6AXPvQ0mdYjhMMYzGKrZR04YnZXJp_kZ5lH051Srg7VadNK1_X_g6UxPRuQWwId3cDQ</span><br><span class="line">00:05:35 ERROR: DeepStream: Download &#x27;DeepStream&#x27; failure</span><br><span class="line">00:05:35 ERROR: DeepStream: download failed</span><br><span class="line">00:05:35 : DeepStream: download https://developer.nvidia.com/assets/embedded/secure/tools/files/jetpack-sdks/jetpack-4.4.1/JETPACK_441_b50_DEEPSTREAM/deepstream-5.0_5.0.1-1_arm64.deb failed, retrying 1...</span><br><span class="line"></span><br><span class="line">其它未列举的</span><br></pre></td></tr></table></figure><p>烧写过程中出错，已有下载的包，且md5sum正确，但提示出错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">23:30:53 INFO: NVIDIA Container Runtime with Docker integration (Beta): verifying checksum of /home/latelee/Downloads/nvidia/my_download/nvidia-container-runtime_3.1.0-1_arm64.deb</span><br><span class="line">23:30:53 INFO: NVIDIA Container Runtime with Docker integration (Beta): Found file /home/latelee/Downloads/nvidia/my_download/nvidia-container-runtime_3.1.0-1_arm64.deb with correct checksum, skip downloading.</span><br><span class="line">23:30:53 INFO: NVIDIA Container Runtime with Docker integration (Beta): verifying checksum of /home/latelee/Downloads/nvidia/my_download/nvidia-docker2_2.2.0-1_all.deb</span><br><span class="line">23:30:53 INFO: NVIDIA Container Runtime with Docker integration (Beta): Found file /home/latelee/Downloads/nvidia/my_download/nvidia-docker2_2.2.0-1_all.deb with correct checksum, skip downloading.</span><br><span class="line">23:31:58 SUMMARY: NVIDIA Container Runtime with Docker integration (Beta): Depends on failed component</span><br><span class="line">23:31:58 SUMMARY: NVIDIA Container Runtime with Docker integration (Beta): Depends on failed component</span><br><span class="line">23:31:58 SUMMARY: NVIDIA Container Runtime with Docker integration (Beta): Depends on failed component</span><br><span class="line"></span><br><span class="line">3:30:53 INFO: Multimedia API: verifying checksum of /home/latelee/Downloads/nvidia/my_download/nvidia-l4t-jetson-multimedia-api_32.5.0-20210115151051_arm64.deb</span><br><span class="line">23:30:54 INFO: Multimedia API: Found file /home/latelee/Downloads/nvidia/my_download/nvidia-l4t-jetson-multimedia-api_32.5.0-20210115151051_arm64.deb with correct checksum, skip downloading.</span><br><span class="line">23:31:58 SUMMARY: Multimedia API: Depends on failed component</span><br><span class="line">23:31:58 SUMMARY: Multimedia API: Depends on failed component</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>个人猜测：没有完成所有包的检测，没有做标记，因此有些包的依赖没有记录，所以提示出错。多次从头重试可解决。  </p><p>李迟 2021.2.6 周六</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文为使用 nvidia 提供的 SDK Manager（本文称 sdkmanager） 工具下载、烧写 Jetson TX2 的记录。本文根据笔者长时间的摸索经历，以有限的经验对刷机过程及要点进行描述，由于历时较长，&lt;strong&gt;本文所述步骤不保证是完完全全的实际操作顺序，仅供参考。&lt;/strong&gt;&lt;br&gt;本文不涉及 TX2 特性或功能或深度学习方面内容。&lt;br&gt;笔者仅以本文作记录，由于能力有限，对本文涉及的问题无法回答。  &lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://www.latelee.org/category/ml/"/>
    
    
  </entry>
  
  <entry>
    <title>新年新计划-2021年</title>
    <link href="http://www.latelee.org/the-life/2021-new-plan.html"/>
    <id>http://www.latelee.org/the-life/2021-new-plan.html</id>
    <published>2021-01-31T16:00:00.000Z</published>
    <updated>2021-09-06T14:40:30.122Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>无意间回顾博客目录，发现上一篇新年计划，是2015年2月份写的。一年之计在于春，也开始尝试写写计划。  </p><span id="more"></span><h2 id="心态方面"><a href="#心态方面" class="headerlink" title="心态方面"></a>心态方面</h2><p>承认自己是个普通人，认知有限。赚不到认知以外的钱，学不了能力之外的技术。<br>不用太理会别人的意见和看法。（注：这里有个“太”字）<br>不与不在同一频道的人争论。  </p><h2 id="工作方面"><a href="#工作方面" class="headerlink" title="工作方面"></a>工作方面</h2><p>认真工作，提升存在感。注：今年只跟部门一把手聊过两回，一是试用期考核，领导问我工作怎样。二是在电梯，领导看到我的破包叫我换。<br>和同事和睦相处，对待正式同事，要特别热情友好。<br>对于自己擅长的领域，适当在同事面前展示一二。<br>笑脸迎人，骂不还口，不带情绪办公。争取加班随叫随到，不能者，亦解释。（注：心里骂几句亦可）  </p><h2 id="技能提升方面"><a href="#技能提升方面" class="headerlink" title="技能提升方面"></a>技能提升方面</h2><p>以家庭为重心，少接不熟悉领域的私活。尽量少熬夜，防止寿命减少。<br>阅读几本专业书，可慢，贵在理解和应用。不贪快，不贪多。暂有目标：《重构》第2版。<br>考证：架构师。以考促学，研究和架构，分布式有关的领域基础知识。（注1：是“基础知识”；注2：没提一定必须考过）<br>写一篇论文发表。评一下职称。（注：论文是“发表”，职称没提一定要得）  </p><h2 id="家庭生活方面"><a href="#家庭生活方面" class="headerlink" title="家庭生活方面"></a>家庭生活方面</h2><p>骂不还口。如有脾气或生闷气，不能超过3天。<br>勤力做家务，及时做家务。<br>巩固并提升做菜水平，注重家常。<br>对待小孩，该打还得打，该讲道理要讲，该宠也得宠。<br>给李大锤练耐力（跑步），胆量（未想好）。陪大锤爬山、看夕阳。<br>巩固并继续诗歌（诗词）的教育。开始白话的训练。<br>争取带李大妞去公园玩。  </p><p>李迟 2021.02.01</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;无意间回顾博客目录，发现上一篇新年计划，是2015年2月份写的。一年之计在于春，也开始尝试写写计划。  &lt;/p&gt;</summary>
    
    
    
    <category term="生活掠影" scheme="http://www.latelee.org/category/the-life/"/>
    
    
    <category term="新年计划" scheme="http://www.latelee.org/tag/%E6%96%B0%E5%B9%B4%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
</feed>
