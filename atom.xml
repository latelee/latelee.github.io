<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>迟思堂随笔</title>
  
  <subtitle>李迟的技术主页</subtitle>
  <link href="http://www.latelee.org/atom.xml" rel="self"/>
  
  <link href="http://www.latelee.org/"/>
  <updated>2021-02-05T02:01:02.999Z</updated>
  <id>http://www.latelee.org/</id>
  
  <author>
    <name>李迟</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>nvidia TX2 使用 SDK Manager工具刷机记录</title>
    <link href="http://www.latelee.org/ml/nvidia-flash-to-tx2%EF%BC%8Dusing-sdkmanager.html"/>
    <id>http://www.latelee.org/ml/nvidia-flash-to-tx2%EF%BC%8Dusing-sdkmanager.html</id>
    <published>2021-02-05T16:00:00.000Z</published>
    <updated>2021-02-05T02:01:02.999Z</updated>
    
    <content type="html"><![CDATA[<p>本文为使用 nvidia 提供的 SDK Manager（本文称 sdkmanager） 工具下载、烧写 TX2 的记录。本文根据笔者长时间的摸索经历，以有限的经验对刷机过程及要点进行描述，不涉及 TX2 特性或功能或深度学习方面内容。    </p><a id="more"></a><h2 id="一、要点"><a href="#一、要点" class="headerlink" title="一、要点"></a>一、要点</h2><p>一些基础要点或要注意的事在此节说明。  </p><ul><li>TX2只支持HDMI接口，只有一个 usb 接口（要用 usbhub扩展）。使用 nvidia 原装 usb 线连接烧写。    </li><li>TX2有四个红色并排的按钮，开机按钮标注有POWER BTN，由其向左分别是Force Recovery Button、User Defined Button和Reset Button。在手动刷机情况下，要分别操作 Force Recovery Button 和 POWER BTN。见后文。  </li><li>sdkmanager 目前只有 Linux 版本，支持 ubuntu16.04 和 ubuntu18.04。使用大屏幕、大内存的好的机器，最好是物理机安装 ubuntu。如是虚拟机，连 usb 线时需要让虚拟机识别到 TX2。   </li><li>sdkmanager 集下载（系统镜像，软件包）、烧写（系统镜像，软件包）、卸载（软件包）、修复（软件包）功能。</li><li>sdkmanager 下载需要使用 nvidia 开发者账号，（免费）注册即可。  </li><li>sdkmanager 有 HOST 端和 TARGET 端之分，可按需下载烧写。如只烧写系统镜像或只安装软件。  </li><li>烧写 Linux 镜像后，需要在板子上做一些设置，如设置账号密码，连接WiFi等，进入系统后，有一网络设备默认IP为 192.168.55.1，该IP在 sdkmanager 中被使用。。  </li></ul><h2 id="二、过程"><a href="#二、过程" class="headerlink" title="二、过程"></a>二、过程</h2><h3 id="2-1-环境准备"><a href="#2-1-环境准备" class="headerlink" title="2.1 环境准备"></a>2.1 环境准备</h3><p>sdkmanager 目前只有 Linux 版本。可用 ubuntu16.04 和 ubuntu18.04 发行版。内存最低为8GB，屏幕分辨率 1440x900 以上。内存过小会卡，分辨率过低则界面显示不完整，经测试，在 ubuntu16.04 系统中运行时可点击”View”-&gt;”Zoom Out”缩小界面。<br>需要联网，因为要从 nvidia 官网下载软件包。<br>如果要烧写，则需要使用原装 usb 线连接板子和PC。  </p><h3 id="2-2-注册账号"><a href="#2-2-注册账号" class="headerlink" title="2.2 注册账号"></a>2.2 注册账号</h3><p>下载软件需要注册，地址：<a href="https://developer.nvidia.com/login">https://developer.nvidia.com/login</a> 。<br>注：登录时需要输入账号密码，并点击符合要求的图案（如飞机，车之类的），以证明登录者是人类。  </p><h3 id="2-3-安装运行-sdkmanager"><a href="#2-3-安装运行-sdkmanager" class="headerlink" title="2.3 安装运行 sdkmanager"></a>2.3 安装运行 sdkmanager</h3><p>之前使用 jetpack 工具下载烧写的，目前是使用 sdkmanager，下载地址为：<a href="https://developer.nvidia.com/embedded/jetpack">https://developer.nvidia.com/embedded/jetpack</a> 。安装方式有两种，一是用 SD 卡镜像，二是使用 sdkmanager，即<code>NVIDIA SDK Manager method</code>，TX2 使用方法二。<br>本文使用的文件为<code>sdkmanager_1.4.0-7363_amd64.deb</code>，md5为<code>535b9b2b41248e89b839b6f5a3acb185</code>。安装命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install .&#x2F;sdkmanager_1.4.0-7363_amd64.deb </span><br></pre></td></tr></table></figure><p>sdkmanager <strong>必须使用普通用户</strong>运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sdkmanager</span><br></pre></td></tr></table></figure><p>稍等片刻即可看到启动界面。如系统系统不满足最低要求会弹出提示框，如图1所示。<br><img src="/ml/nvidia-flash-to-tx2%EF%BC%8Dusing-sdkmanager/1.png" alt="图1"><br>点击Yes进入登录界面。如图2所示。<br><img src="/ml/nvidia-flash-to-tx2%EF%BC%8Dusing-sdkmanager/2.png" alt="图2"><br>第三个页面为离线包方式，适用已下载软件包情况，不用登录。第一页面为即本文所用的方式。点击Login，在自动打开的浏览器中输入账号，再输入密码，点击图案验证。建议保存密码减少操作。图3为已经验证即将登录的界面。<br><img src="/ml/nvidia-flash-to-tx2%EF%BC%8Dusing-sdkmanager/3.png" alt="图3">  </p><p>登录过程中，可能会遇到一些问题，如下：<br>1、提示<code>no SDKs available for your account</code>，网上有说法执行<code>sudo updatedb</code>可解决，笔者验证未成功。<br>2、提示<code>Failed to get client token</code>，重试多次未能解决，未知原因。<br>3、卡在<code>Loading and processing available products...</code>，重试多次可解决。  </p><h3 id="2-4-下载软件"><a href="#2-4-下载软件" class="headerlink" title="2.4 下载软件"></a>2.4 下载软件</h3><p>成功登录后进入第一步骤配置，如图4所示。<br><img src="/ml/nvidia-flash-to-tx2%EF%BC%8Dusing-sdkmanager/4.png" alt="图4"><br>主要有四项内容，第一为产品目录，即 Jetson，第二为硬件配置，分为主机端和目标板端，本文不使用主机端配置（目前没有需要在主机做开发），由于笔者连接了板子，故图4中已检测到 TX2。也可以手动点击右下角的<code>...</code>选择实际板子型号。第三为系统版本，目前为 4.5 版本。最后是 deepstream，版本为5.0，为可选项，笔者不想在后续单独安装，因此也选上了。  </p><p>点击“CONTINUE”进入第二步骤。如图5所示。<br><img src="/ml/nvidia-flash-to-tx2%EF%BC%8Dusing-sdkmanager/5.png" alt="图5"><br>软件包括了系统镜像和SDK两大类软件，默认全选，也可分别安装。页面底部有默认下载和安装目录，也可手动指定，默认目录不存在，会提示创建目录。勾选接受协议。如果只希望下载软件，则勾选<code>Download now, Install later.</code>。笔者建议勾选。因为下载十分耗时，且容易出错。<br>点击“CONTINUE”进入第三步骤。图6为即将下载的界面。<br><img src="/ml/nvidia-flash-to-tx2%EF%BC%8Dusing-sdkmanager/6.png" alt="图6">  </p><p>此时可在 TERMINAL 中查看日志，如图7所示。也可查看<code>~/.nvsdkm/sdkm.log</code>文件（<code>~/.nvsdkm</code>是 sdkmanager 日志所在目录）。<br><img src="/ml/nvidia-flash-to-tx2%EF%BC%8Dusing-sdkmanager/7.png" alt="图7">  </p><p>经过十分漫长的等待，完成下载，如图8所示。点击 FINISH 退出。<strong>如果下载、安装一并进行，下载完成后进入安装步骤，FINISH 表示最终的完成</strong>。<br><img src="/ml/nvidia-flash-to-tx2%EF%BC%8Dusing-sdkmanager/8.png" alt="图8">  </p><p>注：<br>1、下载十分耗时，而且容易出错，所以板子不用开机，也不用连接PC。<br>2、sdkmanager 下载速度与网络有关。<br>3、关于下载失败的终极解决方法：<strong>重试，多重试，多次重试，换台电脑试，换个网络再试，隔一段时间重试。</strong><br>4、笔者经过多次尝试，在 sdkmanager 中均无法完整下载，后想到一种笨方法。当 sdkmanager 下载失败时，在默认的下载目录 <code>/home/latelee/Downloads/nvidia/sdkm_downloads</code><br>中查看下载的软件包（有deb包、zip包等，未下载完成的以mtd结尾），再在 sdkmanager 日志中查看软件包的下载地址，一一列出。然后在 Windows 的浏览器中登录 nvidia官网，再粘贴下载地址下载（运行了某种工具以保证官方网站连接畅通）。共63个文件，大的有1.8GB，小的有数十KB。 </p><p>另外，在不同时候下载，个别软件包的版本不同，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NsightSystems-linux-public-2020.5.3.17-0256620.deb</span><br><span class="line">NsightSystems-linux-public-2020.4.2.18-f0b18f6.deb</span><br><span class="line"></span><br><span class="line">nvidia-l4t-jetson-multimedia-api_32.4.4-20201016123640_arm64.deb</span><br><span class="line">nvidia-l4t-jetson-multimedia-api_32.5.0-20210115151051_arm64.deb</span><br></pre></td></tr></table></figure><p>从软件包日期也可看到笔者进行较长时间的尝试。  </p><p>如有兴趣，可到<strong>附3：提示及日志</strong>的<strong>部分下载失败日志</strong>处查看失败日志。  </p><h3 id="2-5-安装软件"><a href="#2-5-安装软件" class="headerlink" title="2.5 安装软件"></a>2.5 安装软件</h3><p>这里的“软件”包括了系统（和驱动）以及 sdk 软件。对于系统而言，实际应该是“烧写”而不是安装。<br>系统镜像（OS镜像）和sdk可分开安装，如果在安装sdk出错，下次重试时，可取消系统的安装，节省时间。本文完全刷机，所以两者均安装。<br>烧写镜像前， sdkmanager 会创建OS镜像，默认位于<code>~/nvidia/nvidia_sdk</code>目录，如图9所示，第一进度条表示正在创建 Jetson OS 镜像。<br><img src="/ml/nvidia-flash-to-tx2%EF%BC%8Dusing-sdkmanager/9.png" alt="图9"><br>在此过程，也可点击 TERMINAL 查看日志，如图10所示。<br><img src="/ml/nvidia-flash-to-tx2%EF%BC%8Dusing-sdkmanager/10.png" alt="图10"><br>注意，从图10可看到下载目录为非默认目录，该目录就是笔者手动下载并拷贝到 Linux 虚拟机中的目录。<br>当 OS 镜像准备完毕后，出现烧写提示。方式有二，图11所示为自动方式，TX2 板子要开机，并且联网，输入 TX2 正在使用的账号密码，注意，IP地址不需要修改。<br><img src="/ml/nvidia-flash-to-tx2%EF%BC%8Dusing-sdkmanager/11.png" alt="图11"><br>当系统损坏无法启动时，可选择手动模式，如图12所示。<br><img src="/ml/nvidia-flash-to-tx2%EF%BC%8Dusing-sdkmanager/12.png" alt="图12"><br>本文选择自动方式（实际也尝试了手动方式），烧写过程比较耗时。如果超过时间，sdkmanager 会提示，如图13所示。<br><img src="/ml/nvidia-flash-to-tx2%EF%BC%8Dusing-sdkmanager/13.png" alt="图13"><br>烧写结束之后 TX2 会关机。如果使用虚拟机，此过程要保持鼠标在虚拟机内，以保证 TX2 总能被虚拟机识别。<br>TX2 重新启动后板子显示器出现系统配置界面，第一个界面为接受协议，如图14所示。<br><img src="/ml/nvidia-flash-to-tx2%EF%BC%8Dusing-sdkmanager/14.png" alt="图14"> </p><p>后续界面依次为：选择语言，选择键盘，连接WiFi（笔者手上没有多余网线，只能用WiFi），选择时区，账号密码（可选自动登录），Nvpmodel模式，除WiFi和账号密码要输入信息外，其它用默认即可。等待片刻自动重启，之后进入系统，此时已经有了基本可用的系统（当然还用不了cuda）。  </p><p>此时可在 TX2 系统中查看板子IP，网络设备 l4tbr0 的 IP 为 192.168.55.1，对应的，PC端网络设备 ens35u1i5 IP 为 192.168.55.100。两系统可互相 ping 通。  </p><p>系统镜像烧写成功后，sdkmanager 进入安装 sdk 阶段（sdk 可单独安装，过程相同）。如图15所示。<br><img src="/ml/nvidia-flash-to-tx2%EF%BC%8Dusing-sdkmanager/15.png" alt="图15"> </p><p>输入刚才设置的账号和密码。图16为正在安装sdk包界面。<br><img src="/ml/nvidia-flash-to-tx2%EF%BC%8Dusing-sdkmanager/16.png" alt="图16"> </p><p>再经过一段时间等待，安装成功，如图17所示，点击 FINISH 完成任务。<br><img src="/ml/nvidia-flash-to-tx2%EF%BC%8Dusing-sdkmanager/17.png" alt="图17"> </p><p>TX2 系统默认桌面如图18所示。<br><img src="/ml/nvidia-flash-to-tx2%EF%BC%8Dusing-sdkmanager/18.png" alt="图18">   </p><p>注：<br>本节步骤不一定反映实际情况，因为会经常中断。<br>烧写系统镜像过程如果断开，会从头开始，如果已经进行一半，此时系统可能会损坏，如是则要用手动模式。<br>耗时：在下载好软件包情况下，晚8点开始，至12点前结束，期间中断了3次。  </p><h3 id="2-6-验证程序"><a href="#2-6-验证程序" class="headerlink" title="2.6 验证程序"></a>2.6 验证程序</h3><p>前面刷机已经勾选了 DeepStream，可直接使用。进入 TX2 系统，查看 DeepStream 版本信息：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ deepstream-app --version-all</span><br><span class="line">2021-02-04 23:51:41.044864: I tensorflow&#x2F;stream_executor&#x2F;platform&#x2F;default&#x2F;dso_loader.cc:48] Successfully opened dynamic library libcudart.so.10.2</span><br><span class="line">deepstream-app version 5.0.0</span><br><span class="line">DeepStreamSDK 5.0.0</span><br><span class="line">CUDA Driver Version: 10.2</span><br><span class="line">CUDA Runtime Version: 10.2</span><br><span class="line">TensorRT Version: 7.1</span><br><span class="line">cuDNN Version: 8.0</span><br><span class="line">libNVWarp360 Version: 2.0.1d3</span><br></pre></td></tr></table></figure><p>可用如下命令查看和nvidia有关的插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gst-inspect-1.0 -a | grep -i nvidia</span><br></pre></td></tr></table></figure><p>编译、运行自带的示例工程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;opt&#x2F;nvidia&#x2F;deepstream&#x2F;deepstream&#x2F;sources&#x2F;apps&#x2F;sample_apps&#x2F;deepstream-test1</span><br><span class="line">make</span><br><span class="line">.&#x2F;deepstream-test1-app &#x2F;opt&#x2F;nvidia&#x2F;deepstream&#x2F;deepstream&#x2F;samples&#x2F;streams&#x2F;sample_720p.h264 </span><br></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Now playing: &#x2F;opt&#x2F;nvidia&#x2F;deepstream&#x2F;deepstream&#x2F;samples&#x2F;streams&#x2F;sample_720p.h264</span><br><span class="line"></span><br><span class="line">Using winsys: x11 </span><br><span class="line">Opening in BLOCKING MODE</span><br><span class="line">Opening in BLOCKING MODE </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>效果如图19所示。<br><img src="/ml/nvidia-flash-to-tx2%EF%BC%8Dusing-sdkmanager/19.png" alt="图19">  </p><h2 id="三、参考资源"><a href="#三、参考资源" class="headerlink" title="三、参考资源"></a>三、参考资源</h2><p>sdkmanager官方使用说明： <a href="https://docs.nvidia.com/sdk-manager/install-with-sdkm-jetson/index.html">https://docs.nvidia.com/sdk-manager/install-with-sdkm-jetson/index.html</a><br>sdkmanager配置：<a href="https://docs.nvidia.com/sdk-manager/sdkm-settings/index.html">https://docs.nvidia.com/sdk-manager/sdkm-settings/index.html</a><br>NVIDIA Jetson TX2 上手指南：<a href="https://blog.csdn.net/qq_36782182/article/details/91488284">https://blog.csdn.net/qq_36782182/article/details/91488284</a>  </p><h2 id="附1：尝试"><a href="#附1：尝试" class="headerlink" title="附1：尝试"></a>附1：尝试</h2><p>本节记录个人的尝试，流行话叫“踩坑”。<br>无物理机，故使用虚拟机，但内存不够大，屏幕不够大（本本是7、8年前买的），分辨率和内存满足不了 sdkmanager 最低要求。<br>先安装使用ubuntu18.04，但 sdkmanager 无法缩小，操作不便，找不到同意协议选项，无法执行。<br>改用之前在 VirtualBox 上安装的 lubuntu1604，其资源占用稍少，但亦无缩小，多次重启，提示<code>The virtual machine &#39;lubuntu1604&#39; has terminated unexpectedly during startup with exit code 1</code>，所有 VirtualBox 虚拟机系统损坏无法使用。<br>最后用 ubuntu16.04，点击标题<code>View</code>中进行缩小。可顺利进行。  </p><h2 id="附2：成果"><a href="#附2：成果" class="headerlink" title="附2：成果"></a>附2：成果</h2><p>1、刷机过程生成的日志已存放 github 备份。<br>2、下载的软件包只在 TX2 测试通过，约6GB，已整合为 docker 镜像，并上传至阿里云仓库备份。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t registry.cn-hangzhou.aliyuncs.com&#x2F;latelee&#x2F;deepstream:tx2 .</span><br><span class="line">docker push registry.cn-hangzhou.aliyuncs.com&#x2F;latelee&#x2F;deepstream:tx2</span><br></pre></td></tr></table></figure><p>镜像说明：包括 TAEGET 端所有的包以及部分 HOST 端的包。运行后在容器的 <code>/nvidia</code> 目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name foobar registry.cn-hangzhou.aliyuncs.com&#x2F;latelee&#x2F;deepstream:tx2 sh</span><br><span class="line">docker exec -it foobar sh</span><br><span class="line">ls &#x2F;nvidia</span><br></pre></td></tr></table></figure><p>逐一拷贝：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir my_download</span><br><span class="line">docker cp foobar:&#x2F;nvidia&#x2F;Tegra_Linux_Sample-Root-Filesystem_R32.5.0_aarch64.tbz2 my_download</span><br><span class="line">docker cp foobar:&#x2F;nvidia&#x2F;cuda-repo-l4t-10-2-local-10.2.89_1.0-1_arm64.deb my_download</span><br><span class="line">其它文件类似</span><br></pre></td></tr></table></figure><p>Dockerfile：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM latelee&#x2F;busybox </span><br><span class="line">RUN mkdir &#x2F;nvidia  </span><br><span class="line">COPY cuda-repo-cross-aarch64-10-2-local-10.2.89_1.0-1_all.deb  &#x2F;nvidia</span><br><span class="line">COPY cuda-repo-l4t-10-2-local-10.2.89_1.0-1_arm64.deb  &#x2F;nvidia</span><br><span class="line">其它文件类似</span><br></pre></td></tr></table></figure><h3 id="附3：提示及日志"><a href="#附3：提示及日志" class="headerlink" title="附3：提示及日志"></a>附3：提示及日志</h3><p>启动显示系统最低要求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Warning</span><br><span class="line">Could not detect SDK Manager&#39;s minimal system requirement(s):</span><br><span class="line"> - Minimum of 7.5GB of RAM (4.74GB detected)</span><br><span class="line"> - Screen resolution equal or larger than 1440x900 (800x600 detected)</span><br><span class="line"></span><br><span class="line">Do you wish to continue?</span><br></pre></td></tr></table></figure><p>部分下载失败日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">未授权的（一般是之前已经登录，但过期了）</span><br><span class="line">01:49:33 : CUDA on Host: download https:&#x2F;&#x2F;developer.nvidia.com&#x2F;assets&#x2F;embedded&#x2F;secure&#x2F;tools&#x2F;files&#x2F;jetpack-sdks&#x2F;jetpack-4.4.1&#x2F;JETPACK_441_b50&#x2F;ubuntu1604&#x2F;cuda-repo-ubuntu1604-10-2-local-10.2.89-440.40_1.0-1_amd64.deb failed, retrying 1...</span><br><span class="line">01:49:33 INFO: CUDA on Host: start to download https:&#x2F;&#x2F;developer.nvidia.com&#x2F;assets&#x2F;embedded&#x2F;secure&#x2F;tools&#x2F;files&#x2F;jetpack-sdks&#x2F;jetpack-4.4.1&#x2F;JETPACK_441_b50&#x2F;ubuntu1604&#x2F;cuda-repo-ubuntu1604-10-2-local-10.2.89-440.40_1.0-1_amd64.deb to &#x2F;home&#x2F;ubuntu&#x2F;Downloads&#x2F;nvidia&#x2F;sdkm_downloads&#x2F;cuda-repo-ubuntu1604-10-2-local-10.2.89-440.40_1.0-1_amd64.deb</span><br><span class="line">01:49:36 ERROR: CUDA on Host: DevZone get download url failed: HTTPError: Response code 401 (Unauthorized).</span><br><span class="line">01:49:36 ERROR: CUDA on Host: Download &#39;CUDA on Host&#39; failure</span><br><span class="line">01:49:36 ERROR: CUDA on Host: DevZone get download url failed: HTTPError: Response code 401 (Unauthorized).</span><br><span class="line">01:49:36 ERROR: CUDA on Host: Download &#39;CUDA on Host&#39; failure</span><br><span class="line">01:49:36 ERROR: CUDA on Host: download failed</span><br><span class="line"></span><br><span class="line">网络断开的</span><br><span class="line">22:02:21 : CUDA on Host: download https:&#x2F;&#x2F;developer.nvidia.com&#x2F;assets&#x2F;embedded&#x2F;secure&#x2F;tools&#x2F;files&#x2F;jetpack-sdks&#x2F;jetpack-4.4.1&#x2F;JETPACK_441_b50&#x2F;ubuntu1604&#x2F;cuda-repo-ubuntu1604-10-2-local-10.2.89-440.40_1.0-1_amd64.deb failed, retrying 1...</span><br><span class="line">22:02:21 INFO: CUDA on Host: start to download https:&#x2F;&#x2F;developer.nvidia.com&#x2F;assets&#x2F;embedded&#x2F;secure&#x2F;tools&#x2F;files&#x2F;jetpack-sdks&#x2F;jetpack-4.4.1&#x2F;JETPACK_441_b50&#x2F;ubuntu1604&#x2F;cuda-repo-ubuntu1604-10-2-local-10.2.89-440.40_1.0-1_amd64.deb to &#x2F;home&#x2F;ubuntu&#x2F;Downloads&#x2F;nvidia&#x2F;sdkm_downloads&#x2F;cuda-repo-ubuntu1604-10-2-local-10.2.89-440.40_1.0-1_amd64.deb</span><br><span class="line">22:02:37 ERROR: CUDA on Host: DevZone get download url failed: RequestError: Client network socket disconnected before secure TLS connection was established.</span><br><span class="line">22:02:37 ERROR: CUDA on Host: Download &#39;CUDA on Host&#39; failure</span><br><span class="line">22:02:37 ERROR: CUDA on Host: DevZone get download url failed: RequestError: Client network socket disconnected before secure TLS connection was established.</span><br><span class="line">22:02:37 ERROR: CUDA on Host: Download &#39;CUDA on Host&#39; failure</span><br><span class="line">22:02:37 ERROR: CUDA on Host: download failed</span><br><span class="line"></span><br><span class="line">网络有问题的</span><br><span class="line">22:42:24 INFO: DeepStream: start to download https:&#x2F;&#x2F;developer.nvidia.com&#x2F;assets&#x2F;embedded&#x2F;secure&#x2F;tools&#x2F;files&#x2F;jetpack-sdks&#x2F;jetpack-4.4.1&#x2F;JETPACK_441_b50_DEEPSTREAM&#x2F;deepstream-5.0_5.0.1-1_arm64.deb to &#x2F;home&#x2F;ubuntu&#x2F;Downloads&#x2F;nvidia&#x2F;sdkm_downloads&#x2F;deepstream-5.0_5.0.1-1_arm64.deb</span><br><span class="line">22:43:31 ERROR: DeepStream: Head request failed on host: ECONNRESET. Error: socket hang uphttps:&#x2F;&#x2F;developer.download.nvidia.com&#x2F;assets&#x2F;embedded&#x2F;secure&#x2F;tools&#x2F;files&#x2F;jetpack-sdks&#x2F;jetpack-4.4.1&#x2F;JETPACK_441_b50_DEEPSTREAM&#x2F;deepstream-5.0_5.0.1-1_arm64.deb?IQOvXtJ6q2h7wEVW_SUReWVsdQk8i0duzlCSFmayyqE8duPuyZPhND_O1S6yd6hoXuobjaYpB8MKsg-8fadWWALJQBs8m_SAwYpFD9-XvCrw1tt1CCtlt7547_3c0P3GoXqi85jW_LogPq06flT9gCxtYNxjhENTzdQA80uZeV3ZEKh4PUJO9Gvtl1aqWzBugJ1W1T6PwrLIM-GWXQQR3p3idZlx-OltlatQEFGv2cyhXv-Ty2l8dg</span><br><span class="line">22:43:31 ERROR: DeepStream: Download &#39;DeepStream&#39; failure</span><br><span class="line">22:43:31 ERROR: DeepStream: Head request failed on host: ECONNRESET. Error: socket hang uphttps:&#x2F;&#x2F;developer.download.nvidia.com&#x2F;assets&#x2F;embedded&#x2F;secure&#x2F;tools&#x2F;files&#x2F;jetpack-sdks&#x2F;jetpack-4.4.1&#x2F;JETPACK_441_b50_DEEPSTREAM&#x2F;deepstream-5.0_5.0.1-1_arm64.deb?IQOvXtJ6q2h7wEVW_SUReWVsdQk8i0duzlCSFmayyqE8duPuyZPhND_O1S6yd6hoXuobjaYpB8MKsg-8fadWWALJQBs8m_SAwYpFD9-XvCrw1tt1CCtlt7547_3c0P3GoXqi85jW_LogPq06flT9gCxtYNxjhENTzdQA80uZeV3ZEKh4PUJO9Gvtl1aqWzBugJ1W1T6PwrLIM-GWXQQR3p3idZlx-OltlatQEFGv2cyhXv-Ty2l8dg</span><br><span class="line">22:43:31 ERROR: DeepStream: Download &#39;DeepStream&#39; failure</span><br><span class="line">22:43:31 ERROR: DeepStream: download failed</span><br><span class="line">22:43:31 ERROR: DeepStream: Download &#39;DeepStream&#39; failure</span><br><span class="line">22:43:31 ERROR: DeepStream: download failed</span><br><span class="line"></span><br><span class="line">拒绝连接的</span><br><span class="line">22:55:51 INFO: CUDA on Host: start to download https:&#x2F;&#x2F;developer.nvidia.com&#x2F;assets&#x2F;embedded&#x2F;secure&#x2F;tools&#x2F;files&#x2F;jetpack-sdks&#x2F;jetpack-4.4.1&#x2F;JETPACK_441_b50&#x2F;ubuntu1604&#x2F;cuda-repo-ubuntu1604-10-2-local-10.2.89-440.40_1.0-1_amd64.deb to &#x2F;home&#x2F;ubuntu&#x2F;Downloads&#x2F;nvidia&#x2F;sdkm_downloads&#x2F;cuda-repo-ubuntu1604-10-2-local-10.2.89-440.40_1.0-1_amd64.deb</span><br><span class="line">22:55:51 ERROR: CUDA on Host: The .mtd file is corrupt. Start a new download.</span><br><span class="line">22:55:51 ERROR: CUDA on Host: Download &#39;CUDA on Host&#39; failure</span><br><span class="line">22:55:51 ERROR: CUDA on Host: The .mtd file is corrupt. Start a new download.</span><br><span class="line">22:55:51 ERROR: CUDA on Host: Download &#39;CUDA on Host&#39; failure</span><br><span class="line">22:55:51 ERROR: CUDA on Host: download failed</span><br><span class="line"></span><br><span class="line">22:57:14 ERROR: DeepStream: DevZone get download url failed: RequestError: connect ECONNREFUSED 128.1.83.20:443.</span><br><span class="line">22:57:14 ERROR: DeepStream: Download &#39;DeepStream&#39; failure</span><br><span class="line">22:57:14 ERROR: DeepStream: DevZone get download url failed: RequestError: connect ECONNREFUSED 128.1.83.20:443.</span><br><span class="line">22:57:14 ERROR: DeepStream: Download &#39;DeepStream&#39; failure</span><br><span class="line">22:57:14 ERROR: DeepStream: download failed</span><br><span class="line"></span><br><span class="line">连接重置的</span><br><span class="line">00:05:35 ERROR: DeepStream: Head request failed on host: ECONNRESET. Error: read ECONNRESEThttps:&#x2F;&#x2F;developer.download.nvidia.com&#x2F;assets&#x2F;embedded&#x2F;secure&#x2F;tools&#x2F;files&#x2F;jetpack-sdks&#x2F;jetpack-4.4.1&#x2F;JETPACK_441_b50_DEEPSTREAM&#x2F;deepstream-5.0_5.0.1-1_arm64.deb?FlpOvCmigTA5N-TqbXBm-hfRtR6pMsu_xxBikJ2lu_xusmVBC6WA4nupxDJwHA3jAjOiheJW8KuUzRs5xGE-u4HwBi98x5Xc_2pdtZURC-MmgH4a48ptyI0Xy9xkMayuLRdKXdK8hdINsiIlgUGf8uZbtkvFE_KJHO54WgiuyEPLdeoCE3K6AXPvQ0mdYjhMMYzGKrZR04YnZXJp_kZ5lH051Srg7VadNK1_X_g6UxPRuQWwId3cDQ</span><br><span class="line">00:05:35 ERROR: DeepStream: Download &#39;DeepStream&#39; failure</span><br><span class="line">00:05:35 ERROR: DeepStream: download failed</span><br><span class="line">00:05:35 : DeepStream: download https:&#x2F;&#x2F;developer.nvidia.com&#x2F;assets&#x2F;embedded&#x2F;secure&#x2F;tools&#x2F;files&#x2F;jetpack-sdks&#x2F;jetpack-4.4.1&#x2F;JETPACK_441_b50_DEEPSTREAM&#x2F;deepstream-5.0_5.0.1-1_arm64.deb failed, retrying 1...</span><br><span class="line"></span><br><span class="line">其它未列举的</span><br></pre></td></tr></table></figure><p>烧写过程中出错，已有下载的包，且md5sum正确，但提示出错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">23:30:53 INFO: NVIDIA Container Runtime with Docker integration (Beta): verifying checksum of &#x2F;home&#x2F;latelee&#x2F;Downloads&#x2F;nvidia&#x2F;my_download&#x2F;nvidia-container-runtime_3.1.0-1_arm64.deb</span><br><span class="line">23:30:53 INFO: NVIDIA Container Runtime with Docker integration (Beta): Found file &#x2F;home&#x2F;latelee&#x2F;Downloads&#x2F;nvidia&#x2F;my_download&#x2F;nvidia-container-runtime_3.1.0-1_arm64.deb with correct checksum, skip downloading.</span><br><span class="line">23:30:53 INFO: NVIDIA Container Runtime with Docker integration (Beta): verifying checksum of &#x2F;home&#x2F;latelee&#x2F;Downloads&#x2F;nvidia&#x2F;my_download&#x2F;nvidia-docker2_2.2.0-1_all.deb</span><br><span class="line">23:30:53 INFO: NVIDIA Container Runtime with Docker integration (Beta): Found file &#x2F;home&#x2F;latelee&#x2F;Downloads&#x2F;nvidia&#x2F;my_download&#x2F;nvidia-docker2_2.2.0-1_all.deb with correct checksum, skip downloading.</span><br><span class="line">23:31:58 SUMMARY: NVIDIA Container Runtime with Docker integration (Beta): Depends on failed component</span><br><span class="line">23:31:58 SUMMARY: NVIDIA Container Runtime with Docker integration (Beta): Depends on failed component</span><br><span class="line">23:31:58 SUMMARY: NVIDIA Container Runtime with Docker integration (Beta): Depends on failed component</span><br><span class="line"></span><br><span class="line">3:30:53 INFO: Multimedia API: verifying checksum of &#x2F;home&#x2F;latelee&#x2F;Downloads&#x2F;nvidia&#x2F;my_download&#x2F;nvidia-l4t-jetson-multimedia-api_32.5.0-20210115151051_arm64.deb</span><br><span class="line">23:30:54 INFO: Multimedia API: Found file &#x2F;home&#x2F;latelee&#x2F;Downloads&#x2F;nvidia&#x2F;my_download&#x2F;nvidia-l4t-jetson-multimedia-api_32.5.0-20210115151051_arm64.deb with correct checksum, skip downloading.</span><br><span class="line">23:31:58 SUMMARY: Multimedia API: Depends on failed component</span><br><span class="line">23:31:58 SUMMARY: Multimedia API: Depends on failed component</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>个人猜测：没有完成所有包的检测，没有做标记，因此有些包的依赖没有记录，所以提示出错。多次从头重试可解决。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文为使用 nvidia 提供的 SDK Manager（本文称 sdkmanager） 工具下载、烧写 TX2 的记录。本文根据笔者长时间的摸索经历，以有限的经验对刷机过程及要点进行描述，不涉及 TX2 特性或功能或深度学习方面内容。    &lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://www.latelee.org/category/ml/"/>
    
    
    <category term="nvidia" scheme="http://www.latelee.org/tag/nvidia/"/>
    
  </entry>
  
  <entry>
    <title>新年新计划-2021年</title>
    <link href="http://www.latelee.org/the-life/2021-new-plan.html"/>
    <id>http://www.latelee.org/the-life/2021-new-plan.html</id>
    <published>2021-01-31T16:00:00.000Z</published>
    <updated>2021-02-05T02:01:02.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>无意间回顾博客目录，发现上一篇新年计划，是2015年2月份写的。一年之计在于春，也开始尝试写写计划。  </p><a id="more"></a><h2 id="心态方面"><a href="#心态方面" class="headerlink" title="心态方面"></a>心态方面</h2><p>承认自己是个普通人，认知有限。赚不到认知以外的钱，学不了能力之外的技术。<br>不用太理会别人的意见和看法。（注：这里有个“太”字）<br>不与不在同一频道的人争论。  </p><h2 id="工作方面"><a href="#工作方面" class="headerlink" title="工作方面"></a>工作方面</h2><p>认真工作，提升存在感。注：今年只跟部门一把手聊过两回，一是试用期考核，领导问我工作怎样。二是在电梯，领导看到我的破包叫我换。<br>和同事和睦相处，对待正式同事，要特别热情友好。<br>对于自己擅长的领域，适当在同事面前展示一二。<br>笑脸迎人，骂不还口，不带情绪办公。争取加班随叫随到，不能者，亦解释。（注：心里骂几句亦可）  </p><h2 id="技能提升方面"><a href="#技能提升方面" class="headerlink" title="技能提升方面"></a>技能提升方面</h2><p>以家庭为重心，少接不熟悉领域的私活。尽量少熬夜，防止寿命减少。<br>阅读几本专业书，可慢，贵在理解和应用。不贪快，不贪多。暂有目标：《重构》第2版。<br>考证：架构师。以考促学，研究和架构，分布式有关的领域基础知识。（注1：是“基础知识”；注2：没提一定必须考过）<br>写一篇论文发表。评一下职称。（注：论文是“发表”，职称没提一定要得）  </p><h2 id="家庭生活方面"><a href="#家庭生活方面" class="headerlink" title="家庭生活方面"></a>家庭生活方面</h2><p>骂不还口。如有脾气或生闷气，不能超过3天。<br>勤力做家务，及时做家务。<br>巩固并提升做菜水平，注重家常。<br>对待小孩，该打还得打，该讲道理要讲，该宠也得宠。<br>给李大锤练耐力（跑步），胆量（未想好）。陪大锤爬山、看夕阳。<br>巩固并继续诗歌（诗词）的教育。开始白话的训练。<br>争取带李大妞去公园玩。  </p><p>李迟 2021.02.01</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;无意间回顾博客目录，发现上一篇新年计划，是2015年2月份写的。一年之计在于春，也开始尝试写写计划。  &lt;/p&gt;</summary>
    
    
    
    <category term="生活掠影" scheme="http://www.latelee.org/category/the-life/"/>
    
    
    <category term="新年计划" scheme="http://www.latelee.org/tag/%E6%96%B0%E5%B9%B4%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>几个共享方法的小结</title>
    <link href="http://www.latelee.org/code-life/backup-works.html"/>
    <id>http://www.latelee.org/code-life/backup-works.html</id>
    <published>2021-01-30T16:00:00.000Z</published>
    <updated>2021-02-05T02:01:02.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文涉及的“共享”实际是不同系统，不同网络，不同地点的文件共享。比如网盘。<br>文中所涉，几乎是笔者使用（过）的方式。随意写写，不一定正确。    </p><a id="more"></a><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在公司编写完的代码，如何方便在家里也能更新到？<br>nvidia的cuda库，国内下载慢，如何下载？<br>某台远程电脑可以到外网下载，下载完后，如何传到自己电脑？<br>k8s部署所用的gcr如何下载？<br>（不）知网的论文如何下载？  </p><h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><h3 id="网盘"><a href="#网盘" class="headerlink" title="网盘"></a>网盘</h3><p>常用方式，可共享给他人，或自用。<br>优点：<br>缺点：云盘为第三方，不一定能随时提供服务，甚至断供。    </p><h3 id="云主机"><a href="#云主机" class="headerlink" title="云主机"></a>云主机</h3><p>使用个人云主机做中转，只要支持ssh或可用浏览器，即可实现共享。<br>云主机自建http服务器，可用浏览器下载。<br>优点：<br>缺点：</p><h3 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h3><p>如gitlab和github等，可在一网络（系统）提交，在另一网络（系统）更新，完成共享。  </p><h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><p>利用dockerhub，在将需要共享的文件做成docker镜像，再上传到网络，再在另一网络（系统）下载。<br>利用dockerhub，在dockerfile中从外网下载，设置自动构建或手动触发，完成docker镜像时，即可下载。<br>如不涉及外网，可使用阿里云docker仓库，添加加速地址，提升速度。  </p><p>如果体积大，构建时，可在dockerfile逐条命令拷贝，这样逐层下载。  </p><p>案例：<br>1.某年安装 cuda 驱动，使用某雷下载，看体积似乎完整，但安装只有部分成功。最终发现md5sum不一致（耗时几天才发现此问题）。解决：编写Dockefile，根据cuda地址下载。提交github，在dockerhub触发构建，生成镜像，下载镜像，运行，从中取文件。    </p><h3 id="墙里墙外"><a href="#墙里墙外" class="headerlink" title="墙里墙外"></a>墙里墙外</h3><p>墙太高了，需要使用梯子，或自建，或购买。如google搜索或google代码，golang有些文档和代码亦在外网。  </p><p>国内一些大厂有镜像网站，可同步国外资源。如淘宝的npm。如ubuntu官方会提供部分大学镜像网站。      </p><p>一些开源项目可能同时在github上有镜像仓库（有的甚至在gitee上也有镜像仓库），可用之。  </p><p>国内一些教育机构（如图书馆）、学校购买了数据库，可下载论文/专利。一般需要注册。（如笔者的图书馆证已经八、九年历史时，虽然证不见了，但账号依然能用。当年独自一人去，后陪女朋友去，现陪大锤去）  </p><p>联系学校老师学长学姐学弟学妹帮忙。  </p><h2 id="文字共享"><a href="#文字共享" class="headerlink" title="文字共享"></a>文字共享</h2><p>文字有纸质的，也有电子的。<br>平时在口袋或背包里放纸和笔，方便记录。有些情况用手机记录方便。<br>涉及金钱时一般写到餐纸上，方便销毁。<br>零散性的东西，可写在github的issue或一些博客平台。<br>系统性的东西，可记云笔记。  </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;本文涉及的“共享”实际是不同系统，不同网络，不同地点的文件共享。比如网盘。&lt;br&gt;文中所涉，几乎是笔者使用（过）的方式。随意写写，不一定正确。    &lt;/p&gt;</summary>
    
    
    
    <category term="代码生活" scheme="http://www.latelee.org/category/code-life/"/>
    
    
  </entry>
  
  <entry>
    <title>工作学习资料备份记录</title>
    <link href="http://www.latelee.org/code-life/backup-works.html"/>
    <id>http://www.latelee.org/code-life/backup-works.html</id>
    <published>2021-01-25T16:00:00.000Z</published>
    <updated>2021-02-05T02:01:02.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>毕业后一直有整理备份的习惯，但不够全面。那一年租房失窃，电脑相机被偷，毕业设计资料和代码全部丢失——那时还没有备份到网络，自此对本地备份的风险有一定认识。后来慢慢迁移到云端，也使用了云笔记。近日，所用的工作电脑固态硬盘损坏，先是windows系统提示备份，接着使用软件扫描硬盘，突然蓝屏，此后无法启动系统，无法访问硬盘。报修，三天后结论是修复不了。根据扫描结果，固态硬盘才通电使用1000小时，就如此挂了，想不明白是什么原因。幸好刚到公司半年左右，积累的资料不多，也没负责重大项目，手上2~3个工程只损失了几天的代码量，可凭记忆手动恢复。但前辈留下的非常多的工作资料就没有了。   </p><p>本文以个人角度记录目录分类和备份方法。  </p><a id="more"></a><h2 id="一些习惯"><a href="#一些习惯" class="headerlink" title="一些习惯"></a>一些习惯</h2><p>原看不惯创建目录使用数字形式，但后来发现挺好的——只要不过份。<br>目录按大类划分。如“公司文档”、“资料”、“开发文档”、“问题集”、“事务”、“项目”。<br>其中公司文档为制度类文件，考勤表，考核表。事务为小任务（如临时任务，维护任务），项目为大任务，时间跨度长。  </p><p>目录可细分，如“事务”类，可按“1 xxx”、“2 xxx”、“3 xxx”排序，或按年份+日期排序。对于类型相似的，可用前缀区别。  </p><p>代码类使用“workshop”、“project”等大目录，<strong>保持目录全为英文</strong>。设置虚拟机的共享目录亦为代码所在目录，如此一来，一份代码，多处使用。实例：<code>E://workshop/project/</code>包含c++工程、MFC工程、nodejs工程、golang工程、Delphi工程，对于xp虚拟机，只使用Delphi工程；linux虚拟机，使用c++、golang工程。  </p><h2 id="一些方法"><a href="#一些方法" class="headerlink" title="一些方法"></a>一些方法</h2><p>根据工作内容划分几大类。总体原则：能放云上放之，涉密放内部仓库。<br>版本管理争取及时提交。  </p><h3 id="代码类"><a href="#代码类" class="headerlink" title="代码类"></a>代码类</h3><p>使用版本管理，如git为主，兼顾svn。<br>工作工程，在公司内部个人账号创建仓库，尽量每天下班提交，允许有调试内容，但日志需写清楚。<br>如果是多人协作项目，向领导请示，可先在个人账号做一临时仓库，后再同步到主仓库。  </p><h3 id="文档类"><a href="#文档类" class="headerlink" title="文档类"></a>文档类</h3><p>使用云盘，如百度。将日常工作文档目录放置其中。注意不能太大，否则同步耗时。<br>考虑自建，如NextClound，已搭建有服务，但云主机容量是个问题。<br>文档类别：<br>正式文档，归入版本管理。<br>个人维护文档：归入版本管理。<br>日常文档，如专利申请，工作汇报等等，云盘。<br>公司制度，资料：云盘。<br>收集资料：云盘。  </p><h3 id="小笔记类"><a href="#小笔记类" class="headerlink" title="小笔记类"></a>小笔记类</h3><p>使用云笔记。如evernote、有道。不涉密者，如数据库常用sql语句，业务基础，问题排查，等等，可放之。      </p><h3 id="个人类"><a href="#个人类" class="headerlink" title="个人类"></a>个人类</h3><p>下面是个人学习研究的记录。<br>个人学习或实践的东西，一般会写文章/笔记/小结。不涉密都会公开，放github仓库，博客使用hexo构建。目前已经创建较完整的目录，涉及各方面，日常使用notepad++或vs code编辑，完成当成一个工程管理，提交文件后，自动触发ci构建并上传到云主机，从而完成网站更新。<br>另外一些不可公开资源或代码（非公司），存放于github私有仓库。<br>对于不同编程语言，学习时有积累的，使用<code>xxx_test</code>形式仓库名称，如<code>shell_test</code>、<code>golang_test</code>、<code>nodejs_test</code>，等等。<br>有些杂记放到 <a href="https://github.com/cststudio/csthinking/issues">https://github.com/cststudio/csthinking/issues</a> 上面。如读书笔记（零散的）、共享资源、想法、思路、要做的事，等等。  </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;毕业后一直有整理备份的习惯，但不够全面。那一年租房失窃，电脑相机被偷，毕业设计资料和代码全部丢失——那时还没有备份到网络，自此对本地备份的风险有一定认识。后来慢慢迁移到云端，也使用了云笔记。近日，所用的工作电脑固态硬盘损坏，先是windows系统提示备份，接着使用软件扫描硬盘，突然蓝屏，此后无法启动系统，无法访问硬盘。报修，三天后结论是修复不了。根据扫描结果，固态硬盘才通电使用1000小时，就如此挂了，想不明白是什么原因。幸好刚到公司半年左右，积累的资料不多，也没负责重大项目，手上2~3个工程只损失了几天的代码量，可凭记忆手动恢复。但前辈留下的非常多的工作资料就没有了。   &lt;/p&gt;
&lt;p&gt;本文以个人角度记录目录分类和备份方法。  &lt;/p&gt;</summary>
    
    
    
    <category term="代码生活" scheme="http://www.latelee.org/category/code-life/"/>
    
    
  </entry>
  
  <entry>
    <title>一个项目工程的重构小结</title>
    <link href="http://www.latelee.org/code-life/refactor-a-project.html"/>
    <id>http://www.latelee.org/code-life/refactor-a-project.html</id>
    <published>2021-01-16T16:00:00.000Z</published>
    <updated>2021-02-05T02:01:02.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首次看到移交到我手上的C++工程那个7千多行代码的文件时，既佩服又担心，前辈的构架能力让我甘拜下风，同时担心能不能胜任。<br>在研究源码的时候，也解决几个线上遗留的问题。愈发觉得有重构的必要——因为这将是我负责的代码。  </p><a id="more"></a><h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><h3 id="重构原则"><a href="#重构原则" class="headerlink" title="重构原则"></a>重构原则</h3><p>不完全重构——那叫重写，一是否定了前辈的功劳，二是接触不久业务不熟，风险大。<br>因此总体原则是逐步重构，部分重构块——比如核心模式，一些算法优化。对于整体流程和部分魔幻式代码，不敢动。<br>在重构过程中，顺便编写测试用例，以保证重构前后结果一致。  </p><h3 id="重构方法"><a href="#重构方法" class="headerlink" title="重构方法"></a>重构方法</h3><p>参数检查及出错处理，统一提前到初始化接口，即新建Init函数。原始系统在代码深处的不同地方做判断。出错尽早返回，不使用深嵌套。<br>参数统一化。如时间，传入为“yyy-MM-ddThh:mm:ss”形式，在代码中需要时间差的地方，转换为time_t格式，再计算。现统一在初始化接口中先转换。在最终转出时间，再转换为字符串。<br>去掉冗余不必要的多余算法步骤。<br>最短路径，在找到终点节点时，即返回，不用再遍历，节省时间。<br>深入研究最短路径的业务使用，调整计算步骤，减少遍历时次数。<br>将部分 C 风格的代码必为 C++ 风格（非全部）。<br>在部分结构体中添加构造函数，去掉 malloc 方式申请内存以及用 memset 初始化，设置好字段默认值，避免多处单独字段的赋值。  </p><p>添加 yaml 配置文件，将编译依赖改为运行时依赖。    </p><p>添加结构体比较函数，输出不同字段，方便新旧接口的对比。  </p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>不拘泥于语言本身，如 C++ 代码也可以用 printf 输出，一是笔者习惯，二是格式化比 cout 容易写。<br>添加额外的测试用例，方便实验测试人员参考。  </p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>耗时和内存占用均有所减少。新旧接口的运行，原接口平均为25ms，新接口为3ms。 </p><h2 id="未解决问题"><a href="#未解决问题" class="headerlink" title="未解决问题"></a>未解决问题</h2><p>同一个接口，根据时间的不同，使用两套不同命名空间的参数，未找到好的解决办法。  </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;首次看到移交到我手上的C++工程那个7千多行代码的文件时，既佩服又担心，前辈的构架能力让我甘拜下风，同时担心能不能胜任。&lt;br&gt;在研究源码的时候，也解决几个线上遗留的问题。愈发觉得有重构的必要——因为这将是我负责的代码。  &lt;/p&gt;</summary>
    
    
    
    <category term="代码生活" scheme="http://www.latelee.org/category/code-life/"/>
    
    
    <category term="问题集" scheme="http://www.latelee.org/tag/%E9%97%AE%E9%A2%98%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>nvidia示例</title>
    <link href="http://www.latelee.org/ml/nvidia-sample.html"/>
    <id>http://www.latelee.org/ml/nvidia-sample.html</id>
    <published>2021-01-11T05:20:00.000Z</published>
    <updated>2021-02-05T02:01:03.015Z</updated>
    
    <content type="html"><![CDATA[<p>nvidia示例。</p><a id="more"></a><h2 id="安装-deepstream-SDK"><a href="#安装-deepstream-SDK" class="headerlink" title="安装 deepstream SDK"></a>安装 deepstream SDK</h2><h3 id="方法一：使用-sdkmanager"><a href="#方法一：使用-sdkmanager" class="headerlink" title="方法一：使用 sdkmanager"></a>方法一：使用 sdkmanager</h3><p>在sdkmanager中选择deepstream，按刷机的方式安装即可。  </p><h3 id="方法二：单独下载"><a href="#方法二：单独下载" class="headerlink" title="方法二：单独下载"></a>方法二：单独下载</h3><p>下载：<a href="https://developer.nvidia.com/deepstream-getting-started">https://developer.nvidia.com/deepstream-getting-started</a>  (要登录）  </p><p>安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- CUDA (10.2)</span><br><span class="line">- TensorRT (7.1+)</span><br><span class="line">- OpenCV (3.3.1)</span><br><span class="line">- VisionWorks (1.6)</span><br></pre></td></tr></table></figure><p>安装工具：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install \</span><br><span class="line">    libssl1.0.0 \</span><br><span class="line">    libgstreamer1.0-0 \</span><br><span class="line">    gstreamer1.0-tools \</span><br><span class="line">    gstreamer1.0-plugins-good \</span><br><span class="line">    gstreamer1.0-plugins-bad \</span><br><span class="line">    gstreamer1.0-plugins-ugly \</span><br><span class="line">    gstreamer1.0-libav \</span><br><span class="line">    gstreamer1.0-alsa \</span><br><span class="line">    libgstrtspserver-1.0-0 \</span><br><span class="line">    libjansson4</span><br></pre></td></tr></table></figure><p>安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;install.sh</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">md5sum deepstream_sdk_v5.0.1_jetson.tbz2 </span><br><span class="line">5c60a89924535129ec3b4997ebbc0f83  deepstream_sdk_v5.0.1_jetson.tbz2</span><br><span class="line"></span><br><span class="line">sudo nvpmodel -m 0 </span><br><span class="line">sudo jetson_clocks</span><br></pre></td></tr></table></figure><p>安装环境后，检查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># deepstream-app --version-all </span><br><span class="line">deepstream-app version 5.0.0</span><br><span class="line">DeepStreamSDK 5.0.0</span><br><span class="line">CUDA Driver Version: 10.2</span><br><span class="line">CUDA Runtime Version: 10.2</span><br><span class="line">TensorRT Version: 7.1</span><br><span class="line">cuDNN Version: 8.0</span><br><span class="line">Dewarper: not found</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">模型文件：&#x2F;opt&#x2F;nvidia&#x2F;deepstream&#x2F;deepstream-5.0&#x2F;samples&#x2F;models</span><br><span class="line"></span><br><span class="line">示例文档：https:&#x2F;&#x2F;docs.nvidia.com&#x2F;metropolis&#x2F;deepstream&#x2F;dev-guide&#x2F;text&#x2F;DS_ref_app_github.html  </span><br><span class="line">示例地址：https:&#x2F;&#x2F;github.com&#x2F;NVIDIA-AI-IOT&#x2F;deepstream_reference_apps。克隆其到 &#x2F;opt&#x2F;nvidia&#x2F;deepstream&#x2F;deepstream_reference_apps。  </span><br><span class="line"></span><br><span class="line">安装依赖：</span><br><span class="line">查看：&#x2F;opt&#x2F;nvidia&#x2F;deepstream&#x2F;deepstream&#x2F;sources&#x2F;apps&#x2F;sample_apps&#x2F;deepstream-app&#x2F;README  </span><br><span class="line">命令：   </span><br><span class="line">sudo apt-get install libgstreamer-plugins-base1.0-dev libgstreamer1.0-dev \</span><br><span class="line">   libgstrtspserver-1.0-dev libx11-dev libjson-glib-dev</span><br><span class="line">编译：make （验证SDK、依赖是否完备）。  </span><br><span class="line"></span><br><span class="line">将 anomaly 拷贝到 &#x2F;opt&#x2F;nvidia&#x2F;deepstream&#x2F;deepstream&#x2F;sources&#x2F;apps&#x2F;sample_apps&#x2F; ：</span><br><span class="line">cp  &#x2F;opt&#x2F;nvidia&#x2F;deepstream&#x2F;deepstream_reference_apps&#x2F;anomaly&#x2F; &#x2F;opt&#x2F;nvidia&#x2F;deepstream&#x2F;deepstream&#x2F;sources&#x2F;apps&#x2F;sample_apps&#x2F; </span><br><span class="line"></span><br><span class="line">进入目录：</span><br><span class="line">cd &#x2F;opt&#x2F;nvidia&#x2F;deepstream&#x2F;deepstream&#x2F;sources&#x2F;apps&#x2F;sample_apps&#x2F;anomaly</span><br><span class="line">编译库：</span><br><span class="line">cd plugins&#x2F;gst-dsdirection&#x2F;</span><br><span class="line">make &amp;&amp; sudo make install</span><br><span class="line"></span><br><span class="line">编辑 .&#x2F;anomaly&#x2F;apps&#x2F;deepstream-anomaly-detection-test&#x2F;dsanomaly_pgie_config.txt 文件。</span><br><span class="line"></span><br><span class="line">测试资源：</span><br><span class="line">&#x2F;opt&#x2F;nvidia&#x2F;deepstream&#x2F;deepstream&#x2F;samples&#x2F;streams</span><br><span class="line">&#x2F;opt&#x2F;nvidia&#x2F;deepstream&#x2F;deepstream&#x2F;samples&#x2F;streams&#x2F;sample_720p.h264</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gst-launch-1.0 filesrc location &#x3D; samples&#x2F;streams&#x2F;sample_1080p_h264.mp4 ! qtdemux ! h264parse ! nvv4l2decoder ! m.sink_0 \</span><br><span class="line">nvstreammux name&#x3D;m batch-size&#x3D;1 width&#x3D;1280 height&#x3D;720 ! nvinfer config-file-path&#x3D; samples&#x2F;configs&#x2F;deepstream-app&#x2F;config_infer_primary.txt  \</span><br><span class="line">! nvof ! tee name&#x3D;t ! queue ! nvofvisual ! nvmultistreamtiler width&#x3D;1920 height&#x3D;1080 !  nvegltransform ! nveglglessink sync&#x3D;0 t. ! queue ! dsdirection ! \</span><br><span class="line">nvmultistreamtiler width&#x3D;1920 height&#x3D;1080 ! nvvideoconvert ! nvdsosd ! nvegltransform ! nveglglessink sync&#x3D;0</span><br><span class="line"></span><br><span class="line">gst-launch-1.0 -e nvstreammux name&#x3D;mux batch-size&#x3D;2 width&#x3D;1920 height&#x3D;1080 ! nvinfer config-file-path&#x3D;&#x2F;opt&#x2F;nvidia&#x2F;deepstream&#x2F;deepstream-5.0&#x2F;samples&#x2F;configs&#x2F;deepstream-app&#x2F;config_infer_primary.txt batch-size&#x3D;2  \</span><br><span class="line">! nvstreamdemux name&#x3D;demux filesrc location&#x3D;&#x2F;opt&#x2F;nvidia&#x2F;deepstream&#x2F;deepstream-5.0&#x2F;samples&#x2F;streams&#x2F;sample_1080p_h264.mp4 ! qtdemux ! h264parse ! nvv4l2decoder ! queue \</span><br><span class="line">! mux.sink_0 filesrc location&#x3D;&#x2F;opt&#x2F;nvidia&#x2F;deepstream&#x2F;deepstream-5.0&#x2F;samples&#x2F;streams&#x2F;sample_720p.h264 ! h264parse ! nvv4l2decoder ! queue ! mux.sink_1 demux.src_0 ! &quot;video&#x2F;x-raw(memory:NVMM), format&#x3D;NV12&quot; \</span><br><span class="line">! queue ! nvvideoconvert ! &quot;video&#x2F;x-raw(memory:NVMM), format&#x3D;RGBA&quot; ! nvdsosd ! nvvideoconvert ! nveglglessink demux.src_1 ! queue ! &quot;video&#x2F;x-raw(memory:NVMM), format&#x3D;NV12&quot; ! queue ! nvvideoconvert ! &quot;video&#x2F;x-raw(memory:NVMM), format&#x3D;RGBA&quot; ! nvegltransform ! nveglglessink</span><br><span class="line"></span><br><span class="line">出错（在图形界面中运行也一样）：</span><br><span class="line">nvbuf_utils: Could not get EGL display connection</span><br><span class="line">WARNING: erroneous pipeline: no element &quot;nvstreammux&quot;</span><br><span class="line"></span><br><span class="line">2个示例：</span><br><span class="line">cd &#x2F;opt&#x2F;nvidia&#x2F;deepstream&#x2F;deepstream_reference_apps&#x2F;anomaly&#x2F;apps&#x2F;deepstream-anomaly-detection-test</span><br><span class="line">.&#x2F;deepstream-anomaly-detection-app  &#x2F;opt&#x2F;nvidia&#x2F;deepstream&#x2F;deepstream&#x2F;samples&#x2F;streams&#x2F;sample_720p.h264</span><br><span class="line"></span><br><span class="line">cd &#x2F;opt&#x2F;nvidia&#x2F;deepstream&#x2F;deepstream_reference_apps&#x2F;back-to-back-detectors</span><br><span class="line">.&#x2F;back-to-back-detectors &#x2F;opt&#x2F;nvidia&#x2F;deepstream&#x2F;deepstream&#x2F;samples&#x2F;streams&#x2F;sample_720p.h264</span><br></pre></td></tr></table></figure><p>出错及解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">nvbuf_utils: Could not get EGL display connection：</span><br><span class="line">临时设置环境环境： export DISPLAY&#x3D;:0</span><br><span class="line"></span><br><span class="line">One element could not be created. Exiting.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查看插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">filesrc</span><br><span class="line"></span><br><span class="line">gst-inspect-1.0 -a |grep -i NVIDIA</span><br><span class="line"></span><br><span class="line">$ gst-inspect-1.0  nvarguscamerasrc</span><br><span class="line">有信息输出</span><br><span class="line"></span><br><span class="line">$ gst-inspect-1.0  nvstreammux</span><br><span class="line">No such element or plugin &#39;nvstreammux&#39;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -it --rm --net&#x3D;host --runtime nvidia  -e DISPLAY&#x3D;$DISPLAY -w &#x2F;opt&#x2F;nvidia&#x2F;deepstream&#x2F;deepstream-5.0 -v &#x2F;tmp&#x2F;.X11-unix&#x2F;:&#x2F;tmp&#x2F;.X11-unix -v &#x2F;opt&#x2F;nvidia&#x2F;deepstream&#x2F;deepstream_reference_apps:&#x2F;opt&#x2F;nvidia&#x2F;deepstream&#x2F;deepstream_reference_app nvcr.io&#x2F;nvidia&#x2F;deepstream-l4t:5.0.1-20.09-samples</span><br><span class="line"></span><br><span class="line"> sudo docker run -it --rm --net&#x3D;host --runtime nvidia  -e DISPLAY&#x3D;$DISPLAY -v &#x2F;tmp&#x2F;.X11-unix&#x2F;:&#x2F;tmp&#x2F;.X11-unix  nvcr.io&#x2F;nvidia&#x2F;deepstream-l4t:5.0.1-20.09-base  bash</span><br></pre></td></tr></table></figure><p><a href="https://github.com/NVIDIA-AI-IOT/redaction_with_deepstream/">https://github.com/NVIDIA-AI-IOT/redaction_with_deepstream/</a>  </p><p>安装指南：<a href="https://docs.nvidia.com/metropolis/deepstream/dev-guide/text/DS_Quickstart.html#jetson-setup">https://docs.nvidia.com/metropolis/deepstream/dev-guide/text/DS_Quickstart.html#jetson-setup</a>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;nvidia示例。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://www.latelee.org/category/ml/"/>
    
    
    <category term="机器学习" scheme="http://www.latelee.org/tag/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>2020年个人总结</title>
    <link href="http://www.latelee.org/the-life/my-2020.html"/>
    <id>http://www.latelee.org/the-life/my-2020.html</id>
    <published>2021-01-07T16:00:00.000Z</published>
    <updated>2021-02-05T02:01:02.951Z</updated>
    
    <content type="html"><![CDATA[<p>2021年的脚步已经来临了。时光荏苒，白驹过隙，日月如梭，岁月不居，时节如流，总结2020年，以此记念。  </p><a id="more"></a><p>今年过得特别快，那个带着大锤陪婆婆在地里看韭菜花的下午，仿佛就在昨天。在犹豫几次后，坐表哥的车到火车站，踏上来南宁的路程。一晃就是一年。  </p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>今年按时间划分，有几大块：过年在家，来南宁上班，小女出生，换工作，复习并考试，上班。<br>喜得一女，对家庭更加看重，在月子期间，请大假，居家，负责买菜做饭、洗衣洗澡晒太阳等事，小女健康无事。<br>主动承担绝大部分事务，承担大锤教育事务。<br>个人时间更少了，导致比去年熬夜更多，时间更长。但早睡一天又能恢复。没有大病小病。<br>换了一次工作，前后面试了2家公司。<br>技术方面没有明显提升。<br>通过软考高项。  </p><h2 id="工作学习"><a href="#工作学习" class="headerlink" title="工作学习"></a>工作学习</h2><p>今年过年假期是历史最久的，年初在家里，除了听广播，担心能不能按时返工外，还完善了Qt的程序。<br>到了5月份，公司还没有发工资的意思，于是找前前同事帮投简历，在6月中旬有回音，请假面试，顺利过关，由于对拖欠工资已经怕了，只有一份工作即可，所以对薪资没有太多要求。最终在六月最后2天入职报到。<br>公司比较大，是大集团公司下属的集团公司，分若干事业部，每个事业部分若干部门，一个部门分若干小组，我在其中一个小组里面做开发。这里的气氛比较好友，但在软件开发上，和我之前接触的不同，虽然人数众多，但各自为战居多，会议不多，又没有交集，以致半年后我连组内的同事还没认全。日常以 QQ 交流为主，不习惯用邮件，很多事务无法回溯，很多事没有流程和文档，靠的是口口相传，我接手的事务完全没版本管理版本，而是使用日期压缩包，而且压缩包随处可见。  </p><p>申请 gitlab 账号后第一件事就是把手上的代码进行版本管理，接着跟负责 git 服务的同事说安装一个插件，这样可以提交代码时通知相关人员，不过没有下文，理由是学习成本大，大家忙。  </p><p>我的事务主要是负责一个 Delphi 工程（工程文件最早的时间为1998年），以及一个和最短路径算法有关的工具。另外就是一些边边角角的事务，这半年来，没有接触到核心业务。主要的事是 Delphi 工程操作优化——实际上就是加了快捷键以减少鼠标点击步骤，把一些繁琐的步骤做到一个按钮中操作。另外重构算法的工程，因此业务不太熟悉，估计年后就完成了。在测试和升级服务过程中，使用代码和脚本把操作都尽量自动化或半自动化，包括自动化测试程序，线上升级自动脚本，等。还抽空做了一个检查 oracle 数据库合规性的工具，考虑良久还是使用 Golang 编写，方便编码，也方便积累自己的经验。在平时工作中，一方面同事讨论时留心记，包括用到的术语和知识及提到的问题，为此重拾了封尘了几年的印象笔记；另一方面把手上的任务做好；第三是工作积极，领导随叫随到，加班也无怨言。  </p><p>我有过3次加班超过半夜的，一次是2点半，一次是1点半，当时我关注倒不是事务本身，而是大锤有没有洗澡，有没有尿床。我对加班并不抗拒，即使真有怨言，也是偷偷心里骂。  </p><p>我们考勤使用钉钉，除了刚到的2天没法打卡，只迟到过一次，且只迟到1分钟。加班累计有十多个小时（晚上7点后打卡自动统计）。问了几位同事，说可以调休，有次大锤打疫苗，我请调休，但助理拒绝，只能请要扣钱的事假。后了解得知，去年年初因为大项目，部门绝大部分人加班，如按加班时长均可请一年假期，故严格控制调休。  </p><p>在7月份，看到同事讨论软考，我也决定报名参加，在不影响工作和家庭情况下，靠着上下班和深夜、周末空闲时间复习，有好几个晚上都想放弃，但还是逼着自己看书做题。考试当天，案例分析时就感觉不妙，到论文时就感觉支撑不住，但我信奉的是坚持到底，再怎么也要写完。考完后我没估分，后面查成绩时，论文刚好45分，准备点击看到分数按钮时，我的手抖了很久。  </p><p>公司的同事，生活档次都比较高，所谈者，是车辆耗油几何，周末去哪，几时收房，哪个公司装修好，哪家商贷便宜，等等。虽然融不到圈子里，但做倾听状，提高知识，还是可以的。  </p><p>我能入职，是因为刚好有人离职了，我填坑。部门100多人，有一半是外包或劳务派遣，我排在最后几位。看到过一些文件，说每年都会有人能转正，但又看到文件说，外包至少要5年才能资格——除非有特殊贡献。在日常开发中并不区分正式员工、劳务派遣人员和外包人员，总体上没有歧视外包，所以不会出现网上不给外包吃零食的现象（当然本来也没零食）。但在行政事务或通知时，会让我时刻不忘外包仔的身份。像群里发的请正式员工到11楼量尺寸定制西装，请正式员工速到5楼领年节福利，还有明确表示外包人员不参加XX活动等。有时只简单称呼“大家”，但我也得分析一下“大家”是不是包含外包人，否则自讨没趣。另外，一些表格也会严格区别——虽然只是标题不同。如果说不被影响肯定是假的，但也不能太过敏感。曾经问过一些外包的同事，原来他们也有类似的感受。<br>后来发现，劳务派遣人员和外包人员是有很多区别的，比如，某些福利，正式员工和劳务派遣人员可以享有，但外包人员没有。而现在公司的劳务派遣人员已经很少了，这也符合劳务派遣比例的有关规定。我的基本工资是1810元——我才知道这是南宁最低工资，另外加上绩效，扣除少数的保险额，加上上有二老下有二小的减免税额，我还不到交个税的程度。  </p><p>正式员工的福利，让我开了眼界，本来我不想关注的，奈何福利时不时听到看到，也慢慢熟悉了。比如，每月有饭卡补贴，先前是每月600块，后提高到800块。还有工作服、电影票、互助金、尽孝金，当然，五险一金肯定多。除此外，一些培训和晋升空间，也偏向正式员工，诸如此类，等等等等。至于更高级别的，限于认知和眼界，还不清楚。  </p><h2 id="家庭生活"><a href="#家庭生活" class="headerlink" title="家庭生活"></a>家庭生活</h2><p>有了大锤的经验教训后，对于大妞或二锤（小名我早就想好了）的到来，我十分上心。在预产期前跟领导请了2个月的大假，虽然没有收入，但帮交了社保，因此即使后来没有补齐之前欠的工资，我也不强求了。 </p><p>我提前到B站看了很多的视频，想象后面要做的事，特别是预防黄疸和肚脐清理，还跑去调研了小孩洗澡的草药。清明假期，大妞出生了——但幸好不是清明当天（否则又有抱怨了）。岳母因工作不能来南宁，我也不能让我妈来，虽然只有我一个人，虽然有些差错，但一切总算顺利，母女平安。住院三天中，凌晨5点从医院赶回来煮饭煮汤，傍晚赶回来买菜煮饭煮汤。在医院床边睡觉也是随叫随醒，但给人的印象就是“只知道睡觉”。  </p><p>月子期间，我负责全部的护理工作，特别是肚脐的消毒。除了刚回来头2天洗了草药水，其它时间都是擦身子，尽量减少肚脐接触水的概率。在肚脐脱落时，想了很多种方法防止感染，跑了很多药店都没买到肚脐贴，最后使用了创可贴，竟也有用。最终平安度过，心里石头也放下了。这个时期，大妞没有出现严重的肠绞疼，没有经常哭闹。我会经常按摩她的肚子，我也享受大妞趴着我肚子睡觉的时光。对于一些育儿经验也有自己的看法，像竖抱、趴床等等，在刚出生几天，我就给大妞做了，一开始只是几秒，慢慢加长时间。有太阳时带去树根晒太阳，旁边大妈看到我带小孩晒太阳，会好奇过来问我各种问题，无非是些老人怎么没有帮带小孩，你怎么没上班之类的。<br>大人方面，就是换着花样做饭菜，粥粉面饭，煮蒸闷炒，基本准时把三餐饭菜送到房间，再抱大妞。自此，我就负责买菜拖地洗衣的事。某段时间，我下班后还没有煮饭，于是马不停蹄，洗菜切菜煮饭煮菜，发挥程序优势，开启多线程处理，但马也有失蹄，有次着急切到手，疼了一周。到年底发现刀工见长了，做的菜的花样也慢慢多，炒的糖色也不苦了。    </p><p>大概2~3个月后，大妞不让我抱了，孩子妈洗澡时，哭得特别严重，一度让人以为我虐待小孩，当然少不了争吵。那时我心态也不好，一方面是没有收入，另一方面是大量支出，再一方面是天天处理杂事。年底后，大概是我勤快买菜拖地而又不反抗的缘故，已经不怎么对我发脾气了。大妞半岁后，我抱她时已经不会哭了，后来逗她时也会笑了。因为孩子妈不放心我带小的，所以今年没有带大妞去外面玩，最多只是到超市买菜。<br>在大妞出生前后，起名的事也闹了很久，孩子妈坚持要跟娘家姓，我父母坚决不同意，我夹在中间，但我也不同意。我的看法是，不同姓的话，兄妹就不是兄妹了，家也不是家了。岳母则支持我，但为这事孩子妈也跟岳母吵了一架，闹得去寻死，在找人的那2个小时里，无数个念头在我脑中闪过，我似乎看到了明天的新闻。万幸半夜前找回来，但家里的东西就遭殃了，我也在外面过了一夜，第二天我煮的面也扔掉。自此后我就怕了，无数次教训着我不能反抗。而且起名的事也得罪父母，说不要回家过年，一时仿徨不知何去何从。最后用了折中的方法，还是跟我姓，但户口不跟我。为了让两孩子的名字听得像兄妹，看了经典和字典，想了很久，最终给大妞起了一个觉得不错的姓名，符合五行，寓意不错，而且拼音缩写和哥哥完全一致。当然有人肯定觉得不好。   </p><p>大妞出生后，孩子妈就唠叨要把大锤接来一起生活，因为总是担心在老家老人乱给零食吃，于是五月底回了趟老家，在老家市区网吧过了一夜，翌日老妈带大锤出来，顺便给大锤办了身份证（这个事也唠叨了几年了），临走时给了老妈5千块钱。到南宁第二天就带大锤去办了张银行卡，存了100块钱，当是小孩婆婆给的红包。办卡时，柜员姐姐问了小孩怎么没上幼儿园，于是临时决定带小孩去看幼儿园。去看了四五家，有2家比较喜欢，一家环境好而贵，一家便宜但一般般，距离都不远不近。最终孩子妈选择环境好的那家。  </p><p>到了8月份，运气非常好，在20%的概率中中签了一家国企幼儿园，费用低一些（但也超过5千了），场地大一些，距离近一些。大锤上幼儿园后，除周末外，每天的时间似乎都按分钟算。早上7点我得起床，7点50分必须把大锤送到学校门口，然后在8点半前赶到公司。上了幼儿园后，能明显感到大锤的进步，虽然不大，但我已经满足了。        </p><p>有小孩后，我就不是自由的了，凡事都会考虑到小孩，包括语言行为。在2个小孩前面要特别注意，既不能让大的感受到冷落，又不让忽视小的。我会一手抱大锤一手抱大妞，跟兄妹俩说话——我十分珍惜这个时刻，因为，我单手快抱不动大锤了，大锤也渐渐不用我抱了。  </p><p>我对小孩的教育比较开放，大原则是尊重小孩成长规律，在此前提下，多教一些，学多一些，但不刻意去强求结果。小孩爱玩、爱闹、要抱、使性子，等，都是天性，只要不过分，我都会允许。小孩是一张白纸，需要大人去填充颜色，是五彩缤纷还是黑白，取决于大人；另一方面，小孩诸多习性和能力，也需要大人引导。这一年感悟尤为深刻。大锤是我的精神寄托，是我早起晚睡的动力。  </p><p>在大锤成长过程中，我也会回忆起自己的童年，我在大锤这个年纪只会玩泥巴，但大锤去了很多公园，见识很多事物。我初中毕业后才第一次接触电话，大一期末才第一次坐火车。这些与现今已不可同日而语，但我又希望大锤可以接触大自然，有机会尝试“也傍桑阴学种瓜”，不过家庭的事从不是我一个做决定。我只能尽量让大锤有个好的童年，但这个“好”，我不知道怎么定义。  </p><p>很久前和罗师傅聊小孩教育，谈到家风家规，我也积累总结，看到好的都写下来，慢慢越来越多。考虑到接受程度，精简后得到几条，在生活中有机会就会跟小孩说。一、承认事实（不刻意回避事实，如打针会疼，摔跤会疼）；二、慢慢进步（不要求马上进步，但要求有进步，有成长。）；三、勇于尝试（尝试了才知道好不好能不能做，不能不试就说不好不做。）；四、允许有错（去尝试，过程中允许犯错做错，从中学习，再进步）。<br>另外罗师傅也提到陶冶小孩情操，他买了书画挂家里，我也买了一些复制的书画——只是不能挂。但大锤只对书法感兴趣，前后买了《赤壁赋》、《滕王阁序》、《心经》、《兰亭集序》。或者是缘分，我和孩子妈姓名的某个字都能在《赤壁赋》找到，并且不止一处，所以在看时，也顺便让大锤找爸妈的名字。<br>对于国学，我并不想让小孩背《三字经》和《弟子规》，我更喜欢教《声律启蒙》和诗歌。这一年，教的诗词主要依据时令（如中秋节）而定，再者选取田园风光、童趣、豪放风格等方面，另外还有一些是个人喜欢的，如蒋捷和韦庄诗歌。教的虽然不多，但间隔一段时间再回顾，以加深印象。大部分诗词是在游玩或路上时读给小孩听，有时触景时也会教，教时并不是强迫记，而是慢慢解释、引导。在中秋节后教他“明月几时有”。在青秀山教他“解落三秋叶”，在人民公园教他“接天莲叶无穷碧”，在晴天时教他“白云千载空悠悠”，在太阳下山时教他“夕阳无限好”。<br>周末只要有空，就会带大锤去了玩，今年去了很多地方，主要集中在免费的地方。趁年底半价，还去了一次动物园，去了两次青秀山。当然最常去的是人民公园，其次是图书馆（每次我借书还书都会带着去）。大锤语言能力还不如其它小朋友，日常中可以明显看出，一是新环境怕生，二是话少不主动表达。因此年末的外出活动，争取和班上的小朋友一起玩。  </p><p>大锤模仿能力非常强，不管好的坏的。因此我也注意日常的说话和行为，有时大人吵架后，也会跟小孩解释和说明（虽然我不想吵，但有时忍不住）。上幼儿园后，一度对炒菜感兴趣，或许是陪我去买菜时日久了自然熟悉，加上外婆买了套厨具给他玩。我切菜时他切菜，我剁肉时他剁肉，还拿他的刀和勺子跟真实的比较。<br>另外，把一些逻辑和计算机思维融入生活。比如，学会穿衣服穿袜子，就是成长（而不是等成长了才学会穿）；天下雨了地板会湿（但地板湿不一定是下雨）。买了汉诺塔和九连环给小孩玩（当然主要是我玩）。在安装铁架、包饺子过程中会讲分类和分工（结构化，流水线，分治等术语当然不会跟小孩讲），等等。    </p><p>至于其它的，就看大人言传身教了。为了让大锤不怕打针抽血，在软考后第二天，带大锤到附近血屋献了400cc，告诉他爸爸用的是大针，抽了很多血，很疼，但爸爸不怕。抽完后，大锤喝了送的牛奶，我拿了送的小锅，各取所需。（注：检查合格，并在一周后被使用了。献血是计划了很久的，前后一共献了1000cc，身体自我感觉无恙。）   </p><h2 id="个人能力"><a href="#个人能力" class="headerlink" title="个人能力"></a>个人能力</h2><p>将所有网站迁移到云主机，全部docker化部署，外加nginx转发，并实现https证书。<br>整理后台程序框架，使用golang语言，集中在gin和cobra中。至于接口，随用随积累。前端看了几行vue代码，但没有继续。<br>持续更新自己的技术网站，虽然数量少了一些，质量也不高，但起码没有敷衍了事，都是对工作和学习的总结记录。<br>集群方面，限于精力没有做。  </p><p>明年重点内容：<br>完成golang后台，前端不做要求。<br>业余研究方向为架构、分布式等方面。如设计模式、设计原则，redis、mysql等。<br>在工作中寻找可以发挥的地方，既能完成工作，又积累技能。  </p><h2 id="个人事"><a href="#个人事" class="headerlink" title="个人事"></a>个人事</h2><p>今年因为疫情，社交比以往更少了，没有约夜宵，也没有和大学同学聚会。<br>和罗师傅参加前领导请的一次吃饭，主要谈未来的业务和项目的可能性，前领导欠的几百万还没还清，听其语气，对公司被迫歇业的事没有了当初的愤慨，而多了几份无奈，一边做项目还债，一边还想着我们几个人。<br>和前同事碰面几次，还是谈业务，谈了很多次，不过没有成的。主要是个人作战力量太单薄了。<br>上半年和老家的叔伯碰面，谈线上买卖菜的项目，但当时只有idea，除此外什么也没有（现在各头部大厂进场，小兵肯定没机会）。<br>给网友的回复比去年少了，一是懒，二是没时间，三是没精力。<br>买了个二手kindle，买了个二手电子表，有闹钟计时，有电波光动能，时间还比较准。<br>上下班路上听听音频，上半年主要有听刑法、逻辑学等，下半年开始听软考的高项。  </p><h2 id="个人反省"><a href="#个人反省" class="headerlink" title="个人反省"></a>个人反省</h2><p>说实话，这么多年，没有进行过认真的反思。<br>我性格偏向软弱，但看到不平事，也会义愤填膺，只是不会站出来，而且接受既定事实。我不擅长吵架，不喜欢争吵，也怕看到别人争吵。我没有花很多时间研究如何吵架，也没有积累吵架经验，所以吵架时我始终在下风。何况在当今社会，男女吵架闹矛盾，不管怎么说，男的始终不占理。人与人的认知不同，生活经历不同，因此对事物看法和感受不同。有人评价我不会带孩子，有人评价我对软件开发的理解不够。<br>在头条或网上的男人，回家只会玩手机打游戏，不会照顾小孩，女的则为母则刚做坚强的人。对此我有自己的思考，但不是人人都有分辨力，如果有人时不时在旁边说别人家生活怎样，别人老公如何，别人去哪里旅游，我不在意也不放心上，但如果是亲人的话，我只能是无何何奈。其实男人就应该以赚钱为第一要义，在新公司听到别人讨论高档次的生活时，我发现已经脱节了。<br>我也有脾气，吃软不吃硬。一边抱怨钱少，一边骂我，一边说我不够大度，我只能一声叹息。我试过为公司的项目写代码到半夜2点，对公司的事十分在上心，因为领导器重，并且我看到希望了。如果别人的错要我背锅，又要我无怨言加班到半夜，又要准时上班，又不给我调休，我肯定不爽。但人本就矛盾，为了钱，还得假装欢笑享受。<br>我希望得到尊重和理解，不过近年来，我不敢已经奢望美好的生活，感觉啥事都低人一等，不管在家还是在公司，比如公司要求周一着正装上班，正式员工都统一一套，我穿着毕业那会儿买的西服，只敢走楼梯。有时下班回去给大妞喂奶没喝完又被骂。只有在欺负大锤时，才觉得有点成就感。    </p><h2 id="杂事"><a href="#杂事" class="headerlink" title="杂事"></a>杂事</h2><p>不知何故，听了几次《琵琶行》，竟也能背下，换作以前那么长的诗都不会看完，或许是有共鸣吧。白居易在出官二年后才“是夕始觉有迁谪意”，我想他之前的许多个时刻，也会感觉到“迁谪意”，只是没有听到琵琶声当晚那么有感触。我有时也会失落孤独，比如，换新工作第一天下班的时候，加班到深夜骑着电驴吹着风回家的时候。回想工作后的十年，我不知是怎么度过的，“今年欢笑复明年”也是有的，就是我陪大锤大妞玩的时候——他们还小，当然需要欢笑。然而更多时候，我都“恬然自安”，没有想过房子车子和未来的事，我忙忙碌碌，终究还是没什么成绩。暮去朝来，秋月春风就这样过去了，我也隐隐有了白头发。  </p><h2 id="流水账"><a href="#流水账" class="headerlink" title="流水账"></a>流水账</h2><p>1月份，回家，听广播，写Qt程序。<br>2月份，来南宁。<br>3月份，上班。面试。<br>4月份，大妞出生，请假2个月陪护。<br>5月份，更新了居住证。回老家带大锤上南宁。带大锤找幼儿园。<br>6月份，上班，面试，换工作。大锤正式上幼儿园。<br>7月份，决定考软考。公司评职称，因无论文及未满一年，未参加。<br>8月份，上班。中签租房对面的幼儿园。<br>9月份，大锤换新幼儿园。公司换新地址，离得更远，起得更早。<br>10月份，带大锤去梧州看爷爷，回老家看奶奶。上班。<br>11月份，参加软考。<br>12月份，上班。      </p><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>希望明年能评上职称。<br>希望明年能通过架构师考试。<br>希望早日上岸，摆脱外包仔身份——虽然遥遥无期。  </p><p>PS：本文编写时，得知软考分数线为45分，以及格线通过，如按同事说法公司有补贴，那明年大锤幼儿园学费就有着落了。  </p><p>李迟 2021.1.8 周五  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2021年的脚步已经来临了。时光荏苒，白驹过隙，日月如梭，岁月不居，时节如流，总结2020年，以此记念。  &lt;/p&gt;</summary>
    
    
    
    <category term="生活掠影" scheme="http://www.latelee.org/category/the-life/"/>
    
    
    <category term="个人总结" scheme="http://www.latelee.org/tag/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>redis笔记2：问题及记录</title>
    <link href="http://www.latelee.org/my-study/redis-note1.html"/>
    <id>http://www.latelee.org/my-study/redis-note1.html</id>
    <published>2021-01-06T16:00:01.000Z</published>
    <updated>2021-02-05T02:01:02.999Z</updated>
    
    <content type="html"><![CDATA[<p>redis 术语、问题等等。从网上收集。    </p><a id="more"></a><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>数据未加载到缓存中，或者缓存同一时间大面积的失效，从而导致所有请求都去查数据库，导致数据库CPU和内存负载过高，甚至宕机。  </p><p>解决：缓存的高可用性、缓存降级、Redis备份和快速预热、提前演练  </p><p>在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。  </p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指查询一个一不存在的数据。例如：从缓存redis没有命中，需要从mysql数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。失去了缓存的意义。  </p><p>解决：<br>如果查询数据库也为空，直接设置一个默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库。设置一个过期时间或者当有值的时候将缓存中的值替换掉即可。<br>可以给key设置一些格式规则，然后查询之前先过滤掉不符合规则的Key。  </p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。</p><p>解决方式也很简单，可以将热点数据设置为永远不过期；或者基于 redis or zookeeper 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据。</p><h2 id="缓存与数据库双写一致"><a href="#缓存与数据库双写一致" class="headerlink" title="缓存与数据库双写一致"></a>缓存与数据库双写一致</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;redis 术语、问题等等。从网上收集。    &lt;/p&gt;</summary>
    
    
    
    <category term="技术杂铺" scheme="http://www.latelee.org/category/my-study/"/>
    
    
    <category term="架构学习" scheme="http://www.latelee.org/tag/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>redis笔记1：集群</title>
    <link href="http://www.latelee.org/my-study/redis-note1.html"/>
    <id>http://www.latelee.org/my-study/redis-note1.html</id>
    <published>2021-01-06T16:00:00.000Z</published>
    <updated>2021-02-05T02:01:02.999Z</updated>
    
    <content type="html"><![CDATA[<p>docker 化部署 redis，主从复制、哨兵、集群实践。  </p><a id="more"></a><p>redis 集群有三种模式：  </p><ul><li>主从模式</li><li>Sentinel模式</li><li>Cluster模式</li></ul><h2 id="技术小结"><a href="#技术小结" class="headerlink" title="技术小结"></a>技术小结</h2><p>使用 docker 部署，需要注意所有容器均在同一网段，容器间使用容器名称访问。  </p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><ul><li>主可写可读，从只读（否则无法保证数据一致性）。主同步数据到从。一主可带多个从，一从只属一个主。  </li><li>从服务挂掉不影响其它从。  </li><li>主挂掉，整个集群不能写，但从依然可读。 </li><li>主只写，从只读，分工减少主的压力。  </li></ul><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>三台服务：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ttredis 6379</span><br><span class="line">ttredis1 6381</span><br><span class="line">ttredis2 6382</span><br><span class="line">ttredis3 6383</span><br></pre></td></tr></table></figure><p>docker-compose.yml文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">version: &#39;2&#39;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  ttredis:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    container_name: ttredis</span><br><span class="line">    restart: always</span><br><span class="line">    command: redis-server &#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf</span><br><span class="line">    volumes:</span><br><span class="line">      - .&#x2F;redisdata0:&#x2F;data</span><br><span class="line">      - .&#x2F;redis0.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf</span><br><span class="line">    ports:</span><br><span class="line">      - 6379:6379</span><br><span class="line">    networks:</span><br><span class="line">      - ttredis-net</span><br><span class="line">  ttredis1:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    container_name: ttredis1</span><br><span class="line">    restart: always</span><br><span class="line">    command: redis-server &#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf</span><br><span class="line">    volumes:</span><br><span class="line">      - .&#x2F;redisdata1:&#x2F;data</span><br><span class="line">      - .&#x2F;redis1.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf</span><br><span class="line">    ports:</span><br><span class="line">      - 6381:6379</span><br><span class="line">    networks:</span><br><span class="line">      - ttredis-net</span><br><span class="line">  ttredis2:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    container_name: ttredis2</span><br><span class="line">    restart: always</span><br><span class="line">    command: redis-server &#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf</span><br><span class="line">    volumes:</span><br><span class="line">      - .&#x2F;redisdata2:&#x2F;data</span><br><span class="line">      - .&#x2F;redis1.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf</span><br><span class="line">    ports:</span><br><span class="line">      - 6382:6379</span><br><span class="line">    networks:</span><br><span class="line">      - ttredis-net</span><br><span class="line">  ttredis3:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    container_name: ttredis3</span><br><span class="line">    restart: always</span><br><span class="line">    command: redis-server &#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf</span><br><span class="line">    volumes:</span><br><span class="line">      - .&#x2F;redisdata3:&#x2F;data</span><br><span class="line">      - .&#x2F;redis1.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf</span><br><span class="line">    ports:</span><br><span class="line">      - 6383:6379</span><br><span class="line">    networks:</span><br><span class="line">      - ttredis-net</span><br><span class="line">networks:</span><br><span class="line">  ttredis-net:</span><br><span class="line">    driver: bridge</span><br></pre></td></tr></table></figure><p>说明：<br>1、创建三个容器，分别为ttredis、ttredis1、ttredis2，第一个为主，使用单独的配置文件。第二第三个为从，使用同一配置，但数据目录不同。<br>2、注意端口映射，在容器看来，均为6379(默认)，只是映射到不同端口。<br>3、三个容器在同一网络 ttredis-net 中。  </p><p>主配置文件主要内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bind 0.0.0.0</span><br><span class="line">protected-mode yes</span><br><span class="line">port 6379</span><br><span class="line">requirepass 12345678</span><br><span class="line">appendonly yes</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br></pre></td></tr></table></figure><p>从配置文件主要内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bind 0.0.0.0</span><br><span class="line">protected-mode yes</span><br><span class="line">port 6379</span><br><span class="line">requirepass 12345678</span><br><span class="line">appendonly yes</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"># replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line">#replicaof 127.0.0.1 6379</span><br><span class="line"># for docker</span><br><span class="line">replicaof ttredis 6379</span><br><span class="line">masterauth 12345678</span><br></pre></td></tr></table></figure><p>说明：在从配置文件中，使用 replicaof （注：旧版本为 slaveof）指定主的IP和端口，masterauth 指定主的密码。如是本机，则使用<code>127.0.0.1</code>，本例为容器，故用主的容器名<code>ttredis</code>。由于需要外网机器访问，故绑定 IP 为<code>0.0.0.0</code>。主从密码均为<code>12345678</code>。         </p><p>启动容器并查看状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># docker-compose -f docker-compose.yml up -d</span><br><span class="line"></span><br><span class="line"># docker-compose ps</span><br><span class="line">  Name                Command               State           Ports          </span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line">ttredis    docker-entrypoint.sh redis ...   Up      0.0.0.0:6379-&gt;6379&#x2F;tcp </span><br><span class="line">ttredis1   docker-entrypoint.sh redis ...   Up      0.0.0.0:6381-&gt;6379&#x2F;tcp </span><br><span class="line">ttredis2   docker-entrypoint.sh redis ...   Up      0.0.0.0:6382-&gt;6379&#x2F;tcp </span><br></pre></td></tr></table></figure><p>连接主容器并查看集群：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6379 -a 12345678</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip&#x3D;192.168.224.2,port&#x3D;6379,state&#x3D;online,offset&#x3D;1386,lag&#x3D;1</span><br><span class="line">slave1:ip&#x3D;192.168.224.4,port&#x3D;6379,state&#x3D;online,offset&#x3D;1386,lag&#x3D;1</span><br><span class="line">master_replid:44d65d402d81131ac37867f352a513093263f0aa</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:1386</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:1386</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or set)</span><br><span class="line"></span><br><span class="line">输入值：</span><br><span class="line">set  key1 101</span><br><span class="line">set  key2 102</span><br><span class="line">set  key3 103</span><br><span class="line">set  key4 104</span><br><span class="line">set  key5 105</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查看：</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;key5&quot;</span><br><span class="line">2) &quot;key1&quot;</span><br><span class="line">3) &quot;key2&quot;</span><br><span class="line">4) &quot;key3&quot;</span><br><span class="line">5) &quot;key4&quot;</span><br></pre></td></tr></table></figure><p>在从查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6381&gt; keys *</span><br><span class="line">1) &quot;key3&quot;</span><br><span class="line">2) &quot;key1&quot;</span><br><span class="line">3) &quot;key4&quot;</span><br><span class="line">4) &quot;key2&quot;</span><br><span class="line">5) &quot;key5&quot;</span><br></pre></td></tr></table></figure><p>在主执行 flushall 命令清空所有数据库，从亦被清空。    </p><h2 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h2><h3 id="理论-1"><a href="#理论-1" class="headerlink" title="理论"></a>理论</h3><p>解决主从复制的缺点，即主挂掉整个集群不可写。哨兵可再选一个主出来。  </p><h3 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h3><p>docker-compose.yml文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">version: &#39;2&#39;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  ttredis:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    container_name: ttredis</span><br><span class="line">    restart: always</span><br><span class="line">    #command: redis-server</span><br><span class="line">    #command: redis-server --requirepass 12345678 --appendonly yes</span><br><span class="line">    command: </span><br><span class="line">    - sh</span><br><span class="line">    - -c</span><br><span class="line">    - |</span><br><span class="line">        redis-server &#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf &amp;</span><br><span class="line">        redis-sentinel &#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;sentinel.conf</span><br><span class="line">    volumes:</span><br><span class="line">      - .&#x2F;redisdata0:&#x2F;data</span><br><span class="line">      - .&#x2F;redis0.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf</span><br><span class="line">      - .&#x2F;sentinel.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;sentinel.conf</span><br><span class="line">    ports:</span><br><span class="line">      - 6379:6379</span><br><span class="line">      - 26379:26379</span><br><span class="line">    networks:</span><br><span class="line">      - ttredis-net</span><br><span class="line">  ttredis1:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    container_name: ttredis1</span><br><span class="line">    restart: always</span><br><span class="line">    #command: redis-server</span><br><span class="line">    #command: redis-server --requirepass 12345678 --appendonly yes --replicaof ttredis 6379 --masterauth 12345678</span><br><span class="line">    command: redis-server &#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf</span><br><span class="line">    volumes:</span><br><span class="line">      - .&#x2F;redisdata1:&#x2F;data</span><br><span class="line">      - .&#x2F;redis1.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf</span><br><span class="line">    ports:</span><br><span class="line">      - 6381:6379</span><br><span class="line">    networks:</span><br><span class="line">      - ttredis-net</span><br><span class="line">  ttredis2:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    container_name: ttredis2</span><br><span class="line">    restart: always</span><br><span class="line">    #command: redis-server</span><br><span class="line">    #command: redis-server --requirepass 12345678 --appendonly yes --replicaof ttredis 6379 --masterauth 12345678</span><br><span class="line">    command: redis-server &#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf</span><br><span class="line">    volumes:</span><br><span class="line">      - .&#x2F;redisdata2:&#x2F;data</span><br><span class="line">      - .&#x2F;redis1.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf</span><br><span class="line">    ports:</span><br><span class="line">      - 6382:6379</span><br><span class="line">    networks:</span><br><span class="line">      - ttredis-net</span><br><span class="line">  ttredis3:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    container_name: ttredis3</span><br><span class="line">    restart: always</span><br><span class="line">    #command: redis-server</span><br><span class="line">    #command: redis-server --requirepass 12345678 --appendonly yes --replicaof ttredis 6379 --masterauth 12345678</span><br><span class="line">    command: redis-server &#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf</span><br><span class="line">    volumes:</span><br><span class="line">      - .&#x2F;redisdata3:&#x2F;data</span><br><span class="line">      - .&#x2F;redis1.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf</span><br><span class="line">    ports:</span><br><span class="line">      - 6383:6379</span><br><span class="line">    networks:</span><br><span class="line">      - ttredis-net</span><br><span class="line">networks:</span><br><span class="line">  ttredis-net:</span><br><span class="line">    driver: bridge</span><br></pre></td></tr></table></figure><p>与前述相比，ttredis 中，多了 sentinel.conf 的配置。该配置由 redis-sentinel 使用，因此，command 需要执行2个命令，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">command: </span><br><span class="line">- sh</span><br><span class="line">- -c</span><br><span class="line">- |</span><br><span class="line">    redis-server &#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf &amp;</span><br><span class="line">    redis-sentinel &#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;sentinel.conf</span><br></pre></td></tr></table></figure><p>sentinel.conf 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protected-mode no</span><br><span class="line"></span><br><span class="line"># The port that this sentinel instance will run on</span><br><span class="line">port 26379</span><br><span class="line">daemonize no</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis-sentinel.pid</span><br><span class="line">logfile &quot;&quot;</span><br><span class="line"></span><br><span class="line">dir &#x2F;tmp</span><br><span class="line"></span><br><span class="line">sentinel monitor mymaster ttredis 6379 2</span><br><span class="line">sentinel auth-pass mymaster 12345678</span><br><span class="line"></span><br><span class="line"># Default is 30 seconds.</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line">acllog-max-len 128</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"># Default is 3 minutes.</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line">sentinel deny-scripts-reconfig yes</span><br></pre></td></tr></table></figure><p>测试：<br>同上，在主写数据。然后执行<code>docker-compose stop ttredis</code>停用主服务，观察从是否会变成主。<br>注：暂不成功。  </p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>待实践。  </p><h3 id="理论-2"><a href="#理论-2" class="headerlink" title="理论"></a>理论</h3><h3 id="实践-2"><a href="#实践-2" class="headerlink" title="实践"></a>实践</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;docker 化部署 redis，主从复制、哨兵、集群实践。  &lt;/p&gt;</summary>
    
    
    
    <category term="技术杂铺" scheme="http://www.latelee.org/category/my-study/"/>
    
    
    <category term="架构学习" scheme="http://www.latelee.org/tag/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>openssl生成自签证书</title>
    <link href="http://www.latelee.org/pkc/redis-note1.html"/>
    <id>http://www.latelee.org/pkc/redis-note1.html</id>
    <published>2021-01-05T16:00:01.000Z</published>
    <updated>2021-02-05T02:01:02.955Z</updated>
    
    <content type="html"><![CDATA[<p>使用 openssl 生成自签证书。用于程序测试。  </p><a id="more"></a><h2 id="检查-openssl-："><a href="#检查-openssl-：" class="headerlink" title="检查 openssl ："></a>检查 openssl ：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ openssl version</span><br><span class="line">OpenSSL 1.0.2k-fips  26 Jan 2017</span><br></pre></td></tr></table></figure><p>创建三个目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir root server client</span><br></pre></td></tr></table></figure><p>预定义好证书信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBJ&#x3D;&quot;&#x2F;C&#x3D;CN&#x2F;ST&#x3D;Guangxi&#x2F;L&#x3D;Cenxi&#x2F;O&#x3D;cststudio&#x2F;OU&#x3D;cststudio&#x2F;CN&#x3D;cststudio.com.cn&quot;</span><br></pre></td></tr></table></figure><p>SUBJ 释义：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">字段        含义                本文示例</span><br><span class="line">&#x2F;C&#x3D;    Country 国家        CN</span><br><span class="line">&#x2F;ST&#x3D;State or Province 省Guangxi</span><br><span class="line">&#x2F;L&#x3D;    Location or City 城市Cenxi</span><br><span class="line">&#x2F;O&#x3D;    Organization 组织或企业cststudio</span><br><span class="line">&#x2F;OU&#x3D;Organization Unit 部门cststudio</span><br><span class="line">&#x2F;CN&#x3D;Common Name 域名或IP    cststudio.com.cn</span><br></pre></td></tr></table></figure><h2 id="根证书"><a href="#根证书" class="headerlink" title="根证书"></a>根证书</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cd root</span><br><span class="line"># 生成RSA私钥 pass指定密码</span><br><span class="line">openssl genrsa -des3 -passout pass:1qaz@WSX -out root.pass.key 2048</span><br><span class="line"></span><br><span class="line"># 删除私钥中的密码</span><br><span class="line">openssl rsa -passin pass:1qaz@WSX -in root.pass.key -out root.key</span><br><span class="line">rm -f root.pass.key</span><br><span class="line"></span><br><span class="line"># 生成 CSR(Certificate Signing Request，证书请求文件)</span><br><span class="line">openssl req -new -key root.key -out root.csr -subj &quot;$SUBJ&quot;</span><br><span class="line"></span><br><span class="line"># 生成根证书，-days指定为10年  </span><br><span class="line">openssl x509 -req -days 3650 -CAcreateserial -in root.csr -signkey root.key -out root.crt</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">root.crt  root.csr  root.key</span><br></pre></td></tr></table></figure><h2 id="服务证书"><a href="#服务证书" class="headerlink" title="服务证书"></a>服务证书</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cd ..&#x2F;server&#x2F;</span><br><span class="line"></span><br><span class="line"># 生成RSA私钥 pass指定密码</span><br><span class="line">openssl genrsa -des3 -passout pass:1qaz@WSX -out server.pass.key 2048</span><br><span class="line"></span><br><span class="line"># 删除私钥中的密码</span><br><span class="line">openssl rsa -passin pass:1qaz@WSX -in server.pass.key -out server.key</span><br><span class="line">rm -f server.pass.key</span><br><span class="line"></span><br><span class="line"># 生成 CSR(Certificate Signing Request，证书请求文件)</span><br><span class="line">openssl req -new -key server.key -out server.csr -subj &quot;$SUBJ&quot;</span><br><span class="line"></span><br><span class="line"># 生成crt证书，-days指定为10年  </span><br><span class="line">openssl x509 -req -days 3650 -CAcreateserial -CA ..&#x2F;root&#x2F;root.crt -CAkey ..&#x2F;root&#x2F;root.key  -in server.csr -signkey server.key -out server.crt</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">server.crt  server.csr  server.key</span><br></pre></td></tr></table></figure><h2 id="客户证书"><a href="#客户证书" class="headerlink" title="客户证书"></a>客户证书</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cd ..&#x2F;client&#x2F;</span><br><span class="line"></span><br><span class="line"># 生成RSA私钥 pass指定密码</span><br><span class="line">openssl genrsa -des3 -passout pass:1qaz@WSX -out client.pass.key 2048</span><br><span class="line"></span><br><span class="line"># 删除私钥中的密码</span><br><span class="line">openssl rsa -passin pass:1qaz@WSX -in client.pass.key -out client.key</span><br><span class="line">rm -f client.pass.key</span><br><span class="line"></span><br><span class="line"># 生成 CSR(Certificate Signing Request，证书请求文件)</span><br><span class="line">openssl req -new -key client.key -out client.csr -subj &quot;$SUBJ&quot;</span><br><span class="line"></span><br><span class="line"># 生成crt证书，-days指定为10年  </span><br><span class="line">openssl x509 -req -days 3650 -CAcreateserial -CA ..&#x2F;root&#x2F;root.crt -CAkey ..&#x2F;root&#x2F;root.key  -in client.csr -signkey client.key -out client.crt</span><br><span class="line"></span><br><span class="line">openssl pkcs12 -export -passout pass:123456 -clcerts -in client.crt -inkey client.key -out client.p12</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">client.crt  client.csr  client.key client.p12</span><br></pre></td></tr></table></figure><p>参考：<br><a href="https://www.cnblogs.com/mufeng3421/p/13896400.html">https://www.cnblogs.com/mufeng3421/p/13896400.html</a><br><a href="https://blog.csdn.net/baidu_19338587/article/details/78489028">https://blog.csdn.net/baidu_19338587/article/details/78489028</a>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用 openssl 生成自签证书。用于程序测试。  &lt;/p&gt;</summary>
    
    
    
    <category term="个人知识中心" scheme="http://www.latelee.org/category/pkc/"/>
    
    
    <category term="工具使用" scheme="http://www.latelee.org/tag/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>yaml文件解析：golang篇</title>
    <link href="http://www.latelee.org/my-library/parsing-yaml-in-golang.html"/>
    <id>http://www.latelee.org/my-library/parsing-yaml-in-golang.html</id>
    <published>2020-12-27T16:00:00.000Z</published>
    <updated>2021-02-05T02:01:03.047Z</updated>
    
    <content type="html"><![CDATA[<p>本文使用 golang 库 viper 对 yaml 文件进行解析。  </p><a id="more"></a><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>执行 <code>go get github.com/spf13/viper</code> 安装。<br>golang 中 yaml 文件解析较多。本文选用 viper 进行解析，主要因为笔者的命令终端库使用了 viper 和 cobra，前者解析 yaml 文件，后者进行命令参数的解析，能方便形成程序主体框架。 </p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="yaml-配置文件"><a href="#yaml-配置文件" class="headerlink" title="yaml 配置文件"></a>yaml 配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"># yaml测试样例</span><br><span class="line"># null 或 NULL 为关键字，不能写</span><br><span class="line"></span><br><span class="line"># 名称</span><br><span class="line"># 字符串</span><br><span class="line">name: conf file</span><br><span class="line"></span><br><span class="line"># 版本</span><br><span class="line"># 如按浮点，2.0会转换成2</span><br><span class="line"># 如按字符串，保留原样</span><br><span class="line">version: 2.0</span><br><span class="line"></span><br><span class="line"># 布尔类，转换为1或0</span><br><span class="line">need: true</span><br><span class="line"></span><br><span class="line"># 时间</span><br><span class="line">time: 2020-10-03T09:21:13</span><br><span class="line"></span><br><span class="line">empty: nul</span><br><span class="line"></span><br><span class="line"># 对象</span><br><span class="line"># 加双引号会转义\n，即会换行</span><br><span class="line">my:</span><br><span class="line">  name: late \n lee</span><br><span class="line">  name1: &quot;late \n lee&quot;</span><br><span class="line">  age: 99</span><br><span class="line">  </span><br><span class="line"># 块</span><br><span class="line">text: |</span><br><span class="line">  hello</span><br><span class="line">  world!</span><br><span class="line"></span><br><span class="line"># 数组</span><br><span class="line">fruit:</span><br><span class="line">  - apple</span><br><span class="line">  - apple1</span><br><span class="line">  - apple2</span><br><span class="line">  - apple3</span><br><span class="line">  - apple4</span><br><span class="line">  - apple5</span><br><span class="line"></span><br><span class="line"># 多级数组</span><br><span class="line">multi:</span><br><span class="line">  sta:</span><br><span class="line">    - 110 210 ddd 99</span><br><span class="line">    - 133 135 1 2 1588 1509</span><br><span class="line">    - 310-410</span><br><span class="line">    - 333-444</span><br></pre></td></tr></table></figure><p>该示例基本涵盖了大部分的 yaml 格式。包括：字符串，数值、数组、多级map。  </p><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>测试代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">true&quot;os&quot;</span><br><span class="line">true&quot;github.com&#x2F;spf13&#x2F;viper&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">truecfgFile string</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">trueif cfgFile !&#x3D; &quot;&quot; &#123;</span><br><span class="line">truetrue&#x2F;&#x2F; Use config file from the flag.</span><br><span class="line">truetrueviper.SetConfigFile(cfgFile)</span><br><span class="line">true&#125; else &#123;</span><br><span class="line">truetrueviper.AddConfigPath(&quot;.&#x2F;&quot;)</span><br><span class="line">truetrueviper.SetConfigName(&quot;config&quot;)</span><br><span class="line">truetrueviper.SetConfigType(&quot;yaml&quot;)</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">trueviper.AutomaticEnv() &#x2F;&#x2F; read in environment variables that match</span><br><span class="line"></span><br><span class="line">trueerr :&#x3D; viper.ReadInConfig();</span><br><span class="line">trueif  err !&#x3D; nil &#123;</span><br><span class="line">truetruefmt.Println(&quot;&#39;config.yaml&#39; file read error:&quot;, err)</span><br><span class="line">truetrueos.Exit(0)</span><br><span class="line">true&#125;</span><br><span class="line">    name :&#x3D; viper.GetString(&quot;name&quot;)</span><br><span class="line">    version :&#x3D; viper.GetString(&quot;version&quot;)</span><br><span class="line"></span><br><span class="line">    need :&#x3D; viper.GetBool(&quot;need&quot;)</span><br><span class="line">    theTime :&#x3D; viper.GetString(&quot;time&quot;)</span><br><span class="line">    empty :&#x3D; viper.GetString(&quot;empty&quot;)</span><br><span class="line">    text :&#x3D; viper.GetString(&quot;text&quot;)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(&quot;need: %v name: %v&#x3D;\n version: %v \ntime: %v \nempty: %s \ntext: %v\n&quot;, need, name, version, theTime, empty, text)</span><br><span class="line">    </span><br><span class="line">    name &#x3D; viper.GetString(&quot;my.name&quot;)</span><br><span class="line">    name1 :&#x3D; viper.GetString(&quot;my.name1&quot;)</span><br><span class="line">    age :&#x3D; viper.GetInt(&quot;my.age&quot;)</span><br><span class="line">    fmt.Printf(&quot;name: %v, name1: %v age: %v \n&quot;, name, name1, age)</span><br><span class="line"></span><br><span class="line">    newSta :&#x3D; viper.GetStringSlice(&quot;multi.sta&quot;)</span><br><span class="line">    for idx, value :&#x3D; range newSta &#123;</span><br><span class="line">        fmt.Printf(&quot;sta[%d]: %v\n&quot;, idx, value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fruit :&#x3D; viper.GetStringSlice(&quot;fruit&quot;)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(&quot;fruit: %v\n&quot;, fruit)</span><br><span class="line">    </span><br><span class="line">    bad :&#x3D; viper.GetString(&quot;bad&quot;)</span><br><span class="line">    bad1 :&#x3D; viper.GetString(&quot;my.bad&quot;)</span><br><span class="line">    fmt.Printf(&quot;bad: %v bad1: %v\n&quot;, bad, bad1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>go build</code>进行编译。<br>输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;yaml_test.exe</span><br><span class="line">need: true name: conf file&#x3D;</span><br><span class="line"> version: 2</span><br><span class="line">time: 2020-10-03T09:21:13</span><br><span class="line">empty: nul</span><br><span class="line">text: hello</span><br><span class="line">world!</span><br><span class="line"></span><br><span class="line">name: late \n lee, name1: late</span><br><span class="line"> lee age: 99</span><br><span class="line">sta[0]: 110 210 ddd 99</span><br><span class="line">sta[1]: 133 135 1 2 1588 1509</span><br><span class="line">sta[2]: 310-410</span><br><span class="line">sta[3]: 333-444</span><br><span class="line">fruit: [apple apple1 apple2 apple3 apple4 apple5]</span><br><span class="line">bad:  bad1:</span><br></pre></td></tr></table></figure><h3 id="结果说明"><a href="#结果说明" class="headerlink" title="结果说明"></a>结果说明</h3><p>1、<code>name: &quot;late \n lee&quot;</code> 输出会换行。而 <code>name: late \n lee</code> 则会原样输出。<br>2、参数的值不能为 null 或 NULL，但可以为nul。如果为 null，解析的值为空。<br>3、如果字段不存在，不会报错，解析得到的值为空。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文使用 golang 库 viper 对 yaml 文件进行解析。  &lt;/p&gt;</summary>
    
    
    
    <category term="我的程序代码" scheme="http://www.latelee.org/category/my-library/"/>
    
    
    <category term="工程库代码" scheme="http://www.latelee.org/tag/%E5%B7%A5%E7%A8%8B%E5%BA%93%E4%BB%A3%E7%A0%81/"/>
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>yaml文件解析：nodejs篇</title>
    <link href="http://www.latelee.org/my-library/parsing-yaml-in-nodejs.html"/>
    <id>http://www.latelee.org/my-library/parsing-yaml-in-nodejs.html</id>
    <published>2020-12-26T16:00:01.000Z</published>
    <updated>2021-02-05T02:01:03.047Z</updated>
    
    <content type="html"><![CDATA[<p>本文使用 nodejs 的 yamljs 库对 yaml 文件进行解析。  </p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>直接使用 <code>npm i yamljs</code> 即可安装。  </p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="yaml-配置文件"><a href="#yaml-配置文件" class="headerlink" title="yaml 配置文件"></a>yaml 配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"># yaml测试样例</span><br><span class="line"># null 或 NULL 为关键字，不能写</span><br><span class="line"></span><br><span class="line"># 名称</span><br><span class="line"># 字符串</span><br><span class="line">name: conf file</span><br><span class="line"></span><br><span class="line"># 版本</span><br><span class="line"># 如按浮点，2.0会转换成2</span><br><span class="line"># 如按字符串，保留原样</span><br><span class="line">version: 2.0</span><br><span class="line"></span><br><span class="line"># 布尔类，转换为1或0</span><br><span class="line">need: true</span><br><span class="line"></span><br><span class="line"># 时间</span><br><span class="line">time: 2020-10-03T09:21:13</span><br><span class="line"></span><br><span class="line">empty: nul</span><br><span class="line"></span><br><span class="line"># 对象</span><br><span class="line"># 加双引号会转义\n，即会换行</span><br><span class="line">my:</span><br><span class="line">  name: late \n lee</span><br><span class="line">  name1: &quot;late \n lee&quot;</span><br><span class="line">  age: 99</span><br><span class="line">  </span><br><span class="line"># 块</span><br><span class="line">text: |</span><br><span class="line">  hello</span><br><span class="line">  world!</span><br><span class="line"></span><br><span class="line"># 数组</span><br><span class="line">fruit:</span><br><span class="line">  - apple</span><br><span class="line">  - apple1</span><br><span class="line">  - apple2</span><br><span class="line">  - apple3</span><br><span class="line">  - apple4</span><br><span class="line">  - apple5</span><br><span class="line"></span><br><span class="line"># 多级数组</span><br><span class="line">multi:</span><br><span class="line">  sta:</span><br><span class="line">    - 110 210 ddd 99</span><br><span class="line">    - 133 135 1 2 1588 1509</span><br><span class="line">    - 310-410</span><br><span class="line">    - 333-444</span><br></pre></td></tr></table></figure><p>该示例基本涵盖了大部分的 yaml 格式。包括：字符串，数值、数组、多级map。  </p><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>测试代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">npm i yamljs</span><br><span class="line">执行：nodejs test.js</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">YAML &#x3D; require(&#39;yamljs&#39;);</span><br><span class="line"> function main()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 固定配置文件名 TODO：容错处理</span><br><span class="line">    nativeObject &#x3D; YAML.load(&#39;config.yaml&#39;);</span><br><span class="line">    </span><br><span class="line">    jsonstr &#x3D; JSON.stringify(nativeObject);</span><br><span class="line">    theJson &#x3D; JSON.parse(jsonstr, null);</span><br><span class="line">    </span><br><span class="line">    console.log(&quot;alljson: &quot;, theJson);</span><br><span class="line">    console.log(&quot;name: &quot;, theJson.name);</span><br><span class="line">    console.log(&quot;version: &quot;, theJson.version);</span><br><span class="line">    </span><br><span class="line">    console.log(&quot;empty: &quot;, theJson.empty); &#x2F;&#x2F; nodejs 可处理null值</span><br><span class="line">    console.log(&quot;time: &quot;, theJson.time);</span><br><span class="line">    </span><br><span class="line">    console.log(&quot;name: &quot;, theJson.my.name);</span><br><span class="line">    console.log(&quot;name1: &quot;, theJson.my.name1);</span><br><span class="line">    console.log(&quot;age: &quot;, theJson.my.age);</span><br><span class="line">    </span><br><span class="line">    console.log(&quot;text: &quot;, theJson.text);</span><br><span class="line"></span><br><span class="line">    theText &#x3D; &quot;&quot;;</span><br><span class="line">    &#x2F;&#x2F; 数组，遍历</span><br><span class="line">    theJson.multi.sta.forEach(function(v, _, _)&#123;</span><br><span class="line">            theText +&#x3D; v + &#39;\n&#39;;</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(&quot;sta &quot;, theText);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 是否需要显示提交日志</span><br><span class="line">    if (theJson.need &#x3D;&#x3D; true)</span><br><span class="line">    &#123;</span><br><span class="line">        console.log(&quot;need...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; call main</span><br><span class="line">main();</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">$ node test.js</span><br><span class="line">alljson:  &#123; name: &#39;conf file&#39;,</span><br><span class="line">  version: 2,</span><br><span class="line">  need: true,</span><br><span class="line">  time: &#39;2020-10-03T09:21:13.000Z&#39;,</span><br><span class="line">  empty: &#39;nul&#39;,</span><br><span class="line">  my: &#123; name: &#39;late \\n lee&#39;, name1: &#39;late \n lee&#39;, age: 99 &#125;,</span><br><span class="line">  text: &#39;hello\nworld!\n&#39;,</span><br><span class="line">  fruit:</span><br><span class="line">   [ &#39;apple&#39;, &#39;apple1&#39;, &#39;apple2&#39;, &#39;apple3&#39;, &#39;apple4&#39;, &#39;apple5&#39; ],</span><br><span class="line">  multi:</span><br><span class="line">   &#123; sta:</span><br><span class="line">      [ &#39;110 210 ddd 99&#39;,</span><br><span class="line">        &#39;133 135 1 2 1588 1509&#39;,</span><br><span class="line">        &#39;310-410&#39;,</span><br><span class="line">        &#39;333-444&#39; ] &#125; &#125;</span><br><span class="line">name:  conf file</span><br><span class="line">version:  2</span><br><span class="line">empty:  nul</span><br><span class="line">time:  2020-10-03T09:21:13.000Z</span><br><span class="line">name:  late \n lee</span><br><span class="line">name1:  late</span><br><span class="line"> lee</span><br><span class="line">age:  99</span><br><span class="line">text:  hello</span><br><span class="line">world!</span><br><span class="line"></span><br><span class="line">bad:  undefined</span><br><span class="line">sta  110 210 ddd 99</span><br><span class="line">133 135 1 2 1588 1509</span><br><span class="line">310-410</span><br><span class="line">333-444</span><br><span class="line"></span><br><span class="line">need...</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="结果说明"><a href="#结果说明" class="headerlink" title="结果说明"></a>结果说明</h3><p>1、可以看到，解析后的 theJson 变量，就是整个配置文件的 json，可以直接使用其中的字段。<br>2、使用 yamljs 解析时，参数的值可以为 null 或 NULL。这点与 yaml-cpp 库不一样。<br>3、如果字段不存在时，得到的结果为 undefined，并不会出现段错误。这点与 yaml-cpp 库也不一样。    </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文使用 nodejs 的 yamljs 库对 yaml 文件进行解析。  &lt;/p&gt;</summary>
    
    
    
    <category term="我的程序代码" scheme="http://www.latelee.org/category/my-library/"/>
    
    
    <category term="nodejs" scheme="http://www.latelee.org/tag/nodejs/"/>
    
    <category term="工程库代码" scheme="http://www.latelee.org/tag/%E5%B7%A5%E7%A8%8B%E5%BA%93%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>yaml文件解析：c++篇</title>
    <link href="http://www.latelee.org/my-library/parsing-yaml-in-c++.html"/>
    <id>http://www.latelee.org/my-library/parsing-yaml-in-c++.html</id>
    <published>2020-12-26T16:00:00.000Z</published>
    <updated>2021-02-05T02:01:03.047Z</updated>
    
    <content type="html"><![CDATA[<p>本文使用 C++ 库 yaml-cpp 对 yaml 文件进行解析。  </p><a id="more"></a><h2 id="下载编译"><a href="#下载编译" class="headerlink" title="下载编译"></a>下载编译</h2><p>下载地址：<a href="https://github.com/jbeder/yaml-cpp/releases/tag/yaml-cpp-0.6.3">https://github.com/jbeder/yaml-cpp/releases/tag/yaml-cpp-0.6.3</a> 。 文件名为：yaml-cpp-yaml-cpp-0.6.3.zip。<br>解压，进入库目录，创建build目录。执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd build</span><br><span class="line">cmake ..&#x2F;</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>在build目录生成 libyaml-cpp.a 文件。将其与源码的 include 目录拷贝至工程目录，在编译时进行链接即可。</p><p>注：cmake须3.0以上。  </p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="yaml-配置文件"><a href="#yaml-配置文件" class="headerlink" title="yaml 配置文件"></a>yaml 配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"># yaml测试样例</span><br><span class="line"># null 或 NULL 为关键字，不能写</span><br><span class="line"></span><br><span class="line"># 名称</span><br><span class="line"># 字符串</span><br><span class="line">name: conf file</span><br><span class="line"></span><br><span class="line"># 版本</span><br><span class="line"># 如按浮点，2.0会转换成2</span><br><span class="line"># 如按字符串，保留原样</span><br><span class="line">version: 2.0</span><br><span class="line"></span><br><span class="line"># 布尔类，转换为1或0</span><br><span class="line">need: true</span><br><span class="line"></span><br><span class="line"># 时间</span><br><span class="line">time: 2020-10-03T09:21:13</span><br><span class="line"></span><br><span class="line">empty: nul</span><br><span class="line"></span><br><span class="line"># 对象</span><br><span class="line"># 加双引号会转义\n，即会换行</span><br><span class="line">my:</span><br><span class="line">  name: late \n lee</span><br><span class="line">  name1: &quot;late \n lee&quot;</span><br><span class="line">  age: 99</span><br><span class="line">  </span><br><span class="line"># 块</span><br><span class="line">text: |</span><br><span class="line">  hello</span><br><span class="line">  world!</span><br><span class="line"></span><br><span class="line"># 数组</span><br><span class="line">fruit:</span><br><span class="line">  - apple</span><br><span class="line">  - apple1</span><br><span class="line">  - apple2</span><br><span class="line">  - apple3</span><br><span class="line">  - apple4</span><br><span class="line">  - apple5</span><br><span class="line"></span><br><span class="line"># 多级数组</span><br><span class="line">multi:</span><br><span class="line">  sta:</span><br><span class="line">    - 110 210 ddd 99</span><br><span class="line">    - 133 135 1 2 1588 1509</span><br><span class="line">    - 310-410</span><br><span class="line">    - 333-444</span><br></pre></td></tr></table></figure><p>该示例基本涵盖了大部分的 yaml 格式。包括：字符串，数值、数组、多级map。  </p><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>测试代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;yaml-cpp&#x2F;yaml.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc,char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    YAML::Node config;</span><br><span class="line">    &#x2F;&#x2F; 当文件不存在或yaml格式出错时，抛异常</span><br><span class="line">    try &#123;</span><br><span class="line">        config &#x3D; YAML::LoadFile(&quot;config.yaml&quot;);</span><br><span class="line">    &#125; catch (...) &#123;</span><br><span class="line">        printf(&quot;error loading file, yaml file error or not exist.\n&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获取类型</span><br><span class="line">    for (YAML::const_iterator it &#x3D; config.begin(); it !&#x3D; config.end(); ++it) &#123;</span><br><span class="line">        std::string key &#x3D; it-&gt;first.as&lt;std::string&gt;();</span><br><span class="line">        YAML::Node value &#x3D; it-&gt;second;</span><br><span class="line">        switch (value.Type()) &#123;</span><br><span class="line">            case YAML::NodeType::Scalar:</span><br><span class="line">            printf(&quot;key: %s scalar\n&quot;, key.c_str());</span><br><span class="line">            break;</span><br><span class="line">            case YAML::NodeType::Sequence:</span><br><span class="line">            printf(&quot;key: %s Sequence\n&quot;, key.c_str());</span><br><span class="line">            cout &lt;&lt; &quot;seq: &quot; &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">            break;</span><br><span class="line">            case YAML::NodeType::Map:</span><br><span class="line">            printf(&quot;key: %s Map\n&quot;, key.c_str());</span><br><span class="line">            break;</span><br><span class="line">            case YAML::NodeType::Null:</span><br><span class="line">            printf(&quot;key: %s Null\n&quot;, key.c_str());</span><br><span class="line">            break;</span><br><span class="line">            case YAML::NodeType::Undefined:</span><br><span class="line">            printf(&quot;key: %s Undefined\n&quot;, key.c_str());</span><br><span class="line">            break;</span><br><span class="line">            &#x2F;&#x2F; etc.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 顶层</span><br><span class="line">    cout &lt;&lt; &quot;version:&quot; &lt;&lt; config[&quot;version&quot;].as&lt;float&gt;() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;version(str):&quot; &lt;&lt; config[&quot;version&quot;].as&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;need:&quot; &lt;&lt; config[&quot;need&quot;].as&lt;bool&gt;() &lt;&lt; endl; &#x2F;&#x2F; 输出值为1</span><br><span class="line">    cout &lt;&lt; &quot;time:&quot; &lt;&lt; config[&quot;time&quot;].as&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;empty:&quot; &lt;&lt; config[&quot;empty&quot;].as&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    try &#123;</span><br><span class="line">        printf(&quot;sizeof array: %d\n&quot;, (int)config[&quot;fruit&quot;].size());</span><br><span class="line">        &#x2F;&#x2F;cout &lt;&lt; &quot;fruit1:\n&quot; &lt;&lt; config[&quot;fruit&quot;] &lt;&lt; endl; &#x2F;&#x2F; 此处返回 Node</span><br><span class="line">        &#x2F;&#x2F; 索引方式取</span><br><span class="line">        &#x2F;&#x2F;for (int i &#x3D; 0; i &lt; (int)config[&quot;fruit&quot;].size(); i++)</span><br><span class="line">        &#x2F;&#x2F;&#123;</span><br><span class="line">        &#x2F;&#x2F;    cout &lt;&lt; &quot;fruit2: &quot; &lt;&lt; config[&quot;fruit&quot;][i].as&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">        &#x2F;&#x2F;&#125;</span><br><span class="line">        &#x2F;&#x2F; 单个取</span><br><span class="line">        for (auto item : config[&quot;fruit&quot;])</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;fruit3: &quot; &lt;&lt; item.as&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; catch(...) &#123;</span><br><span class="line">        printf(&quot;fruit not ok.\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    try &#123;</span><br><span class="line">        printf(&quot;new sta: \n&quot;);</span><br><span class="line">        for (auto item : config[&quot;multi&quot;][&quot;sta&quot;])</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%s \n&quot;, item.as&lt;string&gt;().c_str());</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125; catch (...) &#123;</span><br><span class="line">        &#x2F;&#x2F;printf(&quot;key not exist...\n&quot;);</span><br><span class="line">        &#x2F;&#x2F;return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 对于不存在的key，似乎只能用try</span><br><span class="line">    try &#123;</span><br><span class="line">        cout &lt;&lt; &quot;bad:&quot; &lt;&lt; config[&quot;bad&quot;].as&lt;int&gt;() &lt;&lt; endl;</span><br><span class="line">    &#125; catch (...) &#123;</span><br><span class="line">        printf(&quot;key bad not exist...\n&quot;);</span><br><span class="line">        &#x2F;&#x2F;return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; &quot;text:&quot; &lt;&lt; config[&quot;text&quot;].as&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">    &#x2F;&#x2F; 有两层</span><br><span class="line">    printf(&quot;name: %s \nname1: %s \nage: %d\n&quot;, </span><br><span class="line">            config[&quot;my&quot;][&quot;name&quot;].as&lt;string&gt;().c_str(),</span><br><span class="line">            config[&quot;my&quot;][&quot;name1&quot;].as&lt;string&gt;().c_str(),</span><br><span class="line">            config[&quot;my&quot;][&quot;age&quot;].as&lt;int&gt;());</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;a.out </span><br><span class="line">key: name scalar</span><br><span class="line">key: version scalar</span><br><span class="line">key: need scalar</span><br><span class="line">key: time scalar</span><br><span class="line">key: empty scalar</span><br><span class="line">key: my Map</span><br><span class="line">key: text scalar</span><br><span class="line">key: fruit Sequence</span><br><span class="line">seq: - apple</span><br><span class="line">- apple1</span><br><span class="line">- apple2</span><br><span class="line">- apple3</span><br><span class="line">- apple4</span><br><span class="line">- apple5</span><br><span class="line">key: multi Map</span><br><span class="line">version:2</span><br><span class="line">version(str):2.0</span><br><span class="line">need:1</span><br><span class="line">time:2020-10-03T09:21:13</span><br><span class="line">empty:nul</span><br><span class="line">sizeof array: 6</span><br><span class="line">fruit3: apple</span><br><span class="line">fruit3: apple1</span><br><span class="line">fruit3: apple2</span><br><span class="line">fruit3: apple3</span><br><span class="line">fruit3: apple4</span><br><span class="line">fruit3: apple5</span><br><span class="line">new sta: </span><br><span class="line">110 210 ddd 99 </span><br><span class="line">133 135 1 2 1588 1509 </span><br><span class="line">310-410 </span><br><span class="line">333-444 </span><br><span class="line"></span><br><span class="line">key bad not exist...</span><br><span class="line">text:hello</span><br><span class="line">world!</span><br><span class="line"></span><br><span class="line">name: late \n lee </span><br><span class="line">name1: late </span><br><span class="line"> lee </span><br><span class="line">age: 99</span><br></pre></td></tr></table></figure><h3 id="结果说明"><a href="#结果说明" class="headerlink" title="结果说明"></a>结果说明</h3><p>1、<code>name: &quot;late \n lee&quot;</code> 输出会换行。而 <code>name: late \n lee</code> 则会原样输出。<br>2、参数的值不能为 null 或 NULL，但可以为nul。<br>3、如果字段不存在或非法，会直接报段错误，因此需要用 <code>try catch</code> 读取。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文使用 C++ 库 yaml-cpp 对 yaml 文件进行解析。  &lt;/p&gt;</summary>
    
    
    
    <category term="我的程序代码" scheme="http://www.latelee.org/category/my-library/"/>
    
    
    <category term="工程库代码" scheme="http://www.latelee.org/tag/%E5%B7%A5%E7%A8%8B%E5%BA%93%E4%BB%A3%E7%A0%81/"/>
    
    <category term="c&amp;c++" scheme="http://www.latelee.org/tag/c-c/"/>
    
  </entry>
  
  <entry>
    <title>c++命令行解析库cmdline使用</title>
    <link href="http://www.latelee.org/my-library/cmdline-in-c++.html"/>
    <id>http://www.latelee.org/my-library/cmdline-in-c++.html</id>
    <published>2020-12-25T16:00:00.000Z</published>
    <updated>2021-02-05T02:01:03.047Z</updated>
    
    <content type="html"><![CDATA[<p>之前用过 getopt 函数对主函数参数进行解析，后发现了 cmdline 这个库——说是库，实际只是一个头文件，非常方便集成到程序中。本文对此库进行简单测试。  </p><a id="more"></a><h2 id="下载编译"><a href="#下载编译" class="headerlink" title="下载编译"></a>下载编译</h2><p>cmdline 库地址为：<a href="https://github.com/tanakh/cmdline">https://github.com/tanakh/cmdline</a> 。<br>可直接下载 cmdline.h 头文件使用，也可以下载仓库，编译其中的测试示例。  </p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>测试代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"></span><br><span class="line">如果解析不存在的参数，会报段错误，最好加默认值</span><br><span class="line"></span><br><span class="line">TODO：添加子命令，类似 git log、git status 这样的</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">#include &quot;cmdline.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool g_bPrint &#x3D; false;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 有些帮助信息过多，使用函数组装</span><br><span class="line">char* getHelp(int type)</span><br><span class="line">&#123;</span><br><span class="line">    static char info[256] &#x3D; &#123;0&#125;;</span><br><span class="line">    if (type &#x3D;&#x3D; &#39;t&#39;)</span><br><span class="line">    &#123;</span><br><span class="line">        sprintf(info, </span><br><span class="line">&quot; test type \n \</span><br><span class="line">autotest  - for auto test\n \</span><br><span class="line">dualtest  - for dual version test\n \</span><br><span class="line">more comming up...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return info;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    cmdline::parser theArgs;</span><br><span class="line">    &#x2F;&#x2F; 一般形式：长命令名、短命令名（如不支持短命令填&#39;\0&#39;），描述，是否必填，默认值</span><br><span class="line">    &#x2F;&#x2F; 如果为必填，则在运行时必须带该参数，否则解析失败</span><br><span class="line">    theArgs.add&lt;string&gt;(&quot;test&quot;, &#39;t&#39;, getHelp(&#39;t&#39;), false, &quot;auto&quot;);</span><br><span class="line">    theArgs.add&lt;string&gt;(&quot;host&quot;, &#39;h&#39;, &quot;host name&quot;, false, &quot;&quot;);</span><br><span class="line">    theArgs.add&lt;int&gt;(&quot;rate&quot;, &#39;r&#39;, &quot;rate number&quot;, false, 80, cmdline::range(1, 65535)); &#x2F;&#x2F; 带默认值、范围的</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; bool 型，与上述不同，后判断有无该参数</span><br><span class="line">    theArgs.add(&quot;print&quot;, &#39;p&#39;, &quot;show message&quot;); &#x2F;&#x2F; 需要判断是否存在，存在则置标志为true</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;theArgs.add(&quot;help&quot;, 0, &quot;print this message1111&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;theArgs.footer(&quot;filename ...&quot;);</span><br><span class="line">    &#x2F;&#x2F;theArgs.set_program_name(&quot;mytool&quot;);</span><br><span class="line">    theArgs.set_program_name(argv[0]);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 调整位置，让cmdline误以为第二个参数才是命令</span><br><span class="line">    &#x2F;&#x2F;theArgs.parse_check(argc-1, &amp;argv[1]);</span><br><span class="line"></span><br><span class="line">    try&#123;</span><br><span class="line">        printf(&quot;test type: %s\n&quot;, theArgs.get&lt;string&gt;(&quot;test&quot;).c_str());</span><br><span class="line">    &#125; catch(const std::exception &amp;e)&#123;&#125;</span><br><span class="line">    try&#123;</span><br><span class="line">        printf(&quot;bad: %s\n&quot;, theArgs.get&lt;string&gt;(&quot;bad&quot;).c_str()); &#x2F;&#x2F; 不存在的参数</span><br><span class="line">    &#125; catch(const std::exception &amp;e)&#123;</span><br><span class="line">        printf(&quot;param [bad] not exist...\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    try&#123;</span><br><span class="line">        printf(&quot;host: %s\n&quot;, theArgs.get&lt;string&gt;(&quot;host&quot;).c_str());</span><br><span class="line">    &#125; catch(const std::exception &amp;e)&#123;&#125;</span><br><span class="line">    try&#123;</span><br><span class="line">        printf(&quot;rate: %d\n&quot;, theArgs.get&lt;int&gt;(&quot;rate&quot;));</span><br><span class="line">    &#125; catch(const std::exception &amp;e)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    try&#123;</span><br><span class="line">        printf(&quot;rest args: \n&quot;);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; (int)theArgs.rest().size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;cout &lt;&lt; theArgs.rest()[i] &lt;&lt; endl;</span><br><span class="line">            printf(&quot;%s\n&quot;, theArgs.rest()[i].c_str());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch(const std::exception &amp;e)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 此法不能判断不存在的参数</span><br><span class="line">    &#x2F;&#x2F; if (theArgs.exist(&quot;type&quot;))</span><br><span class="line">    &#x2F;&#x2F; &#123;</span><br><span class="line">    &#x2F;&#x2F;     printf(&quot;type111: %d\n&quot;, theArgs.get&lt;string&gt;(&quot;type&quot;).c_str());</span><br><span class="line">    &#x2F;&#x2F; &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    if (theArgs.exist(&quot;rate&quot;)) &#x2F;&#x2F; 非bool类型，似乎也不能如此判断</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;rate111: %d\n&quot;, theArgs.get&lt;int&gt;(&quot;rate&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (theArgs.exist(&quot;print&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        g_bPrint &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;a.out </span><br><span class="line">argument number must be longer than 0</span><br><span class="line">usage: .&#x2F;a.out [options] ... </span><br><span class="line">options:</span><br><span class="line">  -t, --test      test type </span><br><span class="line"> autotest  - for auto test</span><br><span class="line"> dualtest  - for dual version test</span><br><span class="line"> more comming up... (string [&#x3D;auto])</span><br><span class="line">  -h, --host     host name (string [&#x3D;])</span><br><span class="line">  -r, --rate     rate number (int [&#x3D;80])</span><br><span class="line">  -p, --print    show message</span><br><span class="line">  -?, --help     print this message</span><br><span class="line"></span><br><span class="line">$ .&#x2F;a.out -r 100 -h latelee.org</span><br><span class="line">test type: auto</span><br><span class="line">param [bad] not exist...</span><br><span class="line">host: latelee.org</span><br><span class="line">rest args: </span><br><span class="line">100</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前用过 getopt 函数对主函数参数进行解析，后发现了 cmdline 这个库——说是库，实际只是一个头文件，非常方便集成到程序中。本文对此库进行简单测试。  &lt;/p&gt;</summary>
    
    
    
    <category term="我的程序代码" scheme="http://www.latelee.org/category/my-library/"/>
    
    
    <category term="工程库代码" scheme="http://www.latelee.org/tag/%E5%B7%A5%E7%A8%8B%E5%BA%93%E4%BB%A3%E7%A0%81/"/>
    
    <category term="c&amp;c++" scheme="http://www.latelee.org/tag/c-c/"/>
    
  </entry>
  
  <entry>
    <title>架构师考点汇总 UML图</title>
    <link href="http://www.latelee.org/architecture/architect-note.html"/>
    <id>http://www.latelee.org/architecture/architect-note.html</id>
    <published>2020-12-22T16:00:00.000Z</published>
    <updated>2021-02-05T02:01:03.019Z</updated>
    
    <content type="html"><![CDATA[<p>架构师考点汇总 UML各种图，类型</p><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;p&gt;架构师考点汇总 UML各种图，类型&lt;/p&gt;</summary>
    
    
    
    <category term="软件架构" scheme="http://www.latelee.org/category/architecture/"/>
    
    
    <category term="考证" scheme="http://www.latelee.org/tag/%E8%80%83%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>架构师考点汇总 设计模式</title>
    <link href="http://www.latelee.org/architecture/architect-note.html"/>
    <id>http://www.latelee.org/architecture/architect-note.html</id>
    <published>2020-12-22T16:00:00.000Z</published>
    <updated>2021-02-05T02:01:03.019Z</updated>
    
    <content type="html"><![CDATA[<p>架构师考点汇总 设计模式</p><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;p&gt;架构师考点汇总 设计模式&lt;/p&gt;</summary>
    
    
    
    <category term="软件架构" scheme="http://www.latelee.org/category/architecture/"/>
    
    
    <category term="考证" scheme="http://www.latelee.org/tag/%E8%80%83%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>架构师考点汇总 计算机 网络</title>
    <link href="http://www.latelee.org/architecture/architect-note.html"/>
    <id>http://www.latelee.org/architecture/architect-note.html</id>
    <published>2020-12-22T16:00:00.000Z</published>
    <updated>2021-02-05T02:01:03.019Z</updated>
    
    <content type="html"><![CDATA[<p> 架构师考点汇总 计算机 网络</p><a id="more"></a><p>ISO七层<br>应用层<br>表示层<br>会话层<br>传输层<br>网络层<br>数据链路层<br>物理层  </p><p>TCP/IP四层<br>应用层   （对应最上三种）<br>传输层 运输层<br>网际层 网络层 网际互联层 互联网层<br>网络接口层  网络访问层 数据链路层  链路层  （对应最下两种）   </p>]]></content>
    
    
    <summary type="html">&lt;p&gt; 架构师考点汇总 计算机 网络&lt;/p&gt;</summary>
    
    
    
    <category term="软件架构" scheme="http://www.latelee.org/category/architecture/"/>
    
    
    <category term="考证" scheme="http://www.latelee.org/tag/%E8%80%83%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>架构师考点汇总 设计模式</title>
    <link href="http://www.latelee.org/architecture/architect-note.html"/>
    <id>http://www.latelee.org/architecture/architect-note.html</id>
    <published>2020-12-22T16:00:00.000Z</published>
    <updated>2021-02-05T02:01:03.019Z</updated>
    
    <content type="html"><![CDATA[<p>架构师考点汇总 设计模式</p><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;p&gt;架构师考点汇总 设计模式&lt;/p&gt;</summary>
    
    
    
    <category term="软件架构" scheme="http://www.latelee.org/category/architecture/"/>
    
    
    <category term="考证" scheme="http://www.latelee.org/tag/%E8%80%83%E8%AF%81/"/>
    
    <category term="设计原则" scheme="http://www.latelee.org/tag/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>golang和C的输出格式化对齐</title>
    <link href="http://www.latelee.org/my-library/printf-format-alignment-in-golang-and-c.html"/>
    <id>http://www.latelee.org/my-library/printf-format-alignment-in-golang-and-c.html</id>
    <published>2020-12-22T16:00:00.000Z</published>
    <updated>2021-02-05T02:01:03.047Z</updated>
    
    <content type="html"><![CDATA[<p>写代码那么多年，对代码，输出日志有一种近似洁癖的要求。对于不整齐、不整洁、命名混乱的代码，真心看不下去，总会想办法去整顿——或用工具，或人工。曾因这个原因耽误时间，虽然想着改，但一时也改不了多少。今年唯一例外的，应该我手上维护的那套98年开始写的 delphi 工程。  </p><p>本文从小处着手，单说一些输出日志的对齐方法。  </p><a id="more"></a><p>在 golang 中，常用的命令行库为 cobra，内部实现了帮助信息的对齐。以 docker 为例，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># docker --help</span><br><span class="line">Usage:  docker [OPTIONS] COMMAND</span><br><span class="line"></span><br><span class="line">A self-sufficient runtime for containers</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --config string      Location of client config files (default &quot;&#x2F;root&#x2F;.docker&quot;)</span><br><span class="line">  -D, --debug              Enable debug mode</span><br><span class="line"></span><br><span class="line">Management Commands:</span><br><span class="line">  builder     Manage builds</span><br><span class="line">  config      Manage Docker configs</span><br><span class="line">  container   Manage containers</span><br><span class="line">  context     Manage contexts</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  attach      Attach local standard input, output, and error streams to a running container</span><br><span class="line">  build       Build an image from a Dockerfile</span><br><span class="line">  commit      Create a new image from a container&#39;s changes</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在自己实现的小型命令终端程序框架时，也使用了 cobra ，但做了一些精简，比如子命令的命令，按官方方法是使用多级子命令形式，但觉得麻烦，将“子命令的命令”作为子命令的参数处理，但如此一来，有些输出信息就不整齐了。<br>为解决问题，参考了 cobra 源码，提炼出核心代码，最终达到预期目标。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;cmdtool.exe test</span><br><span class="line">test...</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  foo   just a foo help info</span><br><span class="line">  watch watch config file</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  cmdtool.exe test [flags]</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">  example comming up...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -h, --help       help for test</span><br><span class="line">  -m, --mode int   set the test mode</span><br><span class="line"></span><br><span class="line">Global Flags:</span><br><span class="line">  -c, --config string   config file (config.yaml)</span><br><span class="line">  -o, --output string   specify the output file name</span><br><span class="line">  -p, --print           verbose output</span><br></pre></td></tr></table></figure><p>其中，<code>Available Commands:</code>为自定义函数中的输出，将参数作为子命令的命令。核心代码如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; rpad adds padding to the right of a string.</span><br><span class="line">func rpad(s string, padding int) string &#123;</span><br><span class="line">truetemplate :&#x3D; fmt.Sprintf(&quot;%%-%ds&quot;, padding)</span><br><span class="line">truereturn fmt.Sprintf(template, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;返回字符串的</span><br><span class="line">func GetHelpInfo(theCmd []conf.UserCmdFunc) (ret string) &#123;</span><br><span class="line">truevar cmdMaxLen int &#x3D; 0</span><br><span class="line">trueret &#x3D; fmt.Sprintf(&quot;Available Commands:\n&quot;);</span><br><span class="line"></span><br><span class="line">truefor _, item :&#x3D; range theCmd &#123;</span><br><span class="line">truetruenameLen :&#x3D; len(item.Name)</span><br><span class="line">truetrueif nameLen &gt; cmdMaxLen &#123;</span><br><span class="line">truetruetruecmdMaxLen &#x3D; nameLen</span><br><span class="line">truetrue&#125;</span><br><span class="line">true&#125;</span><br><span class="line">true</span><br><span class="line">truefor _, item :&#x3D; range theCmd &#123;</span><br><span class="line">truetrueret +&#x3D; fmt.Sprintf(&quot;  %v %v\n&quot;, rpad(item.Name, cmdMaxLen), item.ShortHelp)</span><br><span class="line">true&#125;</span><br><span class="line">true</span><br><span class="line">truereturn</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>rpad</code>为组装格式化字符串（因此会出现多个<code>%</code>，<code>-</code>为左对齐）函数，输入的<code>padding</code>为一列数据的最大值，该值是遍历用户命令列表的名称，获取得到 的最大长度。用户命令列表如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var theCmd &#x3D; []conf.UserCmdFunc&#123;</span><br><span class="line">    conf.UserCmdFunc &#123;</span><br><span class="line">        Name: &quot;foo&quot;,</span><br><span class="line">        ShortHelp: &quot;just a foo help info&quot;,</span><br><span class="line">        Func: foo,</span><br><span class="line">    &#125;,</span><br><span class="line">    conf.UserCmdFunc &#123;&quot;watch&quot;, &quot;watch config file&quot;, testWatch,&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依据上述思路，在C中也容易实现类似的对齐需求。示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char fmt[128] &#x3D; &#123;0&#125;;</span><br><span class="line">sprintf(fmt, &quot;autoTestFee %%s%%-%ds -&gt; %%s%%-%ds vehicleType %%s payFee %%-6d outFee %%-9.2f realFee %%-6d\n&quot;, </span><br><span class="line">              nameLen1+2, nameLen2+2);</span><br><span class="line">&#x2F;&#x2F; printf(&quot;%s\n&quot;, fmt);</span><br><span class="line">printf(fmt, item-&gt;en, item-&gt;enName, item-&gt;ex, item-&gt;exName, type, payFee, outFee, realFee);</span><br></pre></td></tr></table></figure><p>代码中使用 sprintf 组装格式化字符串，该语句转化后如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;autoTestFee %s%-10s -&gt; %s%-9s vehicleType %s payFee %-6d outFee %-9.2f realFee %-6d\n&quot;  # 数字为示例</span><br></pre></td></tr></table></figure><p>其中 nameLen1 和 nameLen2 分别为 enName 和 exName 列表的最大值（方便对齐）。<br>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">autoTestFee 100(hello)     -&gt; 200(foobarrrrbbbbbbbbbbb) vehicleType 未名 payFee 2018   outFee 20.00     realFee 2003  </span><br><span class="line">autoTestFee 101(hello)     -&gt; 201(f)                    vehicleType 未名 payFee 2019   outFee 20.00     realFee 2003  </span><br></pre></td></tr></table></figure><p>这样，在搜索日志时就容易分辨了。  </p><p>经测试，如果字符串含有中文且中文长度不等（或中英混合），对齐还是有问题，待后续解决。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;写代码那么多年，对代码，输出日志有一种近似洁癖的要求。对于不整齐、不整洁、命名混乱的代码，真心看不下去，总会想办法去整顿——或用工具，或人工。曾因这个原因耽误时间，虽然想着改，但一时也改不了多少。今年唯一例外的，应该我手上维护的那套98年开始写的 delphi 工程。  &lt;/p&gt;
&lt;p&gt;本文从小处着手，单说一些输出日志的对齐方法。  &lt;/p&gt;</summary>
    
    
    
    <category term="我的程序代码" scheme="http://www.latelee.org/category/my-library/"/>
    
    
    <category term="工程库代码" scheme="http://www.latelee.org/tag/%E5%B7%A5%E7%A8%8B%E5%BA%93%E4%BB%A3%E7%A0%81/"/>
    
    <category term="c&amp;c++" scheme="http://www.latelee.org/tag/c-c/"/>
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>架构师考点汇总</title>
    <link href="http://www.latelee.org/architecture/architect-note.html"/>
    <id>http://www.latelee.org/architecture/architect-note.html</id>
    <published>2020-12-22T16:00:00.000Z</published>
    <updated>2021-02-05T02:01:03.019Z</updated>
    
    <content type="html"><![CDATA[<p>架构师考点汇总</p><a id="more"></a><h1 id="较集中知识点"><a href="#较集中知识点" class="headerlink" title="较集中知识点"></a>较集中知识点</h1><h2 id="质量属性"><a href="#质量属性" class="headerlink" title="质量属性"></a>质量属性</h2><p>功能性 （Functionality）、性能（Performance）、 可靠性 （Reliability）、可用性（Availability）、安全性（Security）、 互操作性（Inter-operation）<br>易用性（Usability）、可测试性（Testability）、可变性（Changeability）、可修改性（Modification）、健壮性（Robustness）  </p><p>记忆： 11个 功能靠用安操   易试变改壮   或：功能用改安，靠操易试变壮  </p><p>效用树  4个重要组成：<br>性能、可用性、可修改性、安全性  记忆：能用改安  </p><p>风险点、非风险点、敏感点与权衡点<br>系统架构风险是指架构设计中潜在的、存在问题的架构决策所带来的隐患。<br>敏感点是指为了实现某种特定的质量属性，一个或多个构件所具有的特性。<br>权衡点是影响多个质量属性的特性，是多个质量属性的敏感点。</p><p>敏感点和权衡点都是在软件架构中所做的关键决策，不同的是，敏感点决策只影响一个软件质量属性，而权衡点则同时影响多个质量属性，有时不同属性间还会互相冲突，比如选择不同的加密方式同时影响性能和安全性，所以需要权衡。</p><p>风险承担者是指那些关心软件架构，个人利益受软件架构好坏影响的人，在项目管理领域也称为项目干系人或涉众。这照些人整体上又可以分为系统的生产者和系统的消费者。生产者包括架构师，开发人员，维护人员，测试人员等；消费者包括客户，最终用户等。</p><p>构架设计方案应让各风险承担者积极参与评估  </p><p>10）功能性<br>功能性是系统所能完成所期望工作的能力。</p><p>1）性能<br>性能（performance）是指系统的响应能力，即要经过多长时间才能对某个事件做出响应，或者在某段时间内系统所能处理的事件的个数。<br>代表参数：响应时间、吞吐量<br>设计策略：增加计算资源、改善资源需求（减少计算复杂度等）、资源 调度（先进先出队列、优先级队列等）、资源管理（并发、数据复制等）。</p><p>2）可用性<br>可用性（availability）是系统能够正常运行的时间比例。经常用两次故障之间的时间长度或在出现故障时系统能够恢复正常的速度来表示。<br>代表参数：故障间隔时间<br>设计策略：冗余、心跳、Ping/Echo、异常。<br>3）安全性<br>安全性（security）是指系统在向合法用户提供服务的同时能够阻止非授权用户使用的企图或拒绝服务的能力。安全性又可划分为机密性、完整性、不可否认性及可控性等特性。<br>设计策略：抵御攻击（授权、认证和限制访问等）、追踪审计、信息隐藏、攻击检测（入侵检测等）、从攻 击中恢复（部分可用性策略）。</p><p>4）可修改性<br>可修改性（modifiability）是指能够快速地以较高的性能价格比对系统进行变更的能力。通常以某些具体的变更为基准，通过考察这些变更的代价衡量可修改性。<br>设计策略：软件模块泛化、 限制模块之间通信、使用中介和延迟绑定。局部化变更、防止连锁反应、推迟绑定时间</p><p>6）健壮性<br>健壮性是指在处理或环境中，系统能够承受压力或变更的能力。</p><p>7）可变性<br>可变性是指体系结构经扩充或变更成为新体系结构的能力。</p><p>8）易用性<br>易用性是衡量用户使用一个软件产品完成指定任务的难易程度。<br>分离用户接口、支持用户主动、用户模型</p><p>9）可测试性<br>可测试性是指软件发现故障并隔离、定位其故障的能力特性，以及在一定的时间和成本前提 下，进行测试设计、测试执行的能力。</p><p>11）互操作性<br>互操作性是指系统与外界或系统与系统之间的相互作用能力。</p><p>5）可靠性<br>可靠性（Reliability）是指产品在规定的条件下和规定的时间内完成规定功能的能力。其子特性包括成熟性，容错性，易恢复性，可靠性，依从性。</p><p>5.1.影响因素：</p><p>运行环境（软件可靠性的定义是相对于运行环境的）；软件规模；软件内部结构（内部结构越复杂，包含的缺陷数就可能越多）；软件的开发方法和开发环境；软件的可靠性投入等。</p><p>5.2.遵循原则：1、软件可靠性设计是软件设计的一部分，必须在软件的总体设计框架中使用，并且不能与其他设计<br>原则相冲突。2、软件可靠性设计在满足提高软件质量要求的前提下，以提高和保障软件可靠性为最终目标。3、软件可靠性设计应确定软件的可靠性目标，不能无限扩大，并且排在功能、用户需求、开发费用之后考虑。</p><p>5.3.可靠性分析方法： 在软件可靠性设计之前和软件可靠性设计过程中，都需要采用软件可靠性分析和预|测方法，来确定当前系统中的主要可靠性因素和目标。常见的软件可靠性分析方法包括故障树分析方法、失效模式与效应分析方法等。<br>       故障树分析方法：一种自顶向下的软件可靠性分析方法，即从软件系统不希望发生的事件（顶 事件)，特别是对人员和设备的安全及可靠性产生重大影响的事件开始，向下逐步追查导致顶事件发生的原因，直至基本事件（底事件)，从而确定软件故障原因的各种可能组合方式和（或）发生概率。基本的步骤是软件故障树的建立、定性分析和定量分析。<br>       失效模式与效应分析方法：在软件开发阶段的早期，通过识别软件失效模式，分析造成的后果，研究分析各种失效模式产生的原因，寻找消除和减少其有害后果的方法，以便尽早发现潜在的问题，并采取相应的措施,从而提髙软件的可靠性和安全性。SFMEA的分析对象可以是开发早期阶段的高层次的子系统、部件，也可以是详细设计阶段的单元、模块。对于不同的分析对象，其软件失效模式是不同的，采用的SFMEA分析方法也不同，前者采用系统级分析方法（systemFMEA)，后者为详细级分析方法（detailedFMEA)。其基本的步骤是系统定义、软件失效模式分析、软件失效原因分析、软件失效影响分析、改进措施分析。</p><p>5.4.设计策略：(1)容错设计（N版本程序设计、恢复块方法 、冗余设计、双机热备或集群系统 ） (2)检错设计 (3)降低复杂度设计</p><p>(1)错设计技术：对于软件失效后果特别严重的场合，如飞机的飞行控制系统、空中交通管制系统等，采用容错设计技术。常见的容错设计技术有三种：恢复块设计、N版本程序设计和冗余设计。(a)恢复块设计：选择一组软件操作作为容错设计单元，把普通的程序块变成恢复块。一个恢复块包含有若千个功能相同、设计差异的程序块文本，一个运行文本，多个备份文本，构成“动态冗余”，一旦运行文本出现故障，则用备份文本替换。软件容错的恢复块方法就是使软件包含有一系列恢复块。(b)N版本程序设计：N版本程序的核心是通过设计出多个模块或不同版本，对于相同初始条件和相同输入的操作结果，实现多数表决，防止其中某一软件模块/版本的故障提供错误的服务，以实现软件容错。 (c)冗余设计：在一套完整的软件系统之外，设计一种不同路径、不同算法或不同实现方法的模块或系统作为备份，在出现故障时可以使用冗余的部分进行替换，从而维持软件系统的正常运行。缺点是费用和资源的消耗会有所增加。</p><p>(2)检错技术：在软件系统中，无需在线容错的地方，或不能采用冗余设计技术的部分，如果对可靠性要求较高，故障有可能导致严重的后果时，一般采用检错技术，在软件出现故障后能及时发现并报警，其缺点是不能自动解决故障。</p><p>(3)降低复杂度设计：软件复杂性与软件可靠性有着密切的关系，是产生软件缺陷的重要根源。在设计时考虑降低软件的复杂性，是提高软件可靠性的有效方法。降低复杂度设计的思想是在保证实现软件功能的基础上，简化软件结构，缩短程序代码，优化软件数据流向，降低软件复杂度，从而提高软件可靠性。</p><p>属性效用树示例：</p><p>质量属性    属性求精    场景<br>安全性      访问的安全性    在web服务中，应该有防火墙保护，防止网络上的非法数据请求**( M, H )**<br>安全性      数据的完整性    当出现异地订票点同时需要对通一张票请求操作时，系统必须保证数据库内数据的完整性**(H, L)**<br>可用性      异常检测和抛出  用户企图输入不符合系统条件的查询或者订购不存在的票务的时候，系统必须检测出，并且抛出相应的异常，转入挂起操作<br>可修改性    信息管理        为了适应变化得票务数据，系统必须提供一个后台管理界面**( M, L )**<br>性能        等待时间        用户在界面上进行票务查询或者进行订购操作的时候，系统必须在规定的时间内做出反应，不能出现用户无故长时间等待的情况。( H, M )</p><h2 id="架构评估方法"><a href="#架构评估方法" class="headerlink" title="架构评估方法"></a>架构评估方法</h2><p>基于问卷调查的评估方式<br>基于场景的评估方式<br>基于度量的评估方式  </p><p>传统软件架构评估方法按评估形式，一般分为三种:<br>一是调查问卷法，即直接请对系统架构了解的专家学者对系统架构做出主观评估。<br>二是度量法，即将软件系统架构完全量化，通过一些客观的数字指标来评估架构的好坏。<br>三是场景评估法，即挑选出重要的系统使用场景(一系列有序的使用或修改系统的步骤，即系统涉众如何使用系统的 )，根据不同场景中各架构的表现分别作评估，主客观程度介于前面两种方法之间。</p><p>场景评估法划分：架构权衡分析法ATAM(Architachture Tradeoff Analysis Method)，软件架构分析法SAAM，成本效益分析法CBAM。</p><p>ATAM通过理解体系结构方法来分析体系结构，评估过程分9个步骤</p><p>1- 描述ATAM方法  ATAM描述  </p><p>即评估小组负责人向参加会议的风险承担者介绍ATAM评估方法，让大家清楚接下来要做什么，每个人的角色和任务。</p><p>2- 描述业务动机  商业动机表述  </p><p>项目经理从业务角度介绍系统的概况，一般包括业务环境，背景，业务约束条件，技术约束，质量属性需求等内容。</p><p>3- 描述体系结构 软件架构表述  </p><p>首席设计师或设计小组对体系结构进行详略适当的介绍。包括技术约束，与本统交互的其他系统，用以满足质量属性要求的体系结构方法（功能，模块，进程，硬件）。</p><p>4- 确定体系结构方法  确认架构方式</p><p>由设计师确定体系结构方法，由分析小组捕获，但不进行分析。</p><p>5- 生成质量属性效用树  生成效用树  </p><p>评估小组，设计小组，管理人员和客户代表一起确定系统最重要的质量属性目标，并对这些目标设置优先级和细化。</p><p>6- 分析体系结构方法  分析构架方式</p><p>7- 讨论分级场景  确定场景及其优先级</p><p>8- 分析体系结构方法  进一步分析架构方式  </p><p>9- 描述评估结果 得出结论  </p><p>SAAM（软件系统架构分析方法），它也是一种基于场景的评估方法，最早用于分析体系结构的可修改性，后来也用于其他质量属性的评估。相比于SAAM，要简单许多，主要包括如下6个步骤：</p><ol><li><p>形成场景</p></li><li><p>描述体系结构</p></li><li><p>对场景进行分类和确定优先级</p></li><li><p>对间接场景进行单个评估</p></li><li><p>评估场景的相互作用</p></li><li><p>形成总体评价</p></li></ol><p>下面分别给大家说明一下。</p><p>1.形成场景</p><p>指的是风险承担者们集中在一起，集体讨论，提出一个个系统需求场景。记录人员把这些场景记录在册，形成文档的过程。</p><p>2.描述体系结构</p><p>指的是体现结构设计师，对待评估的体系结构进行适当的描述，包括静态属性和动态特征，可以用自然语言也可以用形式化手段，以让参加评估的所有人员都能充分理解。</p><p>这一步骤和上一个形成场景的步骤可以合并在一起，重复进行多次。</p><p>3.对场景进行分类和确定优先级</p><p>系统可分为直接场景和间接场景，直接场景指的是本体系结构可以直接支持的场景，即不需要对体系结构做任何修改即可直接实现。</p><p>另外一种间接场景则是需要对现有体系结构做些更改才能支持的场景。</p><p>最后用投票的方法，确定间接场景的重要性优先级，以便大家将有限的时间花在最重要的事情上。</p><p>4.对间接场景进行单个评估</p><p>就是将选出来的重要场景与体系结构描述对应起来。体系结构设计师具体说明体系结构需要做哪些修改变更才能适用间接场景的要求，并估计这些变更的代价。</p><p>最后形成一份全部场景的总结性列表。</p><p>列表字段包括：场景编号、场景描述、直接/间接、需要做的更改、更改/新增构建数量、更改工作量估计</p><p>5.评估场景的相互作用</p><p>当两个或多个间接场景需要修改到同一个构建时，这时场景就在这个构件上出现了相互作用，需要特别评估。</p><p>出现这种情况，往往是设计方案中功能分配不合理，或者是设计文档未能充分说明体系结构。</p><p>6.形成总体评价</p><p>最后，评估人员对场景和场景间的相互作用做一个总体的权衡和评价。通过各个场景权重与分值得出一个总体的评价，从多个体系结构，或者一个体系结构的不同设计方案选择出一个最优的方案。</p><h2 id="评价程序评价机器性能"><a href="#评价程序评价机器性能" class="headerlink" title="评价程序评价机器性能"></a>评价程序评价机器性能</h2><p>小型基准程序：代码行数比较少，通常是测试算法；<br>真实程序：所有程序全部测评，准确性最高；<br>核心程序：真实程序中具有代表性的代码；<br>合成基准程序：人为合成基准程序，准确性最低。  </p><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p>开闭原则：对扩展开放，对修改关闭。<br>里氏替换原则：在使用父类的地方，都能使用其子类，不需要进行修改（反过来不成立）。<br>最少知识：一个软件实体应该尽可能少的与其他实体相互作用。<br>依赖倒置：抽线不依赖于细节，细节依赖于抽象。针对接口编程，不针对实现编程。  </p><h2 id="测试相关"><a href="#测试相关" class="headerlink" title="测试相关"></a>测试相关</h2><p>软件集成测试也称为组装测试、联合测试(对于子系统而言，则称为部件测试)。它将已通过单元测试的模块集成在一起，主要测试模块之间的协作性。从组装策略而言，可以分为一次性组装测试和增量式组装(包括自项向下、自底向上及混合式)两种。集成测试计划通常是在软件概要设计阶段完成的，集成测试一般采用黑盒测试方法。</p><p>根据国家标准<code>GB／T 15532-2008</code>，软件测试可分为单元测试、集成测试、配置项测试、系统测试、验收测试和回归测试等类别。<br>单元测试：也称为模块测试，测试对象为模块。测试模块的功能，性能等是否达到标准。其目的是检查每个模块能否正确地实现设计说明中的功能、性能、接口和其他设计约束等条件，发现模块内可能存在的各种差错。（白盒测试， 依据：软件的详细设计）；<br>集成测试：目的是检查模块之间，以及模块和已集成的软件之间的接口关系，并验证已集成的软件是否符合设计要求。模块与模块之间，软件与集成之间的（黑盒测试，依据：软件的概要设计）；<br>系统测试：对象是完整的、集成的计算机系统。目的是在真实系统工作环境下，验证完整的软件配置项能否和系统正确连接，并满足系统／子系统设计文档和软件开发合同规定的要求。在真实系统中，验证配置项是否和系统能成功连接，达到规定要求（依据：用户需求或开发合同）；  </p><p>常见的系统测试主要有恢复测试、安全性测试、压力测试、性能测试、可靠性测试、可用性测试、可维护性测试和安装测试。不包括路径测试。<br>配置项测试：对象是软件配置项。目的是检验软件配置项与软件需求规格说明的一致性。<br>确认测试：主要验证软件的功能、性能和其他特性是否与用户需求一致。验收测试是指针对软件需求规格说明，在交付前以用户为主进行的测试。<br>回归测试：测试软件变更后的正确性；目的是测试软件变更之后，变更部分的正确性和对变更需求的复合型，以及软件原有的、正确的功能、性能和其他规定的要求的不损害性。  </p><p>白盒测试：也称结构测试或逻辑驱动测试，它是知道产品内部工作过程，可通过测试来检测产品内部动作是否按照规格说明书的规定正常进行，按照程序内部的结构测试程序，检验程序中的每条通路是否都有能按预定要求正确工作，而不顾它的功能。白盒”法全面了解程序内部逻辑结构、对所有逻辑路径进行测试。 白盒测试逻辑驱动方法：语句覆盖 判定覆盖 条件覆盖 判定/条件覆盖 条件组合覆盖 路径覆盖</p><p>黑盒测试：一种从软件外部对软件实施的测试，也称功能测试或基于规格说明的测试。其基本观点是：任何程序都可以看作是从输入定义域到输出值域的映射，这种观点将被测程序看作一个打不开的黑盒，黑盒里面的内容(实现)是完全不知道的，只知道软件要做什么。因无法看到盒子中的内容，所以不知道软件是如何实现的，也不关心黑盒里面的结构，只关心软件的输入数据和输出结果。主要根据功能需求设计测试用例，进行测试。常用方法：等价类划分 边界值分析 因果图 决策表分析 </p><p>灰盒测试：是介于白盒测试与黑盒测试之间的一种测试，灰盒测试多用于集成测试阶段，不仅关注输出、输入的正确性，同时也关注程序内部的情况。灰盒测试不像白盒那样详细、完整，但又比黑盒测试更关注程序的内部逻辑，常常是通过一些表征性的现象、事件、标志来判断内部的运行状态。</p><p>静态测试是指被测试程序不在机器上运行，而采用人工检测和计算机辅助静态分析的手段对程序进行检测。<br>静态测试工具可用于对软件需求、结构设计、详细设计和代码进行评审、走查和审查。<br>静态测试工具可对软件的复杂度分析、数据流分析、控制流分析和接口分析提供支持。<br>静态测试包括对文档的静态测试和对代码的静态测试。对代码的静态测试包括控制流分析、数据流分析、接口分析和表达式分析。</p><p>动态测试需要运行被测试系统，并设置探针，向代码生成的可执行文件中插入检测代码，可用于软件的覆盖分析和性能分析，也可用于软件的模拟、建模、仿真测试和变异测试等。</p><p>软件维护：<br>1 正确性(改正性)维护。改正在系统开发阶段已发生而系统测试阶段尚未发现的错误。<br>2 适应性维护。在使用过程中，外部环境(新的硬、软件配置)、数据环境(数据库、数据格式、数据输入/输出方式、数据存储介质)可能发生变化。为使软件适应这种变化，而去修改软件的过程就称为适应性维护。<br>3 完善性维护。在软件的使用过程中，用户往往会对软件提出新的功能与性能要求。为了满足这些要求，需要修改或再开发软件，以扩充软件功能、增强软件性能、改进加工效率、提高软件的可维护性。这种情况下进行的维护活动称为完善性维护。<br>4 预防性维护。这是指为了适应未来的软硬件环境的变化，应主动增加预防性的新的功能，以使应用系统适应各类变化而不被淘汰。</p><p>遗留系统策略<br>遗留系统的演化可以采用淘汰、继承、改造和集成四种策略<br>​①淘汰策略。第四象限为低水平、低价值区，即遗留系统的技术含量较低，且具有较低的业务价值。<br>②继承策略。第二象限为低水平、高价值区，即遗留系统的技术含量较低，已经满足企业运作的功能或性能要求，但具有较高的商业价值，目前企业的业务尚紧密依赖该系统。<br>​③改造策略。第一象限为高水平、高价值区，即遗留系统的技术含量较高，本身还有强大的生命力。系统具有较高的业务价值，基本上能够满足企业业务运作和决策支持的需要。<br>​④集成策略。第三象限为高水平、低价值区，即遗留系统的技术含量较高，但其业务价值较低，可能只完成某个部门(或子公司)的业务管理。</p><p>象限：<br>业务价值高    继承       改造<br>业务价值低    淘汰       集成<br>           技术水平低  技术水平高 </p><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><p>统一过程（UP/RUP）具有三个显著特征：用例驱动、以体系结构为中心、迭代和增量。</p><h1 id="信息化-开发方法-知识产权-等"><a href="#信息化-开发方法-知识产权-等" class="headerlink" title="信息化 开发方法 知识产权 等"></a>信息化 开发方法 知识产权 等</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;架构师考点汇总&lt;/p&gt;</summary>
    
    
    
    <category term="软件架构" scheme="http://www.latelee.org/category/architecture/"/>
    
    
    <category term="考证" scheme="http://www.latelee.org/tag/%E8%80%83%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：命令行cobra库实例再三优化</title>
    <link href="http://www.latelee.org/golang/golang-notes-cobra-note-iii.html"/>
    <id>http://www.latelee.org/golang/golang-notes-cobra-note-iii.html</id>
    <published>2020-12-10T16:00:00.000Z</published>
    <updated>2021-02-05T02:01:03.079Z</updated>
    
    <content type="html"><![CDATA[<p>本文是上一文章<a href="golang-notes-cobra-note-ii.html">《Golang实践录：命令行cobra库实例优化》</a> 的优化，主要的子命令的业务实现的整理。  </p><a id="more"></a><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>上一版本实现的方式，还是有点不满意，格式也不对齐，重要的是，似乎不是正规的方式。  </p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>cobra官方支持多级子命令，经研究测试发现，在实现三级子命令时，稍有麻烦。故舍弃官方的做法。同时参考了部分示例代码，结合得到本文的案例。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>旧版本如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">var theCmd &#x3D; []conf.UserCmdFunc&#123;</span><br><span class="line">    conf.UserCmdFunc &#123;</span><br><span class="line">        Name: &quot;foo&quot;,</span><br><span class="line">        ShortHelp: &quot;just a foo help info&quot;,</span><br><span class="line">        Func: foo,</span><br><span class="line">    &#125;,</span><br><span class="line">    conf.UserCmdFunc &#123;&quot;watch&quot;, &quot;watch config file&quot;, testWatch,&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewCmdTest() *cobra.Command&#123;</span><br><span class="line"></span><br><span class="line">    var cmd &#x3D; &amp;cobra.Command&#123;</span><br><span class="line">        Use:     name,</span><br><span class="line">        Short:   shortDescription,</span><br><span class="line">        Long:    longDescription,</span><br><span class="line">        Example: example,</span><br><span class="line">        RunE: func(cmd *cobra.Command, args []string) error &#123;</span><br><span class="line">truetruetrue&#x2F;&#x2F;klog.Println(common.DBName)</span><br><span class="line">truetruetrueif (len(args) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">truetruetruetrueklog.Warning(&quot;no args found&quot;)</span><br><span class="line">truetruetruetruecommon.PrintHelpInfo(theCmd)</span><br><span class="line">truetruetruetruereturn nil</span><br><span class="line">truetruetrue&#125;</span><br><span class="line">            &#x2F;&#x2F; !! 遍历并调用即可</span><br><span class="line">truetruetruefor _, item:&#x3D;range theCmd &#123;</span><br><span class="line">truetruetruetrueif (args[0] &#x3D;&#x3D; item.Name) &#123;</span><br><span class="line">truetruetruetruetrueitem.Func(args)</span><br><span class="line">truetruetruetruetruereturn nil</span><br><span class="line">truetruetruetrue&#125;</span><br><span class="line">truetruetrue&#125;</span><br><span class="line">truetruetrueklog.Printf(&quot;cmd &#39;%v&#39; not support&quot;, args[0])</span><br><span class="line">truetruetruecommon.PrintHelpInfo(theCmd)</span><br><span class="line">            return nil</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; note：使用子命令形式，下列可在help中展开</span><br><span class="line">    &#x2F;&#x2F; 命令参数，保存的值，参数名，默认参数，说明</span><br><span class="line">    &#x2F;&#x2F;cmd.Flags().StringVar(&amp;mode, &quot;db&quot;, &quot;-&quot;, &quot;set the database name&quot;)</span><br><span class="line"></span><br><span class="line">    return cmd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新版本修改如下：  </p><p>根据命令参数长度补齐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; rpad adds padding to the right of a string.</span><br><span class="line">func rpad(s string, padding int) string &#123;</span><br><span class="line">truetemplate :&#x3D; fmt.Sprintf(&quot;%%-%ds&quot;, padding)</span><br><span class="line">truereturn fmt.Sprintf(template, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func GetHelpInfo(theCmd []conf.UserCmdFunc) (ret string) &#123;</span><br><span class="line">trueret &#x3D; fmt.Sprintf(&quot;Available Commands:\n&quot;);</span><br><span class="line"></span><br><span class="line">truefor _, item :&#x3D; range theCmd &#123;</span><br><span class="line">truetruenameLen :&#x3D; len(item.Name)</span><br><span class="line">truetrueif nameLen &gt; cmdMaxLen &#123;</span><br><span class="line">truetruetruecmdMaxLen &#x3D; nameLen</span><br><span class="line">truetrue&#125;</span><br><span class="line">true&#125;</span><br><span class="line">true</span><br><span class="line">truefor _, item :&#x3D; range theCmd &#123;</span><br><span class="line">truetrueret +&#x3D; fmt.Sprintf(&quot;  %v %v\n&quot;, rpad(item.Name, cmdMaxLen), item.ShortHelp)</span><br><span class="line">true&#125;</span><br><span class="line">true</span><br><span class="line">truereturn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子命令实现：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var mode int</span><br><span class="line"></span><br><span class="line">func NewCmdTest() *cobra.Command&#123;</span><br><span class="line"></span><br><span class="line">    var cmd &#x3D; &amp;cobra.Command&#123;</span><br><span class="line">        Use:     name,</span><br><span class="line">        Short:   shortDescription,</span><br><span class="line">        Long:    longDescription + &quot;\n&quot; + common.GetHelpInfo(theCmd),</span><br><span class="line">        Example: example,</span><br><span class="line">        RunE: func(cmd *cobra.Command, args []string) error &#123;</span><br><span class="line">truetruetrue&#x2F;&#x2F; 1 没有参数</span><br><span class="line">truetruetrueif (len(args) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">truetruetruetrue&#x2F;&#x2F;klog.Warning(&quot;no args found&quot;)</span><br><span class="line">truetruetruetrue&#x2F;&#x2F;common.PrintHelpInfo(theCmd)</span><br><span class="line">truetruetruetruecmd.Help()</span><br><span class="line">truetruetruetruereturn nil</span><br><span class="line">truetruetrue&#125;</span><br><span class="line"></span><br><span class="line">truetruetrue&#x2F;&#x2F; 2 遍历是否有合法的参数，如无则提示</span><br><span class="line">truetruetrueidx :&#x3D; -1</span><br><span class="line">truetruetruefor idx1, item :&#x3D; range theCmd &#123;</span><br><span class="line">truetruetruetrueif (args[0] &#x3D;&#x3D; item.Name) &#123;</span><br><span class="line">truetruetruetruetrueidx &#x3D; idx1 &#x2F;&#x2F; why ???</span><br><span class="line">truetruetruetruetruebreak</span><br><span class="line">truetruetruetrue&#125;</span><br><span class="line">truetruetrue&#125;</span><br><span class="line">truetruetrueif idx &#x3D;&#x3D; -1 &#123;</span><br><span class="line">truetruetruetrueklog.Printf(&quot;arg &#39;%v&#39; not support&quot;, args[0])</span><br><span class="line">truetruetruetruecmd.Help()</span><br><span class="line">truetruetruetruereturn nil</span><br><span class="line">truetruetrue&#125;</span><br><span class="line">truetruetrue</span><br><span class="line">truetruetrue&#x2F;&#x2F; 3 执行公共的初始化</span><br><span class="line">truetruetrueklog.Printf(&quot;bussiness init, mode: %v\n&quot;, mode) &#x2F;&#x2F; just test</span><br><span class="line"></span><br><span class="line">truetruetrue&#x2F;&#x2F; 4 执行命令</span><br><span class="line">truetruetruetheCmd[idx].Func(args)</span><br><span class="line"></span><br><span class="line">truetruetruereturn nil</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; note：使用子命令形式，下列可在help中展开</span><br><span class="line">    &#x2F;&#x2F; 命令参数，保存的值，参数名，默认参数，说明</span><br><span class="line">truecmd.Flags().IntVarP(&amp;mode, &quot;mode&quot;, &quot;m&quot;, 0, &quot;set the test mode&quot;)</span><br><span class="line"></span><br><span class="line">    return cmd</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改1：将自定义的帮助信息纳入到<code>Long</code>字段，利用默认的<code>cmd.Help()</code>输出信息（要添加自定义的部分信息）。<br>修改2：先遍历自定义的命令列表，没有时提示帮助信息，有则执行。  </p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>默认输出帮助信息：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;cmdtool.exe</span><br><span class="line">  cmd test tool.</span><br><span class="line">  【中文样例】命令终端测试示例工具。</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  cmdtool.exe [command]</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">  comming soon...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  db          db command</span><br><span class="line">  help        Help about any command</span><br><span class="line">  misc        misc command</span><br><span class="line">  test        test command</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -c, --config string   config file (config.yaml)</span><br><span class="line">  -h, --help            help for cmdtool.exe</span><br><span class="line">  -o, --output string   specify the output file name</span><br><span class="line">  -p, --print           verbose output</span><br><span class="line">      --version         version for cmdtool.exe</span><br><span class="line"></span><br><span class="line">Use &quot;cmdtool.exe [command] --help&quot; for more information about a command.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行子命令，默认将合法的命令输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;cmdtool.exe test</span><br><span class="line">[2020-12-11 14:51:24.009 rootCmd.go:115] helloooooo 100s firstblood</span><br><span class="line">test...</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  foo   just a foo help info</span><br><span class="line">  watch watch config file</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  cmdtool.exe test [flags]</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">  example comming up...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -h, --help       help for test</span><br><span class="line">  -m, --mode int   set the test mode</span><br><span class="line"></span><br><span class="line">Global Flags:</span><br><span class="line">  -c, --config string   config file (config.yaml)</span><br><span class="line">  -o, --output string   specify the output file name</span><br><span class="line">  -p, --print           verbose output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ .&#x2F;cmdtool.exe test nocmd</span><br><span class="line">[2020-12-11 14:53:13.301 rootCmd.go:115] helloooooo 100s firstblood</span><br><span class="line">[2020-12-11 14:53:13.303 cmd.go:60] arg &#39;nocmd&#39; not support</span><br><span class="line">test...</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  foo   just a foo help info</span><br><span class="line">  watch watch config file</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  cmdtool.exe test [flags]</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">  example comming up...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -h, --help       help for test</span><br><span class="line">  -m, --mode int   set the test mode</span><br><span class="line"></span><br><span class="line">Global Flags:</span><br><span class="line">  -c, --config string   config file (config.yaml)</span><br><span class="line">  -o, --output string   specify the output file name</span><br><span class="line">  -p, --print           verbose output</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>源码<a href="https://github.com/latelee/cmdtool">在此</a>。 </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是上一文章&lt;a href=&quot;golang-notes-cobra-note-ii.html&quot;&gt;《Golang实践录：命令行cobra库实例优化》&lt;/a&gt; 的优化，主要的子命令的业务实现的整理。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>软件设计几大原则</title>
    <link href="http://www.latelee.org/architecture/software-design-principles.html"/>
    <id>http://www.latelee.org/architecture/software-design-principles.html</id>
    <published>2020-12-07T16:00:02.000Z</published>
    <updated>2021-02-05T02:01:03.019Z</updated>
    
    <content type="html"><![CDATA[<p>本文整理软件设计几大原则。从网上收集，加了个人的理解，汇总而得。  </p><a id="more"></a><h2 id="其它汇总"><a href="#其它汇总" class="headerlink" title="其它汇总"></a>其它汇总</h2><h3 id="DRY-Don’t-Repeat-Yourself-千万不要重复你自身"><a href="#DRY-Don’t-Repeat-Yourself-千万不要重复你自身" class="headerlink" title="DRY - Don’t Repeat Yourself 千万不要重复你自身"></a>DRY - Don’t Repeat Yourself 千万不要重复你自身</h3><p>尽量在项目中减少重复的代码行，重复的方法，重复的模块。许多设计原则和模式最本质的思想都是在消除重复。DRY意味着系统内的每一个部件都应该是唯一的并且是不模糊的。我们可以通过应用单一职责接口隔离等原则尽量拆分系统，模块，类，方法·。使其每一个部件都是职责明确的并且可重用的。DRY利用的方法就是抽象：把共同的事物抽象出来，把代码抽取到一个地方去。这样就可以避免写重复的代码。</p><h3 id="KISS-Keep-It-Simple-amp-Stupid-保持简单易懂"><a href="#KISS-Keep-It-Simple-amp-Stupid-保持简单易懂" class="headerlink" title="KISS - Keep It Simple &amp; Stupid 保持简单易懂"></a>KISS - Keep It Simple &amp; Stupid 保持简单易懂</h3><p>从小到几行代码的写法大到整个系统的架构我们都应该保持简单易懂。高手高就高在可以将复杂的东西“简单”的实现出来。刚入行的时候，我总喜欢用三目运算符将复杂的逻辑用一句冗长的代码行写出来。后面才发现这是非常愚蠢的。到了重构或者需求变更的时候，连我自己写的代码我都看着非常费劲难以下手。所以我们应该致力于代码的可理解性。降低复杂度也意味着维护变得简单。Martin Flower在《重构》中有一句经典的话：”任何一个傻瓜都能写出计算机可以理解的程序，只有写出人类容易理解的程序才是优秀的程序员。其实不光是程序，这个原则也可以延伸到产品的设计，业务的设计，项目结构的设计上。</p><h3 id="YAGNI-You-Ain’t-Gonna-Need-It-适可而止"><a href="#YAGNI-You-Ain’t-Gonna-Need-It-适可而止" class="headerlink" title="YAGNI - You Ain’t Gonna Need It  适可而止"></a>YAGNI - You Ain’t Gonna Need It  适可而止</h3><p>千万不要进行过度设计。我们经常会在开发当中尽可能的迎合未来可能的需求。而为了迎合某些产生概率极低的需求而设计的成本是非常高的，这种过度设计的收益非常低。可能你深思熟虑的设计花了不少时间成本，却在未来的两三年内这个设计却完全没有派上用场。一些设计是否必要，更多的应该基于当前的情况。而不是为了应对未来的各种变化，画蛇添足的设计。如果淘宝一开始就往日均交易上亿的情况进行设计的话，那么可能就不会有今天的淘宝了。因为创业公司的时间是非常宝贵的，比其他公司早一步退出新的服务就能抢占先机。并不是说淘宝不需要考虑以后交易量暴增的情况，而是不应该以当前日均交易才几万的情况下去设计编码日均交易上亿的项目。过度设计往往会延缓开发迭代的速度。<br>YAGNI原则指的是只需要将应用程序必需的功能包含进来，而不要试图添加任何其他你认为可能需要的功能。</p><h3 id="Tell-Don’t-Ask"><a href="#Tell-Don’t-Ask" class="headerlink" title="Tell, Don’t Ask"></a>Tell, Don’t Ask</h3><h3 id="Soc-Sepration-of-Concerns"><a href="#Soc-Sepration-of-Concerns" class="headerlink" title="Soc - Sepration of Concerns"></a>Soc - Sepration of Concerns</h3><h3 id="LOD-Law-of-Demete-迪米特法则"><a href="#LOD-Law-of-Demete-迪米特法则" class="headerlink" title="LOD - Law of Demete 迪米特法则"></a>LOD - Law of Demete 迪米特法则</h3><p>也叫最少知识原则（Least Knowledge Principle，LKP)。迪米特法则的定义是只与你的直接朋友交谈，不与”陌生人”说话。如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该应用。其目的是降低类之间的耦合度，提高模块的相对独立性。<br>迪米特法则中的朋友是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。<br>优点：<br>1、降低类之间的耦合度，提高模块的相对独立性。<br>2、由于亲和度降低，从而提高了类的可复用率和系统的扩展性。<br>缺点：<br>过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。<br>使用迪米特法则需要注意：<br>1、在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。<br>2、在类的结构设计上，尽量降低类成员的访问权限。<br>3、在类的设计上，优先考虑将一个类设置成不变类。<br>4、在对其他类的引用上，将引用其他对象的次数降到最低。<br>5、不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。<br>6、谨慎使用序列化（Serializable）功能。  </p><h2 id="SOLID原则"><a href="#SOLID原则" class="headerlink" title="SOLID原则"></a>SOLID原则</h2><p>S.O.L.I.D是面向对象设计和编程(OOD&amp;OOP)中几个重要编码原则(Programming Priciple)的首字母缩写。  </p><h3 id="SRP-Single-Responsibility-Principle-单一责任原则"><a href="#SRP-Single-Responsibility-Principle-单一责任原则" class="headerlink" title="SRP - Single Responsibility Principle 单一责任原则"></a>SRP - Single Responsibility Principle 单一责任原则</h3><p>当需要修改某个类的时候原因有且只有一个（THERE SHOULD NEVER BE MORE THAN ONE REASON FOR A CLASS TO CHANGE）。换句话说就是让一个类只做一种类型责任，当这个类需要承当其他类型的责任的时候，就需要分解这个类。<br>对象不应承担太多功能，正如一心不能而用，比如太多的工作(种类)会使人崩溃。唯有专注才能保证对象的高内聚；唯有唯一，才能保证对象的细粒度。<br>解决问题：<br>假如有A和B两个类，当A需求发生改变需要修改时，不能导致B类出问题。<br>现状：<br>在实际情况很难去做到单一职责原则，因为随着业务的不断变更，类的职责也在发生着变化，即职责扩散。如类A完成职责P的功能，但是随着后期业务细化，职责P分解成更小粒度的P1与P2，这时根据单一职责原则则需要拆分类A以分别满足细分后的职责P1和P2。但是实际开发环节，若类的逻辑足够简单，可以在代码上级别上违背单一职责原则；若类的方法足够少，可以在方法级别上违背单一职责原则。</p><h3 id="OCR-Open-Close-Principle-开闭原则"><a href="#OCR-Open-Close-Principle-开闭原则" class="headerlink" title="OCR - Open Close Principle 开闭原则"></a>OCR - Open Close Principle 开闭原则</h3><p>软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。这个原则是诸多面向对象编程原则中最抽象、最难理解的一个。<br>Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.<br>软件对象（类、模块、方法等）应该对于扩展是开放的，对修改是关闭的。比如：一个网络模块，原来只有服务端功能，而现在要加入客户端功能，那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，就应当将客户端和服务端分开。公共部分抽象出来。<br>问题由来：<br>在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。<br>解决办法：<br>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。  </p><h3 id="LSP-Liskov-Substitution-Principle-里氏替换原则"><a href="#LSP-Liskov-Substitution-Principle-里氏替换原则" class="headerlink" title="LSP - Liskov Substitution Principle 里氏替换原则"></a>LSP - Liskov Substitution Principle 里氏替换原则</h3><p>当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有is-A关系<br>子类应当可以替换父类并出现在父类能够出现的地方。比如：公司搞年度派对，都有员工都可以抽奖，那么不管是新员工还是老员工，也不管是总部员工还是外派员工，都应当可以参加抽奖。<br>里氏替换至少包含一下两个含义：<br>1、里氏替换原则是针对继承而言的，如果继承是为了实现代码重用，也就是为了共享方法，那么共享的父类方法就应该保持不变，不能被子类重新定义。子类只能通过新添加方法来扩展功能，父类和子类都可以实例化，而子类继承的方法和父类是一样的，父类调用方法的地方，子类也可以调用同一个继承得来的，逻辑和父类一致的方法，这时用子类对象将父类对象替换掉时，当然逻辑一致，相安无事。<br>2、如果继承的目的是为了多态，而多态的前提就是子类覆盖并重新定义父类的方法，为了符合LSP，我们应该将父类定义为抽象类，并定义抽象方法，让子类重新定义这些方法，当父类是抽象类时，父类就是不能实例化，所以也不存在可实例化的父类对象在程序里。也就不存在子类替换父类实例（根本不存在父类实例了）时逻辑不一致的可能。<br>子类必须能够替换它们的基类(IS-A)。<br>继承表达类型抽象。  </p><h3 id="ISP-Interface-Segregation-Principle-接口分离原则-接口隔离原则"><a href="#ISP-Interface-Segregation-Principle-接口分离原则-接口隔离原则" class="headerlink" title="ISP - Interface Segregation Principle 接口分离原则 接口隔离原则"></a>ISP - Interface Segregation Principle 接口分离原则 接口隔离原则</h3><p>不能强迫用户去依赖那些他们不使用的接口。换句话说，使用多个专门的接口比使用单一的总接口总要好。<br>1、客户端不应依赖它不需要的接口，不应该强迫客户程序依赖它们不用的方法。<br>2、接口应该小而完备。类间的依赖关系应该建立在最小的接口上<br>其实通俗来理解就是，不要在一个接口里面放很多的方法，这样会显得这个类很臃肿。接口应该尽量细化，一个接口对应一个功能模块，同时接口里面的方法应该尽可能的少，使接口更加灵活轻便。或许有的人认为接口隔离原则和单一职责原则很像，但两个原则还是存在着明显的区别。单一职责原则是在业务逻辑上的划分，注重的是职责。接口隔离原则是基于接口设计考虑。例如一个接口的职责包含10个方法，这10个方法都放在同一接口中，并且提供给多个模块调用，但不同模块需要依赖的方法是不一样的，这时模块为了实现自己的功能就不得不实现一些对其没有意义的方法，这样的设计是不符合接口隔离原则的。接口隔离原则要求”尽量使用多个专门的接口”专门提供给不同的模块。  </p><h3 id="DIP-Dependence-Inversion-Principle-依赖倒置原则"><a href="#DIP-Dependence-Inversion-Principle-依赖倒置原则" class="headerlink" title="DIP - Dependence Inversion Principle 依赖倒置原则"></a>DIP - Dependence Inversion Principle 依赖倒置原则</h3><p>1、高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于抽象(稳定) 。自注：高层模块较稳定，低层经常变化（如平台库等要做移植、适配），所以高层不能依赖底层。不管高层、底层模块，都要依赖抽象。<br>2、抽象(稳定)不应该依赖于实现细节(变化) ，实现细节应该依赖于抽象(稳定)。自注：越高层次，越要抽象（参考基类、纯虚函数），抽象的东西是稳定的（或很少变），细节会经常变，因此不能依赖细节的实现（这样太局限，不通用）。<br>3、依赖倒置的中心思想是面向接口编程。<br>4、依赖倒置原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础搭建的架构要稳定的多。<br>5、使用接口或抽象类的目的是指定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类来完成。  </p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="优先使用对象组合，而不是类继承"><a href="#优先使用对象组合，而不是类继承" class="headerlink" title="优先使用对象组合，而不是类继承"></a>优先使用对象组合，而不是类继承</h3><p>类继承通常为“白箱复用”，对象组合通常为“黑箱复用” 。<br>继承在某种程度上破坏了封装性，子类父类耦合度高。<br>而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。<br>自注：如果只用继承，子类会越来越大，（不需要的）功能越来越多。  </p><h3 id="封装变化点"><a href="#封装变化点" class="headerlink" title="封装变化点"></a>封装变化点</h3><p>使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。  </p><h3 id="针对接口编程，而不是针对实现编程"><a href="#针对接口编程，而不是针对实现编程" class="headerlink" title="针对接口编程，而不是针对实现编程"></a>针对接口编程，而不是针对实现编程</h3><p>不将变量类型声明为某个特定的具体类，而是声明为某个接口。<br>客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。<br>减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案。<br>自注：网络通信中，以 http、ws、tcp 接口分类实现，不是按某些类型的设备。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文整理软件设计几大原则。从网上收集，加了个人的理解，汇总而得。  &lt;/p&gt;</summary>
    
    
    
    <category term="软件架构" scheme="http://www.latelee.org/category/architecture/"/>
    
    
    <category term="考证" scheme="http://www.latelee.org/tag/%E8%80%83%E8%AF%81/"/>
    
    <category term="设计原则" scheme="http://www.latelee.org/tag/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>架构分类</title>
    <link href="http://www.latelee.org/architecture/software-architecture-note.html"/>
    <id>http://www.latelee.org/architecture/software-architecture-note.html</id>
    <published>2020-12-07T16:00:01.000Z</published>
    <updated>2021-02-05T02:01:03.019Z</updated>
    
    <content type="html"><![CDATA[<p>本文整理几个架构分类知识。从网上收集，加了个人的理解，汇总而得。  </p><a id="more"></a><h2 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h2><p>分层架构（layered architecture）是最常见的软件架构，也是事实上的标准架构。如果你不知道要用什么架构，那就用它。<br>这种架构将软件分成若干个水平层，每一层都有清晰的角色和分工，不需要知道其他层的细节。层与层之间通过接口通信。<br>虽然没有明确约定，软件一定要分成多少层，但是四层的结构最常见。  </p><ul><li>表现层（presentation）：用户界面，负责视觉和用户互动  </li><li>业务层（business）：实现业务逻辑  </li><li>持久层（persistence）：提供数据，SQL 语句就放在这一层  </li><li>数据库（database） ：保存数据  </li></ul><p>有的软件在逻辑层和持久层之间，加了一个服务层（service），提供不同业务逻辑需要的一些通用接口。  </p><p>分层实现、负责，功能明确，责任清晰。可单独测试每一层。如果修改、调整、扩展功能，较麻烦，涉及层级多。  </p><p>实例：<br>参与某公司软件重构，使用分层架构，从底至顶有：  </p><ul><li>平台接口层(如点灯，读写eeprom)  </li><li>一般接口层（封装平台接口，如点灯，读写eeprom，封装系统函数，如延时，时间转换）  </li><li>业务层（再次将底层接口封装为类，如外存读写类、线程类）  </li><li>应用层（应用程序，如守护进程，升级进程，主进程）  </li></ul><p>实操中有些不完善的地方，如：从上至下，每一层都做参数的检查判断，调用一个基础接口，要经过2~3层的接口，而且有部分接口只是简单的封装（为了分层而分层）。一些功能不必要逐层调用函数，可直接越过中间层到最底层，但可能与组织管理者理念冲突，而且控制不当会泛滥，不好维护。  </p><h2 id="事件驱动架构"><a href="#事件驱动架构" class="headerlink" title="事件驱动架构"></a>事件驱动架构</h2><p>事件（event）是状态发生变化时，软件发出的通知。<br>事件驱动架构（event-driven architecture）就是通过事件进行通信的软件架构。它分成四个部分。  </p><ul><li>事件队列（event queue）：接收事件的入口</li><li>分发器（event mediator）：将不同的事件分发到不同的业务逻辑单元</li><li>事件通道（event channel）：分发器与处理器之间的联系渠道</li><li>事件处理器（event processor）：实现业务逻辑，处理完成后会发出事件，触发下一步操作</li></ul><p>对于简单的项目，事件队列、分发器和事件通道，可以合为一体，整个软件就分成事件代理和事件处理器两部分。  </p><p>异步处理，性能较好，扩展性好，事件处理器之间解耦。开发复杂，涉及远程通信。测试麻烦。原子操作难，回滚比较困难。    </p><p>实例：<br>暂未实质搞过，KubeEdge 的 beehive 可能算是一个。  </p><h2 id="微核架构"><a href="#微核架构" class="headerlink" title="微核架构"></a>微核架构</h2><p>微核架构（microkernel architecture）又称为”插件架构”（plug-in architecture），指的是软件的内核相对较小，主要功能和业务逻辑都通过插件实现。<br>内核（core）通常只包含系统运行的最小功能。插件则是互相独立的，插件之间的通信，应该减少到最低，避免出现互相依赖的问题。  </p><p>插件形式，安装卸载方便，容易部署。延伸性（extensibility）好，高度定制，需要添加功能时，加插件即可。开发难度大，添加内核和插件的通信、插件登记。展性（scalability）差，不易做成分布式。    </p><h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><p>微服务架构（microservices architecture）是服务导向架构（service-oriented architecture，缩写 SOA）的升级。<br>每一个服务就是一个独立的部署单元（separately deployed unit）。这些单元都是分布式的，互相解耦，通过远程通信协议（比如REST、SOAP）联系。<br>微服务架构分成三种实现模式。  </p><ul><li>RESTful API 模式：服务通过 API 提供，云服务就属于这一类</li><li>RESTful 应用模式：服务通过传统的网络协议或者应用协议提供，背后通常是一个多功能的应用程序，常见于企业内部</li><li>集中消息模式：采用消息代理（message broker），可以实现消息队列、负载均衡、统一日志和异常处理，缺点是会出现单点失败，消息代理可能要做成集群</li></ul><p>扩展性好，各个服务之间低耦合，部署方便，开发容易，易于测试。服务可能拆分太细，微服务过多，杂乱且性能不好，原子操作难，回滚比较困难。<br>实例：<br>未搞过。  </p><h2 id="云架构"><a href="#云架构" class="headerlink" title="云架构"></a>云架构</h2><p>云结构（cloud architecture）主要解决扩展性和并发的问题，是最容易扩展的架构。<br>它的高扩展性，主要原因是没使用中央数据库，而是把数据都复制到内存中，变成可复制的内存数据单元。然后，业务处理能力封装成一个个处理单元（prcessing unit）。访问量增加，就新建处理单元；访问量减少，就关闭处理单元。由于没有中央数据库，所以扩展性的最大瓶颈消失了。由于每个处理单元的数据都在内存里，最好要进行数据持久化。<br>这个模式主要分成两部分：处理单元（processing unit）和虚拟中间件（virtualized middleware）。<br>*处理单元：实现业务逻辑<br>*虚拟中间件：负责通信、保持sessions、数据复制、分布式处理、处理单元的部署。</p><p>虚拟中间件又包含四个组件。</p><ul><li>消息中间件（Messaging Grid）：管理用户请求和session，当一个请求进来以后，决定分配给哪一个处理单元。</li><li>数据中间件（Data Grid）：将数据复制到每一个处理单元，即数据同步。保证某个处理单元都得到同样的数据。</li><li>处理中间件（Processing Grid）：可选，如果一个请求涉及不同类型的处理单元，该中间件负责协调处理单元</li><li>部署中间件（Deployment Manager）：负责处理单元的启动和关闭，监控负载和响应时间，当负载增加，就新启动处理单元，负载减少，就关闭处理单元。</li></ul><p>高负载，高扩展性，可动态部署。实现复杂，成本高，测试难，适合网站类应用。  </p><p>实操：  </p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>阮一峰，软件架构入门： <a href="http://www.ruanyifeng.com/blog/2016/09/software-architecture.html">http://www.ruanyifeng.com/blog/2016/09/software-architecture.html</a>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文整理几个架构分类知识。从网上收集，加了个人的理解，汇总而得。  &lt;/p&gt;</summary>
    
    
    
    <category term="软件架构" scheme="http://www.latelee.org/category/architecture/"/>
    
    
    <category term="考证" scheme="http://www.latelee.org/tag/%E8%80%83%E8%AF%81/"/>
    
    <category term="软件架构" scheme="http://www.latelee.org/tag/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>架构扩展知识点</title>
    <link href="http://www.latelee.org/architecture/software-architecture-note.html"/>
    <id>http://www.latelee.org/architecture/software-architecture-note.html</id>
    <published>2020-12-07T16:00:00.000Z</published>
    <updated>2021-02-05T02:01:03.019Z</updated>
    
    <content type="html"><![CDATA[<p>以考促学，对一些技术点进行汇总，不涉及细节。 </p><a id="more"></a><h2 id="简要记录"><a href="#简要记录" class="headerlink" title="简要记录"></a>简要记录</h2><p>1、一来考证，二来积累技术（不一定是工作上能用到的）。<br>2、尽量docker来测试（多台虚拟机运行时电脑性能不够）。<br>3、总结一套自己的后台框架（不要一下子完全现实，迭代进行，也能持续保持学习）。<br>4、设计模式多深入一些，可能在工作中用到。  </p><h2 id="软件架构风格"><a href="#软件架构风格" class="headerlink" title="软件架构风格"></a>软件架构风格</h2><p>几种风格的汇总，加上个人理解。  </p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>B站，李老师讲的视频，在github上有课件源码。在此基础上修改进行调试。结合其它资料汇总。  </p><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>3个容器。<br>负载均衡，均衡的几种方法。session丢失<br>高可用，keepalive？<br>测试：一个客户端正在连接其中一个容器，在进行中，断开该容器服务，观察是否切换到其它的容器。</p><h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h2><h2 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h2><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><p>介于关系数据库和非关系数据库之间的产品。<br>面向文档的数据库  </p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>单核。 </p><p>分布式锁，主从复制。哨兵，集群。<br>并发，秒杀实验。<br>据类型主要有五种：String、Hash、List、Set和Sorted Set  </p><h3 id="memcached"><a href="#memcached" class="headerlink" title="memcached"></a>memcached</h3><p>多核<br>只支持 string。  </p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h3><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>API网关（golang实现）。<br>后台框架，参考kubeedge的beehive。  </p><h2 id="分布式相关"><a href="#分布式相关" class="headerlink" title="分布式相关"></a>分布式相关</h2><p>有点杂</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;以考促学，对一些技术点进行汇总，不涉及细节。 &lt;/p&gt;</summary>
    
    
    
    <category term="软件架构" scheme="http://www.latelee.org/category/architecture/"/>
    
    
    <category term="考证" scheme="http://www.latelee.org/tag/%E8%80%83%E8%AF%81/"/>
    
    <category term="软件架构" scheme="http://www.latelee.org/tag/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：命令行cobra库实例优化</title>
    <link href="http://www.latelee.org/golang/golang-notes-cobra-note-ii.html"/>
    <id>http://www.latelee.org/golang/golang-notes-cobra-note-ii.html</id>
    <published>2020-12-01T16:00:00.000Z</published>
    <updated>2021-02-05T02:01:03.079Z</updated>
    
    <content type="html"><![CDATA[<p>本文上一文章<a href="golang-notes-cobra-note.html">《Golang实践录：命令行cobra库实例》</a> 的优化，主要的子命令的业务实现的整理。  </p><a id="more"></a><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>旧版本中，每个子命令的入口函数，均需一一判断传入参数，并调用对应的业务实现函数，编码扩展稍有繁琐，而且也不美观。<br>思考再三，决定使用结构体数组的形式来优化。  </p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>此思路来源于 busybox 。  </p><p>首先定义结构体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 命令列表，包括名称，帮助信息</span><br><span class="line">type UserCmdFunc struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">    ShortHelp string</span><br><span class="line">    &#x2F;&#x2F; LongHelp string</span><br><span class="line">    Func func(args []string)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再实现遍历命令列表函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func PrintHelpInfo(theCmd []conf.UserCmdFunc) &#123;</span><br><span class="line">truefmt.Println(&quot;valid command: &quot;);</span><br><span class="line">truefor _, item:&#x3D;range theCmd &#123;</span><br><span class="line">        fmt.Println(item.Name, &quot;\t:&quot;, item.ShortHelp)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用时，只需要定义结构体数组，并填写对应的命令名称，帮助信息，及对应的函数指针即可。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var theCmd &#x3D; []conf.UserCmdFunc&#123;</span><br><span class="line">    conf.UserCmdFunc &#123;</span><br><span class="line">        Name: &quot;foo&quot;,</span><br><span class="line">        ShortHelp: &quot;just a foo help info&quot;,</span><br><span class="line">        Func: foo,</span><br><span class="line">    &#125;,</span><br><span class="line">    conf.UserCmdFunc &#123;&quot;watch&quot;, &quot;watch config file&quot;, testWatch,&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line"></span><br><span class="line">当命令不合法——亦即无法在结构体数组中找到时，提示合法的命令，提高体验。  </span><br><span class="line">由于各子命令位于不同的包中，实际上 theCmd 及子命令入口函数绝大部分代码是相同的，容易扩展。  </span><br><span class="line"></span><br><span class="line">## 实现</span><br><span class="line">以子命令 test 为例，旧版本入口源码如下：  </span><br></pre></td></tr></table></figure><p>func NewCmdTest() *cobra.Command{</p><pre><code>var cmd = &amp;cobra.Command&#123;    Use:     name,    Short:   shortDescription,    Long:    longDescription,    Example: example,    RunE: func(cmd *cobra.Command, args []string) error &#123;        if (len(args) == 0) &#123;            klog.Warning(&quot;no args found&quot;)            return nil        &#125;        // !! 以下要一一判断并调用        if (args[0] == &quot;foo&quot;)&#123;            foo(args)        &#125; else if (args[0] == &quot;watch&quot;)&#123;            testWatch(args)        &#125; else &#123;            klog.Printf(&quot;cmd &#39;%v&#39; not support&quot;, args[0])            return nil        &#125;         return nil    &#125;,&#125;return cmd</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">新版本变化如下：</span><br></pre></td></tr></table></figure><p>var theCmd = []conf.UserCmdFunc{<br>    conf.UserCmdFunc {<br>        Name: “foo”,<br>        ShortHelp: “just a foo help info”,<br>        Func: foo,<br>    },<br>    conf.UserCmdFunc {“watch”, “watch config file”, testWatch,},<br>}</p><p>func NewCmdTest() *cobra.Command{</p><pre><code>var cmd = &amp;cobra.Command&#123;    Use:     name,    Short:   shortDescription,    Long:    longDescription,    Example: example,    RunE: func(cmd *cobra.Command, args []string) error &#123;        //klog.Println(common.DBName)        if (len(args) == 0) &#123;            klog.Warning(&quot;no args found&quot;)            common.PrintHelpInfo(theCmd)            return nil        &#125;        // !! 遍历并调用即可        for _, item:=range theCmd &#123;            if (args[0] == item.Name) &#123;                item.Func(args)                return nil            &#125;        &#125;        klog.Printf(&quot;cmd &#39;%v&#39; not support&quot;, args[0])        common.PrintHelpInfo(theCmd)        return nil    &#125;,&#125;// note：使用子命令形式，下列可在help中展开// 命令参数，保存的值，参数名，默认参数，说明//cmd.Flags().StringVar(&amp;mode, &quot;db&quot;, &quot;-&quot;, &quot;set the database name&quot;)return cmd</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 测试</span><br><span class="line">默认输出帮助信息：  </span><br></pre></td></tr></table></figure><p>$ ./cmdtool.exe<br>  cmd test tool.<br>  命令终端测试示例工具。</p><p>Usage:<br>  cmdtool.exe [command]</p><p>Examples:<br>  comming soon…</p><p>Available Commands:<br>  db          db command<br>  help        Help about any command<br>  misc        misc command<br>  test        test command</p><p>Flags:<br>      –config string   config file (config.yaml)<br>  -h, –help            help for cmdtool.exe<br>      –print           will print sth<br>      –version         version for cmdtool.exe</p><p>Use “cmdtool.exe [command] –help” for more information about a command.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行子命令，默认将合法的命令输出：</span><br></pre></td></tr></table></figure><p>$ ./cmdtool.exe test<br>[2020-12-02 17:43:40.771 rootCmd.go:112] helloooooo 100s firstblood<br>[2020-12-02 17:43:40.772 cmd.go:43] no args found<br>valid command:<br>foo     : just a foo help info<br>watch   : watch config file</p><p>$ ./cmdtool.exe test nocmd<br>[2020-12-02 17:43:47.953 rootCmd.go:112] helloooooo 100s firstblood<br>[2020-12-02 17:43:47.954 cmd.go:53] cmd ‘nocmd’ not support<br>valid command:<br>foo     : just a foo help info<br>watch   : watch config file</p><pre><code>## 源码源码[在此](https://github.com/latelee/cmdtool)。 本次也修改了 cobra 帮助信息不对齐的小问题。  </code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文上一文章&lt;a href=&quot;golang-notes-cobra-note.html&quot;&gt;《Golang实践录：命令行cobra库实例》&lt;/a&gt; 的优化，主要的子命令的业务实现的整理。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>CICD实例：nodejs 程序的自动化构建</title>
    <link href="http://www.latelee.org/cicd/cicd-exmaple-deploy-for-nodejs.html"/>
    <id>http://www.latelee.org/cicd/cicd-exmaple-deploy-for-nodejs.html</id>
    <published>2020-11-30T16:00:00.000Z</published>
    <updated>2021-02-05T02:01:03.067Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍 nodejs 程序的自动化构建，包括 x86 和 arm 平台。  </p><a id="more"></a><h2 id="环境描述"><a href="#环境描述" class="headerlink" title="环境描述"></a>环境描述</h2><p>利用 Docker 多阶段构建方法。使用如下镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">构建阶段镜像：</span><br><span class="line">node         10.22.0-stretch  1e318dc8ae6f  2 months ago  911MB</span><br><span class="line">arm32v7&#x2F;node 10.22.0-stretch  b697c995167b  3 months ago  744MB</span><br><span class="line"></span><br><span class="line">运行阶段镜像：</span><br><span class="line">node         10.22.0-alpine   8e473595b853  4 months ago  83.5MB</span><br><span class="line">arm32v7&#x2F;node 10.22.0-alpine   cf3a24984912  4 months ago  75.2MB</span><br></pre></td></tr></table></figure><p>nodejs 程序使用 package.json 指定依赖库。  </p><h2 id="CICD-配置"><a href="#CICD-配置" class="headerlink" title="CICD 配置"></a>CICD 配置</h2><p>选用 CircleCI 执行 CI 脚本。<br>CircleCI 配置文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>CI 脚本如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm  --name armhfbusybox -v &#x2F;usr&#x2F;bin&#x2F;qemu-arm-static:&#x2F;usr&#x2F;bin&#x2F;qemu-arm-static armhf&#x2F;busybox</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="工程仓库"><a href="#工程仓库" class="headerlink" title="工程仓库"></a>工程仓库</h2><h2 id="问题及解决"><a href="#问题及解决" class="headerlink" title="问题及解决"></a>问题及解决</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍 nodejs 程序的自动化构建，包括 x86 和 arm 平台。  &lt;/p&gt;</summary>
    
    
    
    <category term="cicd" scheme="http://www.latelee.org/category/cicd/"/>
    
    
    <category term="cicd" scheme="http://www.latelee.org/tag/cicd/"/>
    
  </entry>
  
  <entry>
    <title>CICD实例：C++程序的自动化构建</title>
    <link href="http://www.latelee.org/cicd/cicd-exmaple-deploy-for-c++.html"/>
    <id>http://www.latelee.org/cicd/cicd-exmaple-deploy-for-c++.html</id>
    <published>2020-11-29T16:00:00.000Z</published>
    <updated>2021-02-05T02:01:03.067Z</updated>
    
    <content type="html"><![CDATA[<p>本文描述一个 C++ 程序的自动化构建过程，涉及：<br>1、制作适用于 c++ 简单程序的基础镜像。<br>2、使用 CICD 进行编译和构建，并发布。在此过程，涉及到邮件通知。  </p><p>本文示例在简单应用场合中有实践意义，即不使用如 jenkins 这样重型工具，如果信任现成免费的私有的服务，可将自动化工作迁移到公网，否则内建局域网服务或使用公有云搭建。  </p><a id="more"></a><h2 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h2><p>注：源码为 C++，使用 C++11 特性，选 alpine，其 C 库不是 glibc。选 busybox 64版本。在 64 位系统直接执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull busybox</span><br></pre></td></tr></table></figure><p>即可得到 64 位的版本。<br>运行 busybox：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it bar busybox sh</span><br></pre></td></tr></table></figure><p>在宿主机拷贝动态库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker cp &#x2F;usr&#x2F;bin&#x2F;file bar:&#x2F;bin</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libmagic.so.1 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libmagic.so.1.0.0 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libz.so.1 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libz.so.1.2.7 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;share&#x2F;misc&#x2F;magic bar:&#x2F;usr&#x2F;share&#x2F;misc  &#x2F;&#x2F; 要自己创建目录</span><br><span class="line"></span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libstdc++.so.6 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libstdc++.so.6.0.19 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libgcc_s.so.1 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libgcc_s-4.8.5-20150702.so.1 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libpthread.so bar:&#x2F;lib64</span><br></pre></td></tr></table></figure><p>重新制作基础镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit bar registry.cn-shenzhen.aliyuncs.com&#x2F;latelee&#x2F;busybox:64</span><br></pre></td></tr></table></figure><p>上传：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push registry.cn-shenzhen.aliyuncs.com&#x2F;latelee&#x2F;busybox:64</span><br></pre></td></tr></table></figure><h2 id="CICD-配置"><a href="#CICD-配置" class="headerlink" title="CICD 配置"></a>CICD 配置</h2><p>选用 CircleCI 执行 CI 脚本。  </p><h2 id="工程仓库"><a href="#工程仓库" class="headerlink" title="工程仓库"></a>工程仓库</h2><h2 id="问题及解决"><a href="#问题及解决" class="headerlink" title="问题及解决"></a>问题及解决</h2><p>不能按一般的登陆方式登陆，否则提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker login --username&#x3D;$ali_docker_name -p $ali_docker_passwd registry.cn-shenzhen.aliyuncs.com</span><br><span class="line">WARNING! Using --password via the CLI is insecure. Use --password-stdin.</span><br><span class="line">Login with your Docker ID to push and pull images from Docker Hub. If you don&#39;t have a Docker ID, head over to https:&#x2F;&#x2F;hub.docker.com to create one.</span><br><span class="line">Username: EOF</span><br></pre></td></tr></table></figure><p>使用官方推荐方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;$ali_docker_passwd&quot; | docker login --username $ali_docker_name --password-stdin  registry.cn-shenzhen.aliyuncs.com</span><br><span class="line">Error: Cannot perform an interactive login from a non TTY device</span><br></pre></td></tr></table></figure><p>此提示真正原因未知，在调试发现环境变量未生效，调整后，登陆成功。 </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>circleci文档：<br>使用docker命令：<a href="https://circleci.com/docs/2.0/building-docker-images/">https://circleci.com/docs/2.0/building-docker-images/</a><br>配置选项参考说明：<a href="https://circleci.com/docs/2.0/configuration-reference/">https://circleci.com/docs/2.0/configuration-reference/</a><br>环境变量：<a href="https://circleci.com/docs/2.0/env-vars/">https://circleci.com/docs/2.0/env-vars/</a><br>自定义docker：<a href="https://circleci.com/docs/2.0/custom-images/">https://circleci.com/docs/2.0/custom-images/</a><br>预置docker镜像：<a href="https://circleci.com/docs/2.0/custom-images/">https://circleci.com/docs/2.0/custom-images/</a><br>注：免费情况下， circleci 私有仓库构建次数有限，术语为 Credits，每周共 2500 个，一次构建消耗数量为数个到数十个。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文描述一个 C++ 程序的自动化构建过程，涉及：&lt;br&gt;1、制作适用于 c++ 简单程序的基础镜像。&lt;br&gt;2、使用 CICD 进行编译和构建，并发布。在此过程，涉及到邮件通知。  &lt;/p&gt;
&lt;p&gt;本文示例在简单应用场合中有实践意义，即不使用如 jenkins 这样重型工具，如果信任现成免费的私有的服务，可将自动化工作迁移到公网，否则内建局域网服务或使用公有云搭建。  &lt;/p&gt;</summary>
    
    
    
    <category term="cicd" scheme="http://www.latelee.org/category/cicd/"/>
    
    
    <category term="cicd" scheme="http://www.latelee.org/tag/cicd/"/>
    
  </entry>
  
  <entry>
    <title>我的docker随笔30：C++程序的自动化构建</title>
    <link href="http://www.latelee.org/docker/docker-30-deploy-for-c++.html"/>
    <id>http://www.latelee.org/docker/docker-30-deploy-for-c++.html</id>
    <published>2020-11-29T16:00:00.000Z</published>
    <updated>2021-02-05T02:01:03.071Z</updated>
    
    <content type="html"><![CDATA[<p>本文描述一个 C++ 程序的自动化构建过程，涉及：<br>1、制作适用于 c++ 简单程序的基础镜像。<br>2、使用 CICD 进行编译和构建，并发布。在此过程，涉及到邮件通知。  </p><p>本文示例在简单应用场合中有实践意义，即不使用如 jenkins 这样重型工具，如果信任现成免费的私有的服务，可将自动化工作迁移到公网，否则内建局域网服务或使用公有云搭建。  </p><a id="more"></a><h2 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h2><p>注：源码为 C++，使用 C++11 特性，选 alpine，其 C 库不是 glibc。选 busybox 64版本。在 64 位系统直接执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull busybox</span><br></pre></td></tr></table></figure><p>即可得到 64 位的版本。<br>运行 busybox：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it bar busybox sh</span><br></pre></td></tr></table></figure><p>在宿主机拷贝动态库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker cp &#x2F;usr&#x2F;bin&#x2F;file bar:&#x2F;bin</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libmagic.so.1 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libmagic.so.1.0.0 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libz.so.1 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libz.so.1.2.7 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;share&#x2F;misc&#x2F;magic bar:&#x2F;usr&#x2F;share&#x2F;misc  &#x2F;&#x2F; 要自己创建目录</span><br><span class="line"></span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libstdc++.so.6 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libstdc++.so.6.0.19 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libgcc_s.so.1 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libgcc_s-4.8.5-20150702.so.1 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libpthread.so bar:&#x2F;lib64</span><br></pre></td></tr></table></figure><p>重新制作基础镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit bar registry.cn-shenzhen.aliyuncs.com&#x2F;latelee&#x2F;busybox:64</span><br></pre></td></tr></table></figure><p>上传：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push registry.cn-shenzhen.aliyuncs.com&#x2F;latelee&#x2F;busybox:64</span><br></pre></td></tr></table></figure><h2 id="CICD-配置"><a href="#CICD-配置" class="headerlink" title="CICD 配置"></a>CICD 配置</h2><p>选用 CircleCI 执行 CI 脚本。  </p><h2 id="工程仓库"><a href="#工程仓库" class="headerlink" title="工程仓库"></a>工程仓库</h2><h2 id="问题及解决"><a href="#问题及解决" class="headerlink" title="问题及解决"></a>问题及解决</h2><p>不能按一般的登陆方式登陆，否则提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker login --username&#x3D;$ali_docker_name -p $ali_docker_passwd registry.cn-shenzhen.aliyuncs.com</span><br><span class="line">WARNING! Using --password via the CLI is insecure. Use --password-stdin.</span><br><span class="line">Login with your Docker ID to push and pull images from Docker Hub. If you don&#39;t have a Docker ID, head over to https:&#x2F;&#x2F;hub.docker.com to create one.</span><br><span class="line">Username: EOF</span><br></pre></td></tr></table></figure><p>使用官方推荐方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;$ali_docker_passwd&quot; | docker login --username $ali_docker_name --password-stdin  registry.cn-shenzhen.aliyuncs.com</span><br><span class="line">Error: Cannot perform an interactive login from a non TTY device</span><br></pre></td></tr></table></figure><p>此提示真正原因未知，在调试发现环境变量未生效，调整后，登陆成功。 </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>circleci文档：<br>使用docker命令：<a href="https://circleci.com/docs/2.0/building-docker-images/">https://circleci.com/docs/2.0/building-docker-images/</a><br>配置选项参考说明：<a href="https://circleci.com/docs/2.0/configuration-reference/">https://circleci.com/docs/2.0/configuration-reference/</a><br>环境变量：<a href="https://circleci.com/docs/2.0/env-vars/">https://circleci.com/docs/2.0/env-vars/</a><br>自定义docker：<a href="https://circleci.com/docs/2.0/custom-images/">https://circleci.com/docs/2.0/custom-images/</a><br>预置docker镜像：<a href="https://circleci.com/docs/2.0/custom-images/">https://circleci.com/docs/2.0/custom-images/</a><br>注：免费情况下， circleci 私有仓库构建次数有限，术语为 Credits，每周共 2500 个，一次构建消耗数量为数个到数十个。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文描述一个 C++ 程序的自动化构建过程，涉及：&lt;br&gt;1、制作适用于 c++ 简单程序的基础镜像。&lt;br&gt;2、使用 CICD 进行编译和构建，并发布。在此过程，涉及到邮件通知。  &lt;/p&gt;
&lt;p&gt;本文示例在简单应用场合中有实践意义，即不使用如 jenkins 这样重型工具，如果信任现成免费的私有的服务，可将自动化工作迁移到公网，否则内建局域网服务或使用公有云搭建。  &lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="http://www.latelee.org/category/docker/"/>
    
    
    <category term="docker" scheme="http://www.latelee.org/tag/docker/"/>
    
  </entry>
  
  <entry>
    <title>vue实践录：vue基础学习</title>
    <link href="http://www.latelee.org/vue/vue-notes-vue-basic.html"/>
    <id>http://www.latelee.org/vue/vue-notes-vue-basic.html</id>
    <published>2020-11-11T14:00:00.000Z</published>
    <updated>2021-02-05T02:01:03.079Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲述 Vue 的基础知识，逐步更新。主要来自网络，有删改和自己的理解。  </p><a id="more"></a><h2 id="Vue指令"><a href="#Vue指令" class="headerlink" title="Vue指令"></a>Vue指令</h2><p>Vue 的指令是以 v- 开头的，它们作用于 HTML 元素，指令提供了一些特殊的特性，将指令绑定在元素上时，指令会为绑定的目标元素添加一些特殊的行为，我们可以将指令看作特殊的 HTML 特性（attribute）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.内容绑定，事件绑定（v-text、v-html、v-on基础）</span><br><span class="line">2.显示切换，属性绑定（v-show、v-if、v-bind）</span><br><span class="line">3.列表训练，表单元素绑定（v-for、v-on补充、v-model)</span><br></pre></td></tr></table></figure><p>详细说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">v-text</span><br><span class="line">1.v-text指令的作用是：设置标签的内容（textContent）</span><br><span class="line">2.默认写法会替换全部内容，使用差值表达式&#123;&#123;&#125;&#125;可以替换指定内容</span><br><span class="line">3.内部支持写表达式</span><br><span class="line"></span><br><span class="line">v-html</span><br><span class="line">1.v-html指令的作用是：设置元素的innerHTML</span><br><span class="line">2.内容中有html结构会被解析成标签</span><br><span class="line">3.v-text指令无论内容是多少，只会解析成文本</span><br><span class="line">4.解析文本使用v-text，需要解析html结构使用v-html</span><br><span class="line"></span><br><span class="line">v-on基础</span><br><span class="line">1.v-on指令的作用是：为元素绑定事件</span><br><span class="line">2.时间名不需要写on</span><br><span class="line">3.指令可以简写成@</span><br><span class="line">4.绑定的方法定义在methods属性中</span><br><span class="line">5.方法的内部通过this关键字可以访问定义在data中数据</span><br><span class="line"></span><br><span class="line">v-show</span><br><span class="line">1.v-show指令的作用是：根据真假切换元素的显示状态</span><br><span class="line">2.原理是修改元素的display，实现显示隐藏</span><br><span class="line">3.指令后面的内容，最终都会解析成布尔值</span><br><span class="line">4.值为true元素显示，值为false元素隐藏</span><br><span class="line">5.数据改变之后，对应元素的显示状态会同步更新</span><br><span class="line"></span><br><span class="line">v-if</span><br><span class="line">1.v-if指令的作用是：根据表达式的真假切换元素的显示状态</span><br><span class="line">2.本质是通过操纵dom元素来切换显示状态（和v-show不同的地方）</span><br><span class="line">3.表达式的值为true，元素存在于dom树中，为false，从dom树中移除</span><br><span class="line">4.频繁的切换v-show，反之使用v-if,前者的切换消耗少</span><br><span class="line"></span><br><span class="line">v-else</span><br><span class="line">1.作为 v-if 或 v-show 的 “else” 部分代码。  </span><br><span class="line">2.必须立即跟在v-if或v-show元素的后面——否则它不能被识别。</span><br><span class="line"></span><br><span class="line">v-bind</span><br><span class="line">1.为元素绑定属性</span><br><span class="line">2.完整写法时v-bind：属性名</span><br><span class="line">3.简写的话可以省略v-bind，只保留：属性名</span><br><span class="line">4.需要动态的增删class建议使用对象的方式</span><br><span class="line"></span><br><span class="line">v-for</span><br><span class="line">1.v-for指令的作用是：根据数据生成列表结构</span><br><span class="line">2.数组经常和v-for结合使用</span><br><span class="line">3.语法是（item，index）in 数据</span><br><span class="line">4.item和index可以结合其他指令一起使用</span><br><span class="line">5.数组长度的更新会同步到页面上是响应式的</span><br><span class="line"></span><br><span class="line">v-on补充</span><br><span class="line">1.事件绑定的方法写成函数调用的形式，可以传入自定义参数</span><br><span class="line">2.定义方法时需要定义形参来接收传入的参数</span><br><span class="line">3.事件的后面跟上.修饰符对事件进行限制</span><br><span class="line">4.enter可以限制触发的按键为回车</span><br><span class="line">5.事件修饰符有多种</span><br><span class="line"></span><br><span class="line">v-model</span><br><span class="line">1.v-model指令的作用是便捷的设置和获取表单元素的值</span><br><span class="line">2.绑定的数据会和表单元素相关联</span><br><span class="line">3.绑定的数据&#x3D;表单数据的值</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>李迟  2020.11.11 周三 晚</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文讲述 Vue 的基础知识，逐步更新。主要来自网络，有删改和自己的理解。  &lt;/p&gt;</summary>
    
    
    
    <category term="vue" scheme="http://www.latelee.org/category/vue/"/>
    
    
    <category term="vue" scheme="http://www.latelee.org/tag/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue实践录：windows 10系统vue环境搭建</title>
    <link href="http://www.latelee.org/vue/vue-notes-starting.html"/>
    <id>http://www.latelee.org/vue/vue-notes-starting.html</id>
    <published>2020-11-10T14:00:00.000Z</published>
    <updated>2021-02-05T02:01:03.079Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲述windows 10 64bit系统中，vue环境的搭建。</p><a id="more"></a><h1 id="nodejs环境"><a href="#nodejs环境" class="headerlink" title="nodejs环境"></a>nodejs环境</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载地址为：<a href="http://npm.taobao.org/mirrors/node/v14.15.0/%EF%BC%8C">http://npm.taobao.org/mirrors/node/v14.15.0/，</a> 下载安装包为<code>node-v14.15.0-x64.msi</code>。<br>双击，根据提示安装。默认已设置好PATH。  </p><h2 id="更新npm源为taobao："><a href="#更新npm源为taobao：" class="headerlink" title="更新npm源为taobao："></a>更新npm源为taobao：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line">npm config list &#x2F;&#x2F; 查看是否生效</span><br></pre></td></tr></table></figure><p>出现<code>metrics-registry = &quot;https://registry.npm.taobao.org/&quot;</code>表示已设置成功。可设置其它配置项的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm set cache &quot;E:\\Program Files\\nodejs\\node_cache&quot;</span><br><span class="line">npm set prefix &quot;E:\\Program Files\\nodejs\\npm_prefix&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>把<code>E:\\Program Files\\nodejs\\npm_prefix</code>加入到 PATH 变量中。否则，安装的包会提示找不到。    </p><h2 id="安装-cnpm"><a href="#安装-cnpm" class="headerlink" title="安装 cnpm"></a>安装 cnpm</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h2 id="安装-vue"><a href="#安装-vue" class="headerlink" title="安装 vue"></a>安装 vue</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cnpm install vue -g</span><br><span class="line">cnpm install vue-cli -g</span><br></pre></td></tr></table></figure><h2 id="简单工程及访问"><a href="#简单工程及访问" class="headerlink" title="简单工程及访问"></a>简单工程及访问</h2><p>根据官方模板创建工程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack-simple hellovue   &#x2F;&#x2F; 一路按回车，用默认值</span><br></pre></td></tr></table></figure><p>安装依赖并运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd hellovue</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>使用浏览器访问：<a href="http://localhost:8080/">http://localhost:8080/</a> 即可看到默认界面。  </p><p>打包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>李迟  2020.11.10 周二 晚</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文讲述windows 10 64bit系统中，vue环境的搭建。&lt;/p&gt;</summary>
    
    
    
    <category term="vue" scheme="http://www.latelee.org/category/vue/"/>
    
    
    <category term="vue" scheme="http://www.latelee.org/tag/vue/"/>
    
  </entry>
  
</feed>
