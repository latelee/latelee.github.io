<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>迟思堂随笔</title>
  
  <subtitle>李迟的技术主页</subtitle>
  <link href="http://www.latelee.org/atom.xml" rel="self"/>
  
  <link href="http://www.latelee.org/"/>
  <updated>2020-12-03T03:00:04.872Z</updated>
  <id>http://www.latelee.org/</id>
  
  <author>
    <name>李迟</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我的docker随笔30：C++程序的自动化构建</title>
    <link href="http://www.latelee.org/docker/docker-30-deploy-for-c++.html"/>
    <id>http://www.latelee.org/docker/docker-30-deploy-for-c++.html</id>
    <published>2020-11-29T16:00:00.000Z</published>
    <updated>2020-12-03T03:00:04.872Z</updated>
    
    <content type="html"><![CDATA[<p>本文描述一个 C++ 程序的自动化构建过程，涉及：<br>1、制作适用于 c++ 简单程序的基础镜像。<br>2、使用 CICD 进行编译和构建，并发布。在此过程，涉及到邮件通知。  </p><p>本文示例在简单应用场合中有实践意义，即不使用如 jenkins 这样重型工具，如果信任现成免费的私有的服务，可将自动化工作迁移到公网，否则内建局域网服务或使用公有云搭建。  </p><a id="more"></a><h2 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h2><p>注：源码为 C++，使用 C++11 特性，选 alpine，其 C 库不是 glibc。选 busybox 64版本。在 64 位系统直接执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull busybox</span><br></pre></td></tr></table></figure><p>即可得到 64 位的版本。<br>运行 busybox：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it bar busybox sh</span><br></pre></td></tr></table></figure><p>在宿主机拷贝动态库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker cp &#x2F;usr&#x2F;bin&#x2F;file bar:&#x2F;bin</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libmagic.so.1 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libmagic.so.1.0.0 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libz.so.1 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libz.so.1.2.7 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;share&#x2F;misc&#x2F;magic bar:&#x2F;usr&#x2F;share&#x2F;misc  &#x2F;&#x2F; 要自己创建目录</span><br><span class="line"></span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libstdc++.so.6 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libstdc++.so.6.0.19 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libgcc_s.so.1 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libgcc_s-4.8.5-20150702.so.1 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libpthread.so bar:&#x2F;lib64</span><br></pre></td></tr></table></figure><p>重新制作基础镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit bar registry.cn-shenzhen.aliyuncs.com&#x2F;latelee&#x2F;busybox:64</span><br></pre></td></tr></table></figure><p>上传：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push registry.cn-shenzhen.aliyuncs.com&#x2F;latelee&#x2F;busybox:64</span><br></pre></td></tr></table></figure><h2 id="CICD-配置"><a href="#CICD-配置" class="headerlink" title="CICD 配置"></a>CICD 配置</h2><p>选用 CircleCI 执行 CI 脚本。  </p><h2 id="工程仓库"><a href="#工程仓库" class="headerlink" title="工程仓库"></a>工程仓库</h2><h2 id="问题及解决"><a href="#问题及解决" class="headerlink" title="问题及解决"></a>问题及解决</h2><p>不能按一般的登陆方式登陆，否则提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker login --username&#x3D;$ali_docker_name -p $ali_docker_passwd registry.cn-shenzhen.aliyuncs.com</span><br><span class="line">WARNING! Using --password via the CLI is insecure. Use --password-stdin.</span><br><span class="line">Login with your Docker ID to push and pull images from Docker Hub. If you don&#39;t have a Docker ID, head over to https:&#x2F;&#x2F;hub.docker.com to create one.</span><br><span class="line">Username: EOF</span><br></pre></td></tr></table></figure><p>使用官方推荐方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;$ali_docker_passwd&quot; | docker login --username $ali_docker_name --password-stdin  registry.cn-shenzhen.aliyuncs.com</span><br><span class="line">Error: Cannot perform an interactive login from a non TTY device</span><br></pre></td></tr></table></figure><p>此提示真正原因未知，在调试发现环境变量未生效，调整后，登陆成功。 </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>circleci文档：<br>使用docker命令：<a href="https://circleci.com/docs/2.0/building-docker-images/">https://circleci.com/docs/2.0/building-docker-images/</a><br>配置选项参考说明：<a href="https://circleci.com/docs/2.0/configuration-reference/">https://circleci.com/docs/2.0/configuration-reference/</a><br>环境变量：<a href="https://circleci.com/docs/2.0/env-vars/">https://circleci.com/docs/2.0/env-vars/</a><br>自定义docker：<a href="https://circleci.com/docs/2.0/custom-images/">https://circleci.com/docs/2.0/custom-images/</a><br>预置docker镜像：<a href="https://circleci.com/docs/2.0/custom-images/">https://circleci.com/docs/2.0/custom-images/</a><br>注：免费情况下， circleci 私有仓库构建次数有限，术语为 Credits，每周共 2500 个，一次构建消耗数量为数个到数十个。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文描述一个 C++ 程序的自动化构建过程，涉及：&lt;br&gt;1、制作适用于 c++ 简单程序的基础镜像。&lt;br&gt;2、使用 CICD 进行编译和构建，并发布。在此过程，涉及到邮件通知。  &lt;/p&gt;
&lt;p&gt;本文示例在简单应用场合中有实践意义，即不使用如 jenkins 这样重型工具，如果信任现成免费的私有的服务，可将自动化工作迁移到公网，否则内建局域网服务或使用公有云搭建。  &lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="http://www.latelee.org/category/docker/"/>
    
    
    <category term="docker" scheme="http://www.latelee.org/tag/docker/"/>
    
  </entry>
  
  <entry>
    <title>vue实践录：vue基础学习</title>
    <link href="http://www.latelee.org/vue/vue-notes-vue-basic.html"/>
    <id>http://www.latelee.org/vue/vue-notes-vue-basic.html</id>
    <published>2020-11-11T14:00:00.000Z</published>
    <updated>2020-12-03T03:00:04.880Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲述 Vue 的基础知识，逐步更新。主要来自网络，有删改和自己的理解。  </p><a id="more"></a><h2 id="Vue指令"><a href="#Vue指令" class="headerlink" title="Vue指令"></a>Vue指令</h2><p>Vue 的指令是以 v- 开头的，它们作用于 HTML 元素，指令提供了一些特殊的特性，将指令绑定在元素上时，指令会为绑定的目标元素添加一些特殊的行为，我们可以将指令看作特殊的 HTML 特性（attribute）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.内容绑定，事件绑定（v-text、v-html、v-on基础）</span><br><span class="line">2.显示切换，属性绑定（v-show、v-if、v-bind）</span><br><span class="line">3.列表训练，表单元素绑定（v-for、v-on补充、v-model)</span><br></pre></td></tr></table></figure><p>详细说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">v-text</span><br><span class="line">1.v-text指令的作用是：设置标签的内容（textContent）</span><br><span class="line">2.默认写法会替换全部内容，使用差值表达式&#123;&#123;&#125;&#125;可以替换指定内容</span><br><span class="line">3.内部支持写表达式</span><br><span class="line"></span><br><span class="line">v-html</span><br><span class="line">1.v-html指令的作用是：设置元素的innerHTML</span><br><span class="line">2.内容中有html结构会被解析成标签</span><br><span class="line">3.v-text指令无论内容是多少，只会解析成文本</span><br><span class="line">4.解析文本使用v-text，需要解析html结构使用v-html</span><br><span class="line"></span><br><span class="line">v-on基础</span><br><span class="line">1.v-on指令的作用是：为元素绑定事件</span><br><span class="line">2.时间名不需要写on</span><br><span class="line">3.指令可以简写成@</span><br><span class="line">4.绑定的方法定义在methods属性中</span><br><span class="line">5.方法的内部通过this关键字可以访问定义在data中数据</span><br><span class="line"></span><br><span class="line">v-show</span><br><span class="line">1.v-show指令的作用是：根据真假切换元素的显示状态</span><br><span class="line">2.原理是修改元素的display，实现显示隐藏</span><br><span class="line">3.指令后面的内容，最终都会解析成布尔值</span><br><span class="line">4.值为true元素显示，值为false元素隐藏</span><br><span class="line">5.数据改变之后，对应元素的显示状态会同步更新</span><br><span class="line"></span><br><span class="line">v-if</span><br><span class="line">1.v-if指令的作用是：根据表达式的真假切换元素的显示状态</span><br><span class="line">2.本质是通过操纵dom元素来切换显示状态（和v-show不同的地方）</span><br><span class="line">3.表达式的值为true，元素存在于dom树中，为false，从dom树中移除</span><br><span class="line">4.频繁的切换v-show，反之使用v-if,前者的切换消耗少</span><br><span class="line"></span><br><span class="line">v-else</span><br><span class="line">1.作为 v-if 或 v-show 的 “else” 部分代码。  </span><br><span class="line">2.必须立即跟在v-if或v-show元素的后面——否则它不能被识别。</span><br><span class="line"></span><br><span class="line">v-bind</span><br><span class="line">1.为元素绑定属性</span><br><span class="line">2.完整写法时v-bind：属性名</span><br><span class="line">3.简写的话可以省略v-bind，只保留：属性名</span><br><span class="line">4.需要动态的增删class建议使用对象的方式</span><br><span class="line"></span><br><span class="line">v-for</span><br><span class="line">1.v-for指令的作用是：根据数据生成列表结构</span><br><span class="line">2.数组经常和v-for结合使用</span><br><span class="line">3.语法是（item，index）in 数据</span><br><span class="line">4.item和index可以结合其他指令一起使用</span><br><span class="line">5.数组长度的更新会同步到页面上是响应式的</span><br><span class="line"></span><br><span class="line">v-on补充</span><br><span class="line">1.事件绑定的方法写成函数调用的形式，可以传入自定义参数</span><br><span class="line">2.定义方法时需要定义形参来接收传入的参数</span><br><span class="line">3.事件的后面跟上.修饰符对事件进行限制</span><br><span class="line">4.enter可以限制触发的按键为回车</span><br><span class="line">5.事件修饰符有多种</span><br><span class="line"></span><br><span class="line">v-model</span><br><span class="line">1.v-model指令的作用是便捷的设置和获取表单元素的值</span><br><span class="line">2.绑定的数据会和表单元素相关联</span><br><span class="line">3.绑定的数据&#x3D;表单数据的值</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>李迟  2020.11.11 周三 晚</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文讲述 Vue 的基础知识，逐步更新。主要来自网络，有删改和自己的理解。  &lt;/p&gt;</summary>
    
    
    
    <category term="vue" scheme="http://www.latelee.org/category/vue/"/>
    
    
    <category term="vue" scheme="http://www.latelee.org/tag/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue实践录：windows 10系统vue环境搭建</title>
    <link href="http://www.latelee.org/vue/vue-notes-starting.html"/>
    <id>http://www.latelee.org/vue/vue-notes-starting.html</id>
    <published>2020-11-10T14:00:00.000Z</published>
    <updated>2020-12-03T03:00:04.880Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲述windows 10 64bit系统中，vue环境的搭建。</p><a id="more"></a><h1 id="nodejs环境"><a href="#nodejs环境" class="headerlink" title="nodejs环境"></a>nodejs环境</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载地址为：<a href="http://npm.taobao.org/mirrors/node/v14.15.0/%EF%BC%8C">http://npm.taobao.org/mirrors/node/v14.15.0/，</a> 下载安装包为<code>node-v14.15.0-x64.msi</code>。<br>双击，根据提示安装。默认已设置好PATH。  </p><h2 id="更新npm源为taobao："><a href="#更新npm源为taobao：" class="headerlink" title="更新npm源为taobao："></a>更新npm源为taobao：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line">npm config list &#x2F;&#x2F; 查看是否生效</span><br></pre></td></tr></table></figure><p>出现<code>metrics-registry = &quot;https://registry.npm.taobao.org/&quot;</code>表示已设置成功。可设置其它配置项的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm set cache &quot;E:\\Program Files\\nodejs\\node_cache&quot;</span><br><span class="line">npm set prefix &quot;E:\\Program Files\\nodejs\\npm_prefix&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>把<code>E:\\Program Files\\nodejs\\npm_prefix</code>加入到 PATH 变量中。否则，安装的包会提示找不到。    </p><h2 id="安装-cnpm"><a href="#安装-cnpm" class="headerlink" title="安装 cnpm"></a>安装 cnpm</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h2 id="安装-vue"><a href="#安装-vue" class="headerlink" title="安装 vue"></a>安装 vue</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cnpm install vue -g</span><br><span class="line">cnpm install vue-cli -g</span><br></pre></td></tr></table></figure><h2 id="简单工程及访问"><a href="#简单工程及访问" class="headerlink" title="简单工程及访问"></a>简单工程及访问</h2><p>根据官方模板创建工程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack-simple hellovue   &#x2F;&#x2F; 一路按回车，用默认值</span><br></pre></td></tr></table></figure><p>安装依赖并运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd hellovue</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>使用浏览器访问：<a href="http://localhost:8080/">http://localhost:8080/</a> 即可看到默认界面。  </p><p>打包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>李迟  2020.11.10 周二 晚</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文讲述windows 10 64bit系统中，vue环境的搭建。&lt;/p&gt;</summary>
    
    
    
    <category term="vue" scheme="http://www.latelee.org/category/vue/"/>
    
    
    <category term="vue" scheme="http://www.latelee.org/tag/vue/"/>
    
  </entry>
  
  <entry>
    <title>软考路：高项1心得</title>
    <link href="http://www.latelee.org/code-life/ruankao-pm1.html"/>
    <id>http://www.latelee.org/code-life/ruankao-pm1.html</id>
    <published>2020-11-08T15:00:00.000Z</published>
    <updated>2020-12-03T03:00:04.764Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录一下高项的复习心得。  </p><a id="more"></a><h2 id="考试科目概述"><a href="#考试科目概述" class="headerlink" title="考试科目概述"></a>考试科目概述</h2><h2 id="上午-综合"><a href="#上午-综合" class="headerlink" title="上午 综合"></a>上午 综合</h2><p>全部选择题。多而杂，记忆的多。计题一般有4~5题，最后5题英文，第一章一般2题。<br>  不需要每字必记，只记关键要点。<br>内容：第一章，立项，十大过程，测试，变更，配置、项目组合项目集，国家标准知识产权，等等。<br>可做战略放弃。  </p><p>难点：某些相近的要点之间的差别。比如，解决冲突方法的“包容”与“妥协”的差别。  </p><h2 id="下午案例"><a href="#下午案例" class="headerlink" title="下午案例"></a>下午案例</h2><p>案例，审题，背理论知识点。<br>难点：理论知识点，计算题。时间紧。    </p><h2 id="下午论文"><a href="#下午论文" class="headerlink" title="下午论文"></a>下午论文</h2><p>论文，十大管理过程，要结论实际项目写。<br>方法：开头背景，收尾总结，中间按十大管理过程分要点写，先写小标题，写理论点（是什么，输入输出有什么），结合项目写怎么做，遇到问题及如何解决。  </p><h2 id="学习分解"><a href="#学习分解" class="headerlink" title="学习分解"></a>学习分解</h2><p>清华版教程为主。    </p><p>1、书本分3大部分<br>开头几章。按内容划分，记关键字及其含义。<br>最后几章。同上。<br>十大过程。先记十大管理，再记47个过程，每个过程的含义、输入、输出、工具（可想象一个项目在这些过程的情景）。  </p><p>2、第一阶段，按书本章节学习。第二阶段，按知识点。如质量方面，有几篇都涉及到。    </p><p>3、扩展学习<br>涉及的如质量，标准，运筹学，可自行扩展学习。但要注意时间分配。</p><p>4、英文<br>教程有一些部分是直接翻译pmp英文版的，实际上，十大管理应该说有很多部分，特别是知识点和输入输出，但也有部分山头。可看之，一是加强理解，二是解决英文题目。  </p><p>5、关于记忆<br>可按自己擅长的方式记。先谐音，再恢复正常的。<br>有些知识前人已总结。如：信息信息6要素：上鹰下鸡左人右龟（上应，下技，左人，右规）。老七/新七工具。等等。<br>有些可自己归纳并联想。  如冲突解决方法：撤回（撤退/回避），和包（缓和包容），协调（妥协调解），强命（强迫命令），合解（合作解决问题）<br>如范围说明书6要点：范标成除制假。<br>有些则要强制记忆。如质量的定义（一组固有特性满足要求的程度，英文为：the degree to which a set of inherent characteristics fulfill requirements）。  </p><p>6、其它<br>十大管理，五大过程组，47个过程。<br>形式矩阵。从不同层面分析。<br>以十大管理角度：每个管理或多或少都涉及到过程组。（如整体管理、采购管理有收尾过程组，其它管理没有）<br>以过程组：每个过程组或多或少涉及到管理。（如启动过程组，涉及整体管理和干系人管理，其它管理没有这个过程组）<br>以项目开展角度，从启动过程组开始，涉及到管理的过程，一一展开。    </p><p>7、扩展学习<br>涉及的如质量，cmmi，软件标准，运筹学，可自行扩展学习。但要注意时间分配。只限兴趣学习。  </p><h2 id="复习重点及操作"><a href="#复习重点及操作" class="headerlink" title="复习重点及操作"></a>复习重点及操作</h2><p>以十大过程，变更，配置（2020年考了测试），能背则背，综合、案例、论文都会涉及到，多背没坏处。<br>在背的过程加上理解。  </p><p>按模块划分，写笔记到不同的文档：<br>1、开头一章<br>2、立项、配置、测试<br>3、采购法、合同法、国家标准、知识产权<br>4、十大管理（可分多个文档，过程描述及输入输出工具为一类，各种文档说明书内容步骤一类，杂项一类）<br>在整理过程中，可查询相关资料，加深理解（如查找质量的新七、老七工具的图例）。  </p><h2 id="报名"><a href="#报名" class="headerlink" title="报名"></a>报名</h2><p>一般提前3个月可报名（如11月初考，8月初可报名，一般每科68元，高级三科200多元）。<br>考前一周可打印准考证。  </p><h2 id="考试"><a href="#考试" class="headerlink" title="考试"></a>考试</h2><p>上场要带的（以个人为例）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">水。</span><br><span class="line">2B铅笔：1~2支</span><br><span class="line">中性笔：1~2支</span><br><span class="line">钢笔+墨水：1+1</span><br><span class="line">刀：1</span><br><span class="line">橡皮擦：1</span><br><span class="line">手表：1</span><br><span class="line">文具盒：1</span><br><span class="line">准考证，身份证</span><br></pre></td></tr></table></figure><h2 id="考场"><a href="#考场" class="headerlink" title="考场"></a>考场</h2><p>有的有时钟，但可能不准时。有的有大屏幕显示倒计时。<br>提前5~10分钟入考场。入场核对个人身份证准考证（监考有考生信息表格，核对照片），5分钟前开始发答题卡，发完再发试卷，发完再发草稿纸。改完再发准考证条形码。<br>答题卡、试卷均填姓名，准考证号。答题卡还要贴条形码。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文记录一下高项的复习心得。  &lt;/p&gt;</summary>
    
    
    
    <category term="代码生活" scheme="http://www.latelee.org/category/code-life/"/>
    
    
    <category term="考证" scheme="http://www.latelee.org/tag/%E8%80%83%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>kindle使用及周边的记录</title>
    <link href="http://www.latelee.org/pkc/kindle-usage.html"/>
    <id>http://www.latelee.org/pkc/kindle-usage.html</id>
    <published>2020-10-31T16:00:00.000Z</published>
    <updated>2020-12-03T03:00:04.768Z</updated>
    
    <content type="html"><![CDATA[<p>kindle及周边的使用记录。</p><a id="more"></a><h2 id="初始化环境"><a href="#初始化环境" class="headerlink" title="初始化环境"></a>初始化环境</h2><p>购买设备，注册官网，添加设备，添加kindle.cn邮箱，添加信任邮箱。  </p><h2 id="kindle日常使用"><a href="#kindle日常使用" class="headerlink" title="kindle日常使用"></a>kindle日常使用</h2><h3 id="传书"><a href="#传书" class="headerlink" title="传书"></a>传书</h3><p>1、使用信任邮箱，添加电子书作为附件，发送之kindle邮箱，主题正文可为空。需格式转换，标题加<code>convert</code>。<br>2、USB线，放到document下，可建不同目录（但kindle不会识别磁盘的目录），字典在其下的字典目录。  </p><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><p>很多功能需开wifi，一般使用飞行模式即可。<br>kindle创建收藏夹，一一放添加书籍。<br>长按，可自动显示字典（可自动识别语言环境），但字典可能无释义。连网情况下，会自动翻译。  </p><h2 id="电子书工具相关"><a href="#电子书工具相关" class="headerlink" title="电子书工具相关"></a>电子书工具相关</h2><p>calibre：格式转换，可查看电子书以确定是否符合要求。<br>briss：PDF裁边。可删除空白边。先预览，合适再保存。<br>使用：File菜单加载文件，点击“取消”，右击蓝色区域，选中，可设置大小。Action菜单有拷贝和预览功能。<br>PDFPasswordRemover：解密工具，如pdf加密（pdf软件标题有”已加密“字样），去之。否则无法裁边。另有线上解密，但可能泄漏资料。    </p><h2 id="目前疑惑"><a href="#目前疑惑" class="headerlink" title="目前疑惑"></a>目前疑惑</h2><p>多个txt，合并为一个mobi或其它格式，有主目录，可索引。（这样书籍数量相对少些）<br>在书籍集合中，先读一本，再跳另一本，前一本是否记住页码？  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;kindle及周边的使用记录。&lt;/p&gt;</summary>
    
    
    
    <category term="个人知识中心" scheme="http://www.latelee.org/category/pkc/"/>
    
    
    <category term="工具使用" scheme="http://www.latelee.org/tag/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：oracle数据库实践</title>
    <link href="http://www.latelee.org/golang/golang-notes-oracle-test.html"/>
    <id>http://www.latelee.org/golang/golang-notes-oracle-test.html</id>
    <published>2020-10-23T15:10:24.000Z</published>
    <updated>2020-12-03T03:00:04.876Z</updated>
    
    <content type="html"><![CDATA[<p>本文在 Windows 7 64bit 系统上使用 golang 连接查询 oracle 数据库。  </p><a id="more"></a><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>前置条件：<br>安装mingw（取其gcc及库，因为要用cgo编译），安装git（取其bash）。安装oci。  </p><p>oracle提供了编程接口，golang 有多个实现库，但均需依赖 oracle 的 instantclient。下载OCI：<br><a href="https://www.oracle.com/database/technologies/instant-client/winx64-64-downloads.html">https://www.oracle.com/database/technologies/instant-client/winx64-64-downloads.html</a> 。<br>版本有 SDK 版本、Basic 版本。压缩包虽不同，但内含目录一致，解压到当前目录即可，拷贝到指定目录，示例：<code>D:\oracle\instantclient</code>。  </p><p>PKG_CONFIG_PATH环境变量 (失败)  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\mingw64\lib\pkg-config</span><br></pre></td></tr></table></figure><p>执行<code>echo $PKG_CONFIG_PATH</code>查看目录，映射到 E:\Program Files\Git\mingw64\lib 下，不存在pkgconfig，创建之。</p><h2 id="安装库"><a href="#安装库" class="headerlink" title="安装库"></a>安装库</h2><p>1、<br>获取oci8.pc。执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">go get github.com&#x2F;wendal&#x2F;go-oci8</span><br><span class="line">提示：</span><br><span class="line"># pkg-config --cflags  -- oci8</span><br><span class="line">Package oci8 was not found in the pkg-config search path.</span><br><span class="line">Perhaps you should add the directory containing &#96;oci8.pc&#39;</span><br><span class="line">to the PKG_CONFIG_PATH environment variable</span><br><span class="line">No package &#39;oci8&#39; found</span><br></pre></td></tr></table></figure><p>无须理会错误，此处是下载源码，主要获取pkg-config.exe和oci8.pc文件。在下载包go-oci8的windows目录，将pkg-config.exe拷贝到git的bin目录，oci8.pc拷贝到 E:\Program Files\Git\mingw64\lib\pkgconfig 目录。  </p><p>2、<br>再次执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go get github.com&#x2F;wendal&#x2F;go-oci8</span><br><span class="line">提示：</span><br><span class="line"># github.com&#x2F;wendal&#x2F;go-oci8</span><br><span class="line">D:&#x2F;mingw64&#x2F;bin&#x2F;..&#x2F;lib&#x2F;gcc&#x2F;x86_64-w64-mingw32&#x2F;8.1.0&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;x86_64-w64-mingw32&#x2F;bin&#x2F;ld.exe: cannot find -lclntsh</span><br><span class="line">collect2.exe: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><p>一说：把oci8.pc文件的lclntsh改为oci，修改后，再执行，通过。得到<code>pkg\windows_amd64\github.com\wendal\go-oci8.a</code>目录。  </p><p>由作者说明得知，<code>wendal</code>是从<code>mattn</code>仓库fork得到的，也下载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com&#x2F;mattn&#x2F;go-oci8</span><br></pre></td></tr></table></figure><p>对比两者源码和生成的.a文件，mattn的文件也多，库也比较大。但对比使用者而言无区别。为安全起见，实际工程使用 mattn 库。    </p><p>3、<br>oci8.pc内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#prefix&#x3D;D:&#x2F;oracle&#x2F;instantclient</span><br><span class="line">includedir&#x3D;D:&#x2F;oracle&#x2F;instantclient&#x2F;sdk&#x2F;include</span><br><span class="line">libdir&#x3D;D:&#x2F;oracle&#x2F;instantclient&#x2F;sdk&#x2F;lib&#x2F;msvc</span><br><span class="line"></span><br><span class="line">Name: oci8</span><br><span class="line">Description: Oracle Instant Client</span><br><span class="line">Version: 19.8</span><br><span class="line">Cflags: -I$&#123;includedir&#125;</span><br><span class="line">Libs: -L$&#123;libdir&#125; -loci</span><br></pre></td></tr></table></figure><p>注：使用全路径，不使用prefix（因为git安装的目录带有空格），将库修改为oci。  </p><p>4、<br>编写测试代码。go build 出错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">D:\go\pkg\tool\windows_amd64\link.exe: running gcc failed: exit status 1</span><br><span class="line">D:&#x2F;mingw64&#x2F;bin&#x2F;..&#x2F;lib&#x2F;gcc&#x2F;x86_64-w64-mingw32&#x2F;8.1.0&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;x86_64-w64-mingw32&#x2F;bin&#x2F;ld.exe: cannot find -loci</span><br><span class="line">collect2.exe: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><p>猜想：官方oci是.lib格式，gcc不认。而golang的驱动得到.a但没有包括oci里面的函数。将得到的go-oci8.a改名为liboci.a，再次<code>go build</code>，提示未定义的函数，用<code>nm</code>查之，函数前为<code>U</code>，猜测格式不对。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pkg-config --cflags -- oci8</span><br><span class="line">-ID:&#x2F;oracle&#x2F;instantclient&#x2F;sdk&#x2F;include</span><br></pre></td></tr></table></figure><p>在<code>D:\oracle\instantclient</code>目录找oci.dll，放到临时目录。从dll生成.a。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gendef.exe oci.dll  # 注：从dll生产def（下一步要用到）</span><br><span class="line"> * [oci.dll] Found PE image</span><br><span class="line"> </span><br><span class="line">$ dlltool.exe -D oci.dll -d oci.def -l liboci.a # 从dll和def生成.a文件。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>生成的文件为liboci.a，可用<code>nm</code>查函数，已有定义。将其放到mingw的lib目录（这样就不用再额外设置路径），本文为 D:\mingw64\lib 。</p><p>5、<br>疑惑1：<br>似乎golang生成的go-oci8.a没什么用，可能内部链接了里面的函数，但最终的oci函数，还是从官方的oci库中获取，如OCIStmtPrepare。<br>疑惑2：<br>在<code>go get github.com/mattn/go-oci8</code>处，会使用pc文件指定的参数，但似乎只针对头文件，也没有链接，具体未详细研究（因为.lib和.a格式已然不同，不通用，链接不上的，没报错，应该没链接）。  </p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">true&quot;database&#x2F;sql&quot;</span><br><span class="line">true&quot;log&quot;</span><br><span class="line">true&quot;errors&quot;</span><br><span class="line">    &#x2F;&#x2F; 导入mysql驱动</span><br><span class="line">    _ &quot;github.com&#x2F;mattn&#x2F;go-oci8&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func CreateOracle(dbstr string) (sqldb *sql.DB, err error) &#123;</span><br><span class="line">    sqldb, err &#x3D; sql.Open(&quot;oci8&quot;, dbstr)</span><br><span class="line">trueif err !&#x3D; nil &#123;</span><br><span class="line">truetruereturn nil, errors.New(&quot;open database failed: &quot; + err.Error())</span><br><span class="line">true&#125;</span><br><span class="line">trueerr &#x3D; sqldb.Ping()</span><br><span class="line">trueif err !&#x3D; nil &#123;</span><br><span class="line">truetruereturn nil, errors.New(&quot;connect database failed: &quot; + err.Error())</span><br><span class="line">true&#125;</span><br><span class="line">truelog.Println(&quot;connect to oracle ok&quot;)</span><br><span class="line">    &#x2F;&#x2F;log.Println(&quot;connect to &quot;, dbParam.server, dbParam.database, &quot;ok&quot;)</span><br><span class="line">    </span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func GetVersion(sqldb *sql.DB) () &#123;</span><br><span class="line">true&#x2F;&#x2F; 降序，最新的在前面</span><br><span class="line">trueresults, err :&#x3D; sqldb.Query(&quot;select version, codetype, addtime from tablevesion order by tablevesion desc&quot;)</span><br><span class="line">trueif err !&#x3D; nil &#123;</span><br><span class="line">truetruefmt.Println(&quot;Query error: &quot;, err)</span><br><span class="line">truetruereturn</span><br><span class="line">true&#125;</span><br><span class="line">truefor results.Next() &#123;</span><br><span class="line">truetruevar item1, item2, item3 sql.NullString</span><br><span class="line">truetrueerr :&#x3D; results.Scan(&amp;item1, &amp;item2, &amp;item3)</span><br><span class="line">truetrueif err !&#x3D; nil &#123;</span><br><span class="line">truetruetruefmt.Println(&quot;scan error: &quot;, err)</span><br><span class="line">truetruetruebreak</span><br><span class="line">truetrue&#125;</span><br><span class="line"></span><br><span class="line">truetrueif (!item1.Valid || !item2.Valid || !item3.Valid) &#123;</span><br><span class="line">truetruetruecontinue</span><br><span class="line">truetrue&#125;</span><br><span class="line"></span><br><span class="line">truetruefmt.Println(item1.String, item2.String, item3.String)</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">truereturn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var dbstr &#x3D; &quot;latelee&#x2F;123456789@192.168.18.188:1521&#x2F;mydb&quot;</span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(&quot;oracle test&quot;)</span><br><span class="line">    </span><br><span class="line">    SQLDB, err :&#x3D; CreateOracle(dbstr)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        fmt.Println(&quot;open db failed&quot;, err)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    GetVersion(SQLDB)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>参考资料：<br><a href="https://www.cnblogs.com/good-temper/p/3791874.html">https://www.cnblogs.com/good-temper/p/3791874.html</a><br><a href="https://blog.csdn.net/yh_coco/article/details/78068610">https://blog.csdn.net/yh_coco/article/details/78068610</a>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文在 Windows 7 64bit 系统上使用 golang 连接查询 oracle 数据库。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：我的工具包</title>
    <link href="http://www.latelee.org/golang/golang-notes-my-utils.html"/>
    <id>http://www.latelee.org/golang/golang-notes-my-utils.html</id>
    <published>2020-10-20T16:11:24.000Z</published>
    <updated>2020-12-03T03:00:04.876Z</updated>
    
    <content type="html"><![CDATA[<p>程序员难免会自造轮子，因为有时候自己的轮子才更适合自己，golang 的生态圈不错，官方的，非官方都有很多不同功能的库。本文从小处着眼，基于 github 开源工程创建属于自己的工具包。  </p><a id="more"></a><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>本文的工具包，不依赖第三方库，全部使用官方的包。实际中使用了第三方库，则另起目录，作为其它包提供。不影响本包。本包命名为 com，可理解为通用的包。包括但不限于以下内容：<br>数值和字符串转换，进制转换。<br>目录、文件操作。<br>日期、时间。<br>命令执行。<br>MD5、base64。<br>地址内容打印Dump。  </p><h2 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h2><p>本小节列出一些函数的实现，详细参考文后源码地址。  </p><h3 id="字符串和数值转换"><a href="#字符串和数值转换" class="headerlink" title="字符串和数值转换"></a>字符串和数值转换</h3><p>字符串转为数值：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Convert string to specify type.</span><br><span class="line">type StrTo string</span><br><span class="line"></span><br><span class="line">func (f StrTo) Exist() bool &#123;</span><br><span class="line">truereturn string(f) !&#x3D; string(0x1E)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f StrTo) Uint8() (uint8) &#123;</span><br><span class="line">truev, _ :&#x3D; strconv.ParseUint(f.String(), 10, 8)</span><br><span class="line">truereturn uint8(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f StrTo) Int() (int) &#123;</span><br><span class="line">truev, _ :&#x3D; strconv.ParseInt(f.String(), 10, 0)</span><br><span class="line">truereturn int(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f StrTo) Int64() (int64) &#123;</span><br><span class="line">truev, _ :&#x3D; strconv.ParseInt(f.String(), 10, 64)</span><br><span class="line">truereturn int64(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f StrTo) Float64() (float64) &#123;</span><br><span class="line">truev, _ :&#x3D; strconv.ParseFloat(f.String(), 64)</span><br><span class="line">truereturn float64(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f StrTo) Uint8Hex() (uint8) &#123;</span><br><span class="line">truev, _ :&#x3D; strconv.ParseUint(f.String(), 16, 8)</span><br><span class="line">truereturn uint8(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f StrTo) IntHex() (int) &#123;</span><br><span class="line">truev, _ :&#x3D; strconv.ParseInt(f.String(), 16, 0)</span><br><span class="line">truereturn int(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f StrTo) Int64Hex() (int64) &#123;</span><br><span class="line">truev, _ :&#x3D; strconv.ParseInt(f.String(), 16, 64)</span><br><span class="line">truereturn int64(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f StrTo) String() string &#123;</span><br><span class="line">trueif f.Exist() &#123;</span><br><span class="line">truetruereturn string(f)</span><br><span class="line">true&#125;</span><br><span class="line">truereturn &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可根据不同函数，将字符串转换成对应的数值。注意，此处不判断原始字符串，通过不同函数指定格式。如<code>256</code>，即可认为十进制，也可认为是十六进制。  </p><p>数值转换为字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; Convert any type to string.</span><br><span class="line">func ToStr(value interface&#123;&#125;, args ...int) (s string) &#123;</span><br><span class="line">trueswitch v :&#x3D; value.(type) &#123;</span><br><span class="line">truecase bool:</span><br><span class="line">truetrues &#x3D; strconv.FormatBool(v)</span><br><span class="line">truecase float32:</span><br><span class="line">truetrues &#x3D; strconv.FormatFloat(float64(v), &#39;f&#39;, argInt(args).Get(0, -1), argInt(args).Get(1, 32))</span><br><span class="line">truecase float64:</span><br><span class="line">truetrues &#x3D; strconv.FormatFloat(v, &#39;f&#39;, argInt(args).Get(0, -1), argInt(args).Get(1, 64))</span><br><span class="line">truecase int:</span><br><span class="line">truetrues &#x3D; strconv.FormatInt(int64(v), argInt(args).Get(0, 10))</span><br><span class="line">truecase int8:</span><br><span class="line">truetrues &#x3D; strconv.FormatInt(int64(v), argInt(args).Get(0, 10))</span><br><span class="line">truecase int16:</span><br><span class="line">truetrues &#x3D; strconv.FormatInt(int64(v), argInt(args).Get(0, 10))</span><br><span class="line">truecase int32:</span><br><span class="line">truetrues &#x3D; strconv.FormatInt(int64(v), argInt(args).Get(0, 10))</span><br><span class="line">truecase int64:</span><br><span class="line">truetrues &#x3D; strconv.FormatInt(v, argInt(args).Get(0, 10))</span><br><span class="line">truecase uint:</span><br><span class="line">truetrues &#x3D; strconv.FormatUint(uint64(v), argInt(args).Get(0, 10))</span><br><span class="line">truecase uint8:</span><br><span class="line">truetrues &#x3D; strconv.FormatUint(uint64(v), argInt(args).Get(0, 10))</span><br><span class="line">truecase uint16:</span><br><span class="line">truetrues &#x3D; strconv.FormatUint(uint64(v), argInt(args).Get(0, 10))</span><br><span class="line">truecase uint32:</span><br><span class="line">truetrues &#x3D; strconv.FormatUint(uint64(v), argInt(args).Get(0, 10))</span><br><span class="line">truecase uint64:</span><br><span class="line">truetrues &#x3D; strconv.FormatUint(v, argInt(args).Get(0, 10))</span><br><span class="line">truecase string:</span><br><span class="line">truetrues &#x3D; v</span><br><span class="line">truecase []byte:</span><br><span class="line">truetrues &#x3D; string(v)</span><br><span class="line">truedefault:</span><br><span class="line">truetrues &#x3D; fmt.Sprintf(&quot;%v&quot;, v)</span><br><span class="line">true&#125;</span><br><span class="line">truereturn s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>十六进制和字符串转换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HexStr2int converts hex format string to decimal number.</span><br><span class="line">func HexStr2int(hexStr string) (int) &#123;</span><br><span class="line">truenum :&#x3D; 0</span><br><span class="line">truelength :&#x3D; len(hexStr)</span><br><span class="line">truefor i :&#x3D; 0; i &lt; length; i++ &#123;</span><br><span class="line">truetruechar :&#x3D; hexStr[length-i-1]</span><br><span class="line">truetruefactor :&#x3D; -1</span><br><span class="line"></span><br><span class="line">truetrueswitch &#123;</span><br><span class="line">truetruecase char &gt;&#x3D; &#39;0&#39; &amp;&amp; char &lt;&#x3D; &#39;9&#39;:</span><br><span class="line">truetruetruefactor &#x3D; int(char) - &#39;0&#39;</span><br><span class="line">truetruecase char &gt;&#x3D; &#39;a&#39; &amp;&amp; char &lt;&#x3D; &#39;f&#39;:</span><br><span class="line">truetruetruefactor &#x3D; int(char) - &#39;a&#39; + 10</span><br><span class="line">truetruedefault:</span><br><span class="line">truetruetruereturn -1</span><br><span class="line">truetrue&#125;</span><br><span class="line"></span><br><span class="line">truetruenum +&#x3D; factor * PowInt(16, i)</span><br><span class="line">true&#125;</span><br><span class="line">truereturn num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Int2HexStr converts decimal number to hex format string.</span><br><span class="line">func Int2HexStr(num int) (hex string) &#123;</span><br><span class="line">trueif num &#x3D;&#x3D; 0 &#123;</span><br><span class="line">truetruereturn &quot;0&quot;</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">truefor num &gt; 0 &#123;</span><br><span class="line">truetruer :&#x3D; num % 16</span><br><span class="line"></span><br><span class="line">truetruec :&#x3D; &quot;?&quot;</span><br><span class="line">truetrueif r &gt;&#x3D; 0 &amp;&amp; r &lt;&#x3D; 9 &#123;</span><br><span class="line">truetruetruec &#x3D; string(r + &#39;0&#39;)</span><br><span class="line">truetrue&#125; else &#123;</span><br><span class="line">truetruetruec &#x3D; string(r + &#39;a&#39; - 10)</span><br><span class="line">truetrue&#125;</span><br><span class="line">truetruehex &#x3D; c + hex</span><br><span class="line">truetruenum &#x3D; num &#x2F; 16</span><br><span class="line">true&#125;</span><br><span class="line">truereturn hex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓冲区、结构体打印"><a href="#缓冲区、结构体打印" class="headerlink" title="缓冲区、结构体打印"></a>缓冲区、结构体打印</h3><p>缓冲区打印：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">func Dump(by []byte, len int) &#123;</span><br><span class="line">    line :&#x3D; 16</span><br><span class="line">    n :&#x3D; len &#x2F; line</span><br><span class="line">    if len % line !&#x3D; 0 &#123;</span><br><span class="line">        n++</span><br><span class="line">    &#125;</span><br><span class="line">    for i :&#x3D; 0; i &lt; n; i++ &#123;</span><br><span class="line">        fmt.Printf(&quot;%08x  &quot;, i*line)</span><br><span class="line">        for j :&#x3D; 0; j &lt; line; j++ &#123;</span><br><span class="line">            if i*line+j &lt; len &#123;</span><br><span class="line">                fmt.Printf(&quot;%02x &quot;, by[i*line+j])</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                fmt.Printf(&quot;   &quot;)</span><br><span class="line">            &#125;</span><br><span class="line">            if j &#x3D;&#x3D; 7 &#123;</span><br><span class="line">                fmt.Printf(&quot; &quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(&quot; |&quot;)</span><br><span class="line">        for j :&#x3D; 0; j&lt;line &amp;&amp; (i*line+j)&lt;len; j++ &#123;</span><br><span class="line">            if (i*line+j) &lt; len &#123;</span><br><span class="line">                c :&#x3D; by[i*line+j]</span><br><span class="line">                if c &gt;&#x3D; &#39; &#39; &amp;&amp; c &lt; &#39;~&#39;&#123;</span><br><span class="line">                    fmt.Printf(&quot;%c&quot;, c)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    fmt.Printf(&quot;.&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                fmt.Printf(&quot;   &quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(&quot;|\n&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数实际为笔者 C 语言版本的改写。  </p><p>结构体或map的打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将数组、map等，按行打印，默认fmt.Println是一行</span><br><span class="line">func PrintByLine(w io.Writer, data interface&#123;&#125;) &#123;</span><br><span class="line">trueif w &#x3D;&#x3D; os.Stderr &#123;</span><br><span class="line">truetruefmt.Fprintf(os.Stderr, &quot;error: &quot;)</span><br><span class="line">true&#125;</span><br><span class="line">truet :&#x3D; reflect.TypeOf(data)</span><br><span class="line"></span><br><span class="line">truev :&#x3D; reflect.ValueOf(data)</span><br><span class="line">trueif v.Len() &#x3D;&#x3D; 0 &#123;</span><br><span class="line">truetruereturn</span><br><span class="line">true&#125;</span><br><span class="line">truefmt.Fprintf(w, &quot;[\n&quot;)</span><br><span class="line">trueswitch t.Kind() &#123;</span><br><span class="line">truecase reflect.Slice, reflect.Array:</span><br><span class="line">truetruefor i :&#x3D; 0; i &lt; v.Len(); i++ &#123;</span><br><span class="line">truetruetruefmt.Fprintf(w, &quot;%d  %v\n&quot;, i+1, v.Index(i))</span><br><span class="line">truetrue&#125;</span><br><span class="line">truecase reflect.Map:</span><br><span class="line">truetrueiter :&#x3D; v.MapRange()</span><br><span class="line">truetruei :&#x3D; 0</span><br><span class="line">truetruefor iter.Next() &#123;</span><br><span class="line">truetruetruefmt.Fprintf(w, &quot;%d %v: %v\n&quot;, i+1, iter.Key(), iter.Value())</span><br><span class="line">truetruetruei +&#x3D; 1</span><br><span class="line">truetrue&#125;</span><br><span class="line">truedefault:</span><br><span class="line">truetruefmt.Fprintf(w, &quot;%v\n&quot;, data)</span><br><span class="line">true&#125;</span><br><span class="line">truefmt.Fprintf(w, &quot;]\ntotal: %d\n&quot;, v.Len())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间相关"><a href="#时间相关" class="headerlink" title="时间相关"></a>时间相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Format unix time int64 to string</span><br><span class="line">func Date(ti int64, format string) string &#123;</span><br><span class="line">truet :&#x3D; time.Unix(int64(ti), 0)</span><br><span class="line">truereturn DateT(t, format)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Format unix time string to string</span><br><span class="line">func DateS(ts string, format string) string &#123;</span><br><span class="line">truei, _ :&#x3D; strconv.ParseInt(ts, 10, 64)</span><br><span class="line">truereturn Date(i, format)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Format time.Time struct to string</span><br><span class="line">&#x2F;&#x2F; MM - month - 01</span><br><span class="line">&#x2F;&#x2F; M - month - 1, single bit</span><br><span class="line">&#x2F;&#x2F; DD - day - 02</span><br><span class="line">&#x2F;&#x2F; D - day 2</span><br><span class="line">&#x2F;&#x2F; YYYY - year - 2006</span><br><span class="line">&#x2F;&#x2F; YY - year - 06</span><br><span class="line">&#x2F;&#x2F; HH - 24 hours - 03</span><br><span class="line">&#x2F;&#x2F; H - 24 hours - 3</span><br><span class="line">&#x2F;&#x2F; hh - 12 hours - 03</span><br><span class="line">&#x2F;&#x2F; h - 12 hours - 3</span><br><span class="line">&#x2F;&#x2F; mm - minute - 04</span><br><span class="line">&#x2F;&#x2F; m - minute - 4</span><br><span class="line">&#x2F;&#x2F; ss - second - 05</span><br><span class="line">&#x2F;&#x2F; s - second &#x3D; 5</span><br><span class="line">&#x2F;&#x2F; TODO ms</span><br><span class="line">func DateT(t time.Time, format string) string &#123;</span><br><span class="line">trueres :&#x3D; strings.Replace(format, &quot;MM&quot;, t.Format(&quot;01&quot;), -1)</span><br><span class="line">trueres &#x3D; strings.Replace(res, &quot;M&quot;, t.Format(&quot;1&quot;), -1)</span><br><span class="line">trueres &#x3D; strings.Replace(res, &quot;DD&quot;, t.Format(&quot;02&quot;), -1)</span><br><span class="line">trueres &#x3D; strings.Replace(res, &quot;D&quot;, t.Format(&quot;2&quot;), -1)</span><br><span class="line">trueres &#x3D; strings.Replace(res, &quot;YYYY&quot;, t.Format(&quot;2006&quot;), -1)</span><br><span class="line">trueres &#x3D; strings.Replace(res, &quot;YY&quot;, t.Format(&quot;06&quot;), -1)</span><br><span class="line">trueres &#x3D; strings.Replace(res, &quot;HH&quot;, fmt.Sprintf(&quot;%02d&quot;, t.Hour()), -1)</span><br><span class="line">trueres &#x3D; strings.Replace(res, &quot;H&quot;, fmt.Sprintf(&quot;%d&quot;, t.Hour()), -1)</span><br><span class="line">trueres &#x3D; strings.Replace(res, &quot;hh&quot;, t.Format(&quot;03&quot;), -1)</span><br><span class="line">trueres &#x3D; strings.Replace(res, &quot;h&quot;, t.Format(&quot;3&quot;), -1)</span><br><span class="line">trueres &#x3D; strings.Replace(res, &quot;mm&quot;, t.Format(&quot;04&quot;), -1)</span><br><span class="line">trueres &#x3D; strings.Replace(res, &quot;m&quot;, t.Format(&quot;4&quot;), -1)</span><br><span class="line">trueres &#x3D; strings.Replace(res, &quot;ss&quot;, t.Format(&quot;05&quot;), -1)</span><br><span class="line">trueres &#x3D; strings.Replace(res, &quot;s&quot;, t.Format(&quot;5&quot;), -1)</span><br><span class="line">truereturn res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>延时函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func Sleep(ms time.Duration) &#123;</span><br><span class="line">truetime.Sleep(ms*time.Millisecond);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其它工具包"><a href="#其它工具包" class="headerlink" title="其它工具包"></a>其它工具包</h2><p>本小节列出其它的工具包。  </p><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>我一起纠结使用哪个日志库，在犹豫中花费很多时间，最后决定先用着一个版本，待到不合适时，再选择其它的。在接触 KubeEdge项目时，了解了 klog 库，考虑到其轻便，最终改造并使用。为了保持原样，其位置和名称均无变化。原始版本提供的主要接口函数如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Fatal Fatalf Fatalln</span><br><span class="line">Error Errorf Errorln</span><br><span class="line">Warning Warningf Warningln</span><br><span class="line">Exit Exitf Exitln</span><br></pre></td></tr></table></figure><p>为了方便自己理解和使用，额外再添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Print Printf Println</span><br></pre></td></tr></table></figure><p>这样就可以和 fmt 无缝切换了。  </p><p>另外，考虑到不需要 pid，所以在输出提示符中去掉了 pid。输出格式如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2020-10-20 21:47:29.411 busy.go:20] hello world</span><br></pre></td></tr></table></figure><p>此提示符为笔者一直使用且已习惯。  </p><p>详情可参考<a href="https://github.com/latelee/go_project/blob/master/vendor/k8s.io/klog/klog.go">klog源码</a> 。</p><p>补记：<br>log4go功能强大，但似乎不能转义<code>\n</code>，会将其原样输出。  </p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>本文所述工具包，大部分来自 <a href="https://github.com/Unknwon/com">此处github</a> 的开源项目，在实践中不断优化并添加自己认为必要的工具函数。详细可参考笔者的 <a href="https://github.com/latelee/go_project/tree/master/pkg/com">golang工程</a> 。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;程序员难免会自造轮子，因为有时候自己的轮子才更适合自己，golang 的生态圈不错，官方的，非官方都有很多不同功能的库。本文从小处着眼，基于 github 开源工程创建属于自己的工具包。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：命令行cobra库实例</title>
    <link href="http://www.latelee.org/golang/golang-notes-cobra-note.html"/>
    <id>http://www.latelee.org/golang/golang-notes-cobra-note.html</id>
    <published>2020-10-20T16:10:24.000Z</published>
    <updated>2020-12-03T03:00:04.876Z</updated>
    
    <content type="html"><![CDATA[<p>本文使用 cobra 库实现一个命令行工具，类似 git、docker、kubectl 这类的工具。<br>本文仅为一个初具模型的示例，但有实践参考意义。  </p><a id="more"></a><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>在编程中，很多时候，程序都会处理多个参数，特别是一些工具类的函数，需要整合较多功能，即使同一功能，也会有不同参数，利用配置文件或命令选项方式，可使程序具备通用性，也具扩展性。  </p><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>cobra 功能较强大，在 golang 生态中有很多应用，如大名鼎鼎的 docker。其支持子命令执行，配置文件读写等，本文以实战为目的，不过多介绍。  </p><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p>工程名为 cmdtool，见名知义。<br>工程目录及对应介绍如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── cmd ## 子命令总目录</span><br><span class="line">│   ├── db    ## 子命令1实现目录</span><br><span class="line">│   ├── misc  ## 子命令2实现目录</span><br><span class="line">│   ├── rootCmd.go  ## 子命令入口</span><br><span class="line">│   └── test  ## 子命令3实现目录</span><br><span class="line">├── common ## 共用函数、变量</span><br><span class="line">│   ├── conf</span><br><span class="line">│   ├── constants</span><br><span class="line">│   └── globalfunc.go</span><br><span class="line">├── config.yaml ## 配置文件</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── main.go  ## 入口函数 </span><br><span class="line">├── mybuild.sh ## 编译脚本</span><br><span class="line">├── pkg  ## 库</span><br><span class="line">│   ├── com</span><br><span class="line">│   └── wait</span><br><span class="line">├── README</span><br><span class="line">└── vendor ## 依赖库</span><br><span class="line">    ├── github.com</span><br><span class="line">    ├── golang.org</span><br><span class="line">    ├── gopkg.in</span><br><span class="line">    ├── k8s.io</span><br><span class="line">    └── xorm.io</span><br></pre></td></tr></table></figure><p>其中 cmd 是所有子命令的入口目录，不同子命令，以不同子目录形式存在。common 目录存在共用的变量或初始化函数，等等。pkg 为个人总结积累的一些有用的库。<br>main.go 为主函数，调用了 cmd/rootCmd.go 的创建命令函数，由此进入cobra的处理框架中。<br>一般情况下，只需要扩展 cmd 目录下子命令，并补充 rootCmd.go 函数即可，其它即为业务程序的处理。  </p><h2 id="工程分解"><a href="#工程分解" class="headerlink" title="工程分解"></a>工程分解</h2><h3 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h3><p>主入口函数非常简单，实际调用了 rootCmd.go 中的执行函数。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    _ &quot;fmt&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">    rootCmd &quot;github.com&#x2F;latelee&#x2F;cmdtool&#x2F;cmd&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">trueif err :&#x3D; rootCmd.Execute(); err !&#x3D; nil &#123;</span><br><span class="line">truetrueos.Exit(1)</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命令行入口"><a href="#命令行入口" class="headerlink" title="命令行入口"></a>命令行入口</h3><p>rootCmd.go 源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">package cmd</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">true&quot;os&quot;</span><br><span class="line">true&quot;bytes&quot;</span><br><span class="line">    &quot;path&#x2F;filepath&quot;</span><br><span class="line">true&quot;github.com&#x2F;spf13&#x2F;cobra&quot;</span><br><span class="line">true&quot;github.com&#x2F;spf13&#x2F;viper&quot;</span><br><span class="line">true</span><br><span class="line">true&quot;github.com&#x2F;fsnotify&#x2F;fsnotify&quot;</span><br><span class="line"></span><br><span class="line">    &quot;k8s.io&#x2F;klog&quot;</span><br><span class="line">    test &quot;github.com&#x2F;latelee&#x2F;cmdtool&#x2F;cmd&#x2F;test&quot;</span><br><span class="line">truemisc &quot;github.com&#x2F;latelee&#x2F;cmdtool&#x2F;cmd&#x2F;misc&quot;</span><br><span class="line">truedb   &quot;github.com&#x2F;latelee&#x2F;cmdtool&#x2F;cmd&#x2F;db&quot;</span><br><span class="line">trueconf &quot;github.com&#x2F;latelee&#x2F;cmdtool&#x2F;common&#x2F;conf&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    longDescription &#x3D; &#96;  database test tool.</span><br><span class="line">  命令终端测试示例工具。</span><br><span class="line">&#96;</span><br><span class="line">    example &#x3D; &#96;  comming soon...</span><br><span class="line">&#96;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var cfgFile string</span><br><span class="line"></span><br><span class="line">var rootCmd &#x3D; &amp;cobra.Command&#123;</span><br><span class="line">trueUse:   filepath.Base(os.Args[0]),</span><br><span class="line">trueShort: &quot;database tool&quot;,</span><br><span class="line">trueLong: longDescription,</span><br><span class="line">trueExample: example,</span><br><span class="line">trueVersion: &quot;1.0&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Execute() error &#123;</span><br><span class="line">    rootCmd.AddCommand(test.NewCmdTest())</span><br><span class="line">truerootCmd.AddCommand(misc.NewCmdMisc())</span><br><span class="line">truerootCmd.AddCommand(db.NewCmdDb())</span><br><span class="line"></span><br><span class="line">truereturn rootCmd.Execute()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">truecobra.OnInitialize(initConfig)</span><br><span class="line"></span><br><span class="line">truerootCmd.PersistentFlags().StringVar(&amp;cfgFile, &quot;config&quot;, &quot;&quot;, &quot;config file (config.yaml)&quot;)</span><br><span class="line"></span><br><span class="line">    rootCmd.PersistentFlags().BoolVar(&amp;conf.FlagPrint, &quot;print&quot;, false, &quot;will print sth&quot;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var yamlExample &#x3D; []byte(</span><br><span class="line">&#96;dbserver:</span><br><span class="line">  dbstr: helloooooo</span><br><span class="line">  timeout:</span><br><span class="line">    connect: 67s</span><br><span class="line">    singleblock: 2s</span><br><span class="line">  name:</span><br><span class="line">    name: firstblood</span><br><span class="line">&#96;)</span><br><span class="line"></span><br><span class="line">func initConfig() &#123;</span><br><span class="line">trueif cfgFile !&#x3D; &quot;&quot; &#123;</span><br><span class="line">truetrueviper.SetConfigFile(cfgFile)</span><br><span class="line">true&#125; else &#123;</span><br><span class="line">truetrueviper.AddConfigPath(&quot;.&#x2F;&quot;)</span><br><span class="line">truetrueviper.SetConfigName(&quot;config&quot;)</span><br><span class="line">truetrueviper.SetConfigType(&quot;yaml&quot;)</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">trueviper.AutomaticEnv()</span><br><span class="line"></span><br><span class="line">trueerr :&#x3D; viper.ReadInConfig();</span><br><span class="line">trueif  err !&#x3D; nil &#123;</span><br><span class="line">truetrueklog.Println(&quot;not found config file. using default&quot;)</span><br><span class="line">truetrueviper.ReadConfig(bytes.NewBuffer(yamlExample))</span><br><span class="line">truetrueviper.SafeWriteConfig()</span><br><span class="line">truetrue</span><br><span class="line">true&#125;</span><br><span class="line">trueconf.FlagDBServer &#x3D; viper.GetString(&quot;dbserver.dbstr&quot;)</span><br><span class="line">trueconf.FlagTimeout &#x3D; viper.GetString(&quot;dbserver.timeout.connect&quot;)</span><br><span class="line">trueconf.FlagName &#x3D; viper.GetString(&quot;dbserver.name.name&quot;)</span><br><span class="line">trueklog.Println(conf.FlagDBServer, conf.FlagTimeout, conf.FlagName)</span><br><span class="line"></span><br><span class="line">true&#x2F;&#x2F;设置监听回调函数</span><br><span class="line">trueviper.OnConfigChange(func(e fsnotify.Event) &#123;</span><br><span class="line">truetrueconf.FlagTimeout &#x3D; viper.GetString(&quot;dbserver.timeout.connect&quot;)</span><br><span class="line">true&#125;)</span><br><span class="line"></span><br><span class="line">trueviper.WatchConfig()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 initConfig 函数作用是读取配置文件字段，如果没有文件则自动生成默认的配置。注意，该函数的 yamlExample 需要保持实际配置文件的格式（从 viper.GetString 函数参数可以看出 dbserver 为顶层字段）。<br>最后利用 viper 监听配置文件的变化。实际测试发现会触发2次，利用循环定时判断变量值可以解决。  </p><h3 id="子命令实现"><a href="#子命令实现" class="headerlink" title="子命令实现"></a>子命令实现</h3><p>子命令的实现形式大同小异，以 test 为例，源码如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">package cmd</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;github.com&#x2F;spf13&#x2F;cobra&quot;</span><br><span class="line">true_ &quot;github.com&#x2F;spf13&#x2F;pflag&quot;</span><br><span class="line">true</span><br><span class="line">true&quot;k8s.io&#x2F;klog&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    name &#x3D; &#96;test&#96;</span><br><span class="line">    shortDescription &#x3D; &#96;  test command&#96;</span><br><span class="line">    longDescription  &#x3D; &#96;  test...</span><br><span class="line">&#96;</span><br><span class="line">    example &#x3D; &#96;  example comming up...</span><br><span class="line">&#96;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type UserCmdFunc struct &#123;</span><br><span class="line">truename string</span><br><span class="line">truefn func(args []string)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewCmdTest() *cobra.Command&#123;</span><br><span class="line">true</span><br><span class="line">    var cmd &#x3D; &amp;cobra.Command&#123;</span><br><span class="line">        Use:     name,</span><br><span class="line">        Short:   shortDescription,</span><br><span class="line">        Long:    longDescription,</span><br><span class="line">        Example: example,</span><br><span class="line">        RunE: func(cmd *cobra.Command, args []string) error &#123;</span><br><span class="line">truetruetrueif (len(args) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">truetruetruetrueklog.Warning(&quot;no args found&quot;)</span><br><span class="line">truetruetruetruereturn nil</span><br><span class="line">truetruetrue&#125;</span><br><span class="line"></span><br><span class="line">            if (args[0] &#x3D;&#x3D; &quot;foo&quot;)&#123;</span><br><span class="line">                foo(args)</span><br><span class="line">            &#125; else if (args[0] &#x3D;&#x3D; &quot;watch&quot;)&#123;</span><br><span class="line">                testWatch(args)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">truetruetruetrueklog.Printf(&quot;cmd &#39;%v&#39; not support&quot;, args[0])</span><br><span class="line">truetruetruetruereturn nil</span><br><span class="line">truetruetrue&#125; </span><br><span class="line">            return nil</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return cmd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 NewCmdTest 函数中创建 cobra.Command 并返回，在 RunE 中判断参数并真正执行业务函数。本例实现了参数监听功能，源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 监听配置参数变化</span><br><span class="line">func testWatch(args []string) &#123;</span><br><span class="line">truetimeout :&#x3D; conf.FlagTimeout</span><br><span class="line">truefor &#123;</span><br><span class="line">truetrueif timeout !&#x3D; conf.FlagTimeout &#123;</span><br><span class="line">truetruetrueklog.Printf(&quot;param changed: %v\n&quot;, conf.FlagTimeout)</span><br><span class="line">truetruetruetimeout &#x3D; conf.FlagTimeout</span><br><span class="line">truetrue&#125;</span><br><span class="line">truetruecom.Sleep(1000)</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line">当配置文件相应字段变化时，将其打印出来。  </span><br><span class="line"></span><br><span class="line">## 测试</span><br><span class="line">默认输出帮助信息：  </span><br></pre></td></tr></table></figure><p>$ ./cmdtool.exe<br>  database test tool.<br>  命令终端测试示例工具。</p><p>Usage:<br>  cmdtool.exe [command]</p><p>Examples:<br>  comming soon…</p><p>Available Commands:<br>  db            db command<br>  help        Help about any command<br>  misc          misc command<br>  test          test command</p><p>Flags:<br>  -h, –help      help for cmdtool.exe<br>      –print     will print sth<br>      –version   version for cmdtool.exe</p><p>Use “cmdtool.exe [command] –help” for more information about a command.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行子命令：</span><br></pre></td></tr></table></figure><p>$ ./cmdtool.exe test foo<br>[2020-10-20 21:46:39.304 rootCmd.go:113] helloooooo 61s firstblood<br>[2020-10-20 21:46:39.305 busy.go:12] test foo…..</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">监听配置文件：  </span><br></pre></td></tr></table></figure><p>$ ./cmdtool.exe test watch<br>[2020-10-20 21:47:14.408 rootCmd.go:113] helloooooo 61s firstblood<br>[2020-10-20 21:47:29.411 busy.go:20] param changed: 100s</p><pre><code>## 源码源码[在此](https://github.com/latelee/cmdtool)。## 其它事项利用`viper.SafeWriteConfig()`写配置文件时，发现 yamlExample 添加的注释会被删除，所以可以考虑直接将字符串通过`ioutil.WriteFile`写到文件。  </code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文使用 cobra 库实现一个命令行工具，类似 git、docker、kubectl 这类的工具。&lt;br&gt;本文仅为一个初具模型的示例，但有实践参考意义。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>Windows设置IP脚本</title>
    <link href="http://www.latelee.org/pkc/setting-ip-for-windows.html"/>
    <id>http://www.latelee.org/pkc/setting-ip-for-windows.html</id>
    <published>2020-10-19T16:00:00.000Z</published>
    <updated>2020-12-03T03:00:04.768Z</updated>
    
    <content type="html"><![CDATA[<p>Windows下设置IP的脚本。</p><a id="more"></a><h2 id="固定IP"><a href="#固定IP" class="headerlink" title="固定IP"></a>固定IP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cls</span><br><span class="line">color 0A</span><br><span class="line">echo waiting...</span><br><span class="line"></span><br><span class="line">netsh interface ipv4 set address name&#x3D;&quot;本地连接&quot; source&#x3D;static addr&#x3D;10.10.6.6  mask&#x3D;255.255.255.0 gateway&#x3D;10.10.6.254 gwmetric&#x3D;1</span><br><span class="line">netsh interface ipv4 set dns name&#x3D;&quot;本地连接&quot; source&#x3D;static addr&#x3D;8.8.8.8</span><br><span class="line"></span><br><span class="line">echo done.</span><br><span class="line">Pause</span><br></pre></td></tr></table></figure><h2 id="自动获取IP"><a href="#自动获取IP" class="headerlink" title="自动获取IP"></a>自动获取IP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cls</span><br><span class="line">color 0A</span><br><span class="line">Echo  waiting...</span><br><span class="line"></span><br><span class="line">netsh interface ip set address name&#x3D;&quot;本地连接&quot; source&#x3D;dhcp</span><br><span class="line">netsh interface ip set dns name&#x3D;&quot;本地连接&quot; source&#x3D;dhcp</span><br><span class="line"></span><br><span class="line">Echo done...</span><br><span class="line"></span><br><span class="line">Pause</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Windows下设置IP的脚本。&lt;/p&gt;</summary>
    
    
    
    <category term="个人知识中心" scheme="http://www.latelee.org/category/pkc/"/>
    
    
    <category term="工具使用" scheme="http://www.latelee.org/tag/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>格式化工具indent使用笔记</title>
    <link href="http://www.latelee.org/pkc/database-practice.html"/>
    <id>http://www.latelee.org/pkc/database-practice.html</id>
    <published>2020-09-14T16:00:00.000Z</published>
    <updated>2020-12-03T03:00:04.768Z</updated>
    
    <content type="html"><![CDATA[<p>indent可以格式化C/C++代码，经测试发现，只有Linux格式的文件才能正确格式化，即以LF结尾。</p><a id="more"></a><h2 id="使用格式"><a href="#使用格式" class="headerlink" title="使用格式"></a>使用格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">indent [参数][源文件]</span><br><span class="line">或</span><br><span class="line">indent [参数][源文件][-o 目标文件]</span><br></pre></td></tr></table></figure><h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><h3 id="个人使用的"><a href="#个人使用的" class="headerlink" title="个人使用的"></a>个人使用的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">个人使用的：</span><br><span class="line">indent -linux -bad -bap -bl -hnl -nce -cdw -bli0 -cli0 -cbi0 -ncs -lp -l200 -npcs -saf -sai -saw -i4 -nut hello.c -o b.c</span><br><span class="line"></span><br><span class="line">-cli 指定switch 缩排格数？？</span><br><span class="line">-hnl 多行运算时，按一定格式换行</span><br><span class="line">-bl -nce  for if while 等后的&#123;另起一行 不要将else放到&#125;后，即大括号另起一行</span><br><span class="line">-cdw do&#123;&#125;while中，while与&#125;在同一行。注：似乎和前面的冲突了，不生效（待研究）</span><br><span class="line">-bli0 &#123;不缩进，即对齐for if while 等</span><br><span class="line">-ncs 类型转换不空格。注：只能识别已知类型，自定义的不行（注：发现原有不空格的，变成空格了，待研究）</span><br><span class="line">-lp 过长截取时，对齐，-nlp 反之</span><br><span class="line">-nbc 变量声明中，逗号分隔的变量不分行。最终效果为 int a, b, c;</span><br><span class="line">-bad -bap 声明和实现之间添加空行，不一定符合实际情况。  </span><br><span class="line">-npcs 函数名称后不加空格</span><br><span class="line">-nut -i4  4空格，不使用tab缩进（即tab使用4个空格替换）</span><br><span class="line">-saf -sai -saw for if while 后有一空格</span><br><span class="line"></span><br><span class="line">-l200 非注释行，最长256 默认78</span><br></pre></td></tr></table></figure><p>待改善的问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">默认：指针类型的*不在类型后，而在变量前。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h3><p>indent默认风格为gnu。另有kr、linux、orig（即原始的Berkeley风格）。经测试，linux风格较接近实际使用的。    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">linux风格默认为：</span><br><span class="line">-nbad -bap -nbc -bbo -hnl -br -brs -c33 -cd33 -ncdb -ce -ci4</span><br><span class="line">-cli0 -d0 -di1 -nfc1 -i8 -ip0 -l80 -lp -npcs -nprs -npsl -sai</span><br><span class="line">-saf -saw -ncs -nsc -sob -nfca -cp33 -ss -ts8 -il1</span><br></pre></td></tr></table></figure><h2 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h2><p>查找某目录下所有源码，转换成linux格式，再格式化。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find .&#x2F;  -name &#39;*.cpp&#39; -or -name &#39;*.c&#39; -or -name &quot;*.h&quot; | xargs dos2unix </span><br><span class="line">find .&#x2F;  -name &#39;*.cpp&#39; -or -name &#39;*.c&#39; -or -name &quot;*.h&quot; | xargs indent -linux -bl -nce -cdw -bli0 -cli0 -cbi0 -ncs -lp -l200 -npcs -saf -sai -saw -i4 -nut </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码中有<code>int ret=-1</code>时警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning:old style assignment ambiguity in &quot;&#x3D;-&quot;.  Assuming &quot;&#x3D; -&quot;</span><br></pre></td></tr></table></figure><p>对c++一些语法处理不太好。如<code>for (auto it:dataTable)</code>。<br>对没有分号<code>;</code>结尾的“函数”或宏处理不好，如<code>#pragma pack(1)</code>，会自动再缩进。<br>一些小格式对齐不够人性化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原为：</span><br><span class="line">    int pre  &#x3D; 0;</span><br><span class="line">    int next &#x3D; 0;</span><br><span class="line">变成：</span><br><span class="line">    int pre &#x3D; 0;</span><br><span class="line">    int next &#x3D; 0;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>建议先用工具格式化，再规范编码，后续以人工为准。  </p><h2 id="网络资料"><a href="#网络资料" class="headerlink" title="网络资料"></a>网络资料</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">参数说明：</span><br><span class="line">-npro或--ignore-profile 　不要读取indent的配置文件.indent.pro。</span><br><span class="line">-kr 　指定使用Kernighan&amp;Ritchie的格式。</span><br><span class="line">-i8 　--indent-level 设置缩排的格数为8。</span><br><span class="line">-ts8 设置tab的长度</span><br><span class="line">-sob或--swallow-optional-blank-lines 　删除多余的空白行。</span><br><span class="line">-l80 代码超过80换行</span><br><span class="line">-ss或--space-special-semicolon 　若for区段只有一行时，在分号前加上空格。</span><br><span class="line">-ncs或--no-space-after-casts 　不要在cast之后空一格。</span><br><span class="line">-bl &#123;分行显示</span><br><span class="line">-bli 0 括号缩进为0</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">参　　数：</span><br><span class="line">-bad或--blank-lines-after-declarations 　在声明区段或加上空白行。</span><br><span class="line">-bap或--blank-lines-after-procedures 　在程序或加上空白行。</span><br><span class="line">-bbb或--blank-lines-after-block-comments 　在注释区段后加上空白行。</span><br><span class="line">-bc或--blank-lines-after-commas 　在声明区段中，若出现逗号即换行。</span><br><span class="line">-bl或--braces-after-if-line 　if(或是else,for等等)与后面执行区段的&quot;&#123;&quot;不同行，且&quot;&#125;&quot;自成一行。</span><br><span class="line">-bli&lt;缩排格数&gt;或--brace-indent&lt;缩排格数&gt; 　设置&#123; &#125;缩排的格数。</span><br><span class="line">-br或--braces-on-if-line 　if(或是else,for等等)与后面执行跛段的&quot;&#123;&quot;不同行，且&quot;&#125;&quot;自成一行。</span><br><span class="line">-bs或--blank-before-sizeof 　在sizeof之后空一格。</span><br><span class="line">-c&lt;栏数&gt;或--comment-indentation&lt;栏数&gt; 　将注释置于程序码右侧指定的栏位。</span><br><span class="line">-cd&lt;栏数&gt;或--declaration-comment-column&lt;栏数&gt; 　将注释置于声明右侧指定的栏位。</span><br><span class="line">-cdb或--comment-delimiters-on-blank-lines 　注释符号自成一行。</span><br><span class="line">-ce或--cuddle-else 　将else置于&quot;&#125;&quot;(if执行区段的结尾)之后。</span><br><span class="line">-ci&lt;缩排格数&gt;或--continuation-indentation&lt;缩排格数&gt; 　叙述过长而换行时，指定换行后缩排的格数。</span><br><span class="line">-cli&lt;缩排格数&gt;或--case-indentation-&lt;缩排格数&gt; 　使用case时，switch缩排的格数。</span><br><span class="line">-cp&lt;栏数&gt;或-else-endif-column&lt;栏数&gt; 　将注释置于else与elseif叙述右侧定的栏位。</span><br><span class="line">-cs或--space-after-cast 　在cast之后空一格。</span><br><span class="line">-d&lt;缩排格数&gt;或-line-comments-indentation&lt;缩排格数&gt; 　针对不是放在程序码右侧的注释，设置其缩排格数。</span><br><span class="line">-di&lt;栏数&gt;或--declaration-indentation&lt;栏数&gt; 　将声明区段的变量置于指定的栏位。</span><br><span class="line">-fc1或--format-first-column-comments 　针对放在每行最前端的注释，设置其格式。</span><br><span class="line">-fca或--format-all-comments 　设置所有注释的格式。</span><br><span class="line">-gnu或--gnu-style 　指定使用GNU的格式，此为预设值。</span><br><span class="line">-i&lt;格数&gt;或--indent-level&lt;格数&gt; 　设置缩排的格数。</span><br><span class="line">-ip&lt;格数&gt;或--parameter-indentation&lt;格数&gt; 　设置参数的缩排格数。</span><br><span class="line">-kr或--k-and-r-style 　指定使用Kernighan&amp;Ritchie的格式。</span><br><span class="line">-lp或--continue-at-parentheses 　叙述过长而换行，且叙述中包含了括弧时，将括弧中的每行起始栏位内容垂直对其排列。</span><br><span class="line">-nbad或--no-blank-lines-after-declarations 　在声明区段后不要加上空白行。</span><br><span class="line">-nbap或--no-blank-lines-after-procedures 　在程序后不要加上空白行。</span><br><span class="line">-nbbb或--no-blank-lines-after-block-comments 　在注释区段后不要加上空白行。</span><br><span class="line">-nbc或--no-blank-lines-after-commas 　在声明区段中，即使出现逗号，仍旧不要换行。</span><br><span class="line">-ncdb或--no-comment-delimiters-on-blank-lines 　注释符号不要自成一行。</span><br><span class="line">-nce或--dont-cuddle-else 　不要将else置于&quot;&#125;&quot;之后。</span><br><span class="line">-ncs或--no-space-after-casts 　不要在cast之后空一格。</span><br><span class="line">-nfc1或--dont-format-first-column-comments 　不要格式化放在每行最前端的注释。</span><br><span class="line">-nfca或--dont-format-comments 　不要格式化任何的注释。</span><br><span class="line">-nip或--no-parameter-indentation 　参数不要缩排。</span><br><span class="line">-nlp或--dont-line-up-parentheses 　叙述过长而换行，且叙述中包含了括弧时，不用将括弧中的每行起始栏位垂直对其排列。</span><br><span class="line">-npcs或--no-space-after-function-call-names 　在调用的函数名称之后，不要加上空格。</span><br><span class="line">-npro或--ignore-profile 　不要读取indent的配置文件.indent.pro。</span><br><span class="line">-npsl或--dont-break-procedure-type 　程序类型与程序名称放在同一行。</span><br><span class="line">-nsc或--dont-star-comments 　注解左侧不要加上星号(*)。</span><br><span class="line">-nsob或--leave-optional-semicolon 　不用处理多余的空白行。</span><br><span class="line">-nss或--dont-space-special-semicolon 　若for或while区段仅有一行时，在分号前不加上空格。</span><br><span class="line">-nv或--no-verbosity 　不显示详细的信息。</span><br><span class="line">-orig或--original 　使用Berkeley的格式。</span><br><span class="line">-pcs或--space-after-procedure-calls 　在调用的函数名称与&quot;&#123;&quot;之间加上空格。</span><br><span class="line">-psl或--procnames-start-lines 　程序类型置于程序名称的前一行。</span><br><span class="line">-sc或--start-left-side-of-comments 　在每行注释左侧加上星号(*)。</span><br><span class="line">-sob或--swallow-optional-blank-lines 　删除多余的空白行。</span><br><span class="line">-ss或--space-special-semicolon 　若for或swile区段今有一行时，在分号前加上空格。</span><br><span class="line">-st或--standard-output 　将结果显示在标准输出设备。</span><br><span class="line">-T 　数据类型名称缩排。</span><br><span class="line">-ts&lt;格数&gt;或--tab-size&lt;格数&gt; 　设置tab的长度。</span><br><span class="line">-v或--verbose 　执行时显示详细的信息。</span><br><span class="line">-version 　显示版本信息。</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;indent可以格式化C/C++代码，经测试发现，只有Linux格式的文件才能正确格式化，即以LF结尾。&lt;/p&gt;</summary>
    
    
    
    <category term="个人知识中心" scheme="http://www.latelee.org/category/pkc/"/>
    
    
    <category term="工具使用" scheme="http://www.latelee.org/tag/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>C++ map值为结构体的示例</title>
    <link href="http://www.latelee.org/my-library/map-value-for-struct-using-c++.html"/>
    <id>http://www.latelee.org/my-library/map-value-for-struct-using-c++.html</id>
    <published>2020-09-02T15:00:00.000Z</published>
    <updated>2020-12-03T03:00:04.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>某一种数据，会有重复记录，后附加各类数据。利用map的唯一性，将重复者过滤。并将附加的数据存储到结构体，方便在代码中使用。后续可写入文件或数据。  </p><a id="more"></a><p>实例：某一路段至少有一个门架，门架有各种数据。简单示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">000250 32021 1057</span><br></pre></td></tr></table></figure><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 分割string</span><br><span class="line">std::vector&lt;std::string&gt; stringSplit(const std::string&amp; s, const std::string&amp; delim)</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; elems;</span><br><span class="line">    size_t pos &#x3D; 0;</span><br><span class="line">    size_t len &#x3D; s.length();</span><br><span class="line">    size_t delim_len &#x3D; delim.length();</span><br><span class="line">    if (delim_len &#x3D;&#x3D; 0) return elems;</span><br><span class="line">    while (pos &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        int find_pos &#x3D; s.find(delim, pos);</span><br><span class="line">        if (find_pos &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            elems.push_back(s.substr(pos, len - pos));</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        elems.push_back(s.substr(pos, find_pos - pos));</span><br><span class="line">        pos &#x3D; find_pos + delim_len;</span><br><span class="line">    &#125;</span><br><span class="line">    return elems;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef struct tGantryDist_t &#123;</span><br><span class="line">    int preDist;</span><br><span class="line">    int nextDist;</span><br><span class="line">&#125; GantryDist_t;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; tmpe</span><br><span class="line">void ReadGantry(const char* filename)</span><br><span class="line">&#123;</span><br><span class="line">    std::fstream f(filename);</span><br><span class="line">    std::string line; </span><br><span class="line">    GantryDist_t gantryDist;</span><br><span class="line">    std::map&lt;std::string, GantryDist_t&gt; tmpGantryM;</span><br><span class="line">    std::vector&lt;std::string&gt; tmpV;</span><br><span class="line"></span><br><span class="line">truewhile (std::getline(f, line))</span><br><span class="line">true&#123;</span><br><span class="line">        tmpV &#x3D; stringSplit(line, &quot; &quot;);</span><br><span class="line">        </span><br><span class="line">        gantryDist.preDist &#x3D; std::stoi(tmpV[1]);</span><br><span class="line">        gantryDist.nextDist &#x3D; std::stoi(tmpV[2]);</span><br><span class="line">        tmpGantryM.insert(std::pair&lt;std::string, GantryDist_t&gt;(tmpV[0].c_str(), gantryDist));</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">    for (auto it: tmpGantryM)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        gantryDist &#x3D; static_cast&lt;GantryDist_t&gt;(it.second);</span><br><span class="line">        printf(&quot;result: %s %d %d\n&quot;, it.first.c_str(), gantryDist.preDist, gantryDist.nextDist);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;某一种数据，会有重复记录，后附加各类数据。利用map的唯一性，将重复者过滤。并将附加的数据存储到结构体，方便在代码中使用。后续可写入文件或数据。  &lt;/p&gt;</summary>
    
    
    
    <category term="我的程序代码" scheme="http://www.latelee.org/category/my-library/"/>
    
    
    <category term="Linux编程" scheme="http://www.latelee.org/tag/Linux%E7%BC%96%E7%A8%8B/"/>
    
    <category term="工程库代码" scheme="http://www.latelee.org/tag/%E5%B7%A5%E7%A8%8B%E5%BA%93%E4%BB%A3%E7%A0%81/"/>
    
    <category term="c&amp;c++" scheme="http://www.latelee.org/tag/c-c/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：一个数据库迁移的代码记录</title>
    <link href="http://www.latelee.org/golang/golang-notes-database-migrate-note.html"/>
    <id>http://www.latelee.org/golang/golang-notes-database-migrate-note.html</id>
    <published>2020-08-31T17:10:36.000Z</published>
    <updated>2020-12-03T03:00:04.876Z</updated>
    
    <content type="html"><![CDATA[<p>实现一个数据库迁移的案子。有些知识点值得记录。</p><a id="more"></a><h1 id="技术框架"><a href="#技术框架" class="headerlink" title="技术框架"></a>技术框架</h1><p>github.com/go-xorm/xorm：数据库操作<br>github.com/denisenkom/go-mssqldb：sqlserver驱动<br>github.com/go-sql-driver/mysql：mysql驱动</p><h1 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h1><p>使用 sql 语句查询原数据库数据，再插入新数据库。<br>查询新数据库表最后一条记录。<br>根据条件是否创建新数据表，再查询新数据库最后一条记录的 ID 值，以此为起点查询旧数据库，因为迁移只需要从已导入的最后一条开始即可，如果表不存在，则从 0 开始。<br>使用回调函数，获取旧数据库，处理数据（或舍弃，或修改，等），再插入到新数据库，直接用 xorm 的结构体即可。xorm 可批量插入，但是旧数据库无法做到批量获取，查询并存储到切片中，到达一定数量（如3000条），再插入新数据库。</p><h1 id="选择记录"><a href="#选择记录" class="headerlink" title="选择记录"></a>选择记录</h1><p>原数据库为 sqlserver，表和列部分有中文，不符合 xorm 要求。只能使用 sql 语句操作。<br>新数据库为 mysql，全英文，可用 xorm 结构体映射，查询、插入较方便。<br>试过将 xorm 的结构体成员变量改为中文，在 Golang 中使用中文作为变量名是可以的，只是反射不成功。  </p><h1 id="实践过程及知识点"><a href="#实践过程及知识点" class="headerlink" title="实践过程及知识点"></a>实践过程及知识点</h1><h2 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; mysql</span><br><span class="line">root:root@tcp(8.8.8.8:3305)&#x2F;mydb?charset&#x3D;utf8&amp;interpolateParams&#x3D;true&amp;parseTime&#x3D;true&amp;loc&#x3D;Local</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; mssql</span><br><span class="line">server&#x3D;8.8.8.8;user id&#x3D;latelee;password&#x3D;123456;database&#x3D;mydb;encrypt&#x3D;disable;</span><br></pre></td></tr></table></figure><p>注意，使用<code>github.com/denisenkom/go-mssqldb</code>时，需要添加<code>encrypt=disable;</code>，否则加不上。  </p><h2 id="xorm小知识"><a href="#xorm小知识" class="headerlink" title="xorm小知识"></a>xorm小知识</h2><p>设置时区：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">engine.DatabaseTZ &#x3D; time.UTC  &#x2F;&#x2F; time.Local</span><br><span class="line">engine.TZLocation &#x3D; time.UTC</span><br></pre></td></tr></table></figure><p>是否显示 sql 语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;engine.ShowSQL(true)</span><br><span class="line">engine.ShowSQL(false)</span><br></pre></td></tr></table></figure><h2 id="xorm结构体映射"><a href="#xorm结构体映射" class="headerlink" title="xorm结构体映射"></a>xorm结构体映射</h2><p>xorm 使用结构体与数据库字段映射，各种操作十分方便。<br>设置完全映射：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">engine.SetMapper(core.SameMapper&#123;&#125;)</span><br></pre></td></tr></table></figure><p>定义示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type TheData struct &#123;</span><br><span class="line">Id   int  &#96;xorm:&quot;int pk not null autoincr &#39;id&#39;&quot;&#96; &#x2F;&#x2F; autoincr</span><br><span class="line">Money sql.NullFloat64 &#96;xorm:&quot;float default null&quot;&#96;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一成员带 id，在数据库即为此名，第二成员不带，将映射为 Money。<br>结构体成员需大写，否则反射失败。  </p><h2 id="新数据库创建"><a href="#新数据库创建" class="headerlink" title="新数据库创建"></a>新数据库创建</h2><p>一般创建表使用其它的方法，但为了方便使用，直接在代码中创建。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var sqlstr string</span><br><span class="line">&#x2F;&#x2F;sqlstr &#x3D; &quot;show tables like &#39;xxx&#39;&quot;</span><br><span class="line">sqlstr &#x3D; fmt.Sprintf(&quot;show tables like &#39;%s&#39;&quot;, newTableName)</span><br><span class="line">_, err &#x3D; engine.SQL(sqlstr).Count()</span><br><span class="line">if err !&#x3D; nil &#123; &#x2F;&#x2F; 没有找到现成函数判断，用返回值</span><br><span class="line">    log.Printf(&quot;table %v exist\n&quot;, newTableName)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    log.Printf(&quot;create table for %v\n&quot;, newTableName)</span><br><span class="line"></span><br><span class="line">    err &#x3D; engine.Sync2(vnewtable)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        log.Println(&quot;create table failed: &quot;, err.Error(), &quot;will exit&quot;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码先判断是否存在数据表，不存在再调用<code>engine.Sync2</code>创建，该函数可同时创建多个数据表。不过似乎没有直接的 API 接口判断是否存在数据表，只好用 sql 语句查询，判断其返回值。  </p><h2 id="数据库为空值"><a href="#数据库为空值" class="headerlink" title="数据库为空值"></a>数据库为空值</h2><p>如果读取到数据库中的空值，会返回错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scan failed: sql: Scan error on column index 26, name &quot;测试空值&quot;: converting driver.Value type string (&quot;NULL&quot;) to a float32: invalid syntax</span><br></pre></td></tr></table></figure><p>此问题可用 sql 包提供的类型解决。如<code>sql.NullString</code>、<code>sql.NullFloat64</code>等。这些类型实际是结构体，包括了<code>Valid</code>成员，通过该值可判断。  </p><h2 id="代码重用"><a href="#代码重用" class="headerlink" title="代码重用"></a>代码重用</h2><p>由于迁移过程是完全一样的，只是数据库、表名、字段等不同。可以将共用部分抽象成函数，具体操作使用回调函数解决。<br>至于不同之处，则由调用者将其传递到共用函数中即可。  </p><h3 id="回调函数定义和使用"><a href="#回调函数定义和使用" class="headerlink" title="回调函数定义和使用"></a>回调函数定义和使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type DataCb func (rows *sql.Rows, engine *xorm.Engine, totalCnt int64) int</span><br><span class="line"></span><br><span class="line">func MigrateDB(olddb, oldtable, newdb string, vnewtable interface&#123;&#125;, datacb DataCb) &#123;</span><br><span class="line">...</span><br><span class="line">datacb(rows, engin, cnt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在回调函数中，根据旧数据库字段扫描，示例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for rows.Next() &#123;</span><br><span class="line">    err :&#x3D; rows.Scan(&amp;a, &amp;b, &amp;c, &amp;d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，Scan 参数个数和数据库的列数相同，否则出错。可直接用新数据库结构体成员，如果不需要，可以使用其它变量。  </p><h3 id="结构体映射"><a href="#结构体映射" class="headerlink" title="结构体映射"></a>结构体映射</h3><p>结构体用指针传递，这样可进行通用处理，即 MigrateDB 不再与具体结构体关联。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">   &#x2F;&#x2F; 获取新表结构体名称</span><br><span class="line">   atype :&#x3D; reflect.TypeOf(vnewtable)</span><br><span class="line">   if atype.Kind() &#x3D;&#x3D; reflect.Ptr &#123; &#x2F;&#x2F; 如果是结构体指针，再获取结构体</span><br><span class="line">trueatype &#x3D; atype.Elem()</span><br><span class="line">&#125;</span><br><span class="line">   &#x2F;&#x2F; 如果还不是结构体，出错</span><br><span class="line">if atype.Kind() !&#x3D; reflect.Struct &#123;</span><br><span class="line">truelog.Println(&quot;Check type error not Struct&quot;)</span><br><span class="line">truereturn</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">   newTableName :&#x3D; atype.Name()</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 取第N个字段及值</span><br><span class="line">   idx :&#x3D; 0</span><br><span class="line">   var newIDName string &#x3D; atype.Field(idx).Name&#x2F;&#x2F; 此处为ID值，如果获取不到tag，选择变量名</span><br><span class="line">   &#x2F;&#x2F; 查找单引号，得到tag</span><br><span class="line">   xormStr :&#x3D; atype.Field(idx).Tag.Get(&quot;xorm&quot;)</span><br><span class="line">   idx1 :&#x3D; strings.Index(xormStr, &quot;&#39;&quot;)</span><br><span class="line">   idx2 :&#x3D; strings.LastIndex(xormStr, &quot;&#39;&quot;)</span><br><span class="line">   </span><br><span class="line">   if idx1 !&#x3D; -1 &amp;&amp; idx2 !&#x3D; -1 &amp;&amp; idx1 &lt; idx2 &#123;</span><br><span class="line">       newIDName &#x3D; xormStr[idx1+1:idx2]</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   log.Println(&quot;debug new table: &quot;, newTableName, newIDName)</span><br></pre></td></tr></table></figure><p>功能有二：获取结构体名称，因为 sql 语句需要使用该名称。获取第 0 个字段名称，结合实际情况，数据库第 0 个字段为 ID，故设计上，将结构体第 0 个字段置为 ID。<br>注意，这里使用结构体指针形式传递，不需要额外声明结构体变量，代码较整洁。    </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;实现一个数据库迁移的案子。有些知识点值得记录。&lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：xorm使用记录</title>
    <link href="http://www.latelee.org/golang/golang-notes-xorm.html"/>
    <id>http://www.latelee.org/golang/golang-notes-xorm.html</id>
    <published>2020-08-31T17:00:00.000Z</published>
    <updated>2020-12-03T03:00:04.876Z</updated>
    
    <content type="html"><![CDATA[<p>xorm使用记录。主要针对 mysql，也会涉及其它的。  </p><a id="more"></a><h2 id="技术总结"><a href="#技术总结" class="headerlink" title="技术总结"></a>技术总结</h2><p>提供通用接口，适用于多种数据库，隐藏细节。但需要手动添加数据库驱动（Golang 本身亦如是）。<br>可以用 Sync2 创建数据表，多次创建只提示警告，不会出错。要自行判断，或者额外创建好表，后续不再创建。<br>需要预先创建数据库，否则即使 Sync2 成功，也不会有数据表。<br>引入 xorm 包，再使用 sql 驱动，但使用下划线，表示只引入不使用包内函数。<br>xorm 的结构体成员要大写。  </p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">go get github.com&#x2F;go-xorm&#x2F;xorm</span><br><span class="line">go get github.com&#x2F;go-xorm&#x2F;core</span><br><span class="line">go get github.com&#x2F;go-xorm&#x2F;cmd&#x2F;xorm</span><br><span class="line">&#x2F;&#x2F; 似乎还有一个xorm.io，待写</span><br><span class="line"></span><br><span class="line">驱动：</span><br><span class="line">go get github.com&#x2F;go-sql-driver&#x2F;mysql &#x2F;&#x2F; mysql</span><br><span class="line">go get github.com&#x2F;mattn&#x2F;go-sqlite3  &#x2F;&#x2F;SQLite</span><br><span class="line">go get github.com&#x2F;denisenkom&#x2F;go-mssqldb &#x2F;&#x2F; sqlserver</span><br><span class="line">go get github.com&#x2F;lunny&#x2F;godbc &#x2F;&#x2F; sqlserver</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="结构体与字段映射"><a href="#结构体与字段映射" class="headerlink" title="结构体与字段映射"></a>结构体与字段映射</h2><p>常用方式：<br>SnakeMapper: 默认方式，驼峰命名，如 <code>UserInfo -&gt; user_info</code>。<br>SameMapper: 相同。<code>UserInfo -&gt; UserInfo</code>。<br>GonicMapper：在SnakeMapper的基础上增加了特例，<code>ID -&gt; id</code>。<br>PrefixMapper：前缀。<br>SuffixMapper：后续。  </p><p>设置xorm的字段名称和数据库中的一样（包括表名、字段表）<br>engine.SetMapper(core.SameMapper{})</p><p>不建议做太复杂，选择一两种常用的即可。  </p><p>示例1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">结构体：</span><br><span class="line">type User struct &#123;</span><br><span class="line">   Id   int64  &#96;xorm:&quot;int(20) pk not null autoincr &#39;id&#39;&quot;&#96;</span><br><span class="line">   Email string &#96;xorm:&quot;varchar(255) default null&quot;&#96;</span><br><span class="line">   First_name string &#96;xorm:&quot;varchar(255) default null&quot;&#96;</span><br><span class="line">   Last_name string &#96;xorm:&quot;varchar(255) default null&quot;&#96;</span><br><span class="line">   Username string &#96;xorm:&quot;varchar(255) default null&quot;&#96;</span><br><span class="line">&#125;</span><br><span class="line">对应数据表：</span><br><span class="line">mysql&gt; desc user;</span><br><span class="line">+------------+--------------+------+-----+---------+----------------+</span><br><span class="line">| Field      | Type         | Null | Key | Default | Extra          |</span><br><span class="line">+------------+--------------+------+-----+---------+----------------+</span><br><span class="line">| id         | int(20)      | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| email      | varchar(255) | YES  |     | NULL    |                |</span><br><span class="line">| first_name | varchar(255) | YES  |     | NULL    |                |</span><br><span class="line">| last_name  | varchar(255) | YES  |     | NULL    |                |</span><br><span class="line">| username   | varchar(255) | YES  |     | NULL    |                |</span><br><span class="line">+------------+------------</span><br><span class="line">注：结构体名即为表名，表名为小写，字段按驼峰命名，变量加下划线，保留。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 自定义部分字段，即所有字段小写，无下划线</span><br><span class="line">type User2 struct &#123;</span><br><span class="line">   Id   int64  &#96;xorm:&quot;int(20) pk not null autoincr&quot;&#96;</span><br><span class="line">   Email string &#96;xorm:&quot;varchar(255) default null&quot;&#96;</span><br><span class="line">   First_name string &#96;xorm:&quot;varchar(255) default null &#39;firstname&#39;&quot;&#96;</span><br><span class="line">   Last_name string &#96;xorm:&quot;varchar(255) default null &#39;lastname&#39;&quot;&#96;</span><br><span class="line">   Username string &#96;xorm:&quot;varchar(255) default null &#39;username&#39;&quot;&#96;</span><br><span class="line">&#125;</span><br><span class="line">mysql&gt; desc user2;</span><br><span class="line">+-----------+--------------+------+-----+---------+----------------+</span><br><span class="line">| Field     | Type         | Null | Key | Default | Extra          |</span><br><span class="line">+-----------+--------------+------+-----+---------+----------------+</span><br><span class="line">| id        | int(20)      | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| email     | varchar(255) | YES  |     | NULL    |                |</span><br><span class="line">| firstname | varchar(255) | YES  |     | NULL    |                |</span><br><span class="line">| lastname  | varchar(255) | YES  |     | NULL    |                |</span><br><span class="line">| username  | varchar(255) | YES  |     | NULL    |                |</span><br><span class="line">+-----------+--------------+------+-----+---------+----------------+</span><br><span class="line">注：接上，但在变量中设置了字段名称，变量有下划线，但字段没有。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 保存完全一致</span><br><span class="line">type User3 struct &#123;</span><br><span class="line">   Id   int64  &#96;xorm:&quot;int(20) pk not null autoincr&quot;&#96;</span><br><span class="line">   Email string &#96;xorm:&quot;varchar(255) default null&quot;&#96;</span><br><span class="line">   First_name string &#96;xorm:&quot;varchar(255) default null&quot;&#96;</span><br><span class="line">   Last_name string &#96;xorm:&quot;varchar(255) default null&quot;&#96;</span><br><span class="line">   Username string &#96;xorm:&quot;varchar(255) default null&quot;&#96;</span><br><span class="line">&#125;</span><br><span class="line">代码：engine.SetMapper(core.SameMapper&#123;&#125;)</span><br><span class="line">mysql&gt; desc User3; </span><br><span class="line">+------------+--------------+------+-----+---------+----------------+</span><br><span class="line">| Field      | Type         | Null | Key | Default | Extra          |</span><br><span class="line">+------------+--------------+------+-----+---------+----------------+</span><br><span class="line">| Id         | int(20)      | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| Email      | varchar(255) | YES  |     | NULL    |                |</span><br><span class="line">| First_name | varchar(255) | YES  |     | NULL    |                |</span><br><span class="line">| Last_name  | varchar(255) | YES  |     | NULL    |                |</span><br><span class="line">| Username   | varchar(255) | YES  |     | NULL    |                |</span><br><span class="line">+------------+--------------+------+-----+---------+----------------+</span><br><span class="line"></span><br><span class="line">注：表名和字段名完全一致。  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="反向导出结构体"><a href="#反向导出结构体" class="headerlink" title="反向导出结构体"></a>反向导出结构体</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com&#x2F;go-xorm&#x2F;cmd&#x2F;xorm</span><br></pre></td></tr></table></figure><p>会自动安装到 Golang 的 bin 目录，在命令行直接输入 xorm 即可。    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xorm reverse mysql name:password@(ip:port)&#x2F;xxx?charset&#x3D;utf8 .&#x2F;templates&#x2F;goxorm&#x2F;</span><br><span class="line">windows 示例：</span><br><span class="line">xorm reverse mysql root:root@\(172.18.18.18:3305\)&#x2F;mydb?charset&#x3D;utf8 .&#x2F;templates&#x2F;goxorm&#x2F;</span><br><span class="line">注：templates是指$GOPATH&#x2F;src&#x2F;github.com&#x2F;go-xorm&#x2F;cmd&#x2F;xorm&#x2F;templates</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;userc&#96; (</span><br><span class="line"> &#96;信息id&#96; bigint(20) NOT NULL  AUTO_INCREMENT,</span><br><span class="line"> &#96;邮箱地址&#96; varchar(255) DEFAULT NULL,</span><br><span class="line"> &#96;名&#96; varchar(255) DEFAULT NULL,</span><br><span class="line"> &#96;姓&#96; varchar(255) DEFAULT NULL,</span><br><span class="line"> &#96;姓名&#96; varchar(255) DEFAULT NULL,</span><br><span class="line"> PRIMARY KEY (&#96;信息id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line"></span><br><span class="line">转换后：</span><br><span class="line">type Userc struct &#123;</span><br><span class="line">true信息id int64  &#96;xorm:&quot;not null pk autoincr BIGINT(20)&quot;&#96;</span><br><span class="line">true邮箱地址 string &#96;xorm:&quot;VARCHAR(255)&quot;&#96;</span><br><span class="line">true名    string &#96;xorm:&quot;VARCHAR(255)&quot;&#96;</span><br><span class="line">true姓    string &#96;xorm:&quot;VARCHAR(255)&quot;&#96;</span><br><span class="line">true姓名   string &#96;xorm:&quot;VARCHAR(255)&quot;&#96;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="数据库的中文"><a href="#数据库的中文" class="headerlink" title="数据库的中文"></a>数据库的中文</h2><p>测试中文</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type 学生信息表 struct &#123;</span><br><span class="line">true信息id int64  &#96;xorm:&quot;not null pk autoincr BIGINT(20)&quot;&#96;</span><br><span class="line">true邮箱地址 string &#96;xorm:&quot;VARCHAR(255)&quot;&#96;</span><br><span class="line">true名    string &#96;xorm:&quot;VARCHAR(255)&quot;&#96;</span><br><span class="line">true姓    string &#96;xorm:&quot;VARCHAR(255)&quot;&#96;</span><br><span class="line">true姓名   string &#96;xorm:&quot;VARCHAR(255)&quot;&#96;</span><br><span class="line">&#125;</span><br><span class="line">engine.SetMapper(core.SameMapper&#123;&#125;)</span><br><span class="line">engine.Sync2(new(学生信息表))</span><br></pre></td></tr></table></figure><p>结论：可以使用中文变量，但查询数据，会出错，故还是按英文进行</p><h2 id="所遇问题"><a href="#所遇问题" class="headerlink" title="所遇问题"></a>所遇问题</h2><p>，如果有小写，会提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: reflect.Value.Interface: cannot return value obtained from unexported field or method</span><br></pre></td></tr></table></figure><p>可以用单引号指定特定名称。</p><p>遇到空值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scan failed: sql: Scan error on column index 26, name &quot;姓名&quot;: converting driver.Value type string (&quot;NULL&quot;) to a float32: invalid syntax</span><br></pre></td></tr></table></figure><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">engine, err :&#x3D; xorm.NewEngine(driverName, dataSourceName)</span><br></pre></td></tr></table></figure><h3 id="sql语句"><a href="#sql语句" class="headerlink" title="sql语句"></a>sql语句</h3><p>支持sql语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">直接查，返回[]map[string][]byte类型的切片</span><br><span class="line">results, err :&#x3D; engine.Query(&quot;select * from user&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 适用增改查</span><br><span class="line">affected, err :&#x3D; engine.Exec(&quot;update user set .... where ...&quot;)</span><br><span class="line"></span><br><span class="line">engine.Sql(&quot;select * from user&quot;).Find()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注：方便根据自定义的语句获取结果</p><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">affected, err :&#x3D; engine.Insert(&amp;struct)</span><br><span class="line">&#x2F;&#x2F; INSERT INTO struct () values ()</span><br><span class="line">affected, err :&#x3D; engine.Insert(&amp;struct1, &amp;struct2)</span><br><span class="line">&#x2F;&#x2F; INSERT INTO struct1 () values ()</span><br><span class="line">&#x2F;&#x2F; INSERT INTO struct2 () values ()</span><br><span class="line">affected, err :&#x3D; engine.Insert(&amp;sliceOfStruct)</span><br><span class="line">&#x2F;&#x2F; INSERT INTO struct () values (),(),()</span><br><span class="line">affected, err :&#x3D; engine.Insert(&amp;struct1, &amp;sliceOfStruct2)</span><br><span class="line">&#x2F;&#x2F; INSERT INTO struct1 () values ()</span><br><span class="line">&#x2F;&#x2F; INSERT INTO struct2 () values (),(),()</span><br></pre></td></tr></table></figure><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">affected, err :&#x3D; engine.Where(...).Delete(&amp;user)</span><br><span class="line">&#x2F;&#x2F; DELETE FROM user Where ...</span><br></pre></td></tr></table></figure><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">affected, err :&#x3D; engine.Update(&amp;user)</span><br><span class="line">&#x2F;&#x2F; UPDATE user SET ...</span><br></pre></td></tr></table></figure><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">查数量</span><br><span class="line">counts, err :&#x3D; engine.Count(&amp;user)</span><br><span class="line">&#x2F;&#x2F; SELECT count(*) AS total FROM user</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查询一条记录，返回结构体</span><br><span class="line">has, err :&#x3D; engine.Get(&amp;user)</span><br><span class="line">&#x2F;&#x2F; SELECT * FROM user LIMIT 1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查询多条记录</span><br><span class="line">sliceOfStructs :&#x3D; new(Struct)</span><br><span class="line">err :&#x3D; engine.Find(sliceOfStructs)</span><br><span class="line">&#x2F;&#x2F; SELECT * FROM user</span><br><span class="line"></span><br><span class="line">err :&#x3D; engine.Iterate(...)</span><br><span class="line">&#x2F;&#x2F; SELECT * FROM user</span><br><span class="line"></span><br><span class="line">rows, err :&#x3D; engine.Rows(...)</span><br><span class="line">&#x2F;&#x2F; SELECT * FROM user</span><br><span class="line">bean :&#x3D; new(Struct)</span><br><span class="line">for rows.Next() &#123;</span><br><span class="line">    err &#x3D; rows.Scan(bean)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有条件的数据库操作"><a href="#有条件的数据库操作" class="headerlink" title="有条件的数据库操作"></a>有条件的数据库操作</h2><h3 id="Id-In"><a href="#Id-In" class="headerlink" title="Id In"></a>Id In</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">engine.Id(1).Get(&amp;user) &#x2F;&#x2F; for single primary key</span><br><span class="line">&#x2F;&#x2F; SELECT * FROM user WHERE id &#x3D; 1</span><br><span class="line">engine.Id(core.PK&#123;1, 2&#125;).Get(&amp;user) &#x2F;&#x2F; for composite primary keys</span><br><span class="line">&#x2F;&#x2F; SELECT * FROM user WHERE id1 &#x3D; 1 AND id2 &#x3D; 2</span><br><span class="line">engine.In(&quot;id&quot;, 1, 2, 3).Find(&amp;users)</span><br><span class="line">&#x2F;&#x2F; SELECT * FROM user WHERE id IN (1, 2, 3)</span><br><span class="line">engine.In(&quot;id&quot;, []int&#123;1, 2, 3&#125;)</span><br><span class="line">&#x2F;&#x2F; SELECT * FROM user WHERE id IN (1, 2, 3)</span><br></pre></td></tr></table></figure><h3 id="Where-And-Or"><a href="#Where-And-Or" class="headerlink" title="Where And Or"></a>Where And Or</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">engine.Where().And().Or().Find()</span><br><span class="line">&#x2F;&#x2F; SELECT * FROM user WHERE (.. AND ..) OR ...</span><br></pre></td></tr></table></figure><h3 id="OrderBy-Asc-Desc"><a href="#OrderBy-Asc-Desc" class="headerlink" title="OrderBy Asc Desc"></a>OrderBy Asc Desc</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">engine.Asc().Desc().Find()</span><br><span class="line">&#x2F;&#x2F; SELECT * FROM user ORDER BY .. ASC, .. DESC</span><br><span class="line">engine.OrderBy().Find()</span><br><span class="line">&#x2F;&#x2F; SELECT * FROM user ORDER BY ..</span><br></pre></td></tr></table></figure><h3 id="Limit-Top"><a href="#Limit-Top" class="headerlink" title="Limit Top"></a>Limit Top</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">engine.Limit().Find()</span><br><span class="line">&#x2F;&#x2F; SELECT * FROM user LIMIT .. OFFSET ..</span><br><span class="line">engine.Top(5).Find()</span><br><span class="line">&#x2F;&#x2F; SELECT TOP 5 * FROM user &#x2F;&#x2F; for mssql</span><br><span class="line">&#x2F;&#x2F; SELECT * FROM user LIMIT .. OFFSET 0 &#x2F;&#x2F;for other databases</span><br></pre></td></tr></table></figure><h3 id="Cols-Omit-Distinct"><a href="#Cols-Omit-Distinct" class="headerlink" title="Cols Omit Distinct"></a>Cols Omit Distinct</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">engine.Cols(&quot;col1, col2&quot;).Find()</span><br><span class="line">&#x2F;&#x2F; SELECT col1, col2 FROM user</span><br><span class="line">engine.Cols(&quot;col1&quot;, &quot;col2&quot;).Where().Update(user)</span><br><span class="line">&#x2F;&#x2F; UPDATE user set col1 &#x3D; ?, col2 &#x3D; ? Where ...</span><br><span class="line">engine.Omit(&quot;col1&quot;).Find()</span><br><span class="line">&#x2F;&#x2F; SELECT col2, col3 FROM user</span><br><span class="line">engine.Omit(&quot;col1&quot;).Insert()</span><br><span class="line">&#x2F;&#x2F; INSERT INTO table (non-col1) VALUES ()</span><br><span class="line">engine.Distinct(&quot;col1&quot;).Find()</span><br><span class="line">&#x2F;&#x2F; SELECT DISTINCT col1 FROM user</span><br></pre></td></tr></table></figure><h3 id="Join-GroupBy-Having"><a href="#Join-GroupBy-Having" class="headerlink" title="Join GroupBy Having"></a>Join GroupBy Having</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">engine.GroupBy(&quot;name&quot;).Having(&quot;name&#x3D;&#39;xlw&#39;&quot;).Find()</span><br><span class="line">&#x2F;&#x2F;SELECT * FROM user GROUP BY name HAVING name&#x3D;&#39;xlw&#39;</span><br><span class="line">engine.Join(&quot;LEFT&quot;, &quot;userdetail&quot;, &quot;user.id&#x3D;userdetail.id&quot;).Find()</span><br><span class="line">&#x2F;&#x2F;SELECT * FROM user LEFT JOIN userdetail ON user.id&#x3D;userdetail.id</span><br></pre></td></tr></table></figure><h2 id="综合应用"><a href="#综合应用" class="headerlink" title="综合应用"></a>综合应用</h2><p>本小节以一些应用场合为例，记录sql函数及xorm函数的示例。<br>为方便使用2种方式，可实现2种接口。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sqlstr :&#x3D; fmt.Sprintf(&quot;show tables like &#39;%s&#39;&quot;, newTableName)</span><br><span class="line">cnt, err :&#x3D; engine.SQL(sqlstr).Count()</span><br><span class="line"></span><br><span class="line">sqlstr :&#x3D; fmt.Sprintf(&quot;select count(*) from %s where %s &gt; %d&quot;, tableName, idName, startID)</span><br><span class="line">err :&#x3D; sqldb.QueryRow(sqlstr).Scan(&amp;totalCnt)</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h1 id="附"><a href="#附" class="headerlink" title="附"></a>附</h1><p>参考：<br><a href="https://www.cnblogs.com/guhao123/p/4159688.html">https://www.cnblogs.com/guhao123/p/4159688.html</a>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;xorm使用记录。主要针对 mysql，也会涉及其它的。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：简单的代码片段</title>
    <link href="http://www.latelee.org/golang/golang-code-slice.html"/>
    <id>http://www.latelee.org/golang/golang-code-slice.html</id>
    <published>2020-08-29T15:03:36.000Z</published>
    <updated>2020-12-03T03:00:04.876Z</updated>
    
    <content type="html"><![CDATA[<p>本文列出简单的代码片段及基础知识。  </p><a id="more"></a><h2 id="简单说明"><a href="#简单说明" class="headerlink" title="简单说明"></a>简单说明</h2><ul><li><p>包<br>import的包从src算，如果在子目录，一定要添加子目录路径。如import “a”，则a一定在src目录下。<br>同一个目录只能有一个包名。但可以有多个文件（使用同一包名）。<br>没有被使用的包，要删除或注释，否则编译不通过。<br>包目录不能与系统包名相同，如系统有sync包，不能再创建sync目录。<br>除for等外，逗号不是必须的，看个人习惯。<br>没有使用的变量，编译不通过。 </p></li><li><p>测试<br>文件名带<code>_test</code>的是测试专用，不能用<code>go run</code>来执行。  </p></li></ul><h2 id="编码小结"><a href="#编码小结" class="headerlink" title="编码小结"></a>编码小结</h2><p>右大括号<code>&#123;</code>在行尾，如在新一行，编译不通过。<br>一般使用小写+大写方式。<br>函数：大写 导出，小写 包内（跨文件）可见。<br>变量：大写导出，小写包内可见。专用名称，可大写或小写。<br>接口、结构体：大写（一说小+大）。<br>文件名、包名：小写。  </p><p>可带可不带分号，习惯性带分号(;)亦可。<br>大括号在行尾、if/for/没有小括号，但必须添加大括号。<br>如果引入的包不使用，又不想删除（后面可能会用到），可以注释掉，也可以调用这些包的函数，放到函数中，但不调用这个函数。<br>格式要求严格，如a为uint16， b为<code>[]byte</code>，<code>a = b[0]</code>出错，需要转换<code>a = uint16(b[0])</code>。另外，<code>a = -1</code>也出错，因为是无符号的。  </p><p>打印：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printfln(&quot;Hello world&quot;);</span><br><span class="line">fmt.Printf(&quot;Hello %v\n&quot;, &quot;world&quot;);</span><br></pre></td></tr></table></figure><p>代码片段(用以切换语言时看)：  </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">有传入、输出参数</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrt</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    ret := <span class="number">1.0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        ret = ret - (ret*ret - x) / <span class="number">2</span> / ret</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;类&quot;</span></span><br><span class="line"><span class="keyword">package</span> class</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">true<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空结构体</span></span><br><span class="line"><span class="keyword">type</span> SimpleClass <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// nothing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;类&quot;的形式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *SimpleClass)</span> <span class="title">printf</span><span class="params">()</span></span> &#123;</span><br><span class="line">truefmt.Printf(<span class="string">&quot;%v\n&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大写，包外可见</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SimpleTest</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    c := SimpleClass&#123;&#125;;</span><br><span class="line">    c.printf();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">主函数文件：</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;class&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    class.SimpleTest();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> bit0 == <span class="number">0</span> &#123; <span class="comment">// 注释</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;I&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> bit0 == <span class="number">1</span> &amp;&amp; bit1 == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;S&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> bit0 == <span class="number">1</span> &amp;&amp; bit1 == <span class="number">1</span> &#123; <span class="comment">// 注释</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;U&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 其它</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">打印变量类型：</span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">fmt.Println(reflect.TypeOf(<span class="keyword">var</span>)) </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>组装字符串示例： </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要点：补齐字段的用法</span></span><br><span class="line"><span class="comment">// 年月日时分秒</span></span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%.4v%.2v%.2v%.2v%.2v%.2v&quot;</span>, </span><br><span class="line">                   year, month, day, </span><br><span class="line">                   hour, minute, seconds);</span><br></pre></td></tr></table></figure><p>同一程序代码，生成不同文件执行不同函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">    &quot;path&#x2F;filepath&quot;</span><br><span class="line">    &quot;strings&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    filename :&#x3D; filepath.Base(os.Args[0])</span><br><span class="line">    if strings.Contains(filename, &quot;send&quot;) &#123;</span><br><span class="line">        send()</span><br><span class="line">    &#125; else if strings.Contains(filename, &quot;recv&quot;) &#123;</span><br><span class="line">        recv()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fmt.Println(&quot;do nothing&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、小实验"><a href="#八、小实验" class="headerlink" title="八、小实验"></a>八、小实验</h2><p>自实现模块A，存入github.com，A使用到第三方库，<code>go get</code>获取A会自动检测第三方库，如无则自动下载。  </p><h2 id="九、常见错误"><a href="#九、常见错误" class="headerlink" title="九、常见错误"></a>九、常见错误</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.go:8:5: found packages a (a.go) and main (a1.go) in e:\project\golang\src\hello\a</span><br></pre></td></tr></table></figure><p>原因：同一个目录下，有2个包名。<br>解决：只保留一个包名，如必须有2个，则移到另一目录。  </p><p>PS：工作中切换语言时，先看几眼本文件，以便于思维的切换。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文列出简单的代码片段及基础知识。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：测试框架</title>
    <link href="http://www.latelee.org/golang/golang-testing.html"/>
    <id>http://www.latelee.org/golang/golang-testing.html</id>
    <published>2020-08-26T17:05:36.000Z</published>
    <updated>2020-12-03T03:00:04.876Z</updated>
    
    <content type="html"><![CDATA[<p>这篇集中记录一下测试相关的内容。  </p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>创建工程库代码，方便重用。重用方式可使用函数，也可直接引用文件。<br>完成函数，可在 main 函数中调用进行测试。也可以使用 test 框架进行。<br>在大型项目中，可以用 test 进行测试更方便，即不影响业务代码，也保留测试代码。  </p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>测试文件形式为 <code>&lt;文件名&gt;_test.go</code>，源码文件不能以<code>_test.go</code>结尾。<br>引用<code>testing</code>包。有<code>t.Logf</code>等函数。<br>测试用例使用<code>TestFoo</code>、<code>TestBar</code>的形式。<br>同一个目录，可以有多个测试文件，同一测试文件，可以有多个测试用例。但注意，不能出现同名函数。<br>测试文件与实际源码文件名称，可同可不同。  </p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>简单使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test</span><br></pre></td></tr></table></figure><p>结果以 PASS 或 FAIL 等表示。<br>输出详细日志：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test -v</span><br></pre></td></tr></table></figure><p>上述命令会运行该目录下<strong>所有测试文件的所有测试用例</strong>。  </p><p>为方便、简单测试，可指定测试文件和测试用例。如：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test -v -run TestSleep  </span><br></pre></td></tr></table></figure><p>（注：当测试文件包含其它包时，指定测试文件，似乎不成功）  </p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Golang 提供的测试框架，可以方便地对封装的工具函数进行测试。<br>对于实现简单功能的模块而言，可以使用测试框架，也可以编译为二进制，后者在使用上较方便。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇集中记录一下测试相关的内容。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：工程管理</title>
    <link href="http://www.latelee.org/golang/golang-project-manage.html"/>
    <id>http://www.latelee.org/golang/golang-project-manage.html</id>
    <published>2020-08-20T12:04:36.000Z</published>
    <updated>2020-12-03T03:00:04.876Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍Golang的工程管理。  </p><a id="more"></a><h2 id="工程概述"><a href="#工程概述" class="headerlink" title="工程概述"></a>工程概述</h2><p>GOPATH目录下创建三个目录：  </p><ul><li>src 存放源代码，每个工程一个单独的目录</li><li>pkg 编译过后生成的包文件存放目录，根据平台有不同目录，里面有许多.a库，暂未研究。  </li><li>bin 编译后生产的可执行文件和go相关的工具</li></ul><h2 id="工程管理"><a href="#工程管理" class="headerlink" title="工程管理"></a>工程管理</h2><p>golang 查找依赖包路径：<br>当前目录下的vendor目录。<br>向上级目录查找，直到找到src下的vendor目录。<br>在 GOPATH 下面查找依赖包。<br>在 GOROOT 目录下查找。  </p><p>依赖包有几大各类：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">github.com：位于 github.com 上的仓库。  </span><br><span class="line">golang.org：golang官方包</span><br><span class="line">gopkg.in：</span><br><span class="line">google.golang.org：</span><br><span class="line">k8s.io：k8s相关的</span><br></pre></td></tr></table></figure><p>(理论上可创建自定义的名称，不一定要存在，但无法用 go get 获取。)</p><h2 id="笔记三"><a href="#笔记三" class="headerlink" title="笔记三"></a>笔记三</h2><p>根据实际情况和路径，在 src 先创建目录。可不按 github.com 之类。说明：<br>许多开源项目托管于 github.com 上，且依赖其它同样托管在 github 的项目。因此要在 src 下创建 github.com 目录，如 kubeedge 项目，其路径为：github.com\kubeedge\kubeedge 。cobra 项目路径 为 github.com\spf13\cobra，等等。<br>k8s 项目使用的路径为 k8s.io/kubernetes 。这些路径，一般规定好，写到官方文档。<br>内部项目，可自定义路径目录，只要与源码保持一致即可。<br>项目依赖的包，放到项目的 vendor 中，随项目托管。  </p><h3 id="笔记二"><a href="#笔记二" class="headerlink" title="笔记二"></a>笔记二</h3><p>针对第三方依赖包的讨论：<br>对于小工具或测试模块，不同模块，可能使用同一依赖包，故将依赖包下载到 src 目录，以便共用。事实上，依赖包大目录基本为上述几个，大目录不会杂乱。<br>对于大工程和项目，可将依赖包纳入版本管理，也可不纳入。前者仓库体积可能变大，但方便使用，无须再下载依赖包。后者仓库体积小，但需要使用者额外下载，有可能无法成功下载依赖包。此为矛盾之处。二者均可，取决于团队决策。个人偏向将依赖包进行版本管理，虽然体积大，但“开箱即用”，减少后来者工作。 </p><h3 id="笔记一"><a href="#笔记一" class="headerlink" title="笔记一"></a>笔记一</h3><p>不同的包，单独成目录，放到src目录。将GOPATH放到大的版本管理。如本地测试文件，可不提交管理。<br>对于可公开的库，直接提交到的github.com上，在单独目录做测试（可直接运行的）。<br>在src新建foo目录，foo有main.go，另有vendor子目录，vendor有uitls目录，即为utils包，实现模块。在main.go中引用utils包即可。  </p><p>我的golang工程：为方便编写代码，而不显得目录混乱，又能与其它工程区别开。新建 go_test 项目目录，其下有vendor子目录，vendor 即为该项目所依赖的<strong>自编模块</strong>（注：外部依赖不在此列），其下可有各个模块，如utils目录，即为utils包，目录下文件名可不同，实现函数不同，但均属于 utils 包。同时，vendor有mybuff、mylog等包（目录）。由于部分功能可能与第三方库相同，可添加my为前缀，以示区别。  </p><p>该目录放到任意目录均可。这样，go_test 工程可单独使用，同理，还有其它工程。    </p><p>再注：<br>公司项目根目录只能位于GOPATH，其下bin/pkg/src目录，还有readme和其它配置文件。src有自编模块（目录），也有github.com golang.org gopkg.in（但这些放到.gitignore忽略了）。为与公司兼容，将自己的测试工程放到src下的vendor中，再将vendor忽略。  </p><h2 id="工程目录概述"><a href="#工程目录概述" class="headerlink" title="工程目录概述"></a>工程目录概述</h2><p>参考<a href="https://github.com/golang-standards/project-layout">这里</a> 的说明。  </p><h2 id="go-mod-使用"><a href="#go-mod-使用" class="headerlink" title="go mod 使用"></a>go mod 使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">go mod init  &#x2F;&#x2F; 创建go.mod文件</span><br><span class="line"></span><br><span class="line">后可用go build直接编译，如果不存在的包，会自动下载（测试了github.com等地址），下载地址为GOPATH&#x2F;pkg。</span><br><span class="line">如何下载到本工程的vendor下？</span><br><span class="line">矛盾之处：工程本身在github.com下开发，未提交版本，但go guild时会查找，找不到，报错。</span><br><span class="line"></span><br><span class="line">go mod download</span><br><span class="line">下载依赖，默认pkg目录（可共用）</span><br><span class="line"></span><br><span class="line">go mod tidy</span><br><span class="line">同步依赖包，添加需要的，移除多余的</span><br><span class="line"></span><br><span class="line">go mod vendor</span><br><span class="line">将依赖包拷贝到vendor目录</span><br><span class="line"></span><br><span class="line">go get 下载&#x2F;升级依赖</span><br><span class="line"></span><br><span class="line">.mod所在目录：</span><br><span class="line">go build -mod vendor main.go </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">go env -w GO111MODULE&#x3D;off  auto on</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="govendor使用"><a href="#govendor使用" class="headerlink" title="govendor使用"></a>govendor使用</h2><p>使用<code>go get</code>下载的第三方包，会下载到src目录下。  </p><p>下载govendor并安装：<code>go get -u -v github.com/kardianos/govendor</code>。<br>下载包到vendor目录：<code>govendor fetch github.com/golang/glog</code>。(注：自动下载该包相关的依赖包）<br>添加包到vendor目录：<code>govendor add github.com/golang/glog</code>。<br>删除包：<code>govendor remove github.com/golang/glog</code><br>其它命令：  </p><h2 id="gopm使用"><a href="#gopm使用" class="headerlink" title="gopm使用"></a>gopm使用</h2><p>查看工程依赖包工具。  </p><p>下载安装：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -v -u github.com&#x2F;gpmgo&#x2F;gopm</span><br></pre></td></tr></table></figure><p>用法：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前工程依赖</span><br><span class="line">gopm list</span><br><span class="line"># 显示依赖详细信息</span><br><span class="line">gopm list -v</span><br><span class="line"># 列出文件依赖</span><br><span class="line">gopm list -t [file]</span><br><span class="line"># 拉取依赖到缓存目录</span><br><span class="line">gopm get -r xxx</span><br><span class="line"># 仅下载当前指定的包</span><br><span class="line">gopm get -d xxx</span><br><span class="line"># 拉取依赖到$GOPATH</span><br><span class="line">gopm get -g xxx</span><br><span class="line"># 检查更新所有包</span><br><span class="line">gopm get -u xxx</span><br><span class="line"># 拉取到当前所在目录</span><br><span class="line">gopm get -l xxx</span><br><span class="line"># 运行当前目录程序</span><br><span class="line">gopm run</span><br><span class="line"># 生成当前工程的 gopmfile 文件用于包管理</span><br><span class="line">gopm gen -v</span><br><span class="line"># 根据当前项目 gopmfile 链接依赖并执行 go install</span><br><span class="line">gopm install -v</span><br><span class="line"># 更新当前依赖</span><br><span class="line">gopm update -v</span><br><span class="line"># 清理临时文件</span><br><span class="line">gopm clean</span><br><span class="line"># 编译到当前目录</span><br><span class="line">gopm bin</span><br><span class="line"></span><br><span class="line">3. 通过gopm 来安装gin框架</span><br><span class="line"></span><br><span class="line">gopm get -g -v  github.com&#x2F;gin-gonic&#x2F;gin</span><br><span class="line"></span><br><span class="line">4. 安装govendor管理包工具</span><br><span class="line"></span><br><span class="line"> gopm get -g -v github.com&#x2F;kardianos&#x2F;govendor</span><br><span class="line"></span><br><span class="line">5. 通过 govendor 来管理代码包</span><br><span class="line"></span><br><span class="line">6. go run main.go文件，可能会出现缺少golang.org&#x2F;x，提示报错</span><br><span class="line"></span><br><span class="line">&#x2F;root&#x2F;gowork&#x2F;src&#x2F;attendance_project&#x2F;vendor&#x2F;golang.org&#x2F;x&#x2F;sys&#x2F;unix (vendor tree)</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;src&#x2F;go&#x2F;src&#x2F;golang.org&#x2F;x&#x2F;sys&#x2F;unix (from $GOROOT)</span><br><span class="line">&#x2F;root&#x2F;gowork&#x2F;src&#x2F;golang.org&#x2F;x&#x2F;sys&#x2F;unix (from $GOPATH),</span><br><span class="line"></span><br><span class="line">通过 gopm -g golang.org&#x2F;x&#x2F;sys (sys只是其中的一个模块，例如：text,sys等，具体根据提示来安装即可)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="swagger"><a href="#swagger" class="headerlink" title="swagger"></a>swagger</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com&#x2F;swaggo&#x2F;swag&#x2F;cmd&#x2F;swag</span><br><span class="line">(所遇问题：golang.org\x目录的tools和net的git版本有点旧，会自动更新，但连接不上，解决：先删除，从Github.com上下载)</span><br><span class="line"></span><br><span class="line">go get -u github.com&#x2F;swaggo&#x2F;gin-swagger</span><br><span class="line">go get -u github.com&#x2F;swaggo&#x2F;gin-swagger&#x2F;swaggerFiles</span><br><span class="line">go get -u github.com&#x2F;alecthomas&#x2F;template  &#x2F;&#x2F; 文档需要</span><br></pre></td></tr></table></figure><h2 id="格式检查vet"><a href="#格式检查vet" class="headerlink" title="格式检查vet"></a>格式检查vet</h2><p>在VS code中打开go文件，右下角提示goreturns要安装（具体提示未记录），点击安装。<br>当保存go文件时会自动检测语法，并提示。  </p><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><p>1、<a href="https://blog.csdn.net/Nassue_sn/article/details/86718199">Go项目结构推荐</a>。  </p><p>李迟 2020 上半年 起稿并修改 2020.08.20 周四 修改</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍Golang的工程管理。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：开篇</title>
    <link href="http://www.latelee.org/golang/golang-start.html"/>
    <id>http://www.latelee.org/golang/golang-start.html</id>
    <published>2020-08-19T12:03:36.000Z</published>
    <updated>2020-12-03T03:00:04.876Z</updated>
    
    <content type="html"><![CDATA[<p>自去年开始，因工作的关系，需要使用 Golang 进行开发。一来是工作，二来多了解一个新语言，总归是有好处。现在虽然不是主攻 Golang，但可能用来写一些小工具。    </p><a id="more"></a><p>本系列不会系统介绍Golang，只是根据笔者接触的某个点进行记录，可以认为是一个笔记集。  </p><h2 id="一、我对Golang的认识"><a href="#一、我对Golang的认识" class="headerlink" title="一、我对Golang的认识"></a>一、我对Golang的认识</h2><p>Go生态好，模块多，当然，如NodeJS、Python亦多，但不同语言侧重点不同。如Java侧重后台开发，C偏重底层，Pyhthon则是数据分析，爬虫，Go在虚拟化运维方面，但是没有定法，使用哪种语言没有限制，只有方便不方便，快速不快速。  </p><p>有部分包无法下载，需要使用花费一定时间解决。可以使用国内镜像源，使用github下载，等等。  </p><p>虽然 Go 跨平台，但有些特性与系统相关，因为最好使用多个系统测试。如果明确只使用某系统，则无须如此。  </p><p>笔者在Windows上安装，也在Ubuntu安装（使用vagrant)，为了方便管理，两套系统均使用同一目录作为工程目录。  </p><h2 id="二、Golang-安装"><a href="#二、Golang-安装" class="headerlink" title="二、Golang 安装"></a>二、Golang 安装</h2><h3 id="Golang在Windows系统的安装"><a href="#Golang在Windows系统的安装" class="headerlink" title="Golang在Windows系统的安装"></a>Golang在Windows系统的安装</h3><p>下载：<a href="https://studygolang.com/dl">https://studygolang.com/dl</a>，版本为1.13.4。包名为<code>go1.13.4.windows-amd64.zip</code>。解压到D盘（或其它盘）。</p><p>设置几个环境变量：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GOBIN D:\go\bin</span><br><span class="line">GOROOT D:\go</span><br><span class="line">PATH：%GOBIN%</span><br><span class="line">GOPATH：E:\project\golang</span><br></pre></td></tr></table></figure><p>GOPATH即为工程目录。</p><h3 id="Golang在Linux系统的安装"><a href="#Golang在Linux系统的安装" class="headerlink" title="Golang在Linux系统的安装"></a>Golang在Linux系统的安装</h3><p>直接在命令行下载、解压：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;dl.google.com&#x2F;go&#x2F;go1.13.4.linux-amd64.tar.gz</span><br><span class="line">tar zxf go1.13.4.linux-amd64.tar.gz -C &#x2F;usr&#x2F;local&#x2F;</span><br></pre></td></tr></table></figure><p>修改~/.bashrc，添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export GOROOT&#x3D;&#x2F;usr&#x2F;local&#x2F;go</span><br><span class="line">export GOBIN&#x3D;$GOROOT&#x2F;bin</span><br><span class="line">export PATH&#x3D;$PATH:$GOBIN</span><br><span class="line">export GOPATH&#x3D;&#x2F;vagrant&#x2F;golang</span><br><span class="line">export GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.cn</span><br></pre></td></tr></table></figure><p>注1：在Windows，使用Vagrant启动虚拟机，其工程目录实际为E:\project\，故GOPATH的/vagrant/golang目录，与E:\project\golang实际为同一目录，此情况下，同一套代码在两个系统可同时使用。<br>注2：设置了 GOBIN，当使用 go get 安装包时，会安装到此目录，否则会安装到 GOPATH 的 bin 目录。<br>注3：有些项目，会依赖于 golang 版本，一般会有文档说明。  </p><h2 id="三、环境问题"><a href="#三、环境问题" class="headerlink" title="三、环境问题"></a>三、环境问题</h2><h3 id="golang-org包"><a href="#golang-org包" class="headerlink" title="golang.org包"></a>golang.org包</h3><p>因为众所周知的原因，有部分包无法正常访问。需要额外花工夫解决出现的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot find package &quot;golang.org&#x2F;x&#x2F;sys&#x2F;unix&quot; in any of:</span><br></pre></td></tr></table></figure><p>原因：golang.org无法访问<br>解决：github有镜像，可下载，重命名。在$GOPATH)/src目录下执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p  golang.org&#x2F;x</span><br><span class="line">cd golang.org&#x2F;x&#x2F;</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;sys</span><br><span class="line">其它类似的有：</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;crypto</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;text</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot find package &quot;github.com&#x2F;go-playground&#x2F;validator&#x2F;v10&quot;</span><br></pre></td></tr></table></figure><p>go版本太低（1.6），升级为1.13解决。(注：v10的确不存在，但代码的确引用该包)  </p><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>1.13 及以上使用：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env -w GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.cn,direct</span><br></pre></td></tr></table></figure><p>也可以设置环境变量：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;export GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.cn&quot; &gt;&gt; ~&#x2F;.bashrc &amp;&amp; source ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure><p>默认代理：<code>GOPROXY=&quot;https://proxy.golang.org,direct&quot;</code>。  </p><p>参考： <a href="https://github.com/goproxy/goproxy.cn/blob/master/README.zh-CN.md">https://github.com/goproxy/goproxy.cn/blob/master/README.zh-CN.md</a> 。</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>GOROOT 和 GOPATH 不能相同，否则会提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$GOPATH must not be set to $GOROOT. For more details see: &#39;go help gopath&#39;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go env  # 查看go的环境变量</span><br><span class="line">go env -w GO111MODULE&#x3D;off  # 设置环境变量</span><br></pre></td></tr></table></figure><h2 id="四、工程概述"><a href="#四、工程概述" class="headerlink" title="四、工程概述"></a>四、工程概述</h2><p>GOPATH目录下创建三个目录：  </p><ul><li>src 存放源代码，每个工程一个单独的目录</li><li>pkg 编译过后生成的包文件存放目录</li><li>bin 编译后生产的可执行文件和go相关的工具</li></ul><h2 id="五、go简单使用"><a href="#五、go简单使用" class="headerlink" title="五、go简单使用"></a>五、go简单使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">go build</span><br><span class="line">go build foo.go</span><br><span class="line">go run main.go</span><br><span class="line">go get -u github.com&#x2F;xxx&#x2F;yyy</span><br><span class="line">查看环境: go env</span><br><span class="line"></span><br><span class="line">查看包：go doc xxx</span><br></pre></td></tr></table></figure><p>go install 会安装到GOBIN目录，一般项目可不用如此操作。</p><h2 id="六、编码小结"><a href="#六、编码小结" class="headerlink" title="六、编码小结"></a>六、编码小结</h2><p>右大括号<code>&#123;</code>在行尾，如在新一行，编译不通过。<br>一般使用小写+大写方式。<br>函数：大写 导出，小写 包内（跨文件）可见。<br>变量：大写导出，小写包内可见。专用名称，可大写或小写。<br>接口、结构体：大写（一说小+大）。<br>文件名、包名：小写。  </p><p>要慢慢熟悉的：大括号位置、if/for/没有小括号。<br>如果引入的包不使用，又不想删除（后面可能会用到），可以注释掉，也可以调用这些包的函数，放到函数中，但不调用这个函数。<br>格式要求严格，如a为uint16， b为<code>[]byte</code>，<code>a = b[0]</code>出错，需要转换<code>a = uint16(b[0])</code>。另外，<code>a = -1</code>也出错，因为是无符号的。<br>可用 go fmt 格式化代码。  </p><p>基本知识：<br>打印：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printfln(&quot;Hello world&quot;);</span><br><span class="line">fmt.Printf(&quot;Hello %v\n&quot;, &quot;world&quot;);</span><br></pre></td></tr></table></figure><p>代码片段(用以切换语言时看)：  </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">有传入、付出参数</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrt</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    ret := <span class="number">1.0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        ret = ret - (ret*ret - x) / <span class="number">2</span> / ret</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;类&quot;</span></span><br><span class="line"><span class="keyword">package</span> class</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">true<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空结构体</span></span><br><span class="line"><span class="keyword">type</span> SimpleClass <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// nothing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;类&quot;的形式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *SimpleClass)</span> <span class="title">printf</span><span class="params">()</span></span> &#123;</span><br><span class="line">truefmt.Printf(<span class="string">&quot;%v\n&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大写，包外可见</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SimpleTest</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    c := SimpleClass&#123;&#125;;</span><br><span class="line">    c.printf();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">主函数文件：</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;class&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    class.SimpleTest();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="七、小实验"><a href="#七、小实验" class="headerlink" title="七、小实验"></a>七、小实验</h2><p>自实现模块A，存入github.com，A使用到第三方库，<code>go get</code>获取A会自动检测第三方库，如无则自动下载。  </p><h2 id="八、常见错误"><a href="#八、常见错误" class="headerlink" title="八、常见错误"></a>八、常见错误</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.go:8:5: found packages a (a.go) and main (a1.go) in e:\project\golang\src\hello\a</span><br></pre></td></tr></table></figure><p>原因：同一个目录下，有2个包名。<br>解决：只保留一个包名，如必须有2个，则移到另一目录。  </p><p>下载第三方依赖包时，其依赖的包可能存在于本地，但版本过旧，会出错。此时重新更新所有的依赖包即可。  </p><p>PS：工作中切换语言时，先看几眼本文件，以便于思维的切换。  </p><p>李迟  2020.08.19 周三</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;自去年开始，因工作的关系，需要使用 Golang 进行开发。一来是工作，二来多了解一个新语言，总归是有好处。现在虽然不是主攻 Golang，但可能用来写一些小工具。    &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>我的docker随笔29：oracle数据库部署</title>
    <link href="http://www.latelee.org/docker/docker-29-deploy-oracle.html"/>
    <id>http://www.latelee.org/docker/docker-29-deploy-oracle.html</id>
    <published>2020-07-28T15:25:05.000Z</published>
    <updated>2020-12-03T03:00:04.872Z</updated>
    
    <content type="html"><![CDATA[<p>本文涉及：<br>oracle 的容器化部署。  </p><a id="more"></a><p>下载镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com&#x2F;helowin&#x2F;oracle_11g</span><br></pre></td></tr></table></figure><p>镜像列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY                                             TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com&#x2F;helowin&#x2F;oracle_11g   latest              3fa112fd3642        4 years ago         6.85 GB</span><br></pre></td></tr></table></figure><p>启动容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd -p 1521:1521 --name oracle registry.cn-hangzhou.aliyuncs.com&#x2F;helowin&#x2F;oracle_11g</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">数据持久化：</span><br><span class="line">docker run -itd -p 1521:1521 \</span><br><span class="line">--name&#x3D;oracle \</span><br><span class="line">-v $PWD&#x2F;helowin:&#x2F;home&#x2F;oracle&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;helowin \</span><br><span class="line">-v $PWD&#x2F;flash_recovery_area:&#x2F;home&#x2F;oracle&#x2F;app&#x2F;oracle&#x2F;flash_recovery_area \</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com&#x2F;helowin&#x2F;oracle_11g bash</span><br><span class="line"></span><br><span class="line">--restart&#x3D;always </span><br></pre></td></tr></table></figure><p>状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># docker ps</span><br><span class="line">CONTAINER ID        IMAGE                                                  COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">d3b1cd3efbc7        registry.cn-hangzhou.aliyuncs.com&#x2F;helowin&#x2F;oracle_11g   &quot;&#x2F;bin&#x2F;sh -c &#39;&#x2F;home...&quot;   32 seconds ago      Up 6 seconds        0.0.0.0:1521-&gt;1521&#x2F;tcp   oracle</span><br></pre></td></tr></table></figure><p>默认账号和密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#username: system</span><br><span class="line">#password: helowin</span><br></pre></td></tr></table></figure><p>进入容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec oracle bash</span><br></pre></td></tr></table></figure><p>连接数据库。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">source &#x2F;home&#x2F;oracle&#x2F;.bash_profile  </span><br><span class="line"></span><br><span class="line">sqlplus &#x2F;nolog</span><br><span class="line">SQL&gt; conn &#x2F; as sysdba</span><br><span class="line">Connected.</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line">$ sqlplus </span><br><span class="line"></span><br><span class="line">SQL*Plus: Release 11.2.0.1.0 Production on Mon Oct 26 09:17:43 2020</span><br><span class="line"></span><br><span class="line">Copyright (c) 1982, 2009, Oracle.  All rights reserved.</span><br><span class="line"></span><br><span class="line">Enter user-name: system  # 账号</span><br><span class="line">Enter password: # 密码为helowin</span><br><span class="line"></span><br><span class="line">Connected to:</span><br><span class="line">Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit Production</span><br></pre></td></tr></table></figure><p>修改账号密码。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; alter user system identified by system;    ## 账号和密码为system</span><br><span class="line"></span><br><span class="line">User altered.</span><br><span class="line"></span><br><span class="line">SQL&gt; alter user sys identified by sys;  ## 账号和密码为sys</span><br><span class="line"></span><br><span class="line">User altered.</span><br><span class="line"></span><br><span class="line">SQL&gt; </span><br><span class="line">SQL&gt; alter profile default limit password_life_time unlimited;</span><br><span class="line"></span><br><span class="line">Profile altered.</span><br><span class="line"></span><br><span class="line">SQL&gt; exit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ lsnrctl status</span><br><span class="line"></span><br><span class="line">LSNRCTL for Linux: Version 11.2.0.1.0 - Production on 30-AUG-2020 00:54:57</span><br><span class="line"></span><br><span class="line">Copyright (c) 1991, 2009, Oracle.  All rights reserved.</span><br><span class="line"></span><br><span class="line">Connecting to (DESCRIPTION&#x3D;(ADDRESS&#x3D;(PROTOCOL&#x3D;IPC)(KEY&#x3D;EXTPROC1521)))</span><br><span class="line">STATUS of the LISTENER</span><br><span class="line">------------------------</span><br><span class="line">Alias                     LISTENER</span><br><span class="line">Version                   TNSLSNR for Linux: Version 11.2.0.1.0 - Production</span><br><span class="line">Start Date                27-AUG-2020 23:26:21</span><br><span class="line">Uptime                    2 days 1 hr. 28 min. 36 sec</span><br><span class="line">Trace Level               off</span><br><span class="line">Security                  ON: Local OS Authentication</span><br><span class="line">SNMP                      OFF</span><br><span class="line">Listener Parameter File   &#x2F;home&#x2F;oracle&#x2F;app&#x2F;oracle&#x2F;product&#x2F;11.2.0&#x2F;dbhome_2&#x2F;network&#x2F;admin&#x2F;listener.ora</span><br><span class="line">Listener Log File         &#x2F;home&#x2F;oracle&#x2F;app&#x2F;oracle&#x2F;diag&#x2F;tnslsnr&#x2F;d3b1cd3efbc7&#x2F;listener&#x2F;alert&#x2F;log.xml</span><br><span class="line">Listening Endpoints Summary...</span><br><span class="line">  (DESCRIPTION&#x3D;(ADDRESS&#x3D;(PROTOCOL&#x3D;ipc)(KEY&#x3D;EXTPROC1521)))</span><br><span class="line">  (DESCRIPTION&#x3D;(ADDRESS&#x3D;(PROTOCOL&#x3D;tcp)(HOST&#x3D;d3b1cd3efbc7)(PORT&#x3D;1521)))</span><br><span class="line">Services Summary...</span><br><span class="line">Service &quot;helowin&quot; has 1 instance(s).</span><br><span class="line">  Instance &quot;helowin&quot;, status READY, has 1 handler(s) for this service...</span><br><span class="line">Service &quot;helowinXDB&quot; has 1 instance(s).</span><br><span class="line">  Instance &quot;helowin&quot;, status READY, has 1 handler(s) for this service...</span><br><span class="line">The command completed successfully</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><strong>ORA-12528: TNS: 监听程序: 所有适用例程都无法建立新连接。</strong><br>查看状态为BLOCKED：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ lsnrctl status</span><br><span class="line"></span><br><span class="line">LSNRCTL for Linux: Version 11.2.0.1.0 - Production on 26-OCT-2020 11:05:00</span><br><span class="line"></span><br><span class="line">Copyright (c) 1991, 2009, Oracle.  All rights reserved.</span><br><span class="line"></span><br><span class="line">Connecting to (DESCRIPTION&#x3D;(ADDRESS&#x3D;(PROTOCOL&#x3D;IPC)(KEY&#x3D;EXTPROC1521)))</span><br><span class="line">STATUS of the LISTENER</span><br><span class="line">------------------------</span><br><span class="line">Alias                     LISTENER</span><br><span class="line">Version                   TNSLSNR for Linux: Version 11.2.0.1.0 - Production</span><br><span class="line">Start Date                26-OCT-2020 10:11:00</span><br><span class="line">Uptime                    0 days 0 hr. 53 min. 59 sec</span><br><span class="line">Trace Level               off</span><br><span class="line">Security                  ON: Local OS Authentication</span><br><span class="line">SNMP                      OFF</span><br><span class="line">Listener Parameter File   &#x2F;home&#x2F;oracle&#x2F;app&#x2F;oracle&#x2F;product&#x2F;11.2.0&#x2F;dbhome_2&#x2F;network&#x2F;admin&#x2F;listener.ora</span><br><span class="line">Listener Log File         &#x2F;home&#x2F;oracle&#x2F;app&#x2F;oracle&#x2F;diag&#x2F;tnslsnr&#x2F;5041887d0189&#x2F;listener&#x2F;alert&#x2F;log.xml</span><br><span class="line">Listening Endpoints Summary...</span><br><span class="line">  (DESCRIPTION&#x3D;(ADDRESS&#x3D;(PROTOCOL&#x3D;ipc)(KEY&#x3D;EXTPROC1521)))</span><br><span class="line">  (DESCRIPTION&#x3D;(ADDRESS&#x3D;(PROTOCOL&#x3D;tcp)(HOST&#x3D;5041887d0189)(PORT&#x3D;1521)))</span><br><span class="line">Services Summary...</span><br><span class="line">Service &quot;helowin&quot; has 1 instance(s).</span><br><span class="line">  Instance &quot;helowin&quot;, status BLOCKED, has 1 handler(s) for this service...</span><br><span class="line">The command completed successfully</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>默认启动命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;Volumes&quot;: &#123;</span><br><span class="line">                &quot;&#x2F;home&#x2F;oracle&#x2F;app&#x2F;oracle&#x2F;oradata&quot;: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;WorkingDir&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Entrypoint&quot;: [</span><br><span class="line">                &quot;&#x2F;bin&#x2F;sh&quot;,</span><br><span class="line">                &quot;-c&quot;,</span><br><span class="line">                &quot;&#x2F;home&#x2F;oracle&#x2F;app&#x2F;oracle&#x2F;product&#x2F;11.2.0&#x2F;dbhome_2&#x2F;bin&#x2F;dbstart &#x2F;home&#x2F;oracle&#x2F;app&#x2F;oracle&#x2F;product&#x2F;11.2.0&#x2F;dbhome_2 &amp;&amp; tail -f &#x2F;home&#x2F;oracle&#x2F;app&#x2F;oracle&#x2F;product&#x2F;11.2.0&#x2F;dbhome_2&#x2F;startup.log&quot;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/qiuxiangmuyu/p/7895154.html">https://www.cnblogs.com/qiuxiangmuyu/p/7895154.html</a><br><a href="https://www.cnblogs.com/YsirSun/p/13543313.html">https://www.cnblogs.com/YsirSun/p/13543313.html</a><br><a href="https://blog.csdn.net/chenjin_csdn/article/details/106470108">https://blog.csdn.net/chenjin_csdn/article/details/106470108</a><br><a href="https://github.com/oracle/docker-images/tree/master/OracleDatabase/SingleInstance#running-oracle-database-11gr2-express-edition-in-a-docker-container">https://github.com/oracle/docker-images/tree/master/OracleDatabase/SingleInstance#running-oracle-database-11gr2-express-edition-in-a-docker-container</a>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文涉及：&lt;br&gt;oracle 的容器化部署。  &lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="http://www.latelee.org/category/docker/"/>
    
    
    <category term="docker" scheme="http://www.latelee.org/tag/docker/"/>
    
  </entry>
  
  <entry>
    <title>我的docker随笔28：基于容器的升级方案实验</title>
    <link href="http://www.latelee.org/docker/docker-28-update-using-docker.html"/>
    <id>http://www.latelee.org/docker/docker-28-update-using-docker.html</id>
    <published>2020-07-27T15:25:05.000Z</published>
    <updated>2020-12-03T03:00:04.872Z</updated>
    
    <content type="html"><![CDATA[<p>本文涉及：<br>在容器化场合中，如何更快升级。涉及2方面：<br>docker镜像的设计。<br>升级方案。    </p><a id="more"></a><h2 id="docker镜像设计"><a href="#docker镜像设计" class="headerlink" title="docker镜像设计"></a>docker镜像设计</h2><p>充分利用docker镜像分层机制，减小升级的体积，减少流量消耗。    </p><h3 id="基础镜像设计"><a href="#基础镜像设计" class="headerlink" title="基础镜像设计"></a>基础镜像设计</h3><p>基础镜像可直接沿用官方的，也可自行制作，自行制作机动性强，可加定制内容，如nodejs依赖的node_modules目录，C++额外依赖的库（如cuda等）。<br>每次制作，在基础镜像基础上，而不是上一版本。因为docker是基础上一层制作的，即使版本间差别不大，但体积也只增不减。  </p><p>分层测试示例如下。<br>制作二镜像，先做基础，在此基础上制作0.1版本。先下载基础镜像，再下载0.1版本。观察下载过程日志。    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># docker pull latelee&#x2F;nodejs_test:base</span><br><span class="line"></span><br><span class="line">base: Pulling from latelee&#x2F;nodejs_test</span><br><span class="line">3cfb62949d9d: Pull complete </span><br><span class="line">34aecfb75a58: Pull complete </span><br><span class="line">3d83db6658b4: Pull complete </span><br><span class="line">c94ba0b8da75: Pull complete </span><br><span class="line">d7bff1b55288: Pull complete </span><br><span class="line">Digest: sha256:e17eefc913b842d944702fa008c3178e5f5cf6753b102954ee2426ff548aa6c4</span><br><span class="line">Status: Downloaded newer image for latelee&#x2F;nodejs_test:base</span><br><span class="line"></span><br><span class="line"># docker pull latelee&#x2F;nodejs_test:0.1</span><br><span class="line"></span><br><span class="line">0.1: Pulling from latelee&#x2F;nodejs_test</span><br><span class="line">3cfb62949d9d: Already exists </span><br><span class="line">34aecfb75a58: Already exists </span><br><span class="line">3d83db6658b4: Already exists </span><br><span class="line">c94ba0b8da75: Already exists </span><br><span class="line">d7bff1b55288: Already exists </span><br><span class="line">7c1d066698dd: Pull complete </span><br><span class="line">Digest: sha256:f17bec3186ca681be8815adda298b217b6d0c1bcb248a0f57da4b03a8197db43</span><br><span class="line">Status: Downloaded newer image for latelee&#x2F;nodejs_test:0.1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二次下载的，许多层已经存在了，无须再下载，故速度快。在磁盘上，也是重用镜像的，所以会节省空间。  </p><p>其它测试：使用大文件，在基础镜像上制作0.1版本，再在0.1版本上制作0.2(只做小修改)，另再以0.2版本的文件，基于基础镜像做0.11版本，观察三者下载过程。  </p><h3 id="宿主机映射方案"><a href="#宿主机映射方案" class="headerlink" title="宿主机映射方案"></a>宿主机映射方案</h3><p>一般地，容器作为运行环境，宿主机保存数据文件。如web服务即为典型者。这里反其义用之。即把文件放到镜像中，再把宿主机的运行环境映射到容器中，执行之。<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm -v &#x2F;home&#x2F;latelee&#x2F;nodejs&#x2F;nodejs_test&#x2F;node_modules:&#x2F;home&#x2F;node&#x2F;node_modules \</span><br><span class="line">-v &#x2F;usr&#x2F;local&#x2F;bin&#x2F;:&#x2F;home&#x2F;local&#x2F;bin \</span><br><span class="line">-v &#x2F;lib&#x2F;:&#x2F;home&#x2F;lib \</span><br><span class="line">-v &#x2F;usr&#x2F;lib&#x2F;:&#x2F;home&#x2F;usr&#x2F;lib \</span><br><span class="line">nodejsdata sh </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export PATH&#x3D;$PATH:&#x2F;home&#x2F;local&#x2F;bin</span><br><span class="line">export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:&#x2F;home&#x2F;lib</span><br><span class="line">export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:&#x2F;home&#x2F;usr&#x2F;lib</span><br><span class="line"></span><br><span class="line">&#x2F; # node -v</span><br><span class="line">v10.20.1</span><br><span class="line">&#x2F; # cd &#x2F;home&#x2F;node&#x2F;</span><br><span class="line">&#x2F; # node koa_test.js </span><br><span class="line">Running a koa server at localhost:  4000</span><br><span class="line"></span><br><span class="line">docker run -it --rm -v &#x2F;home&#x2F;latelee&#x2F;nodejs&#x2F;nodejs_test&#x2F;node_modules:&#x2F;home&#x2F;node&#x2F;node_modules \</span><br><span class="line">-v &#x2F;usr:&#x2F;usr \</span><br><span class="line">-v &#x2F;bin:&#x2F;bin \</span><br><span class="line">-v &#x2F;lib&#x2F;:&#x2F;lib \</span><br><span class="line">nodejs_test sh </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>尝试使用<code>scratch</code>制作，即只把相关的js文件拷贝到镜像中，不基于busybox等基础镜像，未挂载命令所在目录时提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker: Error response from daemon: OCI runtime create failed: container_linux.go:345: starting container process caused &quot;exec: \&quot;sh\&quot;: executable file not found in $PATH&quot;: unknown.</span><br></pre></td></tr></table></figure><p>挂载（如/bin/目录）后提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">standard_init_linux.go:211: exec user process caused &quot;no such file or directory&quot;</span><br><span class="line">failed to resize tty, using default size</span><br></pre></td></tr></table></figure><p>似乎无法如此实施。此问题尚未研究深。    </p><p>另，想过在容器A中使用容器B的目录，无果，或许无此应用方式。先挂载，再在容器中拷贝到宿主机，似乎可行，但多占用了存储空间，弃之。    </p><p>另一个示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --rm --name nodejsapp -p 3000:3000 -v &#x2F;home&#x2F;node&#x2F;node_modules&#x2F;:&#x2F;home&#x2F;node&#x2F;node_modules \</span><br><span class="line">-v &#x2F;usr&#x2F;:&#x2F;usr \</span><br><span class="line">-v &#x2F;lib&#x2F;:&#x2F;lib \</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com&#x2F;latelee&#x2F;nodejsdata</span><br><span class="line"></span><br><span class="line">提供的：</span><br><span class="line">docker run -itd --rm --name nodejsapp -p 3000:3000 \</span><br><span class="line">-v &#x2F;mnt&#x2F;data:&#x2F;mnt&#x2F;data \</span><br><span class="line">-v &#x2F;home&#x2F;node&#x2F;node_modules&#x2F;:&#x2F;home&#x2F;node&#x2F;node_modules \</span><br><span class="line">-v &#x2F;usr&#x2F;:&#x2F;usr \</span><br><span class="line">-v &#x2F;lib&#x2F;:&#x2F;lib \</span><br><span class="line">nodejsdata</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 arm 上验证通过。前提：arm 板子安装了nodejs环境以及依赖的node_modules。将应用代码做成镜像，下载并运行之。为减小操作，直接挂载成相同目录。  </p><h2 id="升级方案"><a href="#升级方案" class="headerlink" title="升级方案"></a>升级方案</h2><p>参考热启动和冷启动两种方式进行思考。目前只有构思，未动手编码。  </p><h3 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h3><p>云主机为服务器，终端/板子为客户端，两者保持长连接，可用websocket实现。<br>需要升级时（如用CICD触发，或手工触发，或发post请求），服务器收到升级事件，发指令到客户端，客户端执行<code>docker pull</code>命令，判断其返回值，同时判断新镜像是否正常（如下发指令时带md5或crc，也可用docker自身的ID），一切正常启动，监控些许时间后（如30秒~1分钟），容器未退出，方为正常。<br>客户端主动升级，需判断是否连网，可选择深夜升级，或业务非繁忙时段。    </p><h3 id="冷更新"><a href="#冷更新" class="headerlink" title="冷更新"></a>冷更新</h3><p>制作随系统启动的脚本，在脚本中先执行<code>docker pull</code>，如果已是最新版本，会输出docker ID值，并带有<code>Image is up to date for</code>字样，可判断之。否则，会拉取镜像，此时，需先停止容器并删除容器，再启动（是否直接重启容器即可实现，此刻未研究）。此方式，需要重启设备，如果启动时间长，则服务停止时间长。在时间间隔允许情况下，可采用此法，方便。  </p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文镜像已修改，所示者非真实镜像。  </p><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>一个builtroot更新node的记录。  </p><p>前端所所需版本为10.15，builtroot默认是8.15。<br>1、下载alpine版本镜像，取node，其库为musllibc，目标板库为glibc，运行提示<code>Not found</code>，原由是链接器不同。失败。下载armv7版本的镜像，从中取之。体积30MB余，较大。  </p><p>2、观察buitroot配置，确认node为8.15，临时改配置，更新node为10.15，编译失败，重新改为8.15，成功，猜测openssl问题。查找官方代码路径<code>https://git.busybox.net/buildroot/tree/package/nodejs/nodejs.mk?h=2019.05</code>，选择不同版本号，发现 201905 版本较近，从中取配置文件，替换/新加原有目录。其依赖<code>https://git.busybox.net/buildroot/tree/package/nghttp2?h=2019.05</code>。make时下载慢，用云主机下载，再用scp拷贝之。编译依然失败，从提示日志看，还是openssl。想到将buitroot升级到201905，然又与内核等有关联，成本大，弃之。<br>3、恢复用用8.15编译，暂不烧写镜像（一是仅验证，二是耗时），拷贝/usr/bin/node到目标板，拷贝其依赖库libhttp_parser、libuv、libcares三个库。结果：应用程序依赖的sqlite为<code>/sqlite3/lib/binding/node-v64-linux-arm</code>，但是该版本的node认为依赖的是<code>sqlite3/lib/binding/node-v57-linux-arm/node_sqlite3.node</code>，不兼容，失败。<br>4、使用官方预编译版本，地址<code>https://nodejs.org/dist/v10.15.0/</code>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文涉及：&lt;br&gt;在容器化场合中，如何更快升级。涉及2方面：&lt;br&gt;docker镜像的设计。&lt;br&gt;升级方案。    &lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="http://www.latelee.org/category/docker/"/>
    
    
    <category term="docker" scheme="http://www.latelee.org/tag/docker/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu系统远程桌面</title>
    <link href="http://www.latelee.org/pkc/ubuntu-vnc.html"/>
    <id>http://www.latelee.org/pkc/ubuntu-vnc.html</id>
    <published>2020-07-23T16:00:00.000Z</published>
    <updated>2020-12-03T03:00:04.768Z</updated>
    
    <content type="html"><![CDATA[<p>背景：<br>aarch64(arm64)系统，ubuntu 18.04，需在 Windows 远程连接系统桌面。  </p><a id="more"></a><h2 id="源"><a href="#源" class="headerlink" title="源"></a>源</h2><p>使用华为源：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -O &#x2F;etc&#x2F;apt&#x2F;sources.list https:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;repository&#x2F;conf&#x2F;Ubuntu-Ports-bionic.list</span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><h2 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install xrdp</span><br><span class="line">sudo apt-get install vnc4server</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>安装桌面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install xubuntu-desktop</span><br></pre></td></tr></table></figure><p>过程需选择默认桌面，选gdm3（另一为lightdm)。  </p><p>注：最后提示：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Warning: couldn&#39;t identify filesystem type for fsck hook, ignoring.</span><br><span class="line">I: The initramfs will attempt to resume from &#x2F;dev&#x2F;zram7</span><br><span class="line">I: (UUID&#x3D;c88002d8-584d-4dba-a78b-3177ebcdb5c0)</span><br><span class="line">I: Set the RESUME variable to override this.</span><br><span class="line">&#x2F;sbin&#x2F;ldconfig.real: Warning: ignoring configuration file that cannot be opened: &#x2F;etc&#x2F;ld.so.conf.d&#x2F;aarch64-linux-gnu_EGL.conf: No such file or directory</span><br><span class="line">&#x2F;sbin&#x2F;ldconfig.real: Warning: ignoring configuration file that cannot be opened: &#x2F;etc&#x2F;ld.so.conf.d&#x2F;aarch64-linux-gnu_GL.conf: No such file or directory</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;xfce4-session&quot; &gt;~&#x2F;.xsession</span><br><span class="line">sudo service xrdp restart # 启动xrdp服务</span><br></pre></td></tr></table></figure><h2 id="windows连接"><a href="#windows连接" class="headerlink" title="windows连接"></a>windows连接</h2><p>使用远程桌面连接，输入IP地址，点击“选项”，输入用户。等待连接成功。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;背景：&lt;br&gt;aarch64(arm64)系统，ubuntu 18.04，需在 Windows 远程连接系统桌面。  &lt;/p&gt;</summary>
    
    
    
    <category term="个人知识中心" scheme="http://www.latelee.org/category/pkc/"/>
    
    
    <category term="Linux使用" scheme="http://www.latelee.org/tag/Linux%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>oracle操作实例</title>
    <link href="http://www.latelee.org/pkc/oracle-practice.html"/>
    <id>http://www.latelee.org/pkc/oracle-practice.html</id>
    <published>2020-07-18T04:00:00.000Z</published>
    <updated>2020-12-03T03:00:04.768Z</updated>
    
    <content type="html"><![CDATA[<p>记录oracle操作实例，不过查询的较多。由于同时涉及多种数据库，会混入其它库的记录。  </p><a id="more"></a><h2 id="搭建oracle服务"><a href="#搭建oracle服务" class="headerlink" title="搭建oracle服务"></a>搭建oracle服务</h2><p>使用docker搭建。<br>使用navicat连接，成功后，“其它”-&gt;“表空间”-&gt;“新建表空间”。<br>“常规”：名称：fee.ora，大小10，单位G，路径：/home/oracle/app/oracle/product/11.2.0/dbhome_2/dbs/ (注意后面的<code>/</code>)。自动扩展：ON。<br>“存储”：文件类型BIGFILE，大小：10，单位G，扩展区管理LOCAL。<br>“保存”。  </p><p>用户-&gt;用户，“新建用户”，输入用户名称，密码，“保存”。  </p><p>（似乎要创建用户才能看到数据库）</p><h2 id="连接工具"><a href="#连接工具" class="headerlink" title="连接工具"></a>连接工具</h2><p>（注：本节待移动）<br>navicat，该工具可连接多种数据库。  </p><p>可在不同数据库中迁移，“工具”-&gt;“数据传输”。实际发现，此方式迁移的表的字段类型，可能会与原表不一致，如把char改为text，会出错。<br>导出：可导出不同类型文件，如sql文件，txt文件，xml、json，等等。可选要导出的列。  </p><h2 id="navicat-异构数据库同步问题"><a href="#navicat-异构数据库同步问题" class="headerlink" title="navicat 异构数据库同步问题"></a>navicat 异构数据库同步问题</h2><p>1、原数据库导出为txt，再在新数据库导入。在导出过程，默认字段为text，不一定符合要求。<br>2、原数据库导出为sql，再在新数据库导入。sql文件格式不一定通用，要修改，再导入。  </p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>创建的用户没有权限，提示<code>user test lacks create session privilege logon denied</code>。解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqlplus &#x2F;nolog</span><br><span class="line">onn &#x2F;as sysdba</span><br><span class="line">grant create session to test</span><br></pre></td></tr></table></figure><p><code>create table xxx ()</code>缺失右括号。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter user FEE default tablespace FEE quota 500 M on FEE;</span><br></pre></td></tr></table></figure><h2 id="类型对应关系"><a href="#类型对应关系" class="headerlink" title="类型对应关系"></a>类型对应关系</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">SQL Server 数据类型Oracle 数据类型</span><br><span class="line">bigintNUMBER(19,0)</span><br><span class="line">binary(1-2000)RAW(1-2000)</span><br><span class="line">binary(2001-8000)BLOB</span><br><span class="line">bitNUMBER(1)</span><br><span class="line">char(1-2000)CHAR(1-2000)</span><br><span class="line">char(2001-4000)VARCHAR2(2001-4000)</span><br><span class="line">char(4001-8000)CLOB</span><br><span class="line">dateDATE</span><br><span class="line">datetimeDATE</span><br><span class="line">datetime2(0-7)TIMESTAMP(7)（对于 Oracle 9 和 Oracle 10）；VARCHAR(27)（对于 Oracle 8）</span><br><span class="line">datetimeoffset(0-7)TIMESTAMP(7) WITH TIME ZONE（对于 Oracle 9 和 Oracle 10）；VARCHAR(34)（对于 Oracle 8）</span><br><span class="line">decimal(1-38, 0-38)NUMBER(1-38, 0-38)</span><br><span class="line">float(53)FLOAT</span><br><span class="line">floatFLOAT</span><br><span class="line">地理BLOB</span><br><span class="line">geometryBLOB</span><br><span class="line">hierarchyidBLOB</span><br><span class="line">图像BLOB</span><br><span class="line">intNUMBER(10,0)</span><br><span class="line">moneyNUMBER(19,4)</span><br><span class="line">nchar(1-1000)CHAR(1-1000)</span><br><span class="line">nchar(1001-4000)NCLOB</span><br><span class="line">ntextNCLOB</span><br><span class="line">numeric(1-38, 0-38)NUMBER(1-38, 0-38)</span><br><span class="line">nvarchar(1-1000)VARCHAR2(1-2000)</span><br><span class="line">nvarchar(1001-4000)NCLOB</span><br><span class="line">nvarchar(max)NCLOB</span><br><span class="line">realreal</span><br><span class="line">smalldatetimeDATE</span><br><span class="line">intNUMBER(5,0)</span><br><span class="line">smallmoneyNUMBER(10,4)</span><br><span class="line">sql_variantN&#x2F;A</span><br><span class="line">sysnameVARCHAR2(128)</span><br><span class="line">textCLOB</span><br><span class="line">time(0-7)VARCHAR(16)</span><br><span class="line">timestampRAW(8)</span><br><span class="line">tinyintNUMBER(3,0)</span><br><span class="line">uniqueidentifierCHAR(38)</span><br><span class="line">varbinary(1-2000)RAW(1-2000)</span><br><span class="line">varbinary(2001-8000)BLOB</span><br><span class="line">varchar(1-4000)VARCHAR2(1-4000)</span><br><span class="line">varchar(4001-8000)CLOB</span><br><span class="line">varbinary(max)BLOB</span><br><span class="line">varchar(max)CLOB</span><br><span class="line">xmlNCLOB</span><br></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><h4 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">判断字段空或非空（即null）</span><br><span class="line">select * from xxx where foo is null</span><br><span class="line">select * from xxx where foo is not null</span><br></pre></td></tr></table></figure><h4 id="常用查询"><a href="#常用查询" class="headerlink" title="常用查询"></a>常用查询</h4><p>模糊查找：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from MYDB.STATION where name like &#39;%出口%&#39;</span><br></pre></td></tr></table></figure><p>查找交易表中指定的ID，日期和类型，限制5条：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from MYDB.TRADE_INFO </span><br><span class="line">where ID&#x3D;&#39;001250&#39; </span><br><span class="line">and to_char(trans_time, &#39;yyyy-MM-dd HH24:MI:SS&#39;) like &#39;2020-08-08 %&#39; </span><br><span class="line">and TYPE &#x3D; 1 </span><br><span class="line">and rownum &lt; 5</span><br></pre></td></tr></table></figure><p>注:日期转换要用<code>to_char(trans_time, &#39;yyyy-MM-dd HH24:MI:SS&#39;)</code>这种形式。  </p><p>交易时间最早：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">升序</span><br><span class="line">select * from MYDB.TRADE_INFO g where  rownum &lt; 10 order by g.TRANS_TIME</span><br></pre></td></tr></table></figure><p>交易时间最新：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">降序</span><br><span class="line">select * from MYDB.TRADE_INFO g where  rownum &lt; 10 order by g.TRANS_TIME desc</span><br></pre></td></tr></table></figure><p>注：这是错误的，先取10条，再排序，不符合逻辑。但未找到合适的。特别在几千万条的记录中找，耗时。  </p><p>多表查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select a.id, a.id_hex, a.name from TableA A, TableB B where a.name &#x3D;  b.name and A.id_hex&#x3D;&#39;510156&#39;</span><br><span class="line"></span><br><span class="line">select a.id, a.id_hex, a.name from TableA A, TableB B where a.name like &quot;%&quot; || b.name || &quot;%&quot; and A.id_hex&#x3D;&#39;510156&#39;</span><br><span class="line">注：A、B表，各有各的字段，但包含共同的name字段，以此为条件查两表，另一条件为指定id_hex。</span><br><span class="line">第二语句为a的name有多个，但b的name只有一个，属于包含关系。第一语句为相等</span><br></pre></td></tr></table></figure><p>查询去重<br>如果结果有多条，在语句后续添加<code>group by A.id_hex</code>。有时出错，则在select后加DISTINCT关键字。错误示例：    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择列表中的列 &#39;TableA.id_hex&#39; 无效，因为该列没有包含在聚合函数或 GROUP BY 子句中。 (8120)  </span><br></pre></td></tr></table></figure><p>查询指定字段有重复（即超过1个）的记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from AAA where version&#x3D;&#39;001&#39;  group by sta having count(sta)&gt;1</span><br></pre></td></tr></table></figure><h4 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h4><p>导出查询，将结果导出sql。<br>按条件查询，得到结果，再点击“导出结果”（在“运行”附近），可保存得到的结果。此法适用同一表中有不同版本的记录（即同一条记录存在多个版本，重复）。如要保存所有记录，直接导出即可。  </p><p>直接右键某个表，“导出向导…”，可得不同格式文件。“转储SQL文件”，可得含结构和数据，或仅含结构。  </p><p>Win7 64bit 连接数据库  </p><p>1、下载 64 版本的 OCI<br><a href="https://www.oracle.com/database/technologies/instant-client/winx64-64-downloads.html">https://www.oracle.com/database/technologies/instant-client/winx64-64-downloads.html</a><br>版本 SDK 版本（有静态库，用于开发）、Basic 版本（基础包）、ODBC 版本（有用于安装的exe）。压缩包不同，但内含目录一致，解压到当前目录即可。本文用最新版本instantclient_19_8。将压缩后的目录拷贝到指定目录，示例：D:\oracle\instantclient，下用 ORACLE_HOME 代替。   </p><p>2、设置环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ORACLE_HOME D:\oracle\instantclient</span><br><span class="line">NLS_LANG SIMPLIFIED CHINESE_CHINA.ZHS16GBK</span><br><span class="line">TNS_ADMIN D:\oracle\instantclient</span><br><span class="line">Path D:\oracle\instantclient</span><br></pre></td></tr></table></figure><p>修改编辑ORACLE_HOME\tnsnames.ora，如果没有，从别处拷贝一份。格式类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">oracle_inner &#x3D;</span><br><span class="line">  (DESCRIPTION &#x3D;</span><br><span class="line">    (ADDRESS &#x3D; (PROTOCOL &#x3D; TCP)(HOST &#x3D; 192.168.234.100)(PORT &#x3D; 1521))</span><br><span class="line">    (CONNECT_DATA &#x3D;</span><br><span class="line">      (SERVER &#x3D; DEDICATED)</span><br><span class="line">      (SERVICE_NAME &#x3D; helowin)</span><br><span class="line">    )</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>3、安装<br>进入ORACLE_HOME目录，执行odbc_install.exe，最好使用管理员打开cmd，切换该目录，再执行。</p><p>4、配置<br>打开控制面板，找到：<code>管理工具</code>，<code>ODBC数据源</code>或者 ODBC数据源(32 位)，打开之。<br>添加用户DSN: 点击添加按钮，找到对应版本的ODBC，本文为<code>Oracle in instantclient</code>，输入信息，测试连接。  </p><p>5、除外<br>如果ODBC数据源没有找到版本，打开目录 C:\Windows\SysWOW64。双击运行odbcad32.exe。<br>点击添加按钮，找到对应版本的ODBC。点击完成，添加数据源、服务名、用户名（如oracle1、oracle2、my），点击Test Connection，输入密码。成功后，点击“OK”保存。  </p><p>注0：ODBC数据源界面看到的名称，可认为是数据源，在代码中可直接使用，如上述的oracle1等。<br>注1：不同系统，不同版本，结果可能不同。<br>注2：本文安装目录为instantclient，是因为要尝试多种版本，每次改环境变量麻烦。在选择源时只显示<code>Oracle in instantclient</code>，如目录带版本号，则会显示出来。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录oracle操作实例，不过查询的较多。由于同时涉及多种数据库，会混入其它库的记录。  &lt;/p&gt;</summary>
    
    
    
    <category term="个人知识中心" scheme="http://www.latelee.org/category/pkc/"/>
    
    
    <category term="工具使用" scheme="http://www.latelee.org/tag/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    <category term="数据库" scheme="http://www.latelee.org/tag/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库的一些实例记录</title>
    <link href="http://www.latelee.org/pkc/database-practice.html"/>
    <id>http://www.latelee.org/pkc/database-practice.html</id>
    <published>2020-07-18T04:00:00.000Z</published>
    <updated>2020-12-03T03:00:04.768Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些数据库的操作。会涉及多种数据库。  </p><a id="more"></a><h2 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sqlite：</span><br><span class="line">CREATE TABLE IF NOT EXISTS &quot;AAA&quot; (</span><br><span class="line">  &quot;ID&quot; INT NOT NULL ,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">sqlserver:</span><br><span class="line">if not exists (select * from sysobjects where id &#x3D; object_id(&#39;AAA&#39;))</span><br><span class="line">CREATE TABLE &quot;AAA&quot; (</span><br><span class="line">  &quot;ID&quot; INT NOT NULL ,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">主键可有多个（依次排序），使用 PRIMARY KEY (&quot;AAA&quot;, &quot;BBB&quot;) 即可</span><br></pre></td></tr></table></figure><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">oracle    sqlserver   sqlite</span><br><span class="line">VARCHAR2   VARCHAR</span><br><span class="line">CHAR(16 BYTE)  CHAR(16)</span><br><span class="line">FLOAT(126)  FLOAT(53)</span><br><span class="line">NUMBER(3)   INT</span><br><span class="line">DATE        DATETIME</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注：int就是一个整数，不能指定宽度</p><h2 id="出错"><a href="#出错" class="headerlink" title="出错"></a>出错</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一些数据库的操作。会涉及多种数据库。  &lt;/p&gt;</summary>
    
    
    
    <category term="个人知识中心" scheme="http://www.latelee.org/category/pkc/"/>
    
    
    <category term="工具使用" scheme="http://www.latelee.org/tag/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    <category term="数据库" scheme="http://www.latelee.org/tag/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>delphi基础语法</title>
    <link href="http://www.latelee.org/delphi/delphi-notes-1.html"/>
    <id>http://www.latelee.org/delphi/delphi-notes-1.html</id>
    <published>2020-07-04T16:00:00.000Z</published>
    <updated>2020-12-03T03:00:04.884Z</updated>
    
    <content type="html"><![CDATA[<p>高中时期，有幸上过2节pascal的课，老师讲了一些英文（实为关键字和变量），介绍了二进制及其计算，然理解不透，遂弃之。<br>十几年后，因工作需要维护一个上个世纪的 delphi 工程，故学之，但已无甚意义，简记之，供自学用。  </p><a id="more"></a><h2 id="技术总结"><a href="#技术总结" class="headerlink" title="技术总结"></a>技术总结</h2><p>0、安装IDE。<br>1、看基础语法（不要求短时间内完全了解）。<br>2、IDE使用，快捷键。<br>3、各控件使用、属性等，弹出窗口，多窗口显示，logo，标题，最大/小化。退出程序。对话框弹出。  </p><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">变量似乎不区分大小写。</span><br><span class="line">else 前不能有分号&#96;;&#96;。 </span><br><span class="line">type定义类型，var声明变量。</span><br><span class="line"></span><br><span class="line">delphi中&#96;&#123;$R*.DFM&#125;&#96;的意思是？--》包含同名窗体资源。</span><br><span class="line"></span><br><span class="line">赋值：:&#x3D;</span><br><span class="line">相等：&#x3D;  (if (a &#x3D; 1) then xxx end)</span><br><span class="line">不等：&lt;&gt;</span><br><span class="line"></span><br><span class="line">^: 指针   @: 取址  #: 十进制符   $: 十六进制符</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#96;#：ascii字符： const key &#x3D; #9&#96;</span><br><span class="line">十六进制：$34 &#x3D;&#x3D;&gt; 0x34</span><br><span class="line"></span><br><span class="line">字符串：string abc</span><br><span class="line">有符号32：integer longint</span><br><span class="line">无符号8：byte，无符号16 word，无符号32 cardinal或longword</span><br><span class="line">有符号8：shortint 有符号16 smallint 有符号64 longint(似乎没有uint64_t)</span><br><span class="line">字符：char(ansichar) widechar(16位，unicode)</span><br><span class="line">布尔：boolean</span><br><span class="line">字符串：string pchar pansichar pwidechar</span><br></pre></td></tr></table></figure><h3 id="function和procedure"><a href="#function和procedure" class="headerlink" title="function和procedure"></a>function和procedure</h3><p>function 为函数，必须有返回值，返回值固定名称为result。procedure 为过程，无返回值。个人理解中，两者表现形式似乎没有区别。<br>非主函数中，用exit退出当前函数，相当于“返回”，注意，如果要返回值，在此之前要赋值给result。<br>过程没有返回值，函数有。似乎没有参数，可以不写<code>()</code>。但写上也没问题，为了区别，写之。<br>参数如要传出，前加var，类似C++的引用。<br>多个相同类型参数，可共用一个类型。如<code>a, b:integer</code>，golang似乎参考这种做法。  </p><p>函数示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function foobar(a, b:integer): string;</span><br><span class="line">var</span><br><span class="line">ret:integer;</span><br><span class="line">begin</span><br><span class="line">    if (a &lt; 0) then  &#x2F;&#x2F; 此处判断参数合法，非法返回，类似 return语句</span><br><span class="line">    begin</span><br><span class="line">        result :&#x3D; &#39;&#39;;</span><br><span class="line">        exit;</span><br><span class="line">    end;</span><br><span class="line">    result :&#x3D; IntToStr(a+b);</span><br><span class="line">end;</span><br><span class="line">（注：没有括号，相同参数只写一个类型，与golang类似。返回值只用result表示）</span><br></pre></td></tr></table></figure><p>指针示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function test2():integer;</span><br><span class="line">var</span><br><span class="line">i:integer;</span><br><span class="line">p:^integer; &#x2F;&#x2F; 整型指针</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line">  i :&#x3D; 100;</span><br><span class="line">  p :&#x3D; @i;    &#x2F;&#x2F; 取地址</span><br><span class="line">  result :&#x3D; p^;  &#x2F;&#x2F; 取地址的值</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><h2 id="编程小结"><a href="#编程小结" class="headerlink" title="编程小结"></a>编程小结</h2><p>界面编程中，dfm文件中的中文，使用unicode(可能其它的，待确认)，已不可直接观察。无法搜索关键字。对于多窗口工程，较麻烦。<br>界面入口为 FormCreate，要设置响应事件，否则不生效的。<br>生成可执行文件目录配置（release或debug），在IDE中选，保存到dproj文件。  </p><h2 id="片段"><a href="#片段" class="headerlink" title="片段"></a>片段</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">显示信息对话框：</span><br><span class="line">MessageBox(0 , &#39;是否要退出本系统？&#39; , &#39;提示信息&#39;, MB_YESNO + MB_ICONQUESTION + MB_DEFBUTTON2 + MB_TASKMODAL);</span><br><span class="line"></span><br><span class="line">简单版本：</span><br><span class="line">ShowMessage(&#39;这是换行测试，&#39; + #13 +&#39;可以吗？&#39; + #13 + &#39;能不？&#39;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数字转字符：IntToStr(100)</span><br><span class="line">字符转数字：StrToInt(&#39;123&#39;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  STR :&#x3D; Format(&#39;111111111111111111&#39;+</span><br><span class="line">                &#39;bbbb: %s\r\n&#39;, [currentVs]);</span><br><span class="line">                </span><br><span class="line">string转PAnsiChar：</span><br><span class="line">Edit1.SetTextBuf(PAnsiChar(AnsiString(myStr)));</span><br></pre></td></tr></table></figure><p>枚举：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 枚举和数组示例</span><br><span class="line">&#x2F;&#x2F; 通过枚举值索引数组</span><br><span class="line">function test3():string;</span><br><span class="line">type</span><br><span class="line">EWEEK &#x3D; (MON, TUE, WED, THU, FRI, SAT, SUN);</span><br><span class="line">EColors &#x3D; (RED, GREEN, BLUE);</span><br><span class="line">Tb &#x3D; array of integer;</span><br><span class="line"></span><br><span class="line">var</span><br><span class="line">myColor: EColors;</span><br><span class="line">myWeek: EWEEK;</span><br><span class="line">a: array[0..3] of integer;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 错误</span><br><span class="line">&#x2F;&#x2F;cWeek: array[0..6] of PWideChar &#x3D; (&#39;Sun&#39;,&#39;Mon&#39;,&#39;Tue&#39;,&#39;Wed&#39;,&#39;Thu&#39;,&#39;Fri&#39;,&#39;Sat&#39;);</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line">myColor :&#x3D; BLUE;</span><br><span class="line">myWeek :&#x3D; FRI;</span><br><span class="line">a[0] :&#x3D; 1;</span><br><span class="line">A[1] :&#x3D; 2;</span><br><span class="line">a[2] :&#x3D; 100;</span><br><span class="line">result :&#x3D; format(&#39;%d %d&#39;, [ord(RED), b[2]]);</span><br><span class="line">&#x2F;&#x2F;result :&#x3D; cWeek[ord(THU)];</span><br><span class="line"></span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p>自定义类方法：<br>1、新建单元，保存，在工程中添加单元。<br>2、定义类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type</span><br><span class="line">  CFoo &#x3D; class</span><br><span class="line">  public</span><br><span class="line">     function FooTest(value: integer): integer;</span><br><span class="line">  end;</span><br></pre></td></tr></table></figure><p>实现方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function CFoo.FooTest(value: integer): integer;</span><br><span class="line">var</span><br><span class="line">i:integer;</span><br><span class="line">begin</span><br><span class="line">i :&#x3D; 100;</span><br><span class="line">result :&#x3D; i + value;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p>3、使用。在uses中引入单元名。定义类，调用类方法： a := myFoo.FooTest(100); </p><h2 id="控件及其它缩写"><a href="#控件及其它缩写" class="headerlink" title="控件及其它缩写"></a>控件及其它缩写</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">控件类名及解释 缩写</span><br><span class="line">TActionList, TAction表示动作的列表项 act</span><br><span class="line">TButton, TSpeedButton, TBitBtn等所有的按钮类 btn</span><br><span class="line">TCheckBox, TDBCheckBox等所有的检查框 chk</span><br><span class="line">TRadioButton单选按钮类 rdo</span><br><span class="line">TToolBar工具条 tb</span><br><span class="line">TMainMenu所有的主菜单类 mm</span><br><span class="line">TMainMenuItem所有的菜单项类 mi</span><br><span class="line">TPopupMenu所有的弹出式菜单类 pm</span><br><span class="line">TPopupMenuItem所有的弹出式菜单项类 pmi</span><br><span class="line">TLabel, TStaticText等所有用来显示的标签类 lbl</span><br><span class="line">TPanel等所有的面板类 pnl</span><br><span class="line">TPageControl等所有的页式控件类 pgc</span><br><span class="line">TEdit, TMaskEdit等所有的单行编辑框类 edt</span><br><span class="line">TMemo, TRichEdit等所有的多行编辑框类 mmo</span><br><span class="line">TDrawGrid, TStringGrid等所有的网格类 grd</span><br><span class="line">TAnimate等所有的动画类 ani</span><br><span class="line">TImageList等所有的图片列表类 il</span><br><span class="line">TImage等图片类 img</span><br><span class="line">TChart图表类 cht</span><br><span class="line">TComboBox, TDBComboBox等所有的下拉式列表框类 cbo</span><br><span class="line">TListBox, TDBList等所有的列表框类 lst</span><br><span class="line">TTreeView tv</span><br><span class="line">TListView lv</span><br><span class="line">THotKey hk</span><br><span class="line">TSplitter等所有的分隔符类 spt</span><br><span class="line">TOpenDialog等所有的对话框元件类 dlg</span><br><span class="line">TTable等所有的数据表类 tbl</span><br><span class="line">TQuery等所有的SQL查询类元件 qry</span><br><span class="line">TClientDataSet所有的客户数据集元件 cds</span><br><span class="line">TDataSource ds</span><br><span class="line">TDatabase db</span><br><span class="line">TSockConnection,TDCOMConnection等连接元件类 con</span><br><span class="line">TQuickRep, TFastReport等所有的报表元件类 rpt</span><br><span class="line">TDDEClientConv,TDDEClientItem等所有的DDE元件类 dde</span><br><span class="line">TMonthCalendar等所有的日历类 cal</span><br><span class="line">TGroupBox等控件类 grp</span><br><span class="line"></span><br><span class="line">Frm Form</span><br><span class="line">Mnu MainMenu, PopupMenu, MenuItem</span><br><span class="line">Lbl Label, DBLabel</span><br><span class="line">Edt Edit, Memo, DBEdit, DBMemo, MaskEdit</span><br><span class="line">Rtf RichEdit</span><br><span class="line">Btn Button (BitBtn, SpeedButton)</span><br><span class="line">Chk CheckBox, DBCheckBox</span><br><span class="line">Opt RadioButton</span><br><span class="line">Lst ListBoxes (e.g. TListBox)</span><br><span class="line">Cbx ComboBoxes (e.g. TComboBox)</span><br><span class="line">Sbr ScrollBar</span><br><span class="line">Grp GroupBox, RadioGroup, DBRadioGroup</span><br><span class="line">Pnl Panel</span><br><span class="line"></span><br><span class="line">Tvw TreeView</span><br><span class="line">Lvw ListView</span><br><span class="line">Iml ImageList</span><br><span class="line">Pge PageControl</span><br><span class="line">Trk TrackBar, RzTrackBar</span><br><span class="line">Pbr ProgressBar, RzProgressBar</span><br><span class="line">Sts StatusBar, RzStatusXxx</span><br><span class="line">Key HotKey</span><br><span class="line"></span><br><span class="line">Sbx ScrollBox</span><br><span class="line">Tab TabSet, TabControl</span><br><span class="line">Nbk Notebook</span><br><span class="line">Tbk TabbedNotebook</span><br><span class="line">Out Outline</span><br><span class="line">Grd StringGrid, DrawGrid, DBGrid, ColorGrid, DBCtrlGrid</span><br><span class="line">Img Image, DBImage</span><br><span class="line">Pbx PaintBox</span><br><span class="line">Shp Shape</span><br><span class="line">Bvl Bevel</span><br><span class="line">Hdr Header, HeaderControl</span><br><span class="line">Med MediaPlayer</span><br><span class="line"></span><br><span class="line">Dbs Database</span><br><span class="line">Tbl Table</span><br><span class="line">Qry Query</span><br><span class="line">Stp StoredProc</span><br><span class="line">Ses Session</span><br><span class="line">Sql UpdateSQL</span><br><span class="line">Src DataSource</span><br><span class="line">Bat BatchMove</span><br><span class="line">Rpt Report</span><br><span class="line">Nav DBNavigator</span><br><span class="line"></span><br><span class="line">Dlg Dialog Boxes (e.g. OpenDialog)</span><br><span class="line">Tmr Timer</span><br><span class="line">Ole OleContainer</span><br><span class="line">Dde DDE Controls (e.g. DdeClientConv)</span><br><span class="line">Vbx VBX Controls</span><br><span class="line">Ocx OCX Controls</span><br><span class="line">Gge Guage</span><br><span class="line">Spn SpinButton, UpDown</span><br><span class="line">Cal Calendar</span><br><span class="line"></span><br><span class="line">窗体：frm  </span><br></pre></td></tr></table></figure><p>注：有时文本编辑框缩写为<code>txt</code>，此为个人MFC、Qt编程之习惯。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;高中时期，有幸上过2节pascal的课，老师讲了一些英文（实为关键字和变量），介绍了二进制及其计算，然理解不透，遂弃之。&lt;br&gt;十几年后，因工作需要维护一个上个世纪的 delphi 工程，故学之，但已无甚意义，简记之，供自学用。  &lt;/p&gt;</summary>
    
    
    
    <category term="delphi" scheme="http://www.latelee.org/category/delphi/"/>
    
    
    <category term="delphi" scheme="http://www.latelee.org/tag/delphi/"/>
    
  </entry>
  
  <entry>
    <title>delphi界面开发基础</title>
    <link href="http://www.latelee.org/delphi/delphi-notes-2.html"/>
    <id>http://www.latelee.org/delphi/delphi-notes-2.html</id>
    <published>2020-07-04T16:00:00.000Z</published>
    <updated>2020-12-03T03:00:04.884Z</updated>
    
    <content type="html"><![CDATA[<p>高中时期，有幸上过2节pascal的课，老师讲了一些英文（实为关键字和变量），介绍了二进制及其计算，然理解不透，遂弃之。<br>十几年后，因工作需要维护一个上个世纪的 delphi 工程，故学之，但已无甚意义，简记之，供自学用。  </p><a id="more"></a><h1 id="IDE相关"><a href="#IDE相关" class="headerlink" title="IDE相关"></a>IDE相关</h1><p>Delphi 7，可在xp、win7、win10上运行。  </p><h2 id="控制选择"><a href="#控制选择" class="headerlink" title="控制选择"></a>控制选择</h2><p>鼠标选择。ctrl+光标：小移动。ctrl+shift+光标：较大移动。<br>对齐：右键–&gt;Position-&gt;Align，再选择。注：似乎没有快捷方式。 </p><p>单元代码和控件界面：F12  </p><p>Debug 和 Release 的切换方法:<br>进入 Project Manager -&gt; Build Configurations, 在 Debug 或 Release 上双击, 或从右键 Activate。  </p><p>按Altr+鼠标选择，列模式（和notepad++相同）。  </p><h1 id="界面开发"><a href="#界面开发" class="headerlink" title="界面开发"></a>界面开发</h1><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>各简单控件使用、属性等，弹出窗口，多窗口显示，logo，标题，最大/小化。退出程序。对话框弹出。<br>状态栏  OK<br>菜单 OK<br>多面板<br>树形 OK<br>列表框<br>上下框 OK<br>菜单栏下的图标<br>按键响应（上下左右）</p><p>图片显示<br>socket </p><h2 id="初始化、退出"><a href="#初始化、退出" class="headerlink" title="初始化、退出"></a>初始化、退出</h2><p>initialization：在单元中放在文件结尾前，初始化，只运行一次。<br>finalization：在单元中放在 <code>initialization</code> 和 <code>end.</code> 之间，退出时运行一次。  </p><p>窗体自动初始化：窗体界面，选<code>OnCreate</code>事件，一般函数名为<code>FormCreate</code>。在<code>Create</code>时会自动调用，即进入窗体时最选被调用。<br>手动初始化：窗体实现代码，自定义<code>Init</code>函数，在创建窗体时后，调用之。  </p><h2 id="布局相关"><a href="#布局相关" class="headerlink" title="布局相关"></a>布局相关</h2><p>对齐：alCustom，alNone：可自由拖动。但是其它的类型是自动的。有时不小心会乱，需要关闭但不保存。<br>可以在左侧拖动控件到某个页面（如panel)，可理解为控件也有层次。  </p><h2 id="控件事件及描述"><a href="#控件事件及描述" class="headerlink" title="控件事件及描述"></a>控件事件及描述</h2><p>常用重要的：<br>窗体控件事件：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OnCreate  建立事件，窗件或控件第一次建立时发生。OnCreate事件只发生一次，用来执行初始化任务  </span><br><span class="line">OnShow  窗体或控件显示出来之前发生的事件</span><br><span class="line">OnHide  窗体或控件隐藏时触发的事件</span><br><span class="line">OnClose和OnCloseQuery  当关闭一个窗体时就会响应OnClose和OnCloseQuery事件 ，OnCloseQuery事件比OnClose具有更高的优先级。</span><br><span class="line"></span><br><span class="line">窗体初始化：窗体界面，选 OnCreate 事件，输入 FormCreate，即可。  </span><br><span class="line">图片控件：有OnMouseEnter和OnMouseLeave事件。  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>备忘：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">OnActive  焦点称到窗体或控件时发生</span><br><span class="line">OnClick  鼠标单击事件</span><br><span class="line">OnDbClick  鼠标双击事件</span><br><span class="line">OnClose和OnCloseQuery  当关闭一个窗体时就会响应OnClose和OnCloseQuery事件 ，OnCloseQuery事件比OnClose具有更高的优先级。</span><br><span class="line">OnContextPopup  在窗体上单击鼠标右键时触发</span><br><span class="line">OnCreate  建立事件，窗件或控件第一次建立时发生。OnCreate事件只发生一次，用来执行初始化任务</span><br><span class="line">OnDeactivate  从当前程序切换到另一个应用程序时发生</span><br><span class="line">OnDestroy  卸载窗体或控件时被触发，用来清除窗体或控件所占的内存，或者其他的收尾工作</span><br><span class="line">nDragDrop和OnDragOver  如果有外部对象被拖放到控件上时触发</span><br><span class="line">OnMouseDown和OnMouseUp  响应鼠标在控件上的按下鼠标、释放鼠标的事件</span><br><span class="line">OnMouseMove  鼠标在控件上移动时被触发的事件</span><br><span class="line">OnHide  窗体或控件隐藏时触发的事件</span><br><span class="line">OnKeyDown、OnKeyPress、OnKeyUp  响应键盘事件</span><br><span class="line">OnPaint  窗体或控件需要重画时发生</span><br><span class="line">OnResize  窗体或控件调整大小时被触发的事件。当使用极大化、极小化按钮时此事件也会被触发</span><br><span class="line"></span><br><span class="line">OnMeasureItem  在ComboBox控件中改变选择项时发生的事件</span><br><span class="line">OnChange  在文本框、Image、ScrollBar等控件中的值被改变时发生</span><br><span class="line">OnScroll  拖动滚动条时被触发</span><br><span class="line">OnBandDrag和OnBandMove  当ControlBar内的对象被拖动和移动时触发</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>新建工程类型： VCL Forms Application。  </p><p>默认工程名为Project1，dpr中有<code>program Project1</code>，另dpr、res文件名称保持一致，否则编译不通过。<br>如果修改 exe 文件名称，则系统状态栏名称亦会变化。  </p><p>已定的控件名称（即加了响应代码），如修改之，则代码（函数名）会即时变化，不需手动改。  </p><p>self不需要定义，可直接使用，如<code>self.Text</code>为窗口标题。  </p><p>字符串及资源文件，在pas源码定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">resourcestring</span><br><span class="line">  Str这是变量 &#x3D; &#39;这是显示的字符串，是吗？&#39;;</span><br></pre></td></tr></table></figure><p>会被编译到 drc 文件中，形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define &lt;单元名称&gt;_Str这是变量 638438</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;高中时期，有幸上过2节pascal的课，老师讲了一些英文（实为关键字和变量），介绍了二进制及其计算，然理解不透，遂弃之。&lt;br&gt;十几年后，因工作需要维护一个上个世纪的 delphi 工程，故学之，但已无甚意义，简记之，供自学用。  &lt;/p&gt;</summary>
    
    
    
    <category term="delphi" scheme="http://www.latelee.org/category/delphi/"/>
    
    
    <category term="delphi" scheme="http://www.latelee.org/tag/delphi/"/>
    
  </entry>
  
  <entry>
    <title>delphi界面分类笔记</title>
    <link href="http://www.latelee.org/delphi/delphi-notes-3.html"/>
    <id>http://www.latelee.org/delphi/delphi-notes-3.html</id>
    <published>2020-07-04T16:00:00.000Z</published>
    <updated>2020-12-03T03:00:04.884Z</updated>
    
    <content type="html"><![CDATA[<p>高中时期，有幸上过2节pascal的课，老师讲了一些英文（实为关键字和变量），介绍了二进制及其计算，然理解不透，遂弃之。<br>十几年后，因工作需要维护一个上个世纪的 delphi 工程，故学之，但已无甚意义，简记之，供自学用。  </p><a id="more"></a><h2 id="简单控件"><a href="#简单控件" class="headerlink" title="简单控件"></a>简单控件</h2><h2 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h2><p>Standard 选 MainMenu，放置合适位置，右键 <code>Menu Designer...</code>，点击虚线框直接输入显示的标题，可改名称，注意，名称需加前缀，否则容易和其它控件冲突。<br>在设计界面，单击菜单某项，即可编辑代码。<br>如需要<code>-</code>间隔，在Caption处输入<code>-</code>即可。<br>二级菜单快捷键：点击某项，在ShortCut选择快捷键，或手动输入类似<code>Ctrl+A</code>之类的。默认<code>Alt</code>比较少，可以直接输入。    </p><h2 id="状态栏"><a href="#状态栏" class="headerlink" title="状态栏"></a>状态栏</h2><p>Win32 选 StatusBar，自动到底部，可调整高度。<br>右键控件，选第一项 <code>Panels Editor...</code>，点第一图标新加，名为<code>Panels[0]</code>，可新加，依次为<code>Panels[1]</code>等。可设置文字对齐、方向，显示文字（此刻文字不等同于后续显示文字），等。<br>使用：<code>stsInfo.Panels[0].Text := &#39;显示内容&#39;;</code></p><h2 id="树形"><a href="#树形" class="headerlink" title="树形"></a>树形</h2><p>Win32 选 TreeView。<br>代码：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var</span><br><span class="line">  rootNode, subNode, personNode, mateNode, tmpNode: TTreeNode;</span><br><span class="line">begin</span><br><span class="line">  rootNode :&#x3D; TreeView1.Items.Add(nil, &#39;树根&#39;); &#x2F;&#x2F; 根节点</span><br><span class="line">  subNode :&#x3D; TreeView1.Items.AddChild(rootNode, &#39;伯 节点1&#39;); &#x2F;&#x2F; 其下节点</span><br><span class="line">  personNode :&#x3D; TreeView1.Items.AddChild(subNode, &#39;节节点1&#39;);</span><br><span class="line">  mateNode :&#x3D; TreeView1.Items.AddChild(personNode, &#39;节节节点1&#39;);</span><br><span class="line">  mateNode :&#x3D; TreeView1.Items.AddChild(personNode, &#39;节节节点2&#39;);</span><br><span class="line">  personNode :&#x3D; TreeView1.Items.AddChild(subNode, &#39;节节点2&#39;);</span><br><span class="line">  mateNode :&#x3D; TreeView1.Items.AddChild(personNode, &#39;节节节点1&#39;);</span><br><span class="line">  mateNode :&#x3D; TreeView1.Items.AddChild(personNode, &#39;节节节点2&#39;);</span><br><span class="line">  </span><br><span class="line">  subNode :&#x3D; TreeView1.Items.AddChild(rootNode, &#39;仲 节点2&#39;);</span><br><span class="line">  personNode :&#x3D; TreeView1.Items.AddChild(subNode, &#39;节节点1&#39;);</span><br><span class="line">  mateNode :&#x3D; TreeView1.Items.AddChild(personNode, &#39;节节节点1&#39;);</span><br><span class="line">  mateNode :&#x3D; TreeView1.Items.AddChild(personNode, &#39;节节节点2&#39;);</span><br><span class="line">  personNode :&#x3D; TreeView1.Items.AddChild(subNode, &#39;节节点2&#39;);</span><br><span class="line">  mateNode :&#x3D; TreeView1.Items.AddChild(personNode, &#39;节节节点1&#39;);</span><br><span class="line">  mateNode :&#x3D; TreeView1.Items.AddChild(personNode, &#39;节节节点2&#39;);</span><br></pre></td></tr></table></figure><h2 id="多页面-PageControl"><a href="#多页面-PageControl" class="headerlink" title="多页面 PageControl"></a>多页面 PageControl</h2><p>Win32 选 PageControl。右键控件 New Page，可添加子页面（即TabSheet）。左键TabSheet标题可选之。<br>右键控件页面（可理解为TabSheet）删除子页面。</p><pre><code>PageControl1: TPageControl;TabSheet1: TTabSheet;TabSheet2: TTabSheet;</code></pre><p>注：直接在 PageControl 控件上添加其它控件即可，与其它地方无异。不需像 MFC 那边添加到面板上。  </p><h2 id="Panel"><a href="#Panel" class="headerlink" title="Panel"></a>Panel</h2><p>如果在设计界面上看不到全部的，可以右键选下一面查看。  </p><h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><p>默认没有 tcp 和 udp 控件。component-&gt;Install Packets，点击 Add，选择 delphi 安装目录bin子目录下，文件名为dclsockets70.bpl(注：delphi2010是dclsockets140.bpl)，控件有 Internet，上有 ClientSocket、ServerSocket、 TcpClient(TTcpClient)、TcpServer(TTcpServer)、UdpServer</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;高中时期，有幸上过2节pascal的课，老师讲了一些英文（实为关键字和变量），介绍了二进制及其计算，然理解不透，遂弃之。&lt;br&gt;十几年后，因工作需要维护一个上个世纪的 delphi 工程，故学之，但已无甚意义，简记之，供自学用。  &lt;/p&gt;</summary>
    
    
    
    <category term="delphi" scheme="http://www.latelee.org/category/delphi/"/>
    
    
    <category term="delphi" scheme="http://www.latelee.org/tag/delphi/"/>
    
  </entry>
  
  <entry>
    <title>delphi开发实践记录</title>
    <link href="http://www.latelee.org/delphi/delphi-notes-4.html"/>
    <id>http://www.latelee.org/delphi/delphi-notes-4.html</id>
    <published>2020-07-04T16:00:00.000Z</published>
    <updated>2020-12-03T03:00:04.884Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录用delphi开发过程做了的事，对其它语言开发可能有启发。  </p><a id="more"></a><h2 id="模块小结"><a href="#模块小结" class="headerlink" title="模块小结"></a>模块小结</h2><p>添加快捷键。<br>可提高软件使用效率。把常用的菜单功能分别映射了快捷键，在设计界面选择对应的菜单项，选择需要映射的快捷键，如系统没有的，可直接输入。</p><p>默认选择某数据库表最新版本。<br>原设计默认使用表的最旧版本（即按顺序查询，选第一项），实际使用为最新版本，每次需切换，后改之。  </p><p>去掉小窗口设置选项。<br>原设计，每种数据表都需进入小窗口进行设置，在保存之后生效。表格约14个，较耗时。后改之，为保持原有用户习惯，仅将“点击窗口，设置，保存”三个步骤自动化调用。即点击窗口依然调用窗体创建函数，但不显示。将设置项放置外界面，新加并调用窗体设置函数，完成。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文记录用delphi开发过程做了的事，对其它语言开发可能有启发。  &lt;/p&gt;</summary>
    
    
    
    <category term="delphi" scheme="http://www.latelee.org/category/delphi/"/>
    
    
    <category term="delphi" scheme="http://www.latelee.org/tag/delphi/"/>
    
  </entry>
  
  <entry>
    <title>x86平台接口知识</title>
    <link href="http://www.latelee.org/firmware-bios/x86-platform-interface-note.html"/>
    <id>http://www.latelee.org/firmware-bios/x86-platform-interface-note.html</id>
    <published>2020-07-01T15:47:00.000Z</published>
    <updated>2020-12-03T03:00:04.804Z</updated>
    
    <content type="html"><![CDATA[<p>临时记录，待整理。</p><a id="more"></a><h2 id="一、串口了解"><a href="#一、串口了解" class="headerlink" title="一、串口了解"></a>一、串口了解</h2><p>参考 F81865 芯片手册 2010年，v0.28p。该芯片功能较多，如 GPIO、WDT、FAN、UART，等等。  </p><p>P69 介绍寄存器及访问方式。<br>索引端口为 0x4e，数据端口为 0x4f。也可改为 0x2e/0x2f（把SOUT1引脚拉低）。<br>使能配置，需要向 0x4e 写 0x87（2次），禁止则写 0xaa。<br>2个端口地址配合使用。如获取某个寄存器（索引），先向0x4e写索引值，再读0x4f。 </p><p>P73~P75 介绍串口寄存器。其中，UART1 的 0x60/0x61寄存器分别为高低地址，其默认值分别为0x03、0xf8。合起来为 0x3f8，这个值在 pc 上其实可以查询到。（注：笔者查阅过几个不同的类似芯片，其 UART1 的地址均为0x3f8）<br>类似，UART2：0x2f8，UART3：0x3e8，UART4：0x2e8。（注：UART5、UART6默认值为0，不知何故）  </p><p>P34 开始介绍具体串口寄存器。以 UART1 为例，偏移量为 0 为读写寄存器（存疑：或是读写端口？）。一般说 0x3f8，就是 UART1 的数据端口。默认情况，UART1 端口地址范围为 0x3f8~0x3ff。  </p><p>这种通过某寄存器获取基地址，再通过基地址+偏移量的访问方式，在 PCIE 设备中比较常见。  </p><h2 id="F81866手册理解"><a href="#F81866手册理解" class="headerlink" title="F81866手册理解"></a>F81866手册理解</h2><p>P116介绍寄存器及访问方式。<br>基地址 base 为0x4e或0x2e。<br>进入配置模式（或使能）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">outb(0x87, base);</span><br><span class="line">outb(0x87, base);</span><br></pre></td></tr></table></figure><p>获取0x23/0x24，得到厂商ID（即fintek，依次为0x1934)，0x20/0x21，得到芯片型号ID（依次为0x1010）。  </p><h2 id="二、SMBus"><a href="#二、SMBus" class="headerlink" title="二、SMBus"></a>二、SMBus</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;临时记录，待整理。&lt;/p&gt;</summary>
    
    
    
    <category term="嵌入式底层BIOS" scheme="http://www.latelee.org/category/firmware-bios/"/>
    
    
    <category term="微机知识" scheme="http://www.latelee.org/tag/%E5%BE%AE%E6%9C%BA%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>北斗系统学习：JTT808协议初步解析</title>
    <link href="http://www.latelee.org/my-study/beidou-system-jtt808.html"/>
    <id>http://www.latelee.org/my-study/beidou-system-jtt808.html</id>
    <published>2020-06-26T15:36:00.000Z</published>
    <updated>2020-12-03T03:00:04.812Z</updated>
    
    <content type="html"><![CDATA[<p>本文学习部标（交通运输部）JT/T 808，并使用 Golang 语言解析。当然，仅使用位置数据进行演示，所以只是一个开端（是否有后续，暂未知）。本文不是科普，因此不会详细列出协议字段说明，可参考文后给出的资料。  </p><a id="more"></a><h2 id="技术总结"><a href="#技术总结" class="headerlink" title="技术总结"></a>技术总结</h2><ul><li>协议还算容易阅读，对于曾经做过嵌入式开发，阅读过较多手册和标准的人来说不困难。  </li><li>可用多种语言解析，解析时需要注意传输模式（大端方式），要了解移位，了解精度计算等等。  </li><li>发送消息时，先对消息进行封装，计算校验码，最后进行转义，再发送。  </li><li>接收消息时，先对整体数据包转义还原数据，验证校验码，最后解析消息。  </li></ul><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>本文关注 2013 年版本的 JT/T 808 协议，最新版本是 JT/T 808-2019，由于 2013 年版本资料较多，而笔者目前未有实物验证，故采用之。  </p><h3 id="协议理解"><a href="#协议理解" class="headerlink" title="协议理解"></a>协议理解</h3><p>协议传输使用大端方式。<br>数据类型有：BYTE、WORD、DWORD、<code>BYTE[n]</code>、<code>BCD[n]</code>、STRING（GBK编码），等。<br>消息结构为：<code>标识位 消息头 消息体 校验码 标识位</code>。<br>一个完整的包使用0x7e标识，即包的第一个字节为0x7e，包的最后一个字节亦为0x7e。包中数据出现0x7e，则需转义。即将0x7e使用<code>0x7d 0x02</code>替换。这里引入了0x7d，因此该数值也要转义，即将0x7d使用<code>0x7d 0x01</code>替换。转义后再发送。接收到数据包时，需要进行还原，才能解析。<br>校验码计算较简单，将前后的标识0x7e及校验码自身去掉，其它数据进行异或计算即可，占一字节。<br>消息头中的手机号（终端手机号）为 12 字节，如果不足，在前面补 0。<br>经纬度精度为小数点后6位，即百万分之一度。如 0x021FD934，十进制为 ‭35641652‬，即表示 35.641652 度。<br>协议约定缺省使用 TCP 通信方式，不过笔者看过较多的模块一般使用串口或 IIC 通信，内情如何暂不得而知。  </p><h3 id="版本差别"><a href="#版本差别" class="headerlink" title="版本差别"></a>版本差别</h3><p>消息头<br>2013 版本消息头为 12 字节或 16 字节，2019 版本多了 5 个字节，1 个字节的协议版本号(初始为 1 ，关键修改递增)，终端手机号多了 4 字节的 BCD 码。  </p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>工具类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 校验码，数据异或</span><br><span class="line">func CheckSum(buff []byte) (ret byte) &#123;</span><br><span class="line">trueret &#x3D; buff[0] &#x2F;&#x2F; 取第0个，从第1个开始异或</span><br><span class="line">truefor i :&#x3D; 1; i &lt; len(buff); i++ &#123;</span><br><span class="line">truetrueret &#x3D; ret ^ buff[i]</span><br><span class="line">true&#125;</span><br><span class="line">truereturn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将收到的报文转义</span><br><span class="line">func DecodeMsg(buff []byte) []byte &#123;</span><br><span class="line">    ret :&#x3D; make([]byte, len(buff)) &#x2F;&#x2F; 保持原长度</span><br><span class="line">truei :&#x3D; 0</span><br><span class="line">    &#x2F;&#x2F; j从1开始，表示去掉了头部的0x74，如果传入的不带标识符，可从0开始，长度少1亦然</span><br><span class="line">truefor j :&#x3D; 1; j &lt; len(buff)-1; j++ &#123;</span><br><span class="line">truetrueif j+1 &gt;&#x3D; len(buff) &#123;</span><br><span class="line">truetruetrueret[i] &#x3D; buff[j]</span><br><span class="line">            i++</span><br><span class="line">truetrue&#125; else &#123;</span><br><span class="line">truetruetrueif buff[j] &#x3D;&#x3D; 0x7d &amp;&amp; buff[j+1] &#x3D;&#x3D; 0x01 &#123;</span><br><span class="line">                ret[i] &#x3D; 0x7d</span><br><span class="line">                i++</span><br><span class="line">truetruetruetruej++</span><br><span class="line">truetruetrue&#125; else if buff[j] &#x3D;&#x3D; 0x7d &amp;&amp; buff[j+1] &#x3D;&#x3D; 0x02 &#123;</span><br><span class="line">truetruetruetrueret[i] &#x3D; 0x7e</span><br><span class="line">                i++</span><br><span class="line">truetruetruetruej++</span><br><span class="line">truetruetrue&#125; else &#123;</span><br><span class="line">                ret[i] &#x3D; buff[j]</span><br><span class="line">                i++</span><br><span class="line">truetruetrue&#125;</span><br><span class="line">truetrue&#125;</span><br><span class="line">true&#125;</span><br><span class="line">    if buff[i] &#x3D;&#x3D; 0x7e &#123;</span><br><span class="line">        i -&#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">truereturn ret[:i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将发送的报文转义</span><br><span class="line">func EncodeMsg(buff []byte) []byte &#123;</span><br><span class="line">trueret :&#x3D; make([]byte, len(buff)*2+2) &#x2F;&#x2F; 不会超过此处，头尾为2，假设都转义，*2</span><br><span class="line">truei :&#x3D; 0</span><br><span class="line">    ret[i] &#x3D; 0x7e</span><br><span class="line">    i +&#x3D; 1</span><br><span class="line">truefor j :&#x3D; 0; j &lt; len(buff); j++ &#123;</span><br><span class="line">truetrueif buff[j] &#x3D;&#x3D; 0x7e &#123;</span><br><span class="line">            ret[i] &#x3D; 0x7d</span><br><span class="line">            i +&#x3D; 1</span><br><span class="line">            ret[i] &#x3D; 0x02</span><br><span class="line">            i +&#x3D; 1</span><br><span class="line">truetrue&#125; else if buff[j] &#x3D;&#x3D; 0x7d &#123;</span><br><span class="line">truetruetrueret[i] &#x3D; 0x7d</span><br><span class="line">            i +&#x3D; 1</span><br><span class="line">            ret[i] &#x3D; 0x01</span><br><span class="line">            i +&#x3D; 1</span><br><span class="line">truetrue&#125; else &#123;</span><br><span class="line">truetruetrueret[i] &#x3D; buff[j]</span><br><span class="line">            i +&#x3D; 1</span><br><span class="line">truetrue&#125;</span><br><span class="line">true&#125;</span><br><span class="line">trueret[i] &#x3D; 0x7e</span><br><span class="line">    i +&#x3D; 1</span><br><span class="line">truereturn ret[:i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 检测包是否合法</span><br><span class="line">&#x2F;&#x2F; 注：传入此函数的，应该是一个包，不考虑粘包情况</span><br><span class="line">func CheckPacket(bin []byte) ([]byte, error) &#123;</span><br><span class="line">    blen :&#x3D; len(bin)</span><br><span class="line">    if blen &lt; 13 &#123; &#x2F;&#x2F; TODO：2019标准比13大</span><br><span class="line">        return nil, errors.New(&quot;not enough length &lt; 13&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if bin[0] !&#x3D; 0x7e &amp;&amp; bin[blen-1] !&#x3D; 0x7e &#123;</span><br><span class="line">        return nil, errors.New(&quot;no 0x7e found&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bin &#x3D; DecodeMsg(bin) &#x2F;&#x2F; 去掉头尾的0x7e</span><br><span class="line"></span><br><span class="line">    blen &#x3D; len(bin) &#x2F;&#x2F; 重新计算长度</span><br><span class="line">    cksum :&#x3D; CheckSum(bin[:blen-1]) &#x2F;&#x2F; 最后一字节是校验码，不用计算</span><br><span class="line">    if cksum !&#x3D; bin[blen-1] &#123;</span><br><span class="line">        return nil, errors.New(fmt.Sprintf(&quot;Checksum failed calc 0x%x !&#x3D; org 0x%x&quot;, cksum, bin[blen-1]))</span><br><span class="line">    &#125;</span><br><span class="line">    return bin, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func ParsePacket(bin []byte) (map[string]interface&#123;&#125;, error) &#123; </span><br><span class="line">    array :&#x3D; make(map[string]interface&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    bin, err :&#x3D; CheckPacket(bin)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        log.Println(&quot;check failed:&quot;, err.Error())</span><br><span class="line">        return nil, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buf :&#x3D; com.NewBufferReader(bin)</span><br><span class="line">    id :&#x3D; buf.ReadUint16BE()</span><br><span class="line">    array[&quot;id&quot;] &#x3D; id</span><br><span class="line">    </span><br><span class="line">    var tmp int &#x3D; 0</span><br><span class="line">    tmp &#x3D; int(buf.ReadUint16BE())</span><br><span class="line"></span><br><span class="line">    array[&quot;datalen&quot;] &#x3D; int(tmp &amp; 0x3ff)</span><br><span class="line">    array[&quot;crypt&quot;] &#x3D; (tmp&gt;&gt;10) &amp; 0x07  &#x2F;&#x2F; 0：不加密 1：RSA，其它保留</span><br><span class="line">    array[&quot;split&quot;] &#x3D; (tmp&gt;&gt;13) &amp; 0x01</span><br><span class="line">    &#x2F;&#x2F; 保留2比特</span><br><span class="line">    log.Println(&quot;len: &quot;, len(bin))</span><br><span class="line">    </span><br><span class="line">    headLen :&#x3D; 12 &#x2F;&#x2F; 消息头至少12字节</span><br><span class="line">    if array[&quot;split&quot;].(int) &#x3D;&#x3D; 1 &#123; &#x2F;&#x2F; 分包，分包项共4字节</span><br><span class="line">        headLen +&#x3D; 4</span><br><span class="line">        </span><br><span class="line">        array[&quot;splittotal&quot;] &#x3D; buf.ReadUint16BE()</span><br><span class="line">        array[&quot;splitnum&quot;] &#x3D; buf.ReadUint16BE()</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 消息体 消息头 校验码，即为数据长度</span><br><span class="line">    totalLen :&#x3D; array[&quot;datalen&quot;].(int) + headLen + 1</span><br><span class="line">    if totalLen !&#x3D; len(bin) &#123;</span><br><span class="line">        return nil, errors.New(fmt.Sprintf(&quot;package length not ok, calc %d !&#x3D; org %d&quot;, totalLen, len(bin)))</span><br><span class="line">    &#125;</span><br><span class="line">    array[&quot;phonenum&quot;] &#x3D; buf.ReadBCDString(6)</span><br><span class="line">    array[&quot;serialno&quot;] &#x3D; int(buf.ReadUint16BE())</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    switch id &#123;</span><br><span class="line">    case 0x200: &#x2F;&#x2F; 位置信息汇报</span><br><span class="line">        &#x2F;&#x2F; 基本信息</span><br><span class="line">        tmp :&#x3D; buf.ReadUint32BE()</span><br><span class="line">        array[&quot;alarm&quot;] &#x3D; tmp</span><br><span class="line">        &#x2F;&#x2F; 解析警告信息</span><br><span class="line">        alarmMsg :&#x3D; &quot;&quot;</span><br><span class="line">        var j &#x3D; 0</span><br><span class="line">        if (tmp&gt;&gt;0) &amp; 0x01 &#x3D;&#x3D; 1 &#123;</span><br><span class="line">            if j !&#x3D; 0 &#123;</span><br><span class="line">                alarmMsg +&#x3D; &quot; &quot;</span><br><span class="line">            &#125;</span><br><span class="line">            j++</span><br><span class="line">            alarmMsg +&#x3D; &quot;紧急报警&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        if (tmp&gt;&gt;1) &amp; 0x01 &#x3D;&#x3D; 1 &#123;</span><br><span class="line">            if j !&#x3D; 0 &#123;</span><br><span class="line">                alarmMsg +&#x3D; &quot; &quot;</span><br><span class="line">            &#125;</span><br><span class="line">            j++</span><br><span class="line">            alarmMsg +&#x3D; &quot;超速报警&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; more...</span><br><span class="line">        array[&quot;alarmMsg&quot;] &#x3D; alarmMsg</span><br><span class="line">        </span><br><span class="line">        tmp&#x3D; buf.ReadUint32BE()</span><br><span class="line">        array[&quot;status&quot;] &#x3D; tmp</span><br><span class="line">        &#x2F;&#x2F; 解析状态标志</span><br><span class="line">        if (tmp&gt;&gt;0) &amp; 0x01 &#x3D;&#x3D; 1 &#123;</span><br><span class="line">            array[&quot;ACC&quot;] &#x3D; &quot;on&quot;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            array[&quot;ACC&quot;] &#x3D; &quot;off&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 定位或未定位</span><br><span class="line">        if (tmp&gt;&gt;1) &amp; 0x01 &#x3D;&#x3D; 1 &#123;</span><br><span class="line">            array[&quot;locate&quot;] &#x3D; &quot;on&quot;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            array[&quot;locate&quot;] &#x3D; &quot;off&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        if (tmp&gt;&gt;1) &amp; 0x01 &#x3D;&#x3D; 1 &#123;</span><br><span class="line">            array[&quot;locate&quot;] &#x3D; &quot;on&quot;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            array[&quot;locate&quot;] &#x3D; &quot;off&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 南北纬</span><br><span class="line">        if (tmp&gt;&gt;2) &amp; 0x01 &#x3D;&#x3D; 1 &#123;</span><br><span class="line">            array[&quot;latflag&quot;] &#x3D; &quot;south&quot;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            array[&quot;latflag&quot;] &#x3D; &quot;north&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 东西经</span><br><span class="line">        if (tmp&gt;&gt;3) &amp; 0x01 &#x3D;&#x3D; 1 &#123;</span><br><span class="line">            array[&quot;lonflag&quot;] &#x3D; &quot;east&quot;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            array[&quot;lonflag&quot;] &#x3D; &quot;west&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 使用的定位系统</span><br><span class="line">        if (tmp&gt;&gt;18) &amp; 0x01 &#x3D;&#x3D; 1 &#123;</span><br><span class="line">            array[&quot;locatstyle&quot;] &#x3D; &quot;GPS&quot;</span><br><span class="line">        &#125; else if (tmp&gt;&gt;19) &amp; 0x01 &#x3D;&#x3D; 1&#123;</span><br><span class="line">            array[&quot;locatstyle&quot;] &#x3D; &quot;BD&quot;</span><br><span class="line">        &#125; else if (tmp&gt;&gt;20) &amp; 0x01 &#x3D;&#x3D; 1&#123;</span><br><span class="line">            array[&quot;locatstyle&quot;] &#x3D; &quot;GLONASS&quot;</span><br><span class="line">        &#125; else if (tmp&gt;&gt;21) &amp; 0x01 &#x3D;&#x3D; 1&#123;</span><br><span class="line">            array[&quot;locatstyle&quot;] &#x3D; &quot;Galileo&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        array[&quot;latitude&quot;] &#x3D; com.ToFixed(buf.ReadUint32BE(), 6)</span><br><span class="line">        array[&quot;longitude&quot;] &#x3D; com.ToFixed(buf.ReadUint32BE(), 6)</span><br><span class="line">        array[&quot;altitude&quot;] &#x3D; int(buf.ReadUint16BE())</span><br><span class="line">        array[&quot;speed&quot;] &#x3D; com.ToFixed(buf.ReadUint16BE(), 1)</span><br><span class="line">        array[&quot;direction&quot;] &#x3D; int(buf.ReadUint16BE())</span><br><span class="line">        array[&quot;time&quot;] &#x3D; buf.ReadBCDString(6)</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 附加信息</span><br><span class="line">    </span><br><span class="line">    default:</span><br><span class="line">        break;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    log.Printf(&quot;array:\n%##v\n&quot;, array)</span><br><span class="line">    </span><br><span class="line">    return array, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="源码说明"><a href="#源码说明" class="headerlink" title="源码说明"></a>源码说明</h3><p>关于数据转义函数的实现，可使用<code>bytes.Buffer&#123;&#125;、WriteByte()</code>方式，但测试发现较耗时，不知直接使用数组方便。另外，不使用<code>for...range</code>方式，而是直接使用索引，因为不需要进行拷贝。<br>读取 1 、2、4 字节函数已封装好，读取 BCD 码及精确计算等函数，也封装好。<br>解析函数使用 map 存储，根据不同消息类型进行解析赋值。  </p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>使用如下位置数据测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7E0200003C064808354296023D0000000000080042021FD9340722758000110260013A17082514425701040004329202020000030200002504000000002B0400000000300111310114777E1C007E</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;ACC&quot;:&quot;off&quot;,</span><br><span class="line">    &quot;alarm&quot;:0x0,</span><br><span class="line">    &quot;alarmMsg&quot;:&quot;&quot;,</span><br><span class="line">    &quot;altitude&quot;:17,</span><br><span class="line">    &quot;crypt&quot;:0,</span><br><span class="line">    &quot;datalen&quot;:60,</span><br><span class="line">    &quot;direction&quot;:314,</span><br><span class="line">    &quot;id&quot;:0x200,</span><br><span class="line">    &quot;latflag&quot;:&quot;north&quot;,</span><br><span class="line">    &quot;latitude&quot;:&quot;35.641652&quot;,</span><br><span class="line">    &quot;locate&quot;:&quot;on&quot;, &#x2F;&#x2F; 定位</span><br><span class="line">    &quot;locatstyle&quot;:&quot;BD&quot;, &#x2F;&#x2F; 使用北斗系统定位</span><br><span class="line">    &quot;lonflag&quot;:&quot;west&quot;,</span><br><span class="line">    &quot;longitude&quot;:&quot;119.698816&quot;,</span><br><span class="line">    &quot;phonenum&quot;:&quot;064808354296&quot;,</span><br><span class="line">    &quot;serialno&quot;:573,</span><br><span class="line">    &quot;speed&quot;:&quot;60.8&quot;,</span><br><span class="line">    &quot;split&quot;:0,</span><br><span class="line">    &quot;status&quot;:0x80042,</span><br><span class="line">    &quot;time&quot;:&quot;170825144257&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="未完事宜"><a href="#未完事宜" class="headerlink" title="未完事宜"></a>未完事宜</h2><p>其它类型的解析，参考手册即可。数据的解析仅是其中一小部分，主要的工作，还是在与模块之间的交互，如心跳、鉴权等。不过这些暂时未涉及。  </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/hylexus/article/details/54987786">https://blog.csdn.net/hylexus/article/details/54987786</a><br><a href="https://blog.csdn.net/baidu_32523857/article/details/82787485">https://blog.csdn.net/baidu_32523857/article/details/82787485</a><br><a href="https://blog.csdn.net/Occidentalior/article/details/73901830">https://blog.csdn.net/Occidentalior/article/details/73901830</a><br><a href="https://github.com/gldsly/jtt808_demo">https://github.com/gldsly/jtt808_demo</a><br><a href="https://github.com/niuyn/Jt808">https://github.com/niuyn/Jt808</a>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文学习部标（交通运输部）JT/T 808，并使用 Golang 语言解析。当然，仅使用位置数据进行演示，所以只是一个开端（是否有后续，暂未知）。本文不是科普，因此不会详细列出协议字段说明，可参考文后给出的资料。  &lt;/p&gt;</summary>
    
    
    
    <category term="技术杂铺" scheme="http://www.latelee.org/category/my-study/"/>
    
    
    <category term="beidou" scheme="http://www.latelee.org/tag/beidou/"/>
    
  </entry>
  
  <entry>
    <title>北斗系统学习：概述</title>
    <link href="http://www.latelee.org/my-study/beidou-system-note1.html"/>
    <id>http://www.latelee.org/my-study/beidou-system-note1.html</id>
    <published>2020-06-26T15:00:00.000Z</published>
    <updated>2020-12-03T03:00:04.812Z</updated>
    
    <content type="html"><![CDATA[<p>近日（6月23日），随着北斗三号最后一颗全球组网卫星成功发射，北斗三号收官，正式服务全球。虽然还没用上北斗，但提前了解这个系统，对技术提高有帮助。<br>本篇介绍笔者学习北斗系统过程收集到的一些资料，是按笔者一贯学习新知识的思路来进行的。  </p><a id="more"></a><h2 id="技术总结"><a href="#技术总结" class="headerlink" title="技术总结"></a>技术总结</h2><ul><li>了解基本术语和知识，如了解GNSS，知道全球有哪些定位系统。  </li><li>了解涉及到的协议。  </li><li>到某宝了解相关产品，了解可以应用的场合。  </li><li>其它：了解当前可用的场合，设备等。  </li></ul><p>北斗系统对于我国的军事和民生，都有重大意义，了解其背景还是有必要的，只是从技术角度出发，忽略不提而已。  </p><h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><p>GNSS：全称是全球导航卫星系统（Global Navigation Satellite System），泛指所有的卫星导航系统，包括全球的、区域的和增强的，如美国的GPS、俄罗斯的Glonass、欧洲的Galileo、中国的北斗卫星导航系统，以及相关的增强系统，如美国的WAAS（广域增强系统）、欧洲的EGNOS（欧洲静地导航重叠系统）和日本的MSAS（多功能运输卫星增强系统）等  </p><p>QZSS：日本版 GPS，日文为“准天顶卫星システム”，英文全称为“Quasi-Zenith Satellite System”，以三颗人造卫星透过时间转移完成全球定位系统区域性功能的卫星扩增系统。<br>SBAS：即星基增强系统（Satellite-Based Augmentation System），过地球静止轨道（GEO）卫星搭载卫星导航增强信号转发器，可以向用户播发星历误差、卫星钟差、电离层延迟等多种修正信息，实现对于原有卫星导航系统定位精度的改进，从而成为各航天大国竞相发展的手段。目前，全球已经建立起了多个SBAS系统，如美国的WAAS（Wide Area Augmentation System）、俄罗斯的SDCM（System for Differential Corrections and Monitoring）、欧洲的EGNOS（European Geostationary Navigation Overlay Service）、日本的MSAS（Multi-functional Satellite Augmentation System）以及印度的GAGAN（GPS Aided Geo Augmented Navigation）。  </p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>网上流行的是 2013 年版本的 JT/T 808 协议，协议不太复杂，基本看1、2次能了解清楚。关于协议数据的解析，网上较多的是 Java 版本，C 和 Golang 的也有，可以对比协议手册阅读代码。<br>交通运输部在去年发布 JT/T 808-2019，代替 JT/T 808-2011。笔者对比发现两者差别还是有的，特别是有些报文字段，所以在实现编码时，要需要支持的协议版本。<br>国标、部标等手册，在国内似乎很难下载但又是必不可少的，有的要￥，有的要积分。笔者也是花了一定的力气和时间才找到手册。    </p><h2 id="设备模块"><a href="#设备模块" class="headerlink" title="设备模块"></a>设备模块</h2><p>网上有很多集成了多种系统的模块，有便宜有贵的，支持多种接口，如串口、SPI、IIC。从协议中得到，一般下位机是通过网络与服务器通信的，因此，使用接口的话，还需要自行实现下位机传输。<br>当然，不同模块，其支持的功能不同，在购买前需要了解清楚。  </p><h2 id="未完事宜"><a href="#未完事宜" class="headerlink" title="未完事宜"></a>未完事宜</h2><p>虽然工作没有涉及到定位系统，不过后面如果有时间，还有看看协议的解析。  </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.beidou.gov.cn/">http://www.beidou.gov.cn/</a><br><a href="http://www.beidou.gov.cn/zy/kpyd/201710/t20171023_4776.html">SBAS介绍</a><br><a href="http://www.beidou.gov.cn/zt/bdbz/201710/t20171011_4193.html">国外卫星导航应用标准综述</a><br><a href="http://www.beidou.gov.cn/zt/bdbz/">北斗标准</a>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;近日（6月23日），随着北斗三号最后一颗全球组网卫星成功发射，北斗三号收官，正式服务全球。虽然还没用上北斗，但提前了解这个系统，对技术提高有帮助。&lt;br&gt;本篇介绍笔者学习北斗系统过程收集到的一些资料，是按笔者一贯学习新知识的思路来进行的。  &lt;/p&gt;</summary>
    
    
    
    <category term="技术杂铺" scheme="http://www.latelee.org/category/my-study/"/>
    
    
    <category term="beidou" scheme="http://www.latelee.org/tag/beidou/"/>
    
  </entry>
  
  <entry>
    <title>我的内核学习笔记16：海思Hi3516平台PWM使用记录</title>
    <link href="http://www.latelee.org/linux-kernel/kernel-note-16-pwm-note-for-hi3516.html"/>
    <id>http://www.latelee.org/linux-kernel/kernel-note-16-pwm-note-for-hi3516.html</id>
    <published>2020-06-23T14:50:00.000Z</published>
    <updated>2020-12-03T03:00:04.744Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍海思平台 Hi3516 的 PWM 使用，包括手册介绍及用户空间控制。  </p><a id="more"></a><h2 id="一、PWM-概览"><a href="#一、PWM-概览" class="headerlink" title="一、PWM 概览"></a>一、PWM 概览</h2><p>芯片一共提供2路独立的 PWM，分别以 PWM0 和 PWM1 称呼。PWM 时钟有3种选择：3MHz、24MHz 和50MHz。周期和高电平拍数使用 26 比特存储，最高支持 25MHz（即50MHz/2）输出，最低约 0.045Hz（即3MHz/ 67108863）输出。输出脉冲个数可指定，也可一直输出，如是前者，最大个数为 1023，因其计数器为 10 比特。<br>PWM0 基地址为 0x1207_0000， PWM1 基地址为 0x1207_0020，两者地址相差 0x20。除此外，相关寄存器偏移和控制方式，完全一样，故在驱动中可封装为统一接口（参考文后资源）。  </p><h2 id="二、PWM-控制"><a href="#二、PWM-控制" class="headerlink" title="二、PWM 控制"></a>二、PWM 控制</h2><h3 id="2-1-控制方式"><a href="#2-1-控制方式" class="headerlink" title="2.1 控制方式"></a>2.1 控制方式</h3><ul><li>将 PWM0 或 PWM1 引脚复用为 PWM。  </li><li>PWM内部工作于 3MHz或者 24MHz或者 50MHz。</li><li>选择合适的时钟源，通过计算得到需要的周期数和高电平拍数。 </li><li>将对应数据写入PWMX_CFG0、PWMX_CFG1、PWMX_CFG2 寄存器。</li><li>对PWMX_CTRL bit[0]写入 1，使能PWM 输出。</li><li>如果是一直输出，则 PWMX_CFG2 可不设置，但 PWMX_CTRL bit[2] 需写入 1。<br>注意，默认时钟是3MHz，并且默认开启了，其值为0x2dc6c0，可用此计算周期。如果需要高频率的，则需要设置高的时钟源。  </li></ul><h3 id="2-2-示例"><a href="#2-2-示例" class="headerlink" title="2.2 示例"></a>2.2 示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">himm 0x111F0028 0x601  &#x2F;&#x2F; 复用GPIO6_7为PWM1，其它默认</span><br><span class="line">himm 0x111F0028 0x201  &#x2F;&#x2F; 复用GPIO6_7为PWM1，切换快 其它默认</span><br><span class="line"></span><br><span class="line">## 如果设置时钟，其基地址为0x120101bc 默认是3MHz，打开</span><br><span class="line"></span><br><span class="line">默认时钟，频率为1：</span><br><span class="line">CFG0 周期  himm  0x12070020  0x2dc6c0  默认399</span><br><span class="line">CFG1 占空比高电平 himm 0x12070024 0x16E360  默认199</span><br><span class="line">CFG2 个数  himm 0x12070028  0xff</span><br><span class="line">CRTL 控制 himm  0x1207002c  0x1</span><br><span class="line">一直输出：himm  0x1207002c  0x5</span><br></pre></td></tr></table></figure><p>编写程序，读取PWM1 状态 2 的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[1970-01-01 00:40:22] state2: 0xc14ff</span><br><span class="line">[1970-01-01 00:40:26] state2: 0xbd4ff</span><br><span class="line">[1970-01-01 00:41:14] state2: 0x8d4ff</span><br><span class="line">[1970-01-01 00:41:43] state2: 0x6f4ff</span><br><span class="line">[1970-01-01 00:41:47] state2: 0x6c4ff</span><br><span class="line">[1970-01-01 00:42:13] state2: 0x514ff</span><br><span class="line">[1970-01-01 00:42:22] state2: 0x494ff</span><br></pre></td></tr></table></figure><p>低3个不变者：<br>4表示0100  0为固定数目方波，1表示正在输出方波，00和后面的表示数目。<br>ff：表示数目为255个（用户设定）。  </p><h2 id="未完事宜"><a href="#未完事宜" class="headerlink" title="未完事宜"></a>未完事宜</h2><p>设置频率较低，是因为想利用万用表观察电平变化。在上述示例中，GPIO6_7 由低变高，再由高变，偶尔会出现 0.45 这样的值，由于没有示波器，由于仅作实验，未深入研究波形。仅证明可输出不同电平。  </p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>海思 Hi3516DV300 SoC 用户指南。<br><a href="https://github.com/Tvirus/hisi_pwm_driver">https://github.com/Tvirus/hisi_pwm_driver</a></p><p>李迟 2020.6.23 周二  晚</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍海思平台 Hi3516 的 PWM 使用，包括手册介绍及用户空间控制。  &lt;/p&gt;</summary>
    
    
    
    <category term="Linux内核研究" scheme="http://www.latelee.org/category/linux-kernel/"/>
    
    
    <category term="内核学习笔记" scheme="http://www.latelee.org/tag/%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
