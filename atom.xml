<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>迟思堂随笔</title>
  
  <subtitle>李迟的技术主页</subtitle>
  <link href="http://www.latelee.org/atom.xml" rel="self"/>
  
  <link href="http://www.latelee.org/"/>
  <updated>2020-12-21T09:16:14.900Z</updated>
  <id>http://www.latelee.org/</id>
  
  <author>
    <name>李迟</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Golang实践录：命令行cobra库实例再三优化</title>
    <link href="http://www.latelee.org/golang/golang-notes-cobra-note-iii.html"/>
    <id>http://www.latelee.org/golang/golang-notes-cobra-note-iii.html</id>
    <published>2020-12-10T16:00:00.000Z</published>
    <updated>2020-12-21T09:16:14.900Z</updated>
    
    <content type="html"><![CDATA[<p>本文是上一文章<a href="golang-notes-cobra-note-ii.html">《Golang实践录：命令行cobra库实例优化》</a> 的优化，主要的子命令的业务实现的整理。  </p><a id="more"></a><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>上一版本实现的方式，还是有点不满意，格式也不对齐，重要的是，似乎不是正规的方式。  </p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>cobra官方支持多级子命令，经研究测试发现，在实现三级子命令时，稍有麻烦。故舍弃官方的做法。同时参考了部分示例代码，结合得到本文的案例。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>旧版本如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">var theCmd &#x3D; []conf.UserCmdFunc&#123;</span><br><span class="line">    conf.UserCmdFunc &#123;</span><br><span class="line">        Name: &quot;foo&quot;,</span><br><span class="line">        ShortHelp: &quot;just a foo help info&quot;,</span><br><span class="line">        Func: foo,</span><br><span class="line">    &#125;,</span><br><span class="line">    conf.UserCmdFunc &#123;&quot;watch&quot;, &quot;watch config file&quot;, testWatch,&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewCmdTest() *cobra.Command&#123;</span><br><span class="line"></span><br><span class="line">    var cmd &#x3D; &amp;cobra.Command&#123;</span><br><span class="line">        Use:     name,</span><br><span class="line">        Short:   shortDescription,</span><br><span class="line">        Long:    longDescription,</span><br><span class="line">        Example: example,</span><br><span class="line">        RunE: func(cmd *cobra.Command, args []string) error &#123;</span><br><span class="line">truetruetrue&#x2F;&#x2F;klog.Println(common.DBName)</span><br><span class="line">truetruetrueif (len(args) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">truetruetruetrueklog.Warning(&quot;no args found&quot;)</span><br><span class="line">truetruetruetruecommon.PrintHelpInfo(theCmd)</span><br><span class="line">truetruetruetruereturn nil</span><br><span class="line">truetruetrue&#125;</span><br><span class="line">            &#x2F;&#x2F; !! 遍历并调用即可</span><br><span class="line">truetruetruefor _, item:&#x3D;range theCmd &#123;</span><br><span class="line">truetruetruetrueif (args[0] &#x3D;&#x3D; item.Name) &#123;</span><br><span class="line">truetruetruetruetrueitem.Func(args)</span><br><span class="line">truetruetruetruetruereturn nil</span><br><span class="line">truetruetruetrue&#125;</span><br><span class="line">truetruetrue&#125;</span><br><span class="line">truetruetrueklog.Printf(&quot;cmd &#39;%v&#39; not support&quot;, args[0])</span><br><span class="line">truetruetruecommon.PrintHelpInfo(theCmd)</span><br><span class="line">            return nil</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; note：使用子命令形式，下列可在help中展开</span><br><span class="line">    &#x2F;&#x2F; 命令参数，保存的值，参数名，默认参数，说明</span><br><span class="line">    &#x2F;&#x2F;cmd.Flags().StringVar(&amp;mode, &quot;db&quot;, &quot;-&quot;, &quot;set the database name&quot;)</span><br><span class="line"></span><br><span class="line">    return cmd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新版本修改如下：  </p><p>根据命令参数长度补齐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; rpad adds padding to the right of a string.</span><br><span class="line">func rpad(s string, padding int) string &#123;</span><br><span class="line">truetemplate :&#x3D; fmt.Sprintf(&quot;%%-%ds&quot;, padding)</span><br><span class="line">truereturn fmt.Sprintf(template, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func GetHelpInfo(theCmd []conf.UserCmdFunc) (ret string) &#123;</span><br><span class="line">trueret &#x3D; fmt.Sprintf(&quot;Available Commands:\n&quot;);</span><br><span class="line"></span><br><span class="line">truefor _, item :&#x3D; range theCmd &#123;</span><br><span class="line">truetruenameLen :&#x3D; len(item.Name)</span><br><span class="line">truetrueif nameLen &gt; cmdMaxLen &#123;</span><br><span class="line">truetruetruecmdMaxLen &#x3D; nameLen</span><br><span class="line">truetrue&#125;</span><br><span class="line">true&#125;</span><br><span class="line">true</span><br><span class="line">truefor _, item :&#x3D; range theCmd &#123;</span><br><span class="line">truetrueret +&#x3D; fmt.Sprintf(&quot;  %v %v\n&quot;, rpad(item.Name, cmdMaxLen), item.ShortHelp)</span><br><span class="line">true&#125;</span><br><span class="line">true</span><br><span class="line">truereturn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子命令实现：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var mode int</span><br><span class="line"></span><br><span class="line">func NewCmdTest() *cobra.Command&#123;</span><br><span class="line"></span><br><span class="line">    var cmd &#x3D; &amp;cobra.Command&#123;</span><br><span class="line">        Use:     name,</span><br><span class="line">        Short:   shortDescription,</span><br><span class="line">        Long:    longDescription + &quot;\n&quot; + common.GetHelpInfo(theCmd),</span><br><span class="line">        Example: example,</span><br><span class="line">        RunE: func(cmd *cobra.Command, args []string) error &#123;</span><br><span class="line">truetruetrue&#x2F;&#x2F; 1 没有参数</span><br><span class="line">truetruetrueif (len(args) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">truetruetruetrue&#x2F;&#x2F;klog.Warning(&quot;no args found&quot;)</span><br><span class="line">truetruetruetrue&#x2F;&#x2F;common.PrintHelpInfo(theCmd)</span><br><span class="line">truetruetruetruecmd.Help()</span><br><span class="line">truetruetruetruereturn nil</span><br><span class="line">truetruetrue&#125;</span><br><span class="line"></span><br><span class="line">truetruetrue&#x2F;&#x2F; 2 遍历是否有合法的参数，如无则提示</span><br><span class="line">truetruetrueidx :&#x3D; -1</span><br><span class="line">truetruetruefor idx1, item :&#x3D; range theCmd &#123;</span><br><span class="line">truetruetruetrueif (args[0] &#x3D;&#x3D; item.Name) &#123;</span><br><span class="line">truetruetruetruetrueidx &#x3D; idx1 &#x2F;&#x2F; why ???</span><br><span class="line">truetruetruetruetruebreak</span><br><span class="line">truetruetruetrue&#125;</span><br><span class="line">truetruetrue&#125;</span><br><span class="line">truetruetrueif idx &#x3D;&#x3D; -1 &#123;</span><br><span class="line">truetruetruetrueklog.Printf(&quot;arg &#39;%v&#39; not support&quot;, args[0])</span><br><span class="line">truetruetruetruecmd.Help()</span><br><span class="line">truetruetruetruereturn nil</span><br><span class="line">truetruetrue&#125;</span><br><span class="line">truetruetrue</span><br><span class="line">truetruetrue&#x2F;&#x2F; 3 执行公共的初始化</span><br><span class="line">truetruetrueklog.Printf(&quot;bussiness init, mode: %v\n&quot;, mode) &#x2F;&#x2F; just test</span><br><span class="line"></span><br><span class="line">truetruetrue&#x2F;&#x2F; 4 执行命令</span><br><span class="line">truetruetruetheCmd[idx].Func(args)</span><br><span class="line"></span><br><span class="line">truetruetruereturn nil</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; note：使用子命令形式，下列可在help中展开</span><br><span class="line">    &#x2F;&#x2F; 命令参数，保存的值，参数名，默认参数，说明</span><br><span class="line">truecmd.Flags().IntVarP(&amp;mode, &quot;mode&quot;, &quot;m&quot;, 0, &quot;set the test mode&quot;)</span><br><span class="line"></span><br><span class="line">    return cmd</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改1：将自定义的帮助信息纳入到<code>Long</code>字段，利用默认的<code>cmd.Help()</code>输出信息（要添加自定义的部分信息）。<br>修改2：先遍历自定义的命令列表，没有时提示帮助信息，有则执行。  </p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>默认输出帮助信息：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;cmdtool.exe</span><br><span class="line">  cmd test tool.</span><br><span class="line">  【中文样例】命令终端测试示例工具。</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  cmdtool.exe [command]</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">  comming soon...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  db          db command</span><br><span class="line">  help        Help about any command</span><br><span class="line">  misc        misc command</span><br><span class="line">  test        test command</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -c, --config string   config file (config.yaml)</span><br><span class="line">  -h, --help            help for cmdtool.exe</span><br><span class="line">  -o, --output string   specify the output file name</span><br><span class="line">  -p, --print           verbose output</span><br><span class="line">      --version         version for cmdtool.exe</span><br><span class="line"></span><br><span class="line">Use &quot;cmdtool.exe [command] --help&quot; for more information about a command.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行子命令，默认将合法的命令输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;cmdtool.exe test</span><br><span class="line">[2020-12-11 14:51:24.009 rootCmd.go:115] helloooooo 100s firstblood</span><br><span class="line">test...</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  foo   just a foo help info</span><br><span class="line">  watch watch config file</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  cmdtool.exe test [flags]</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">  example comming up...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -h, --help       help for test</span><br><span class="line">  -m, --mode int   set the test mode</span><br><span class="line"></span><br><span class="line">Global Flags:</span><br><span class="line">  -c, --config string   config file (config.yaml)</span><br><span class="line">  -o, --output string   specify the output file name</span><br><span class="line">  -p, --print           verbose output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ .&#x2F;cmdtool.exe test nocmd</span><br><span class="line">[2020-12-11 14:53:13.301 rootCmd.go:115] helloooooo 100s firstblood</span><br><span class="line">[2020-12-11 14:53:13.303 cmd.go:60] arg &#39;nocmd&#39; not support</span><br><span class="line">test...</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  foo   just a foo help info</span><br><span class="line">  watch watch config file</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  cmdtool.exe test [flags]</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">  example comming up...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -h, --help       help for test</span><br><span class="line">  -m, --mode int   set the test mode</span><br><span class="line"></span><br><span class="line">Global Flags:</span><br><span class="line">  -c, --config string   config file (config.yaml)</span><br><span class="line">  -o, --output string   specify the output file name</span><br><span class="line">  -p, --print           verbose output</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>源码<a href="https://github.com/latelee/cmdtool">在此</a>。 </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是上一文章&lt;a href=&quot;golang-notes-cobra-note-ii.html&quot;&gt;《Golang实践录：命令行cobra库实例优化》&lt;/a&gt; 的优化，主要的子命令的业务实现的整理。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>架构分类</title>
    <link href="http://www.latelee.org/architecture/software-architecture-note.html"/>
    <id>http://www.latelee.org/architecture/software-architecture-note.html</id>
    <published>2020-12-07T16:00:00.000Z</published>
    <updated>2020-12-21T09:16:14.836Z</updated>
    
    <content type="html"><![CDATA[<p>本文整理几个架构分类知识。从网上收集，加了个人的理解，汇总而得。  </p><a id="more"></a><h2 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h2><p>分层架构（layered architecture）是最常见的软件架构，也是事实上的标准架构。如果你不知道要用什么架构，那就用它。<br>这种架构将软件分成若干个水平层，每一层都有清晰的角色和分工，不需要知道其他层的细节。层与层之间通过接口通信。<br>虽然没有明确约定，软件一定要分成多少层，但是四层的结构最常见。  </p><ul><li>表现层（presentation）：用户界面，负责视觉和用户互动  </li><li>业务层（business）：实现业务逻辑  </li><li>持久层（persistence）：提供数据，SQL 语句就放在这一层  </li><li>数据库（database） ：保存数据  </li></ul><p>有的软件在逻辑层和持久层之间，加了一个服务层（service），提供不同业务逻辑需要的一些通用接口。  </p><p>分层实现、负责，功能明确，责任清晰。可单独测试每一层。如果修改、调整、扩展功能，较麻烦，涉及层级多。  </p><p>实例：<br>参与某公司软件重构，使用分层架构，从底至顶有：  </p><ul><li>平台接口层(如点灯，读写eeprom)  </li><li>一般接口层（封装平台接口，如点灯，读写eeprom，封装系统函数，如延时，时间转换）  </li><li>业务层（再次将底层接口封装为类，如外存读写类、线程类）  </li><li>应用层（应用程序，如守护进程，升级进程，主进程）  </li></ul><p>实操中有些不完善的地方，如：从上至下，每一层都做参数的检查判断，调用一个基础接口，要经过2~3层的接口，而且有部分接口只是简单的封装（为了分层而分层）。一些功能不必要逐层调用函数，可直接越过中间层到最底层，但可能与组织管理者理念冲突，而且控制不当会泛滥，不好维护。  </p><h2 id="事件驱动架构"><a href="#事件驱动架构" class="headerlink" title="事件驱动架构"></a>事件驱动架构</h2><p>事件（event）是状态发生变化时，软件发出的通知。<br>事件驱动架构（event-driven architecture）就是通过事件进行通信的软件架构。它分成四个部分。  </p><ul><li>事件队列（event queue）：接收事件的入口</li><li>分发器（event mediator）：将不同的事件分发到不同的业务逻辑单元</li><li>事件通道（event channel）：分发器与处理器之间的联系渠道</li><li>事件处理器（event processor）：实现业务逻辑，处理完成后会发出事件，触发下一步操作</li></ul><p>对于简单的项目，事件队列、分发器和事件通道，可以合为一体，整个软件就分成事件代理和事件处理器两部分。  </p><p>异步处理，性能较好，扩展性好，事件处理器之间解耦。开发复杂，涉及远程通信。测试麻烦。原子操作难，回滚比较困难。    </p><p>实例：<br>暂未实质搞过，KubeEdge 的 beehive 可能算是一个。  </p><h2 id="微核架构"><a href="#微核架构" class="headerlink" title="微核架构"></a>微核架构</h2><p>微核架构（microkernel architecture）又称为”插件架构”（plug-in architecture），指的是软件的内核相对较小，主要功能和业务逻辑都通过插件实现。<br>内核（core）通常只包含系统运行的最小功能。插件则是互相独立的，插件之间的通信，应该减少到最低，避免出现互相依赖的问题。  </p><p>插件形式，安装卸载方便，容易部署。延伸性（extensibility）好，高度定制，需要添加功能时，加插件即可。开发难度大，添加内核和插件的通信、插件登记。展性（scalability）差，不易做成分布式。    </p><h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><p>微服务架构（microservices architecture）是服务导向架构（service-oriented architecture，缩写 SOA）的升级。<br>每一个服务就是一个独立的部署单元（separately deployed unit）。这些单元都是分布式的，互相解耦，通过远程通信协议（比如REST、SOAP）联系。<br>微服务架构分成三种实现模式。  </p><ul><li>RESTful API 模式：服务通过 API 提供，云服务就属于这一类</li><li>RESTful 应用模式：服务通过传统的网络协议或者应用协议提供，背后通常是一个多功能的应用程序，常见于企业内部</li><li>集中消息模式：采用消息代理（message broker），可以实现消息队列、负载均衡、统一日志和异常处理，缺点是会出现单点失败，消息代理可能要做成集群</li></ul><p>扩展性好，各个服务之间低耦合，部署方便，开发容易，易于测试。服务可能拆分太细，微服务过多，杂乱且性能不好，原子操作难，回滚比较困难。<br>实例：<br>未搞过。  </p><h2 id="云架构"><a href="#云架构" class="headerlink" title="云架构"></a>云架构</h2><p>云结构（cloud architecture）主要解决扩展性和并发的问题，是最容易扩展的架构。<br>它的高扩展性，主要原因是没使用中央数据库，而是把数据都复制到内存中，变成可复制的内存数据单元。然后，业务处理能力封装成一个个处理单元（prcessing unit）。访问量增加，就新建处理单元；访问量减少，就关闭处理单元。由于没有中央数据库，所以扩展性的最大瓶颈消失了。由于每个处理单元的数据都在内存里，最好要进行数据持久化。<br>这个模式主要分成两部分：处理单元（processing unit）和虚拟中间件（virtualized middleware）。<br>*处理单元：实现业务逻辑<br>*虚拟中间件：负责通信、保持sessions、数据复制、分布式处理、处理单元的部署。</p><p>虚拟中间件又包含四个组件。</p><ul><li>消息中间件（Messaging Grid）：管理用户请求和session，当一个请求进来以后，决定分配给哪一个处理单元。</li><li>数据中间件（Data Grid）：将数据复制到每一个处理单元，即数据同步。保证某个处理单元都得到同样的数据。</li><li>处理中间件（Processing Grid）：可选，如果一个请求涉及不同类型的处理单元，该中间件负责协调处理单元</li><li>部署中间件（Deployment Manager）：负责处理单元的启动和关闭，监控负载和响应时间，当负载增加，就新启动处理单元，负载减少，就关闭处理单元。</li></ul><p>高负载，高扩展性，可动态部署。实现复杂，成本高，测试难，适合网站类应用。  </p><p>实操：  </p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>阮一峰，软件架构入门： <a href="http://www.ruanyifeng.com/blog/2016/09/software-architecture.html">http://www.ruanyifeng.com/blog/2016/09/software-architecture.html</a>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文整理几个架构分类知识。从网上收集，加了个人的理解，汇总而得。  &lt;/p&gt;</summary>
    
    
    
    <category term="软件架构" scheme="http://www.latelee.org/category/architecture/"/>
    
    
    <category term="软件架构" scheme="http://www.latelee.org/tag/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>软件设计几大原则</title>
    <link href="http://www.latelee.org/architecture/software-design-principles.html"/>
    <id>http://www.latelee.org/architecture/software-design-principles.html</id>
    <published>2020-12-07T16:00:00.000Z</published>
    <updated>2020-12-21T09:16:14.836Z</updated>
    
    <content type="html"><![CDATA[<p>本文整理软件设计几大原则。从网上收集，加了个人的理解，汇总而得。  </p><a id="more"></a><h2 id="ddd"><a href="#ddd" class="headerlink" title="ddd"></a>ddd</h2><h3 id="DRY-Don’t-Repeat-Yourself-千万不要重复你自身"><a href="#DRY-Don’t-Repeat-Yourself-千万不要重复你自身" class="headerlink" title="DRY - Don’t Repeat Yourself 千万不要重复你自身"></a>DRY - Don’t Repeat Yourself 千万不要重复你自身</h3><p>尽量在项目中减少重复的代码行，重复的方法，重复的模块。许多设计原则和模式最本质的思想都是在消除重复。DRY意味着系统内的每一个部件都应该是唯一的并且是不模糊的。我们可以通过应用单一职责接口隔离等原则尽量拆分系统，模块，类，方法·。使其每一个部件都是职责明确的并且可重用的。DRY利用的方法就是抽象：把共同的事物抽象出来，把代码抽取到一个地方去。这样就可以避免写重复的代码。</p><h3 id="KISS-Keep-It-Simple-amp-Stupid-保持简单易懂"><a href="#KISS-Keep-It-Simple-amp-Stupid-保持简单易懂" class="headerlink" title="KISS - Keep It Simple &amp; Stupid 保持简单易懂"></a>KISS - Keep It Simple &amp; Stupid 保持简单易懂</h3><p>从小到几行代码的写法大到整个系统的架构我们都应该保持简单易懂。高手高就高在可以将复杂的东西“简单”的实现出来。刚入行的时候，我总喜欢用三目运算符将复杂的逻辑用一句冗长的代码行写出来。后面才发现这是非常愚蠢的。到了重构或者需求变更的时候，连我自己写的代码我都看着非常费劲难以下手。所以我们应该致力于代码的可理解性。降低复杂度也意味着维护变得简单。Martin Flower在《重构》中有一句经典的话：”任何一个傻瓜都能写出计算机可以理解的程序，只有写出人类容易理解的程序才是优秀的程序员。其实不光是程序，这个原则也可以延伸到产品的设计，业务的设计，项目结构的设计上。</p><h3 id="YAGNI-You-Ain’t-Gonna-Need-It-适可而止"><a href="#YAGNI-You-Ain’t-Gonna-Need-It-适可而止" class="headerlink" title="YAGNI - You Ain’t Gonna Need It  适可而止"></a>YAGNI - You Ain’t Gonna Need It  适可而止</h3><p>千万不要进行过度设计。我们经常会在开发当中尽可能的迎合未来可能的需求。而为了迎合某些产生概率极低的需求而设计的成本是非常高的，这种过度设计的收益非常低。可能你深思熟虑的设计花了不少时间成本，却在未来的两三年内这个设计却完全没有派上用场。一些设计是否必要，更多的应该基于当前的情况。而不是为了应对未来的各种变化，画蛇添足的设计。如果淘宝一开始就往日均交易上亿的情况进行设计的话，那么可能就不会有今天的淘宝了。因为创业公司的时间是非常宝贵的，比其他公司早一步退出新的服务就能抢占先机。并不是说淘宝不需要考虑以后交易量暴增的情况，而是不应该以当前日均交易才几万的情况下去设计编码日均交易上亿的项目。过度设计往往会延缓开发迭代的速度。<br>YAGNI原则指的是只需要将应用程序必需的功能包含进来，而不要试图添加任何其他你认为可能需要的功能。</p><h3 id="Tell-Don’t-Ask"><a href="#Tell-Don’t-Ask" class="headerlink" title="Tell, Don’t Ask"></a>Tell, Don’t Ask</h3><h3 id="Soc-Sepration-of-Concerns"><a href="#Soc-Sepration-of-Concerns" class="headerlink" title="Soc - Sepration of Concerns"></a>Soc - Sepration of Concerns</h3><h3 id="LOD-迪米特法则"><a href="#LOD-迪米特法则" class="headerlink" title="LOD 迪米特法则"></a>LOD 迪米特法则</h3><p>也叫最少知识原则。迪米特法则的定义是只与你的直接朋友交谈，不与”陌生人”说话。如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该应用。其目的是降低类之间的耦合度，提高模块的相对独立性。<br>迪米特法则中的朋友是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。<br>优点：<br>1、降低类之间的耦合度，提高模块的相对独立性。<br>2、由于亲和度降低，从而提高了类的可复用率和系统的扩展性。<br>缺点：<br>过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。<br>使用迪米特法则需要注意：<br>1、在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。<br>2、在类的结构设计上，尽量降低类成员的访问权限。<br>3、在类的设计上，优先考虑将一个类设置成不变类。<br>4、在对其他类的引用上，将引用其他对象的次数降到最低。<br>5、不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。<br>6、谨慎使用序列化（Serializable）功能。  </p><h2 id="SOLID原则"><a href="#SOLID原则" class="headerlink" title="SOLID原则"></a>SOLID原则</h2><p>S.O.L.I.D是面向对象设计和编程(OOD&amp;OOP)中几个重要编码原则(Programming Priciple)的首字母缩写。  </p><h3 id="SRP-Single-Responsibility-Principle-单一责任原则"><a href="#SRP-Single-Responsibility-Principle-单一责任原则" class="headerlink" title="SRP - Single Responsibility Principle 单一责任原则"></a>SRP - Single Responsibility Principle 单一责任原则</h3><p>当需要修改某个类的时候原因有且只有一个（THERE SHOULD NEVER BE MORE THAN ONE REASON FOR A CLASS TO CHANGE）。换句话说就是让一个类只做一种类型责任，当这个类需要承当其他类型的责任的时候，就需要分解这个类。<br>对象不应承担太多功能，正如一心不能而用，比如太多的工作(种类)会使人崩溃。唯有专注才能保证对象的高内聚；唯有唯一，才能保证对象的细粒度。<br>解决问题：<br>假如有A和B两个类，当A需求发生改变需要修改时，不能导致B类出问题。<br>现状：<br>在实际情况很难去做到单一职责原则，因为随着业务的不断变更，类的职责也在发生着变化，即职责扩散。如类A完成职责P的功能，但是随着后期业务细化，职责P分解成更小粒度的P1与P2，这时根据单一职责原则则需要拆分类A以分别满足细分后的职责P1和P2。但是实际开发环节，若类的逻辑足够简单，可以在代码上级别上违背单一职责原则；若类的方法足够少，可以在方法级别上违背单一职责原则。</p><h3 id="OCR-Open-Close-Principle-开闭原则"><a href="#OCR-Open-Close-Principle-开闭原则" class="headerlink" title="OCR - Open Close Principle 开闭原则"></a>OCR - Open Close Principle 开闭原则</h3><p>软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。这个原则是诸多面向对象编程原则中最抽象、最难理解的一个。<br>Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.<br>软件对象（类、模块、方法等）应该对于扩展是开放的，对修改是关闭的。比如：一个网络模块，原来只有服务端功能，而现在要加入客户端功能，那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，就应当将客户端和服务端分开。公共部分抽象出来。<br>问题由来：<br>在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。<br>解决办法：<br>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。  </p><h3 id="LSP-Liskov-Substitution-Principle-里氏替换原则"><a href="#LSP-Liskov-Substitution-Principle-里氏替换原则" class="headerlink" title="LSP - Liskov Substitution Principle 里氏替换原则"></a>LSP - Liskov Substitution Principle 里氏替换原则</h3><p>当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有is-A关系<br>子类应当可以替换父类并出现在父类能够出现的地方。比如：公司搞年度派对，都有员工都可以抽奖，那么不管是新员工还是老员工，也不管是总部员工还是外派员工，都应当可以参加抽奖。<br>里氏替换至少包含一下两个含义：<br>1、里氏替换原则是针对继承而言的，如果继承是为了实现代码重用，也就是为了共享方法，那么共享的父类方法就应该保持不变，不能被子类重新定义。子类只能通过新添加方法来扩展功能，父类和子类都可以实例化，而子类继承的方法和父类是一样的，父类调用方法的地方，子类也可以调用同一个继承得来的，逻辑和父类一致的方法，这时用子类对象将父类对象替换掉时，当然逻辑一致，相安无事。<br>2、如果继承的目的是为了多态，而多态的前提就是子类覆盖并重新定义父类的方法，为了符合LSP，我们应该将父类定义为抽象类，并定义抽象方法，让子类重新定义这些方法，当父类是抽象类时，父类就是不能实例化，所以也不存在可实例化的父类对象在程序里。也就不存在子类替换父类实例（根本不存在父类实例了）时逻辑不一致的可能。   </p><h3 id="ISP-Interface-Segregation-Principle-接口分离原则-接口隔离原则"><a href="#ISP-Interface-Segregation-Principle-接口分离原则-接口隔离原则" class="headerlink" title="ISP - Interface Segregation Principle 接口分离原则 接口隔离原则"></a>ISP - Interface Segregation Principle 接口分离原则 接口隔离原则</h3><p>不能强迫用户去依赖那些他们不使用的接口。换句话说，使用多个专门的接口比使用单一的总接口总要好。<br>1、客户端不应依赖它不需要的接口<br>2、类间的依赖关系应该建立在最小的接口上<br>其实通俗来理解就是，不要在一个接口里面放很多的方法，这样会显得这个类很臃肿。接口应该尽量细化，一个接口对应一个功能模块，同时接口里面的方法应该尽可能的少，使接口更加灵活轻便。或许有的人认为接口隔离原则和单一职责原则很像，但两个原则还是存在着明显的区别。单一职责原则是在业务逻辑上的划分，注重的是职责。接口隔离原则是基于接口设计考虑。例如一个接口的职责包含10个方法，这10个方法都放在同一接口中，并且提供给多个模块调用，但不同模块需要依赖的方法是不一样的，这时模块为了实现自己的功能就不得不实现一些对其没有意义的方法，这样的设计是不符合接口隔离原则的。接口隔离原则要求”尽量使用多个专门的接口”专门提供给不同的模块。  </p><h3 id="DIP-Dependence-Inversion-Principle-依赖倒置原则"><a href="#DIP-Dependence-Inversion-Principle-依赖倒置原则" class="headerlink" title="DIP - Dependence Inversion Principle 依赖倒置原则"></a>DIP - Dependence Inversion Principle 依赖倒置原则</h3><p>1、高层模块不应该依赖底层模块，二者都应该依赖抽象。<br>2、抽象不应该依赖细节，细节应该依赖抽象。<br>3、依赖倒置的中心思想是面向接口编程。<br>4、依赖倒置原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础搭建的架构要稳定的多。<br>5、使用接口或抽象类的目的是指定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类来完成。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文整理软件设计几大原则。从网上收集，加了个人的理解，汇总而得。  &lt;/p&gt;</summary>
    
    
    
    <category term="软件架构" scheme="http://www.latelee.org/category/architecture/"/>
    
    
    <category term="设计原则" scheme="http://www.latelee.org/tag/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：命令行cobra库实例优化</title>
    <link href="http://www.latelee.org/golang/golang-notes-cobra-note-ii.html"/>
    <id>http://www.latelee.org/golang/golang-notes-cobra-note-ii.html</id>
    <published>2020-12-01T16:00:00.000Z</published>
    <updated>2020-12-21T09:16:14.900Z</updated>
    
    <content type="html"><![CDATA[<p>本文上一文章<a href="golang-notes-cobra-note.html">《Golang实践录：命令行cobra库实例》</a> 的优化，主要的子命令的业务实现的整理。  </p><a id="more"></a><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>旧版本中，每个子命令的入口函数，均需一一判断传入参数，并调用对应的业务实现函数，编码扩展稍有繁琐，而且也不美观。<br>思考再三，决定使用结构体数组的形式来优化。  </p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>此思路来源于 busybox 。  </p><p>首先定义结构体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 命令列表，包括名称，帮助信息</span><br><span class="line">type UserCmdFunc struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">    ShortHelp string</span><br><span class="line">    &#x2F;&#x2F; LongHelp string</span><br><span class="line">    Func func(args []string)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再实现遍历命令列表函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func PrintHelpInfo(theCmd []conf.UserCmdFunc) &#123;</span><br><span class="line">truefmt.Println(&quot;valid command: &quot;);</span><br><span class="line">truefor _, item:&#x3D;range theCmd &#123;</span><br><span class="line">        fmt.Println(item.Name, &quot;\t:&quot;, item.ShortHelp)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用时，只需要定义结构体数组，并填写对应的命令名称，帮助信息，及对应的函数指针即可。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var theCmd &#x3D; []conf.UserCmdFunc&#123;</span><br><span class="line">    conf.UserCmdFunc &#123;</span><br><span class="line">        Name: &quot;foo&quot;,</span><br><span class="line">        ShortHelp: &quot;just a foo help info&quot;,</span><br><span class="line">        Func: foo,</span><br><span class="line">    &#125;,</span><br><span class="line">    conf.UserCmdFunc &#123;&quot;watch&quot;, &quot;watch config file&quot;, testWatch,&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line"></span><br><span class="line">当命令不合法——亦即无法在结构体数组中找到时，提示合法的命令，提高体验。  </span><br><span class="line">由于各子命令位于不同的包中，实际上 theCmd 及子命令入口函数绝大部分代码是相同的，容易扩展。  </span><br><span class="line"></span><br><span class="line">## 实现</span><br><span class="line">以子命令 test 为例，旧版本入口源码如下：  </span><br></pre></td></tr></table></figure><p>func NewCmdTest() *cobra.Command{</p><pre><code>var cmd = &amp;cobra.Command&#123;    Use:     name,    Short:   shortDescription,    Long:    longDescription,    Example: example,    RunE: func(cmd *cobra.Command, args []string) error &#123;        if (len(args) == 0) &#123;            klog.Warning(&quot;no args found&quot;)            return nil        &#125;        // !! 以下要一一判断并调用        if (args[0] == &quot;foo&quot;)&#123;            foo(args)        &#125; else if (args[0] == &quot;watch&quot;)&#123;            testWatch(args)        &#125; else &#123;            klog.Printf(&quot;cmd &#39;%v&#39; not support&quot;, args[0])            return nil        &#125;         return nil    &#125;,&#125;return cmd</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">新版本变化如下：</span><br></pre></td></tr></table></figure><p>var theCmd = []conf.UserCmdFunc{<br>    conf.UserCmdFunc {<br>        Name: “foo”,<br>        ShortHelp: “just a foo help info”,<br>        Func: foo,<br>    },<br>    conf.UserCmdFunc {“watch”, “watch config file”, testWatch,},<br>}</p><p>func NewCmdTest() *cobra.Command{</p><pre><code>var cmd = &amp;cobra.Command&#123;    Use:     name,    Short:   shortDescription,    Long:    longDescription,    Example: example,    RunE: func(cmd *cobra.Command, args []string) error &#123;        //klog.Println(common.DBName)        if (len(args) == 0) &#123;            klog.Warning(&quot;no args found&quot;)            common.PrintHelpInfo(theCmd)            return nil        &#125;        // !! 遍历并调用即可        for _, item:=range theCmd &#123;            if (args[0] == item.Name) &#123;                item.Func(args)                return nil            &#125;        &#125;        klog.Printf(&quot;cmd &#39;%v&#39; not support&quot;, args[0])        common.PrintHelpInfo(theCmd)        return nil    &#125;,&#125;// note：使用子命令形式，下列可在help中展开// 命令参数，保存的值，参数名，默认参数，说明//cmd.Flags().StringVar(&amp;mode, &quot;db&quot;, &quot;-&quot;, &quot;set the database name&quot;)return cmd</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 测试</span><br><span class="line">默认输出帮助信息：  </span><br></pre></td></tr></table></figure><p>$ ./cmdtool.exe<br>  cmd test tool.<br>  命令终端测试示例工具。</p><p>Usage:<br>  cmdtool.exe [command]</p><p>Examples:<br>  comming soon…</p><p>Available Commands:<br>  db          db command<br>  help        Help about any command<br>  misc        misc command<br>  test        test command</p><p>Flags:<br>      –config string   config file (config.yaml)<br>  -h, –help            help for cmdtool.exe<br>      –print           will print sth<br>      –version         version for cmdtool.exe</p><p>Use “cmdtool.exe [command] –help” for more information about a command.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行子命令，默认将合法的命令输出：</span><br></pre></td></tr></table></figure><p>$ ./cmdtool.exe test<br>[2020-12-02 17:43:40.771 rootCmd.go:112] helloooooo 100s firstblood<br>[2020-12-02 17:43:40.772 cmd.go:43] no args found<br>valid command:<br>foo     : just a foo help info<br>watch   : watch config file</p><p>$ ./cmdtool.exe test nocmd<br>[2020-12-02 17:43:47.953 rootCmd.go:112] helloooooo 100s firstblood<br>[2020-12-02 17:43:47.954 cmd.go:53] cmd ‘nocmd’ not support<br>valid command:<br>foo     : just a foo help info<br>watch   : watch config file</p><pre><code>## 源码源码[在此](https://github.com/latelee/cmdtool)。 本次也修改了 cobra 帮助信息不对齐的小问题。  </code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文上一文章&lt;a href=&quot;golang-notes-cobra-note.html&quot;&gt;《Golang实践录：命令行cobra库实例》&lt;/a&gt; 的优化，主要的子命令的业务实现的整理。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>CICD实例：nodejs 程序的自动化构建</title>
    <link href="http://www.latelee.org/cicd/cicd-exmaple-deploy-for-nodejs.html"/>
    <id>http://www.latelee.org/cicd/cicd-exmaple-deploy-for-nodejs.html</id>
    <published>2020-11-30T16:00:00.000Z</published>
    <updated>2020-12-21T09:16:14.888Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍 nodejs 程序的自动化构建，包括 x86 和 arm 平台。  </p><a id="more"></a><h2 id="环境描述"><a href="#环境描述" class="headerlink" title="环境描述"></a>环境描述</h2><p>利用 Docker 多阶段构建方法。使用如下镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">构建阶段镜像：</span><br><span class="line">node         10.22.0-stretch  1e318dc8ae6f  2 months ago  911MB</span><br><span class="line">arm32v7&#x2F;node 10.22.0-stretch  b697c995167b  3 months ago  744MB</span><br><span class="line"></span><br><span class="line">运行阶段镜像：</span><br><span class="line">node         10.22.0-alpine   8e473595b853  4 months ago  83.5MB</span><br><span class="line">arm32v7&#x2F;node 10.22.0-alpine   cf3a24984912  4 months ago  75.2MB</span><br></pre></td></tr></table></figure><p>nodejs 程序使用 package.json 指定依赖库。  </p><h2 id="CICD-配置"><a href="#CICD-配置" class="headerlink" title="CICD 配置"></a>CICD 配置</h2><p>选用 CircleCI 执行 CI 脚本。<br>CircleCI 配置文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>CI 脚本如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm  --name armhfbusybox -v &#x2F;usr&#x2F;bin&#x2F;qemu-arm-static:&#x2F;usr&#x2F;bin&#x2F;qemu-arm-static armhf&#x2F;busybox</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="工程仓库"><a href="#工程仓库" class="headerlink" title="工程仓库"></a>工程仓库</h2><h2 id="问题及解决"><a href="#问题及解决" class="headerlink" title="问题及解决"></a>问题及解决</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍 nodejs 程序的自动化构建，包括 x86 和 arm 平台。  &lt;/p&gt;</summary>
    
    
    
    <category term="cicd" scheme="http://www.latelee.org/category/cicd/"/>
    
    
    <category term="cicd" scheme="http://www.latelee.org/tag/cicd/"/>
    
  </entry>
  
  <entry>
    <title>CICD实例：C++程序的自动化构建</title>
    <link href="http://www.latelee.org/cicd/cicd-exmaple-deploy-for-c++.html"/>
    <id>http://www.latelee.org/cicd/cicd-exmaple-deploy-for-c++.html</id>
    <published>2020-11-29T16:00:00.000Z</published>
    <updated>2020-12-21T09:16:14.888Z</updated>
    
    <content type="html"><![CDATA[<p>本文描述一个 C++ 程序的自动化构建过程，涉及：<br>1、制作适用于 c++ 简单程序的基础镜像。<br>2、使用 CICD 进行编译和构建，并发布。在此过程，涉及到邮件通知。  </p><p>本文示例在简单应用场合中有实践意义，即不使用如 jenkins 这样重型工具，如果信任现成免费的私有的服务，可将自动化工作迁移到公网，否则内建局域网服务或使用公有云搭建。  </p><a id="more"></a><h2 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h2><p>注：源码为 C++，使用 C++11 特性，选 alpine，其 C 库不是 glibc。选 busybox 64版本。在 64 位系统直接执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull busybox</span><br></pre></td></tr></table></figure><p>即可得到 64 位的版本。<br>运行 busybox：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it bar busybox sh</span><br></pre></td></tr></table></figure><p>在宿主机拷贝动态库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker cp &#x2F;usr&#x2F;bin&#x2F;file bar:&#x2F;bin</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libmagic.so.1 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libmagic.so.1.0.0 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libz.so.1 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libz.so.1.2.7 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;share&#x2F;misc&#x2F;magic bar:&#x2F;usr&#x2F;share&#x2F;misc  &#x2F;&#x2F; 要自己创建目录</span><br><span class="line"></span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libstdc++.so.6 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libstdc++.so.6.0.19 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libgcc_s.so.1 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libgcc_s-4.8.5-20150702.so.1 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libpthread.so bar:&#x2F;lib64</span><br></pre></td></tr></table></figure><p>重新制作基础镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit bar registry.cn-shenzhen.aliyuncs.com&#x2F;latelee&#x2F;busybox:64</span><br></pre></td></tr></table></figure><p>上传：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push registry.cn-shenzhen.aliyuncs.com&#x2F;latelee&#x2F;busybox:64</span><br></pre></td></tr></table></figure><h2 id="CICD-配置"><a href="#CICD-配置" class="headerlink" title="CICD 配置"></a>CICD 配置</h2><p>选用 CircleCI 执行 CI 脚本。  </p><h2 id="工程仓库"><a href="#工程仓库" class="headerlink" title="工程仓库"></a>工程仓库</h2><h2 id="问题及解决"><a href="#问题及解决" class="headerlink" title="问题及解决"></a>问题及解决</h2><p>不能按一般的登陆方式登陆，否则提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker login --username&#x3D;$ali_docker_name -p $ali_docker_passwd registry.cn-shenzhen.aliyuncs.com</span><br><span class="line">WARNING! Using --password via the CLI is insecure. Use --password-stdin.</span><br><span class="line">Login with your Docker ID to push and pull images from Docker Hub. If you don&#39;t have a Docker ID, head over to https:&#x2F;&#x2F;hub.docker.com to create one.</span><br><span class="line">Username: EOF</span><br></pre></td></tr></table></figure><p>使用官方推荐方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;$ali_docker_passwd&quot; | docker login --username $ali_docker_name --password-stdin  registry.cn-shenzhen.aliyuncs.com</span><br><span class="line">Error: Cannot perform an interactive login from a non TTY device</span><br></pre></td></tr></table></figure><p>此提示真正原因未知，在调试发现环境变量未生效，调整后，登陆成功。 </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>circleci文档：<br>使用docker命令：<a href="https://circleci.com/docs/2.0/building-docker-images/">https://circleci.com/docs/2.0/building-docker-images/</a><br>配置选项参考说明：<a href="https://circleci.com/docs/2.0/configuration-reference/">https://circleci.com/docs/2.0/configuration-reference/</a><br>环境变量：<a href="https://circleci.com/docs/2.0/env-vars/">https://circleci.com/docs/2.0/env-vars/</a><br>自定义docker：<a href="https://circleci.com/docs/2.0/custom-images/">https://circleci.com/docs/2.0/custom-images/</a><br>预置docker镜像：<a href="https://circleci.com/docs/2.0/custom-images/">https://circleci.com/docs/2.0/custom-images/</a><br>注：免费情况下， circleci 私有仓库构建次数有限，术语为 Credits，每周共 2500 个，一次构建消耗数量为数个到数十个。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文描述一个 C++ 程序的自动化构建过程，涉及：&lt;br&gt;1、制作适用于 c++ 简单程序的基础镜像。&lt;br&gt;2、使用 CICD 进行编译和构建，并发布。在此过程，涉及到邮件通知。  &lt;/p&gt;
&lt;p&gt;本文示例在简单应用场合中有实践意义，即不使用如 jenkins 这样重型工具，如果信任现成免费的私有的服务，可将自动化工作迁移到公网，否则内建局域网服务或使用公有云搭建。  &lt;/p&gt;</summary>
    
    
    
    <category term="cicd" scheme="http://www.latelee.org/category/cicd/"/>
    
    
    <category term="cicd" scheme="http://www.latelee.org/tag/cicd/"/>
    
  </entry>
  
  <entry>
    <title>我的docker随笔30：C++程序的自动化构建</title>
    <link href="http://www.latelee.org/docker/docker-30-deploy-for-c++.html"/>
    <id>http://www.latelee.org/docker/docker-30-deploy-for-c++.html</id>
    <published>2020-11-29T16:00:00.000Z</published>
    <updated>2020-12-21T09:16:14.892Z</updated>
    
    <content type="html"><![CDATA[<p>本文描述一个 C++ 程序的自动化构建过程，涉及：<br>1、制作适用于 c++ 简单程序的基础镜像。<br>2、使用 CICD 进行编译和构建，并发布。在此过程，涉及到邮件通知。  </p><p>本文示例在简单应用场合中有实践意义，即不使用如 jenkins 这样重型工具，如果信任现成免费的私有的服务，可将自动化工作迁移到公网，否则内建局域网服务或使用公有云搭建。  </p><a id="more"></a><h2 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h2><p>注：源码为 C++，使用 C++11 特性，选 alpine，其 C 库不是 glibc。选 busybox 64版本。在 64 位系统直接执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull busybox</span><br></pre></td></tr></table></figure><p>即可得到 64 位的版本。<br>运行 busybox：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it bar busybox sh</span><br></pre></td></tr></table></figure><p>在宿主机拷贝动态库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker cp &#x2F;usr&#x2F;bin&#x2F;file bar:&#x2F;bin</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libmagic.so.1 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libmagic.so.1.0.0 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libz.so.1 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libz.so.1.2.7 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;share&#x2F;misc&#x2F;magic bar:&#x2F;usr&#x2F;share&#x2F;misc  &#x2F;&#x2F; 要自己创建目录</span><br><span class="line"></span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libstdc++.so.6 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libstdc++.so.6.0.19 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libgcc_s.so.1 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libgcc_s-4.8.5-20150702.so.1 bar:&#x2F;lib64</span><br><span class="line">docker cp &#x2F;usr&#x2F;lib64&#x2F;libpthread.so bar:&#x2F;lib64</span><br></pre></td></tr></table></figure><p>重新制作基础镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit bar registry.cn-shenzhen.aliyuncs.com&#x2F;latelee&#x2F;busybox:64</span><br></pre></td></tr></table></figure><p>上传：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push registry.cn-shenzhen.aliyuncs.com&#x2F;latelee&#x2F;busybox:64</span><br></pre></td></tr></table></figure><h2 id="CICD-配置"><a href="#CICD-配置" class="headerlink" title="CICD 配置"></a>CICD 配置</h2><p>选用 CircleCI 执行 CI 脚本。  </p><h2 id="工程仓库"><a href="#工程仓库" class="headerlink" title="工程仓库"></a>工程仓库</h2><h2 id="问题及解决"><a href="#问题及解决" class="headerlink" title="问题及解决"></a>问题及解决</h2><p>不能按一般的登陆方式登陆，否则提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker login --username&#x3D;$ali_docker_name -p $ali_docker_passwd registry.cn-shenzhen.aliyuncs.com</span><br><span class="line">WARNING! Using --password via the CLI is insecure. Use --password-stdin.</span><br><span class="line">Login with your Docker ID to push and pull images from Docker Hub. If you don&#39;t have a Docker ID, head over to https:&#x2F;&#x2F;hub.docker.com to create one.</span><br><span class="line">Username: EOF</span><br></pre></td></tr></table></figure><p>使用官方推荐方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;$ali_docker_passwd&quot; | docker login --username $ali_docker_name --password-stdin  registry.cn-shenzhen.aliyuncs.com</span><br><span class="line">Error: Cannot perform an interactive login from a non TTY device</span><br></pre></td></tr></table></figure><p>此提示真正原因未知，在调试发现环境变量未生效，调整后，登陆成功。 </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>circleci文档：<br>使用docker命令：<a href="https://circleci.com/docs/2.0/building-docker-images/">https://circleci.com/docs/2.0/building-docker-images/</a><br>配置选项参考说明：<a href="https://circleci.com/docs/2.0/configuration-reference/">https://circleci.com/docs/2.0/configuration-reference/</a><br>环境变量：<a href="https://circleci.com/docs/2.0/env-vars/">https://circleci.com/docs/2.0/env-vars/</a><br>自定义docker：<a href="https://circleci.com/docs/2.0/custom-images/">https://circleci.com/docs/2.0/custom-images/</a><br>预置docker镜像：<a href="https://circleci.com/docs/2.0/custom-images/">https://circleci.com/docs/2.0/custom-images/</a><br>注：免费情况下， circleci 私有仓库构建次数有限，术语为 Credits，每周共 2500 个，一次构建消耗数量为数个到数十个。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文描述一个 C++ 程序的自动化构建过程，涉及：&lt;br&gt;1、制作适用于 c++ 简单程序的基础镜像。&lt;br&gt;2、使用 CICD 进行编译和构建，并发布。在此过程，涉及到邮件通知。  &lt;/p&gt;
&lt;p&gt;本文示例在简单应用场合中有实践意义，即不使用如 jenkins 这样重型工具，如果信任现成免费的私有的服务，可将自动化工作迁移到公网，否则内建局域网服务或使用公有云搭建。  &lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="http://www.latelee.org/category/docker/"/>
    
    
    <category term="docker" scheme="http://www.latelee.org/tag/docker/"/>
    
  </entry>
  
  <entry>
    <title>vue实践录：vue基础学习</title>
    <link href="http://www.latelee.org/vue/vue-notes-vue-basic.html"/>
    <id>http://www.latelee.org/vue/vue-notes-vue-basic.html</id>
    <published>2020-11-11T14:00:00.000Z</published>
    <updated>2020-12-21T09:16:14.900Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲述 Vue 的基础知识，逐步更新。主要来自网络，有删改和自己的理解。  </p><a id="more"></a><h2 id="Vue指令"><a href="#Vue指令" class="headerlink" title="Vue指令"></a>Vue指令</h2><p>Vue 的指令是以 v- 开头的，它们作用于 HTML 元素，指令提供了一些特殊的特性，将指令绑定在元素上时，指令会为绑定的目标元素添加一些特殊的行为，我们可以将指令看作特殊的 HTML 特性（attribute）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.内容绑定，事件绑定（v-text、v-html、v-on基础）</span><br><span class="line">2.显示切换，属性绑定（v-show、v-if、v-bind）</span><br><span class="line">3.列表训练，表单元素绑定（v-for、v-on补充、v-model)</span><br></pre></td></tr></table></figure><p>详细说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">v-text</span><br><span class="line">1.v-text指令的作用是：设置标签的内容（textContent）</span><br><span class="line">2.默认写法会替换全部内容，使用差值表达式&#123;&#123;&#125;&#125;可以替换指定内容</span><br><span class="line">3.内部支持写表达式</span><br><span class="line"></span><br><span class="line">v-html</span><br><span class="line">1.v-html指令的作用是：设置元素的innerHTML</span><br><span class="line">2.内容中有html结构会被解析成标签</span><br><span class="line">3.v-text指令无论内容是多少，只会解析成文本</span><br><span class="line">4.解析文本使用v-text，需要解析html结构使用v-html</span><br><span class="line"></span><br><span class="line">v-on基础</span><br><span class="line">1.v-on指令的作用是：为元素绑定事件</span><br><span class="line">2.时间名不需要写on</span><br><span class="line">3.指令可以简写成@</span><br><span class="line">4.绑定的方法定义在methods属性中</span><br><span class="line">5.方法的内部通过this关键字可以访问定义在data中数据</span><br><span class="line"></span><br><span class="line">v-show</span><br><span class="line">1.v-show指令的作用是：根据真假切换元素的显示状态</span><br><span class="line">2.原理是修改元素的display，实现显示隐藏</span><br><span class="line">3.指令后面的内容，最终都会解析成布尔值</span><br><span class="line">4.值为true元素显示，值为false元素隐藏</span><br><span class="line">5.数据改变之后，对应元素的显示状态会同步更新</span><br><span class="line"></span><br><span class="line">v-if</span><br><span class="line">1.v-if指令的作用是：根据表达式的真假切换元素的显示状态</span><br><span class="line">2.本质是通过操纵dom元素来切换显示状态（和v-show不同的地方）</span><br><span class="line">3.表达式的值为true，元素存在于dom树中，为false，从dom树中移除</span><br><span class="line">4.频繁的切换v-show，反之使用v-if,前者的切换消耗少</span><br><span class="line"></span><br><span class="line">v-else</span><br><span class="line">1.作为 v-if 或 v-show 的 “else” 部分代码。  </span><br><span class="line">2.必须立即跟在v-if或v-show元素的后面——否则它不能被识别。</span><br><span class="line"></span><br><span class="line">v-bind</span><br><span class="line">1.为元素绑定属性</span><br><span class="line">2.完整写法时v-bind：属性名</span><br><span class="line">3.简写的话可以省略v-bind，只保留：属性名</span><br><span class="line">4.需要动态的增删class建议使用对象的方式</span><br><span class="line"></span><br><span class="line">v-for</span><br><span class="line">1.v-for指令的作用是：根据数据生成列表结构</span><br><span class="line">2.数组经常和v-for结合使用</span><br><span class="line">3.语法是（item，index）in 数据</span><br><span class="line">4.item和index可以结合其他指令一起使用</span><br><span class="line">5.数组长度的更新会同步到页面上是响应式的</span><br><span class="line"></span><br><span class="line">v-on补充</span><br><span class="line">1.事件绑定的方法写成函数调用的形式，可以传入自定义参数</span><br><span class="line">2.定义方法时需要定义形参来接收传入的参数</span><br><span class="line">3.事件的后面跟上.修饰符对事件进行限制</span><br><span class="line">4.enter可以限制触发的按键为回车</span><br><span class="line">5.事件修饰符有多种</span><br><span class="line"></span><br><span class="line">v-model</span><br><span class="line">1.v-model指令的作用是便捷的设置和获取表单元素的值</span><br><span class="line">2.绑定的数据会和表单元素相关联</span><br><span class="line">3.绑定的数据&#x3D;表单数据的值</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>李迟  2020.11.11 周三 晚</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文讲述 Vue 的基础知识，逐步更新。主要来自网络，有删改和自己的理解。  &lt;/p&gt;</summary>
    
    
    
    <category term="vue" scheme="http://www.latelee.org/category/vue/"/>
    
    
    <category term="vue" scheme="http://www.latelee.org/tag/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue实践录：windows 10系统vue环境搭建</title>
    <link href="http://www.latelee.org/vue/vue-notes-starting.html"/>
    <id>http://www.latelee.org/vue/vue-notes-starting.html</id>
    <published>2020-11-10T14:00:00.000Z</published>
    <updated>2020-12-21T09:16:14.900Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲述windows 10 64bit系统中，vue环境的搭建。</p><a id="more"></a><h1 id="nodejs环境"><a href="#nodejs环境" class="headerlink" title="nodejs环境"></a>nodejs环境</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载地址为：<a href="http://npm.taobao.org/mirrors/node/v14.15.0/%EF%BC%8C">http://npm.taobao.org/mirrors/node/v14.15.0/，</a> 下载安装包为<code>node-v14.15.0-x64.msi</code>。<br>双击，根据提示安装。默认已设置好PATH。  </p><h2 id="更新npm源为taobao："><a href="#更新npm源为taobao：" class="headerlink" title="更新npm源为taobao："></a>更新npm源为taobao：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line">npm config list &#x2F;&#x2F; 查看是否生效</span><br></pre></td></tr></table></figure><p>出现<code>metrics-registry = &quot;https://registry.npm.taobao.org/&quot;</code>表示已设置成功。可设置其它配置项的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm set cache &quot;E:\\Program Files\\nodejs\\node_cache&quot;</span><br><span class="line">npm set prefix &quot;E:\\Program Files\\nodejs\\npm_prefix&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>把<code>E:\\Program Files\\nodejs\\npm_prefix</code>加入到 PATH 变量中。否则，安装的包会提示找不到。    </p><h2 id="安装-cnpm"><a href="#安装-cnpm" class="headerlink" title="安装 cnpm"></a>安装 cnpm</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h2 id="安装-vue"><a href="#安装-vue" class="headerlink" title="安装 vue"></a>安装 vue</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cnpm install vue -g</span><br><span class="line">cnpm install vue-cli -g</span><br></pre></td></tr></table></figure><h2 id="简单工程及访问"><a href="#简单工程及访问" class="headerlink" title="简单工程及访问"></a>简单工程及访问</h2><p>根据官方模板创建工程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack-simple hellovue   &#x2F;&#x2F; 一路按回车，用默认值</span><br></pre></td></tr></table></figure><p>安装依赖并运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd hellovue</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>使用浏览器访问：<a href="http://localhost:8080/">http://localhost:8080/</a> 即可看到默认界面。  </p><p>打包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>李迟  2020.11.10 周二 晚</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文讲述windows 10 64bit系统中，vue环境的搭建。&lt;/p&gt;</summary>
    
    
    
    <category term="vue" scheme="http://www.latelee.org/category/vue/"/>
    
    
    <category term="vue" scheme="http://www.latelee.org/tag/vue/"/>
    
  </entry>
  
  <entry>
    <title>软考路：高项1心得</title>
    <link href="http://www.latelee.org/code-life/ruankao-pm1.html"/>
    <id>http://www.latelee.org/code-life/ruankao-pm1.html</id>
    <published>2020-11-08T15:00:00.000Z</published>
    <updated>2020-12-21T09:16:14.784Z</updated>
    
    <content type="html"><![CDATA[<p>本文简单记录高项的备考、复习、考试心得。  </p><a id="more"></a><h2 id="考试科目概述"><a href="#考试科目概述" class="headerlink" title="考试科目概述"></a>考试科目概述</h2><h2 id="上午-综合"><a href="#上午-综合" class="headerlink" title="上午 综合"></a>上午 综合</h2><p>全部选择题。多而杂，记忆的多。计题一般有4~5题，最后5题英文，第一章一般2题。<br>  不需要每字必记，只记关键要点。因为是选择题，只要选对（或最符合题意的）即可。<br>内容：第一章，立项，十大过程，测试，变更，配置、项目组合项目集，国家标准知识产权，等等。<br>可做战略放弃（像项目组合就放弃了）。  </p><p>难点：某些相近的要点之间的差别。比如，解决冲突方法的“包容”与“妥协”的差别。  </p><p>注意，既然是“综合”，则这些知识肯定能应用到其它科目，所以一定要有所侧重。有些要背的必须背。先分大类，再细化，否则，只知树叶不见森林。    </p><h2 id="下午案例"><a href="#下午案例" class="headerlink" title="下午案例"></a>下午案例</h2><p>案例，审题，背理论知识点。<br>难点：理论知识点，计算题。时间紧。    </p><h2 id="下午论文"><a href="#下午论文" class="headerlink" title="下午论文"></a>下午论文</h2><p>作文二选一，不需要写题目，但需要在答卷上选哪一题目，并涂黑。答卷有字数提示。<br>2019 年开始不用写摘要，直接从正文开始。<br>开头：背景介绍，约 500 字，背景有要求，如时间、项目、金额、工期，等等。也涉及项目中的技术（稍提即可，因为高项注重管理，非技术）。<br>中间：正文按题目要求，按过程写，如成本有 4 大过程，质量有 3 大过程。过程名称可做一段，再解释过程，涉及ITO，结合项目写怎么做，遇到问题及如何解决。<br>结尾：项目一定要完满如期完成，并且得到好评，但过程出现了小问题，但我及时发现并改进了。最后说自己还要继续努力学习，再表决心，为国家信息化建设做贡献。<br>注意，字数一定要够，哪怕凑字数。  </p><h2 id="学习分解"><a href="#学习分解" class="headerlink" title="学习分解"></a>学习分解</h2><p>清华版教程为主。    </p><p>1、书本分3大部分<br>开头几章。按内容划分，记关键字及其含义。<br>最后几章。同上。<br>十大过程。先记十大管理，再记47个过程，每个过程的含义、输入、输出、工具（可想象一个项目在这些过程的情景）。  </p><p>2、第一阶段，按书本章节学习。第二阶段，按知识点。如质量方面，有几篇都涉及到。    </p><p>3、扩展学习<br>涉及的如质量，标准，运筹学，可自行扩展学习。但要注意时间分配。</p><p>4、英文<br>教程有一些部分是直接翻译pmp英文版的，实际上，十大管理应该说有很多部分——特别是知识点和输入输出，都是直接翻译的，但也有部分是额外添加，也有部分是删减的。建议看之，一是加强理解，二是解决英文题目。<br>注：对于IT从业者，英文还是建议积累积累。  </p><p>5、关于记忆<br>可按自己擅长的方式记。先谐音，再恢复正常的。<br>有些知识前人已总结。如：信息信息6要素：上鹰下鸡左人右龟（上应，下技，左人，右规）。老七/新七工具。等等。<br>有些可自己归纳并联想。  如冲突解决方法：撤回（撤退/回避），和包（缓和包容），协调（妥协调解），强命（强迫命令），合解（合作解决问题）<br>如范围说明书6要点：范标成除制假。<br>有些则要强制记忆。如质量的定义（一组固有特性满足要求的程度，英文为：the degree to which a set of inherent characteristics fulfill requirements）。  </p><p>6、其它<br>十大管理，五大过程组，47个过程。<br>形式矩阵。从不同层面分析。<br>以十大管理角度：每个管理或多或少都涉及到过程组。（如整体管理、采购管理有收尾过程组，其它管理没有）<br>以过程组：每个过程组或多或少涉及到管理。（如启动过程组，涉及整体管理和干系人管理，其它管理没有这个过程组）<br>以项目开展角度，从启动过程组开始，涉及到管理的过程，一一展开。    </p><p>7、扩展学习<br>涉及的如质量，cmmi，软件标准，运筹学，可自行扩展学习。但要注意时间分配。只限兴趣学习。  </p><h2 id="复习重点及操作"><a href="#复习重点及操作" class="headerlink" title="复习重点及操作"></a>复习重点及操作</h2><p>以十大过程，变更，配置（2020年考了测试），能背则背，综合、案例、论文都会涉及到，多背没坏处。<br>在背的过程加上理解。  </p><p>按模块划分，写笔记到不同的文档：<br>1、开头一章<br>2、立项、配置、测试<br>3、采购法、合同法、国家标准、知识产权<br>4、十大管理（可分多个文档，过程描述及输入输出工具为一类，各种文档说明书内容步骤一类，杂项一类）<br>在整理过程中，可查询相关资料，加深理解（如查找质量的新七、老七工具的图例）。  </p><h2 id="报名"><a href="#报名" class="headerlink" title="报名"></a>报名</h2><p>一般提前3个月可报名（如11月初考，8月初可报名，一般每科68元，高级三科200多元）。<br>考前一周可打印准考证。  </p><h2 id="考试"><a href="#考试" class="headerlink" title="考试"></a>考试</h2><p>上场要带的（以个人为例）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">水。</span><br><span class="line">2B铅笔：1~2支</span><br><span class="line">中性笔：1~2支</span><br><span class="line">钢笔+墨水：1+1</span><br><span class="line">刀：1</span><br><span class="line">橡皮擦：1</span><br><span class="line">手表：1</span><br><span class="line">文具盒：1</span><br><span class="line">准考证，身份证</span><br></pre></td></tr></table></figure><h2 id="考场"><a href="#考场" class="headerlink" title="考场"></a>考场</h2><p>有的有时钟，但可能不准时。有的有大屏幕显示倒计时。<br>提前5~10分钟入考场。入场核对个人身份证准考证（监考有考生信息表格，核对照片），5分钟前开始发答题卡，发完再发试卷，发完再发草稿纸。改完再发准考证条形码。<br>答题卡、试卷均填姓名，准考证号。答题卡还要贴条形码。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文简单记录高项的备考、复习、考试心得。  &lt;/p&gt;</summary>
    
    
    
    <category term="代码生活" scheme="http://www.latelee.org/category/code-life/"/>
    
    
    <category term="考证" scheme="http://www.latelee.org/tag/%E8%80%83%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>软考路：高项2备考</title>
    <link href="http://www.latelee.org/code-life/ruankao-pm2.html"/>
    <id>http://www.latelee.org/code-life/ruankao-pm2.html</id>
    <published>2020-11-08T15:00:00.000Z</published>
    <updated>2020-12-21T09:16:14.784Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录一下高项的一些复习考点。慢慢补充。    </p><a id="more"></a><h2 id="综合知识"><a href="#综合知识" class="headerlink" title="综合知识"></a>综合知识</h2><p>巧记：<br>需求分析阶段：<br>数据模型-实体联系图（E-R图）<br>功能模型-数据流图（DED）<br>行为模型-状态转换图（STD）<br>速记：数实（属实）、功据（工具）、行状（形状）。  </p><h2 id="历年真题案例"><a href="#历年真题案例" class="headerlink" title="历年真题案例"></a>历年真题案例</h2><p>案例为三题，其中一题为计算题。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文记录一下高项的一些复习考点。慢慢补充。    &lt;/p&gt;</summary>
    
    
    
    <category term="代码生活" scheme="http://www.latelee.org/category/code-life/"/>
    
    
    <category term="考证" scheme="http://www.latelee.org/tag/%E8%80%83%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>软考路：高项3考试</title>
    <link href="http://www.latelee.org/code-life/ruankao-pm3.html"/>
    <id>http://www.latelee.org/code-life/ruankao-pm3.html</id>
    <published>2020-11-08T15:00:00.000Z</published>
    <updated>2020-12-21T09:16:14.784Z</updated>
    
    <content type="html"><![CDATA[<p>周六考试。周三下班后买了三天的菜。周四晚上带小孩上培训课我在旁边复习没一直盯着，后来才知道别的家长拍视频，孩子妈看到小孩不认真上课，因此事争吵起来。其实人家孩子妈在门口一边坐着一边看手机一边盯小孩，我一个大男人不方便在其中。周五因为小孩不认真吃饭又吵争，直接跳过拿棍子到拿刀的阶段，当然只是限于嘴上说说。  </p><a id="more"></a><p>准考证周一已经打印了2张，钢笔、墨水，铅笔、橡皮擦、小刀，身份证提前放到袋子里，昨晚也买了馒头，周六早上7点多起床，简单洗漱后就出发。因为特殊情况，要提前一个小时到场，所幸考场离我租房只有20分钟电驴的距离，到了学校，门口旁边已经站着许多人了，有的在吃早餐，有的在看书，我停好车后，一边啃馒头一边看笔记，不久，培哥也到了，简单交流交流几句，就排除进场了。先扫码注册得到通行信息，进大门，出示准考证，摘口罩识别人脸测体温（可能只是记录入场和体温），在高高横幅下面有公示板，找到考场编号，向志愿者问路，由于没到时间，考场封条没拆，恰好我的考场前面是饭堂，就进去坐着继续啃馒头看笔记。——实际上，一天的考试，没有一题是在当天看中的。<br>离考试还有10分钟，进考场。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;周六考试。周三下班后买了三天的菜。周四晚上带小孩上培训课我在旁边复习没一直盯着，后来才知道别的家长拍视频，孩子妈看到小孩不认真上课，因此事争吵起来。其实人家孩子妈在门口一边坐着一边看手机一边盯小孩，我一个大男人不方便在其中。周五因为小孩不认真吃饭又吵争，直接跳过拿棍子到拿刀的阶段，当然只是限于嘴上说说。  &lt;/p&gt;</summary>
    
    
    
    <category term="代码生活" scheme="http://www.latelee.org/category/code-life/"/>
    
    
    <category term="考证" scheme="http://www.latelee.org/tag/%E8%80%83%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>kindle使用及周边的记录</title>
    <link href="http://www.latelee.org/pkc/kindle-usage.html"/>
    <id>http://www.latelee.org/pkc/kindle-usage.html</id>
    <published>2020-10-31T16:00:00.000Z</published>
    <updated>2020-12-21T09:16:14.788Z</updated>
    
    <content type="html"><![CDATA[<p>kindle及周边的使用记录。</p><a id="more"></a><h2 id="初始化环境"><a href="#初始化环境" class="headerlink" title="初始化环境"></a>初始化环境</h2><p>购买设备，注册官网，添加设备，添加kindle.cn邮箱，添加信任邮箱。  </p><h2 id="kindle日常使用"><a href="#kindle日常使用" class="headerlink" title="kindle日常使用"></a>kindle日常使用</h2><h3 id="传书"><a href="#传书" class="headerlink" title="传书"></a>传书</h3><p>1、使用信任邮箱，添加电子书作为附件，发送之kindle邮箱，主题正文可为空。需格式转换，标题加<code>convert</code>。<br>2、USB线，放到document下，可建不同目录（但kindle不会识别磁盘的目录），字典在其下的字典目录。  </p><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><p>很多功能需开wifi，一般使用飞行模式即可。<br>kindle创建收藏夹，一一放添加书籍。<br>长按，可自动显示字典（可自动识别语言环境），但字典可能无释义。连网情况下，会自动翻译。  </p><h2 id="电子书工具相关"><a href="#电子书工具相关" class="headerlink" title="电子书工具相关"></a>电子书工具相关</h2><p>calibre：格式转换，可查看电子书以确定是否符合要求。<br>briss：PDF裁边。可删除空白边。先预览，合适再保存。<br>使用：File菜单加载文件，点击“取消”，右击蓝色区域，选中，可设置大小。Action菜单有拷贝和预览功能。<br>PDFPasswordRemover：解密工具，如pdf加密（pdf软件标题有”已加密“字样），去之。否则无法裁边。另有线上解密，但可能泄漏资料。    </p><h2 id="目前疑惑"><a href="#目前疑惑" class="headerlink" title="目前疑惑"></a>目前疑惑</h2><p>多个txt，合并为一个mobi或其它格式，有主目录，可索引。（这样书籍数量相对少些）<br>在书籍集合中，先读一本，再跳另一本，前一本是否记住页码？  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;kindle及周边的使用记录。&lt;/p&gt;</summary>
    
    
    
    <category term="个人知识中心" scheme="http://www.latelee.org/category/pkc/"/>
    
    
    <category term="工具使用" scheme="http://www.latelee.org/tag/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：oracle数据库实践</title>
    <link href="http://www.latelee.org/golang/golang-notes-oracle-test.html"/>
    <id>http://www.latelee.org/golang/golang-notes-oracle-test.html</id>
    <published>2020-10-23T15:10:24.000Z</published>
    <updated>2020-12-21T09:16:14.900Z</updated>
    
    <content type="html"><![CDATA[<p>本文在 Windows 7 64bit 系统上使用 golang 连接查询 oracle 数据库。  </p><a id="more"></a><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>前置条件：<br>安装mingw（取其gcc及库，因为要用cgo编译），安装git（取其bash）。安装oci。  </p><p>oracle提供了编程接口，golang 有多个实现库，但均需依赖 oracle 的 instantclient。下载OCI：<br><a href="https://www.oracle.com/database/technologies/instant-client/winx64-64-downloads.html">https://www.oracle.com/database/technologies/instant-client/winx64-64-downloads.html</a> 。<br>版本有 SDK 版本、Basic 版本。压缩包虽不同，但内含目录一致，解压到当前目录即可，拷贝到指定目录，示例：<code>D:\oracle\instantclient</code>。  </p><p>PKG_CONFIG_PATH环境变量 (失败)  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\mingw64\lib\pkg-config</span><br></pre></td></tr></table></figure><p>执行<code>echo $PKG_CONFIG_PATH</code>查看目录，映射到 E:\Program Files\Git\mingw64\lib 下，不存在pkgconfig，创建之。</p><h2 id="安装库"><a href="#安装库" class="headerlink" title="安装库"></a>安装库</h2><p>1、<br>获取oci8.pc。执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">go get github.com&#x2F;wendal&#x2F;go-oci8</span><br><span class="line">提示：</span><br><span class="line"># pkg-config --cflags  -- oci8</span><br><span class="line">Package oci8 was not found in the pkg-config search path.</span><br><span class="line">Perhaps you should add the directory containing &#96;oci8.pc&#39;</span><br><span class="line">to the PKG_CONFIG_PATH environment variable</span><br><span class="line">No package &#39;oci8&#39; found</span><br></pre></td></tr></table></figure><p>无须理会错误，此处是下载源码，主要获取pkg-config.exe和oci8.pc文件。在下载包go-oci8的windows目录，将pkg-config.exe拷贝到git的bin目录，oci8.pc拷贝到 E:\Program Files\Git\mingw64\lib\pkgconfig 目录。  </p><p>2、<br>再次执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go get github.com&#x2F;wendal&#x2F;go-oci8</span><br><span class="line">提示：</span><br><span class="line"># github.com&#x2F;wendal&#x2F;go-oci8</span><br><span class="line">D:&#x2F;mingw64&#x2F;bin&#x2F;..&#x2F;lib&#x2F;gcc&#x2F;x86_64-w64-mingw32&#x2F;8.1.0&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;x86_64-w64-mingw32&#x2F;bin&#x2F;ld.exe: cannot find -lclntsh</span><br><span class="line">collect2.exe: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><p>一说：把oci8.pc文件的lclntsh改为oci，修改后，再执行，通过。得到<code>pkg\windows_amd64\github.com\wendal\go-oci8.a</code>目录。  </p><p>由作者说明得知，<code>wendal</code>是从<code>mattn</code>仓库fork得到的，也下载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com&#x2F;mattn&#x2F;go-oci8</span><br></pre></td></tr></table></figure><p>对比两者源码和生成的.a文件，mattn的文件也多，库也比较大。但对比使用者而言无区别。为安全起见，实际工程使用 mattn 库。    </p><p>3、<br>oci8.pc内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#prefix&#x3D;D:&#x2F;oracle&#x2F;instantclient</span><br><span class="line">includedir&#x3D;D:&#x2F;oracle&#x2F;instantclient&#x2F;sdk&#x2F;include</span><br><span class="line">libdir&#x3D;D:&#x2F;oracle&#x2F;instantclient&#x2F;sdk&#x2F;lib&#x2F;msvc</span><br><span class="line"></span><br><span class="line">Name: oci8</span><br><span class="line">Description: Oracle Instant Client</span><br><span class="line">Version: 19.8</span><br><span class="line">Cflags: -I$&#123;includedir&#125;</span><br><span class="line">Libs: -L$&#123;libdir&#125; -loci</span><br></pre></td></tr></table></figure><p>注：使用全路径，不使用prefix（因为git安装的目录带有空格），将库修改为oci。  </p><p>4、<br>编写测试代码。go build 出错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">D:\go\pkg\tool\windows_amd64\link.exe: running gcc failed: exit status 1</span><br><span class="line">D:&#x2F;mingw64&#x2F;bin&#x2F;..&#x2F;lib&#x2F;gcc&#x2F;x86_64-w64-mingw32&#x2F;8.1.0&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;x86_64-w64-mingw32&#x2F;bin&#x2F;ld.exe: cannot find -loci</span><br><span class="line">collect2.exe: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><p>猜想：官方oci是.lib格式，gcc不认。而golang的驱动得到.a但没有包括oci里面的函数。将得到的go-oci8.a改名为liboci.a，再次<code>go build</code>，提示未定义的函数，用<code>nm</code>查之，函数前为<code>U</code>，猜测格式不对。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pkg-config --cflags -- oci8</span><br><span class="line">-ID:&#x2F;oracle&#x2F;instantclient&#x2F;sdk&#x2F;include</span><br></pre></td></tr></table></figure><p>在<code>D:\oracle\instantclient</code>目录找oci.dll，放到临时目录。从dll生成.a。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gendef.exe oci.dll  # 注：从dll生产def（下一步要用到）</span><br><span class="line"> * [oci.dll] Found PE image</span><br><span class="line"> </span><br><span class="line">$ dlltool.exe -D oci.dll -d oci.def -l liboci.a # 从dll和def生成.a文件。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>生成的文件为liboci.a，可用<code>nm</code>查函数，已有定义。将其放到mingw的lib目录（这样就不用再额外设置路径），本文为 D:\mingw64\lib 。  </p><p>5、<br>疑惑1：<br>似乎golang生成的go-oci8.a没什么用，可能内部链接了里面的函数，但最终的oci函数，还是从官方的oci库中获取，如OCIStmtPrepare。<br>疑惑2：<br>在<code>go get github.com/mattn/go-oci8</code>处，会使用pc文件指定的参数，但似乎只针对头文件，也没有链接，具体未详细研究（因为.lib和.a格式已然不同，不通用，链接不上的，没报错，应该没链接）。<br>疑惑3：<br>在测试中发现，如果编译成功后，将 D:\mingw64\lib\liboci.a 改后缀名，也会编译通过（猜测应该是 Golang 做了库的缓存，暂无时间研究透）。<br>疑惑4：<br>在编译 Golang 的机器上连接 oracle 一切正常，将可执行文件放到另一台安装了 oci 的电脑上，提示初始化失败，经查，未找到原因。<br>解决：经查，是 oci 版本导致的。使用 ProcessExplorer 查看其依赖的 oci 库，发现有 oraociei12.dll oraons.dll oci.dll 三个，另一电脑的 oci 为 19 版本，拷贝正确的，可运行。  </p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">true&quot;database&#x2F;sql&quot;</span><br><span class="line">true&quot;log&quot;</span><br><span class="line">true&quot;errors&quot;</span><br><span class="line">    &#x2F;&#x2F; 导入mysql驱动</span><br><span class="line">    _ &quot;github.com&#x2F;mattn&#x2F;go-oci8&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func CreateOracle(dbstr string) (sqldb *sql.DB, err error) &#123;</span><br><span class="line">    sqldb, err &#x3D; sql.Open(&quot;oci8&quot;, dbstr)</span><br><span class="line">trueif err !&#x3D; nil &#123;</span><br><span class="line">truetruereturn nil, errors.New(&quot;open database failed: &quot; + err.Error())</span><br><span class="line">true&#125;</span><br><span class="line">trueerr &#x3D; sqldb.Ping()</span><br><span class="line">trueif err !&#x3D; nil &#123;</span><br><span class="line">truetruereturn nil, errors.New(&quot;connect database failed: &quot; + err.Error())</span><br><span class="line">true&#125;</span><br><span class="line">truelog.Println(&quot;connect to oracle ok&quot;)</span><br><span class="line">    &#x2F;&#x2F;log.Println(&quot;connect to &quot;, dbParam.server, dbParam.database, &quot;ok&quot;)</span><br><span class="line">    </span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func GetVersion(sqldb *sql.DB) () &#123;</span><br><span class="line">true&#x2F;&#x2F; 降序，最新的在前面</span><br><span class="line">trueresults, err :&#x3D; sqldb.Query(&quot;select version, codetype, addtime from tablevesion order by tablevesion desc&quot;)</span><br><span class="line">trueif err !&#x3D; nil &#123;</span><br><span class="line">truetruefmt.Println(&quot;Query error: &quot;, err)</span><br><span class="line">truetruereturn</span><br><span class="line">true&#125;</span><br><span class="line">truefor results.Next() &#123;</span><br><span class="line">truetruevar item1, item2, item3 sql.NullString</span><br><span class="line">truetrueerr :&#x3D; results.Scan(&amp;item1, &amp;item2, &amp;item3)</span><br><span class="line">truetrueif err !&#x3D; nil &#123;</span><br><span class="line">truetruetruefmt.Println(&quot;scan error: &quot;, err)</span><br><span class="line">truetruetruebreak</span><br><span class="line">truetrue&#125;</span><br><span class="line"></span><br><span class="line">truetrueif (!item1.Valid || !item2.Valid || !item3.Valid) &#123;</span><br><span class="line">truetruetruecontinue</span><br><span class="line">truetrue&#125;</span><br><span class="line"></span><br><span class="line">truetruefmt.Println(item1.String, item2.String, item3.String)</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">truereturn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var dbstr &#x3D; &quot;latelee&#x2F;123456789@192.168.18.188:1521&#x2F;mydb&quot;</span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(&quot;oracle test&quot;)</span><br><span class="line">    </span><br><span class="line">    SQLDB, err :&#x3D; CreateOracle(dbstr)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        fmt.Println(&quot;open db failed&quot;, err)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    GetVersion(SQLDB)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>参考资料：<br><a href="https://www.cnblogs.com/good-temper/p/3791874.html">https://www.cnblogs.com/good-temper/p/3791874.html</a><br><a href="https://blog.csdn.net/yh_coco/article/details/78068610">https://blog.csdn.net/yh_coco/article/details/78068610</a>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文在 Windows 7 64bit 系统上使用 golang 连接查询 oracle 数据库。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：我的工具包</title>
    <link href="http://www.latelee.org/golang/golang-notes-my-utils.html"/>
    <id>http://www.latelee.org/golang/golang-notes-my-utils.html</id>
    <published>2020-10-20T16:11:24.000Z</published>
    <updated>2020-12-21T09:16:14.900Z</updated>
    
    <content type="html"><![CDATA[<p>程序员难免会自造轮子，因为有时候自己的轮子才更适合自己，golang 的生态圈不错，官方的，非官方都有很多不同功能的库。本文从小处着眼，基于 github 开源工程创建属于自己的工具包。  </p><a id="more"></a><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>本文的工具包，不依赖第三方库，全部使用官方的包。实际中使用了第三方库，则另起目录，作为其它包提供。不影响本包。本包命名为 com，可理解为通用的包。包括但不限于以下内容：<br>数值和字符串转换，进制转换。<br>目录、文件操作。<br>日期、时间。<br>命令执行。<br>MD5、base64。<br>地址内容打印Dump。  </p><h2 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h2><p>本小节列出一些函数的实现，详细参考文后源码地址。  </p><h3 id="字符串和数值转换"><a href="#字符串和数值转换" class="headerlink" title="字符串和数值转换"></a>字符串和数值转换</h3><p>字符串转为数值：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Convert string to specify type.</span><br><span class="line">type StrTo string</span><br><span class="line"></span><br><span class="line">func (f StrTo) Exist() bool &#123;</span><br><span class="line">truereturn string(f) !&#x3D; string(0x1E)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f StrTo) Uint8() (uint8) &#123;</span><br><span class="line">truev, _ :&#x3D; strconv.ParseUint(f.String(), 10, 8)</span><br><span class="line">truereturn uint8(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f StrTo) Int() (int) &#123;</span><br><span class="line">truev, _ :&#x3D; strconv.ParseInt(f.String(), 10, 0)</span><br><span class="line">truereturn int(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f StrTo) Int64() (int64) &#123;</span><br><span class="line">truev, _ :&#x3D; strconv.ParseInt(f.String(), 10, 64)</span><br><span class="line">truereturn int64(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f StrTo) Float64() (float64) &#123;</span><br><span class="line">truev, _ :&#x3D; strconv.ParseFloat(f.String(), 64)</span><br><span class="line">truereturn float64(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f StrTo) Uint8Hex() (uint8) &#123;</span><br><span class="line">truev, _ :&#x3D; strconv.ParseUint(f.String(), 16, 8)</span><br><span class="line">truereturn uint8(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f StrTo) IntHex() (int) &#123;</span><br><span class="line">truev, _ :&#x3D; strconv.ParseInt(f.String(), 16, 0)</span><br><span class="line">truereturn int(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f StrTo) Int64Hex() (int64) &#123;</span><br><span class="line">truev, _ :&#x3D; strconv.ParseInt(f.String(), 16, 64)</span><br><span class="line">truereturn int64(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f StrTo) String() string &#123;</span><br><span class="line">trueif f.Exist() &#123;</span><br><span class="line">truetruereturn string(f)</span><br><span class="line">true&#125;</span><br><span class="line">truereturn &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可根据不同函数，将字符串转换成对应的数值。注意，此处不判断原始字符串，通过不同函数指定格式。如<code>256</code>，即可认为十进制，也可认为是十六进制。  </p><p>数值转换为字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; Convert any type to string.</span><br><span class="line">func ToStr(value interface&#123;&#125;, args ...int) (s string) &#123;</span><br><span class="line">trueswitch v :&#x3D; value.(type) &#123;</span><br><span class="line">truecase bool:</span><br><span class="line">truetrues &#x3D; strconv.FormatBool(v)</span><br><span class="line">truecase float32:</span><br><span class="line">truetrues &#x3D; strconv.FormatFloat(float64(v), &#39;f&#39;, argInt(args).Get(0, -1), argInt(args).Get(1, 32))</span><br><span class="line">truecase float64:</span><br><span class="line">truetrues &#x3D; strconv.FormatFloat(v, &#39;f&#39;, argInt(args).Get(0, -1), argInt(args).Get(1, 64))</span><br><span class="line">truecase int:</span><br><span class="line">truetrues &#x3D; strconv.FormatInt(int64(v), argInt(args).Get(0, 10))</span><br><span class="line">truecase int8:</span><br><span class="line">truetrues &#x3D; strconv.FormatInt(int64(v), argInt(args).Get(0, 10))</span><br><span class="line">truecase int16:</span><br><span class="line">truetrues &#x3D; strconv.FormatInt(int64(v), argInt(args).Get(0, 10))</span><br><span class="line">truecase int32:</span><br><span class="line">truetrues &#x3D; strconv.FormatInt(int64(v), argInt(args).Get(0, 10))</span><br><span class="line">truecase int64:</span><br><span class="line">truetrues &#x3D; strconv.FormatInt(v, argInt(args).Get(0, 10))</span><br><span class="line">truecase uint:</span><br><span class="line">truetrues &#x3D; strconv.FormatUint(uint64(v), argInt(args).Get(0, 10))</span><br><span class="line">truecase uint8:</span><br><span class="line">truetrues &#x3D; strconv.FormatUint(uint64(v), argInt(args).Get(0, 10))</span><br><span class="line">truecase uint16:</span><br><span class="line">truetrues &#x3D; strconv.FormatUint(uint64(v), argInt(args).Get(0, 10))</span><br><span class="line">truecase uint32:</span><br><span class="line">truetrues &#x3D; strconv.FormatUint(uint64(v), argInt(args).Get(0, 10))</span><br><span class="line">truecase uint64:</span><br><span class="line">truetrues &#x3D; strconv.FormatUint(v, argInt(args).Get(0, 10))</span><br><span class="line">truecase string:</span><br><span class="line">truetrues &#x3D; v</span><br><span class="line">truecase []byte:</span><br><span class="line">truetrues &#x3D; string(v)</span><br><span class="line">truedefault:</span><br><span class="line">truetrues &#x3D; fmt.Sprintf(&quot;%v&quot;, v)</span><br><span class="line">true&#125;</span><br><span class="line">truereturn s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>十六进制和字符串转换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HexStr2int converts hex format string to decimal number.</span><br><span class="line">func HexStr2int(hexStr string) (int) &#123;</span><br><span class="line">truenum :&#x3D; 0</span><br><span class="line">truelength :&#x3D; len(hexStr)</span><br><span class="line">truefor i :&#x3D; 0; i &lt; length; i++ &#123;</span><br><span class="line">truetruechar :&#x3D; hexStr[length-i-1]</span><br><span class="line">truetruefactor :&#x3D; -1</span><br><span class="line"></span><br><span class="line">truetrueswitch &#123;</span><br><span class="line">truetruecase char &gt;&#x3D; &#39;0&#39; &amp;&amp; char &lt;&#x3D; &#39;9&#39;:</span><br><span class="line">truetruetruefactor &#x3D; int(char) - &#39;0&#39;</span><br><span class="line">truetruecase char &gt;&#x3D; &#39;a&#39; &amp;&amp; char &lt;&#x3D; &#39;f&#39;:</span><br><span class="line">truetruetruefactor &#x3D; int(char) - &#39;a&#39; + 10</span><br><span class="line">truetruedefault:</span><br><span class="line">truetruetruereturn -1</span><br><span class="line">truetrue&#125;</span><br><span class="line"></span><br><span class="line">truetruenum +&#x3D; factor * PowInt(16, i)</span><br><span class="line">true&#125;</span><br><span class="line">truereturn num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Int2HexStr converts decimal number to hex format string.</span><br><span class="line">func Int2HexStr(num int) (hex string) &#123;</span><br><span class="line">trueif num &#x3D;&#x3D; 0 &#123;</span><br><span class="line">truetruereturn &quot;0&quot;</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">truefor num &gt; 0 &#123;</span><br><span class="line">truetruer :&#x3D; num % 16</span><br><span class="line"></span><br><span class="line">truetruec :&#x3D; &quot;?&quot;</span><br><span class="line">truetrueif r &gt;&#x3D; 0 &amp;&amp; r &lt;&#x3D; 9 &#123;</span><br><span class="line">truetruetruec &#x3D; string(r + &#39;0&#39;)</span><br><span class="line">truetrue&#125; else &#123;</span><br><span class="line">truetruetruec &#x3D; string(r + &#39;a&#39; - 10)</span><br><span class="line">truetrue&#125;</span><br><span class="line">truetruehex &#x3D; c + hex</span><br><span class="line">truetruenum &#x3D; num &#x2F; 16</span><br><span class="line">true&#125;</span><br><span class="line">truereturn hex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓冲区、结构体打印"><a href="#缓冲区、结构体打印" class="headerlink" title="缓冲区、结构体打印"></a>缓冲区、结构体打印</h3><p>缓冲区打印：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">func Dump(by []byte, len int) &#123;</span><br><span class="line">    line :&#x3D; 16</span><br><span class="line">    n :&#x3D; len &#x2F; line</span><br><span class="line">    if len % line !&#x3D; 0 &#123;</span><br><span class="line">        n++</span><br><span class="line">    &#125;</span><br><span class="line">    for i :&#x3D; 0; i &lt; n; i++ &#123;</span><br><span class="line">        fmt.Printf(&quot;%08x  &quot;, i*line)</span><br><span class="line">        for j :&#x3D; 0; j &lt; line; j++ &#123;</span><br><span class="line">            if i*line+j &lt; len &#123;</span><br><span class="line">                fmt.Printf(&quot;%02x &quot;, by[i*line+j])</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                fmt.Printf(&quot;   &quot;)</span><br><span class="line">            &#125;</span><br><span class="line">            if j &#x3D;&#x3D; 7 &#123;</span><br><span class="line">                fmt.Printf(&quot; &quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(&quot; |&quot;)</span><br><span class="line">        for j :&#x3D; 0; j&lt;line &amp;&amp; (i*line+j)&lt;len; j++ &#123;</span><br><span class="line">            if (i*line+j) &lt; len &#123;</span><br><span class="line">                c :&#x3D; by[i*line+j]</span><br><span class="line">                if c &gt;&#x3D; &#39; &#39; &amp;&amp; c &lt; &#39;~&#39;&#123;</span><br><span class="line">                    fmt.Printf(&quot;%c&quot;, c)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    fmt.Printf(&quot;.&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                fmt.Printf(&quot;   &quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(&quot;|\n&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数实际为笔者 C 语言版本的改写。  </p><p>结构体或map的打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将数组、map等，按行打印，默认fmt.Println是一行</span><br><span class="line">func PrintByLine(w io.Writer, data interface&#123;&#125;) &#123;</span><br><span class="line">trueif w &#x3D;&#x3D; os.Stderr &#123;</span><br><span class="line">truetruefmt.Fprintf(os.Stderr, &quot;error: &quot;)</span><br><span class="line">true&#125;</span><br><span class="line">truet :&#x3D; reflect.TypeOf(data)</span><br><span class="line"></span><br><span class="line">truev :&#x3D; reflect.ValueOf(data)</span><br><span class="line">trueif v.Len() &#x3D;&#x3D; 0 &#123;</span><br><span class="line">truetruereturn</span><br><span class="line">true&#125;</span><br><span class="line">truefmt.Fprintf(w, &quot;[\n&quot;)</span><br><span class="line">trueswitch t.Kind() &#123;</span><br><span class="line">truecase reflect.Slice, reflect.Array:</span><br><span class="line">truetruefor i :&#x3D; 0; i &lt; v.Len(); i++ &#123;</span><br><span class="line">truetruetruefmt.Fprintf(w, &quot;%d  %v\n&quot;, i+1, v.Index(i))</span><br><span class="line">truetrue&#125;</span><br><span class="line">truecase reflect.Map:</span><br><span class="line">truetrueiter :&#x3D; v.MapRange()</span><br><span class="line">truetruei :&#x3D; 0</span><br><span class="line">truetruefor iter.Next() &#123;</span><br><span class="line">truetruetruefmt.Fprintf(w, &quot;%d %v: %v\n&quot;, i+1, iter.Key(), iter.Value())</span><br><span class="line">truetruetruei +&#x3D; 1</span><br><span class="line">truetrue&#125;</span><br><span class="line">truedefault:</span><br><span class="line">truetruefmt.Fprintf(w, &quot;%v\n&quot;, data)</span><br><span class="line">true&#125;</span><br><span class="line">truefmt.Fprintf(w, &quot;]\ntotal: %d\n&quot;, v.Len())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间相关"><a href="#时间相关" class="headerlink" title="时间相关"></a>时间相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Format unix time int64 to string</span><br><span class="line">func Date(ti int64, format string) string &#123;</span><br><span class="line">truet :&#x3D; time.Unix(int64(ti), 0)</span><br><span class="line">truereturn DateT(t, format)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Format unix time string to string</span><br><span class="line">func DateS(ts string, format string) string &#123;</span><br><span class="line">truei, _ :&#x3D; strconv.ParseInt(ts, 10, 64)</span><br><span class="line">truereturn Date(i, format)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Format time.Time struct to string</span><br><span class="line">&#x2F;&#x2F; MM - month - 01</span><br><span class="line">&#x2F;&#x2F; M - month - 1, single bit</span><br><span class="line">&#x2F;&#x2F; DD - day - 02</span><br><span class="line">&#x2F;&#x2F; D - day 2</span><br><span class="line">&#x2F;&#x2F; YYYY - year - 2006</span><br><span class="line">&#x2F;&#x2F; YY - year - 06</span><br><span class="line">&#x2F;&#x2F; HH - 24 hours - 03</span><br><span class="line">&#x2F;&#x2F; H - 24 hours - 3</span><br><span class="line">&#x2F;&#x2F; hh - 12 hours - 03</span><br><span class="line">&#x2F;&#x2F; h - 12 hours - 3</span><br><span class="line">&#x2F;&#x2F; mm - minute - 04</span><br><span class="line">&#x2F;&#x2F; m - minute - 4</span><br><span class="line">&#x2F;&#x2F; ss - second - 05</span><br><span class="line">&#x2F;&#x2F; s - second &#x3D; 5</span><br><span class="line">&#x2F;&#x2F; TODO ms</span><br><span class="line">func DateT(t time.Time, format string) string &#123;</span><br><span class="line">trueres :&#x3D; strings.Replace(format, &quot;MM&quot;, t.Format(&quot;01&quot;), -1)</span><br><span class="line">trueres &#x3D; strings.Replace(res, &quot;M&quot;, t.Format(&quot;1&quot;), -1)</span><br><span class="line">trueres &#x3D; strings.Replace(res, &quot;DD&quot;, t.Format(&quot;02&quot;), -1)</span><br><span class="line">trueres &#x3D; strings.Replace(res, &quot;D&quot;, t.Format(&quot;2&quot;), -1)</span><br><span class="line">trueres &#x3D; strings.Replace(res, &quot;YYYY&quot;, t.Format(&quot;2006&quot;), -1)</span><br><span class="line">trueres &#x3D; strings.Replace(res, &quot;YY&quot;, t.Format(&quot;06&quot;), -1)</span><br><span class="line">trueres &#x3D; strings.Replace(res, &quot;HH&quot;, fmt.Sprintf(&quot;%02d&quot;, t.Hour()), -1)</span><br><span class="line">trueres &#x3D; strings.Replace(res, &quot;H&quot;, fmt.Sprintf(&quot;%d&quot;, t.Hour()), -1)</span><br><span class="line">trueres &#x3D; strings.Replace(res, &quot;hh&quot;, t.Format(&quot;03&quot;), -1)</span><br><span class="line">trueres &#x3D; strings.Replace(res, &quot;h&quot;, t.Format(&quot;3&quot;), -1)</span><br><span class="line">trueres &#x3D; strings.Replace(res, &quot;mm&quot;, t.Format(&quot;04&quot;), -1)</span><br><span class="line">trueres &#x3D; strings.Replace(res, &quot;m&quot;, t.Format(&quot;4&quot;), -1)</span><br><span class="line">trueres &#x3D; strings.Replace(res, &quot;ss&quot;, t.Format(&quot;05&quot;), -1)</span><br><span class="line">trueres &#x3D; strings.Replace(res, &quot;s&quot;, t.Format(&quot;5&quot;), -1)</span><br><span class="line">truereturn res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>延时函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func Sleep(ms time.Duration) &#123;</span><br><span class="line">truetime.Sleep(ms*time.Millisecond);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其它工具包"><a href="#其它工具包" class="headerlink" title="其它工具包"></a>其它工具包</h2><p>本小节列出其它的工具包。  </p><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>我一起纠结使用哪个日志库，在犹豫中花费很多时间，最后决定先用着一个版本，待到不合适时，再选择其它的。在接触 KubeEdge项目时，了解了 klog 库，考虑到其轻便，最终改造并使用。为了保持原样，其位置和名称均无变化。原始版本提供的主要接口函数如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Fatal Fatalf Fatalln</span><br><span class="line">Error Errorf Errorln</span><br><span class="line">Warning Warningf Warningln</span><br><span class="line">Exit Exitf Exitln</span><br></pre></td></tr></table></figure><p>为了方便自己理解和使用，额外再添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Print Printf Println</span><br></pre></td></tr></table></figure><p>这样就可以和 fmt 无缝切换了。  </p><p>另外，考虑到不需要 pid，所以在输出提示符中去掉了 pid。输出格式如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2020-10-20 21:47:29.411 busy.go:20] hello world</span><br></pre></td></tr></table></figure><p>此提示符为笔者一直使用且已习惯。  </p><p>详情可参考<a href="https://github.com/latelee/go_project/blob/master/vendor/k8s.io/klog/klog.go">klog源码</a> 。</p><p>补记：<br>log4go功能强大，但似乎不能转义<code>\n</code>，会将其原样输出。  </p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>本文所述工具包，大部分来自 <a href="https://github.com/Unknwon/com">无闻github</a> 的开源项目，在实践中不断优化并添加自己认为必要的工具函数。详细可参考笔者的 <a href="https://github.com/latelee/go_project/tree/master/pkg/com">golang工程</a> 。在此向 <a href="https://github.com/Unknwon">无闻</a> 致敬！  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;程序员难免会自造轮子，因为有时候自己的轮子才更适合自己，golang 的生态圈不错，官方的，非官方都有很多不同功能的库。本文从小处着眼，基于 github 开源工程创建属于自己的工具包。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：命令行cobra库实例</title>
    <link href="http://www.latelee.org/golang/golang-notes-cobra-note.html"/>
    <id>http://www.latelee.org/golang/golang-notes-cobra-note.html</id>
    <published>2020-10-20T16:10:24.000Z</published>
    <updated>2020-12-21T09:16:14.900Z</updated>
    
    <content type="html"><![CDATA[<p>本文使用 cobra 库实现一个命令行工具，类似 git、docker、kubectl 这类的工具。<br>本文仅为一个初具模型的示例，但有实践参考意义。  </p><a id="more"></a><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>在编程中，很多时候，程序都会处理多个参数，特别是一些工具类的函数，需要整合较多功能，即使同一功能，也会有不同参数，利用配置文件或命令选项方式，可使程序具备通用性，也具扩展性。  </p><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>cobra 功能较强大，在 golang 生态中有很多应用，如大名鼎鼎的 docker。其支持子命令执行，配置文件读写等，本文以实战为目的，不过多介绍。  </p><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p>工程名为 cmdtool，见名知义。<br>工程目录及对应介绍如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── cmd ## 子命令总目录</span><br><span class="line">│   ├── db    ## 子命令1实现目录</span><br><span class="line">│   ├── misc  ## 子命令2实现目录</span><br><span class="line">│   ├── rootCmd.go  ## 子命令入口</span><br><span class="line">│   └── test  ## 子命令3实现目录</span><br><span class="line">├── common ## 共用函数、变量</span><br><span class="line">│   ├── conf</span><br><span class="line">│   ├── constants</span><br><span class="line">│   └── globalfunc.go</span><br><span class="line">├── config.yaml ## 配置文件</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── main.go  ## 入口函数 </span><br><span class="line">├── mybuild.sh ## 编译脚本</span><br><span class="line">├── pkg  ## 库</span><br><span class="line">│   ├── com</span><br><span class="line">│   └── wait</span><br><span class="line">├── README</span><br><span class="line">└── vendor ## 依赖库</span><br><span class="line">    ├── github.com</span><br><span class="line">    ├── golang.org</span><br><span class="line">    ├── gopkg.in</span><br><span class="line">    ├── k8s.io</span><br><span class="line">    └── xorm.io</span><br></pre></td></tr></table></figure><p>其中 cmd 是所有子命令的入口目录，不同子命令，以不同子目录形式存在。common 目录存在共用的变量或初始化函数，等等。pkg 为个人总结积累的一些有用的库。<br>main.go 为主函数，调用了 cmd/rootCmd.go 的创建命令函数，由此进入 cobra 的处理框架中。<br>一般情况下，只需要扩展 cmd 目录下子命令，并补充 rootCmd.go 函数即可，其它即为业务程序的处理。<br>注：原本设计的思路是，在子命令包的 init 函数中自动注册到 rootCmd 中，但发现不一定符合逻辑，故舍弃，需手动在 rootCmd 添加。  </p><h2 id="工程分解"><a href="#工程分解" class="headerlink" title="工程分解"></a>工程分解</h2><h3 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h3><p>主入口函数非常简单，实际调用了 rootCmd.go 中的执行函数。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    _ &quot;fmt&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">    rootCmd &quot;github.com&#x2F;latelee&#x2F;cmdtool&#x2F;cmd&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">trueif err :&#x3D; rootCmd.Execute(); err !&#x3D; nil &#123;</span><br><span class="line">truetrueos.Exit(1)</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命令行入口"><a href="#命令行入口" class="headerlink" title="命令行入口"></a>命令行入口</h3><p>rootCmd.go 源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">package cmd</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">true&quot;os&quot;</span><br><span class="line">true&quot;bytes&quot;</span><br><span class="line">    &quot;path&#x2F;filepath&quot;</span><br><span class="line">true&quot;github.com&#x2F;spf13&#x2F;cobra&quot;</span><br><span class="line">true&quot;github.com&#x2F;spf13&#x2F;viper&quot;</span><br><span class="line">true</span><br><span class="line">true&quot;github.com&#x2F;fsnotify&#x2F;fsnotify&quot;</span><br><span class="line"></span><br><span class="line">    &quot;k8s.io&#x2F;klog&quot;</span><br><span class="line">    test &quot;github.com&#x2F;latelee&#x2F;cmdtool&#x2F;cmd&#x2F;test&quot;</span><br><span class="line">truemisc &quot;github.com&#x2F;latelee&#x2F;cmdtool&#x2F;cmd&#x2F;misc&quot;</span><br><span class="line">truedb   &quot;github.com&#x2F;latelee&#x2F;cmdtool&#x2F;cmd&#x2F;db&quot;</span><br><span class="line">trueconf &quot;github.com&#x2F;latelee&#x2F;cmdtool&#x2F;common&#x2F;conf&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    longDescription &#x3D; &#96;  database test tool.</span><br><span class="line">  命令终端测试示例工具。</span><br><span class="line">&#96;</span><br><span class="line">    example &#x3D; &#96;  comming soon...</span><br><span class="line">&#96;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var cfgFile string</span><br><span class="line"></span><br><span class="line">var rootCmd &#x3D; &amp;cobra.Command&#123;</span><br><span class="line">trueUse:   filepath.Base(os.Args[0]),</span><br><span class="line">trueShort: &quot;database tool&quot;,</span><br><span class="line">trueLong: longDescription,</span><br><span class="line">trueExample: example,</span><br><span class="line">trueVersion: &quot;1.0&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Execute() error &#123;</span><br><span class="line">    rootCmd.AddCommand(test.NewCmdTest())</span><br><span class="line">truerootCmd.AddCommand(misc.NewCmdMisc())</span><br><span class="line">truerootCmd.AddCommand(db.NewCmdDb())</span><br><span class="line"></span><br><span class="line">truereturn rootCmd.Execute()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">truecobra.OnInitialize(initConfig)</span><br><span class="line"></span><br><span class="line">truerootCmd.PersistentFlags().StringVar(&amp;cfgFile, &quot;config&quot;, &quot;&quot;, &quot;config file (config.yaml)&quot;)</span><br><span class="line"></span><br><span class="line">    rootCmd.PersistentFlags().BoolVar(&amp;conf.FlagPrint, &quot;print&quot;, false, &quot;will print sth&quot;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var yamlExample &#x3D; []byte(</span><br><span class="line">&#96;dbserver:</span><br><span class="line">  dbstr: helloooooo</span><br><span class="line">  timeout:</span><br><span class="line">    connect: 67s</span><br><span class="line">    singleblock: 2s</span><br><span class="line">  name:</span><br><span class="line">    name: firstblood</span><br><span class="line">&#96;)</span><br><span class="line"></span><br><span class="line">func initConfig() &#123;</span><br><span class="line">trueif cfgFile !&#x3D; &quot;&quot; &#123;</span><br><span class="line">truetrueviper.SetConfigFile(cfgFile)</span><br><span class="line">true&#125; else &#123;</span><br><span class="line">truetrueviper.AddConfigPath(&quot;.&#x2F;&quot;)</span><br><span class="line">truetrueviper.SetConfigName(&quot;config&quot;)</span><br><span class="line">truetrueviper.SetConfigType(&quot;yaml&quot;)</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">trueviper.AutomaticEnv()</span><br><span class="line"></span><br><span class="line">trueerr :&#x3D; viper.ReadInConfig();</span><br><span class="line">trueif  err !&#x3D; nil &#123;</span><br><span class="line">truetrueklog.Println(&quot;not found config file. using default&quot;)</span><br><span class="line">truetrueviper.ReadConfig(bytes.NewBuffer(yamlExample))</span><br><span class="line">truetrueviper.SafeWriteConfig()</span><br><span class="line">truetrue</span><br><span class="line">true&#125;</span><br><span class="line">trueconf.FlagDBServer &#x3D; viper.GetString(&quot;dbserver.dbstr&quot;)</span><br><span class="line">trueconf.FlagTimeout &#x3D; viper.GetString(&quot;dbserver.timeout.connect&quot;)</span><br><span class="line">trueconf.FlagName &#x3D; viper.GetString(&quot;dbserver.name.name&quot;)</span><br><span class="line">trueklog.Println(conf.FlagDBServer, conf.FlagTimeout, conf.FlagName)</span><br><span class="line"></span><br><span class="line">true&#x2F;&#x2F;设置监听回调函数</span><br><span class="line">trueviper.OnConfigChange(func(e fsnotify.Event) &#123;</span><br><span class="line">truetrueconf.FlagTimeout &#x3D; viper.GetString(&quot;dbserver.timeout.connect&quot;)</span><br><span class="line">true&#125;)</span><br><span class="line"></span><br><span class="line">trueviper.WatchConfig()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 initConfig 函数作用是读取配置文件字段，如果没有文件则自动生成默认的配置。注意，该函数的 yamlExample 需要保持实际配置文件的格式（从 viper.GetString 函数参数可以看出 dbserver 为顶层字段）。<br>最后利用 viper 监听配置文件的变化。实际测试发现会触发2次，利用循环定时判断变量值可以解决。  </p><h3 id="子命令实现"><a href="#子命令实现" class="headerlink" title="子命令实现"></a>子命令实现</h3><p>子命令的实现形式大同小异，以 test 为例，源码如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">package cmd</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;github.com&#x2F;spf13&#x2F;cobra&quot;</span><br><span class="line">true_ &quot;github.com&#x2F;spf13&#x2F;pflag&quot;</span><br><span class="line">true</span><br><span class="line">true&quot;k8s.io&#x2F;klog&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    name &#x3D; &#96;test&#96;</span><br><span class="line">    shortDescription &#x3D; &#96;  test command&#96;</span><br><span class="line">    longDescription  &#x3D; &#96;  test...</span><br><span class="line">&#96;</span><br><span class="line">    example &#x3D; &#96;  example comming up...</span><br><span class="line">&#96;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type UserCmdFunc struct &#123;</span><br><span class="line">truename string</span><br><span class="line">truefn func(args []string)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewCmdTest() *cobra.Command&#123;</span><br><span class="line">true</span><br><span class="line">    var cmd &#x3D; &amp;cobra.Command&#123;</span><br><span class="line">        Use:     name,</span><br><span class="line">        Short:   shortDescription,</span><br><span class="line">        Long:    longDescription,</span><br><span class="line">        Example: example,</span><br><span class="line">        RunE: func(cmd *cobra.Command, args []string) error &#123;</span><br><span class="line">truetruetrueif (len(args) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">truetruetruetrueklog.Warning(&quot;no args found&quot;)</span><br><span class="line">truetruetruetruereturn nil</span><br><span class="line">truetruetrue&#125;</span><br><span class="line"></span><br><span class="line">            if (args[0] &#x3D;&#x3D; &quot;foo&quot;)&#123;</span><br><span class="line">                foo(args)</span><br><span class="line">            &#125; else if (args[0] &#x3D;&#x3D; &quot;watch&quot;)&#123;</span><br><span class="line">                testWatch(args)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">truetruetruetrueklog.Printf(&quot;cmd &#39;%v&#39; not support&quot;, args[0])</span><br><span class="line">truetruetruetruereturn nil</span><br><span class="line">truetruetrue&#125; </span><br><span class="line">            return nil</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return cmd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 NewCmdTest 函数中创建 cobra.Command 并返回，在 RunE 中判断参数并真正执行业务函数。本例实现了参数监听功能，源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 监听配置参数变化</span><br><span class="line">func testWatch(args []string) &#123;</span><br><span class="line">truetimeout :&#x3D; conf.FlagTimeout</span><br><span class="line">truefor &#123;</span><br><span class="line">truetrueif timeout !&#x3D; conf.FlagTimeout &#123;</span><br><span class="line">truetruetrueklog.Printf(&quot;param changed: %v\n&quot;, conf.FlagTimeout)</span><br><span class="line">truetruetruetimeout &#x3D; conf.FlagTimeout</span><br><span class="line">truetrue&#125;</span><br><span class="line">truetruecom.Sleep(1000)</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line">当配置文件相应字段变化时，将其打印出来。  </span><br><span class="line"></span><br><span class="line">## 测试</span><br><span class="line">默认输出帮助信息：  </span><br></pre></td></tr></table></figure><p>$ ./cmdtool.exe<br>  database test tool.<br>  命令终端测试示例工具。</p><p>Usage:<br>  cmdtool.exe [command]</p><p>Examples:<br>  comming soon…</p><p>Available Commands:<br>  db            db command<br>  help        Help about any command<br>  misc          misc command<br>  test          test command</p><p>Flags:<br>  -h, –help      help for cmdtool.exe<br>      –print     will print sth<br>      –version   version for cmdtool.exe</p><p>Use “cmdtool.exe [command] –help” for more information about a command.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行子命令：</span><br></pre></td></tr></table></figure><p>$ ./cmdtool.exe test foo<br>[2020-10-20 21:46:39.304 rootCmd.go:113] helloooooo 61s firstblood<br>[2020-10-20 21:46:39.305 busy.go:12] test foo…..</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">监听配置文件：  </span><br></pre></td></tr></table></figure><p>$ ./cmdtool.exe test watch<br>[2020-10-20 21:47:14.408 rootCmd.go:113] helloooooo 61s firstblood<br>[2020-10-20 21:47:29.411 busy.go:20] param changed: 100s</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 源码</span><br><span class="line"></span><br><span class="line">源码[在此](https:&#x2F;&#x2F;github.com&#x2F;latelee&#x2F;cmdtool)。</span><br><span class="line"></span><br><span class="line">## 其它事项</span><br><span class="line">利用&#96;viper.SafeWriteConfig()&#96;写配置文件时，发现 yamlExample 添加的注释会被删除，所以可以考虑直接将字符串通过&#96;ioutil.WriteFile&#96;写到文件。  </span><br><span class="line"></span><br><span class="line">viper 获取 yaml 参数的接口：  </span><br></pre></td></tr></table></figure><p>获取数值、字符串、字符串数组、数值数组<br>GetInt GetInt32 GetInt64 GetUint GetUint32 GetUint64 GetString GetStringSlice GetIntSlice<br>```</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文使用 cobra 库实现一个命令行工具，类似 git、docker、kubectl 这类的工具。&lt;br&gt;本文仅为一个初具模型的示例，但有实践参考意义。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>Windows设置IP脚本</title>
    <link href="http://www.latelee.org/pkc/setting-ip-for-windows.html"/>
    <id>http://www.latelee.org/pkc/setting-ip-for-windows.html</id>
    <published>2020-10-19T16:00:00.000Z</published>
    <updated>2020-12-21T09:16:14.788Z</updated>
    
    <content type="html"><![CDATA[<p>Windows下设置IP的脚本。</p><a id="more"></a><h2 id="固定IP"><a href="#固定IP" class="headerlink" title="固定IP"></a>固定IP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cls</span><br><span class="line">color 0A</span><br><span class="line">echo waiting...</span><br><span class="line"></span><br><span class="line">netsh interface ipv4 set address name&#x3D;&quot;本地连接&quot; source&#x3D;static addr&#x3D;10.10.6.6  mask&#x3D;255.255.255.0 gateway&#x3D;10.10.6.254 gwmetric&#x3D;1</span><br><span class="line">netsh interface ipv4 set dns name&#x3D;&quot;本地连接&quot; source&#x3D;static addr&#x3D;8.8.8.8</span><br><span class="line"></span><br><span class="line">echo done.</span><br><span class="line">Pause</span><br></pre></td></tr></table></figure><h2 id="自动获取IP"><a href="#自动获取IP" class="headerlink" title="自动获取IP"></a>自动获取IP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cls</span><br><span class="line">color 0A</span><br><span class="line">Echo  waiting...</span><br><span class="line"></span><br><span class="line">netsh interface ip set address name&#x3D;&quot;本地连接&quot; source&#x3D;dhcp</span><br><span class="line">netsh interface ip set dns name&#x3D;&quot;本地连接&quot; source&#x3D;dhcp</span><br><span class="line"></span><br><span class="line">Echo done...</span><br><span class="line"></span><br><span class="line">Pause</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Windows下设置IP的脚本。&lt;/p&gt;</summary>
    
    
    
    <category term="个人知识中心" scheme="http://www.latelee.org/category/pkc/"/>
    
    
    <category term="工具使用" scheme="http://www.latelee.org/tag/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>格式化工具indent使用笔记</title>
    <link href="http://www.latelee.org/pkc/database-practice.html"/>
    <id>http://www.latelee.org/pkc/database-practice.html</id>
    <published>2020-09-14T16:00:00.000Z</published>
    <updated>2020-12-21T09:16:14.788Z</updated>
    
    <content type="html"><![CDATA[<p>indent可以格式化C/C++代码，经测试发现，只有Linux格式的文件才能正确格式化，即以LF结尾。</p><a id="more"></a><h2 id="使用格式"><a href="#使用格式" class="headerlink" title="使用格式"></a>使用格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">indent [参数][源文件]</span><br><span class="line">或</span><br><span class="line">indent [参数][源文件][-o 目标文件]</span><br></pre></td></tr></table></figure><h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><h3 id="个人使用的"><a href="#个人使用的" class="headerlink" title="个人使用的"></a>个人使用的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">个人使用的：</span><br><span class="line">indent -linux -bad -bap -bl -hnl -nce -cdw -bli0 -cli0 -cbi0 -ncs -lp -l200 -npcs -saf -sai -saw -i4 -nut hello.c -o b.c</span><br><span class="line"></span><br><span class="line">-cli 指定switch 缩排格数？？</span><br><span class="line">-hnl 多行运算时，按一定格式换行</span><br><span class="line">-bl -nce  for if while 等后的&#123;另起一行 不要将else放到&#125;后，即大括号另起一行</span><br><span class="line">-cdw do&#123;&#125;while中，while与&#125;在同一行。注：似乎和前面的冲突了，不生效（待研究）</span><br><span class="line">-bli0 &#123;不缩进，即对齐for if while 等</span><br><span class="line">-ncs 类型转换不空格。注：只能识别已知类型，自定义的不行（注：发现原有不空格的，变成空格了，待研究）</span><br><span class="line">-lp 过长截取时，对齐，-nlp 反之</span><br><span class="line">-nbc 变量声明中，逗号分隔的变量不分行。最终效果为 int a, b, c;</span><br><span class="line">-bad -bap 声明和实现之间添加空行，不一定符合实际情况。  </span><br><span class="line">-npcs 函数名称后不加空格</span><br><span class="line">-nut -i4  4空格，不使用tab缩进（即tab使用4个空格替换）</span><br><span class="line">-saf -sai -saw for if while 后有一空格</span><br><span class="line"></span><br><span class="line">-l200 非注释行，最长256 默认78</span><br></pre></td></tr></table></figure><p>待改善的问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">默认：指针类型的*不在类型后，而在变量前。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h3><p>indent默认风格为gnu。另有kr、linux、orig（即原始的Berkeley风格）。经测试，linux风格较接近实际使用的。    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">linux风格默认为：</span><br><span class="line">-nbad -bap -nbc -bbo -hnl -br -brs -c33 -cd33 -ncdb -ce -ci4</span><br><span class="line">-cli0 -d0 -di1 -nfc1 -i8 -ip0 -l80 -lp -npcs -nprs -npsl -sai</span><br><span class="line">-saf -saw -ncs -nsc -sob -nfca -cp33 -ss -ts8 -il1</span><br></pre></td></tr></table></figure><h2 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h2><p>查找某目录下所有源码，转换成linux格式，再格式化。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find .&#x2F;  -name &#39;*.cpp&#39; -or -name &#39;*.c&#39; -or -name &quot;*.h&quot; | xargs dos2unix </span><br><span class="line">find .&#x2F;  -name &#39;*.cpp&#39; -or -name &#39;*.c&#39; -or -name &quot;*.h&quot; | xargs indent -linux -bl -nce -cdw -bli0 -cli0 -cbi0 -ncs -lp -l200 -npcs -saf -sai -saw -i4 -nut </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码中有<code>int ret=-1</code>时警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning:old style assignment ambiguity in &quot;&#x3D;-&quot;.  Assuming &quot;&#x3D; -&quot;</span><br></pre></td></tr></table></figure><p>对c++一些语法处理不太好。如<code>for (auto it:dataTable)</code>。<br>对没有分号<code>;</code>结尾的“函数”或宏处理不好，如<code>#pragma pack(1)</code>，会自动再缩进。<br>一些小格式对齐不够人性化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原为：</span><br><span class="line">    int pre  &#x3D; 0;</span><br><span class="line">    int next &#x3D; 0;</span><br><span class="line">变成：</span><br><span class="line">    int pre &#x3D; 0;</span><br><span class="line">    int next &#x3D; 0;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>建议先用工具格式化，再规范编码，后续以人工为准。  </p><h2 id="网络资料"><a href="#网络资料" class="headerlink" title="网络资料"></a>网络资料</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">参数说明：</span><br><span class="line">-npro或--ignore-profile 　不要读取indent的配置文件.indent.pro。</span><br><span class="line">-kr 　指定使用Kernighan&amp;Ritchie的格式。</span><br><span class="line">-i8 　--indent-level 设置缩排的格数为8。</span><br><span class="line">-ts8 设置tab的长度</span><br><span class="line">-sob或--swallow-optional-blank-lines 　删除多余的空白行。</span><br><span class="line">-l80 代码超过80换行</span><br><span class="line">-ss或--space-special-semicolon 　若for区段只有一行时，在分号前加上空格。</span><br><span class="line">-ncs或--no-space-after-casts 　不要在cast之后空一格。</span><br><span class="line">-bl &#123;分行显示</span><br><span class="line">-bli 0 括号缩进为0</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">参　　数：</span><br><span class="line">-bad或--blank-lines-after-declarations 　在声明区段或加上空白行。</span><br><span class="line">-bap或--blank-lines-after-procedures 　在程序或加上空白行。</span><br><span class="line">-bbb或--blank-lines-after-block-comments 　在注释区段后加上空白行。</span><br><span class="line">-bc或--blank-lines-after-commas 　在声明区段中，若出现逗号即换行。</span><br><span class="line">-bl或--braces-after-if-line 　if(或是else,for等等)与后面执行区段的&quot;&#123;&quot;不同行，且&quot;&#125;&quot;自成一行。</span><br><span class="line">-bli&lt;缩排格数&gt;或--brace-indent&lt;缩排格数&gt; 　设置&#123; &#125;缩排的格数。</span><br><span class="line">-br或--braces-on-if-line 　if(或是else,for等等)与后面执行跛段的&quot;&#123;&quot;不同行，且&quot;&#125;&quot;自成一行。</span><br><span class="line">-bs或--blank-before-sizeof 　在sizeof之后空一格。</span><br><span class="line">-c&lt;栏数&gt;或--comment-indentation&lt;栏数&gt; 　将注释置于程序码右侧指定的栏位。</span><br><span class="line">-cd&lt;栏数&gt;或--declaration-comment-column&lt;栏数&gt; 　将注释置于声明右侧指定的栏位。</span><br><span class="line">-cdb或--comment-delimiters-on-blank-lines 　注释符号自成一行。</span><br><span class="line">-ce或--cuddle-else 　将else置于&quot;&#125;&quot;(if执行区段的结尾)之后。</span><br><span class="line">-ci&lt;缩排格数&gt;或--continuation-indentation&lt;缩排格数&gt; 　叙述过长而换行时，指定换行后缩排的格数。</span><br><span class="line">-cli&lt;缩排格数&gt;或--case-indentation-&lt;缩排格数&gt; 　使用case时，switch缩排的格数。</span><br><span class="line">-cp&lt;栏数&gt;或-else-endif-column&lt;栏数&gt; 　将注释置于else与elseif叙述右侧定的栏位。</span><br><span class="line">-cs或--space-after-cast 　在cast之后空一格。</span><br><span class="line">-d&lt;缩排格数&gt;或-line-comments-indentation&lt;缩排格数&gt; 　针对不是放在程序码右侧的注释，设置其缩排格数。</span><br><span class="line">-di&lt;栏数&gt;或--declaration-indentation&lt;栏数&gt; 　将声明区段的变量置于指定的栏位。</span><br><span class="line">-fc1或--format-first-column-comments 　针对放在每行最前端的注释，设置其格式。</span><br><span class="line">-fca或--format-all-comments 　设置所有注释的格式。</span><br><span class="line">-gnu或--gnu-style 　指定使用GNU的格式，此为预设值。</span><br><span class="line">-i&lt;格数&gt;或--indent-level&lt;格数&gt; 　设置缩排的格数。</span><br><span class="line">-ip&lt;格数&gt;或--parameter-indentation&lt;格数&gt; 　设置参数的缩排格数。</span><br><span class="line">-kr或--k-and-r-style 　指定使用Kernighan&amp;Ritchie的格式。</span><br><span class="line">-lp或--continue-at-parentheses 　叙述过长而换行，且叙述中包含了括弧时，将括弧中的每行起始栏位内容垂直对其排列。</span><br><span class="line">-nbad或--no-blank-lines-after-declarations 　在声明区段后不要加上空白行。</span><br><span class="line">-nbap或--no-blank-lines-after-procedures 　在程序后不要加上空白行。</span><br><span class="line">-nbbb或--no-blank-lines-after-block-comments 　在注释区段后不要加上空白行。</span><br><span class="line">-nbc或--no-blank-lines-after-commas 　在声明区段中，即使出现逗号，仍旧不要换行。</span><br><span class="line">-ncdb或--no-comment-delimiters-on-blank-lines 　注释符号不要自成一行。</span><br><span class="line">-nce或--dont-cuddle-else 　不要将else置于&quot;&#125;&quot;之后。</span><br><span class="line">-ncs或--no-space-after-casts 　不要在cast之后空一格。</span><br><span class="line">-nfc1或--dont-format-first-column-comments 　不要格式化放在每行最前端的注释。</span><br><span class="line">-nfca或--dont-format-comments 　不要格式化任何的注释。</span><br><span class="line">-nip或--no-parameter-indentation 　参数不要缩排。</span><br><span class="line">-nlp或--dont-line-up-parentheses 　叙述过长而换行，且叙述中包含了括弧时，不用将括弧中的每行起始栏位垂直对其排列。</span><br><span class="line">-npcs或--no-space-after-function-call-names 　在调用的函数名称之后，不要加上空格。</span><br><span class="line">-npro或--ignore-profile 　不要读取indent的配置文件.indent.pro。</span><br><span class="line">-npsl或--dont-break-procedure-type 　程序类型与程序名称放在同一行。</span><br><span class="line">-nsc或--dont-star-comments 　注解左侧不要加上星号(*)。</span><br><span class="line">-nsob或--leave-optional-semicolon 　不用处理多余的空白行。</span><br><span class="line">-nss或--dont-space-special-semicolon 　若for或while区段仅有一行时，在分号前不加上空格。</span><br><span class="line">-nv或--no-verbosity 　不显示详细的信息。</span><br><span class="line">-orig或--original 　使用Berkeley的格式。</span><br><span class="line">-pcs或--space-after-procedure-calls 　在调用的函数名称与&quot;&#123;&quot;之间加上空格。</span><br><span class="line">-psl或--procnames-start-lines 　程序类型置于程序名称的前一行。</span><br><span class="line">-sc或--start-left-side-of-comments 　在每行注释左侧加上星号(*)。</span><br><span class="line">-sob或--swallow-optional-blank-lines 　删除多余的空白行。</span><br><span class="line">-ss或--space-special-semicolon 　若for或swile区段今有一行时，在分号前加上空格。</span><br><span class="line">-st或--standard-output 　将结果显示在标准输出设备。</span><br><span class="line">-T 　数据类型名称缩排。</span><br><span class="line">-ts&lt;格数&gt;或--tab-size&lt;格数&gt; 　设置tab的长度。</span><br><span class="line">-v或--verbose 　执行时显示详细的信息。</span><br><span class="line">-version 　显示版本信息。</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;indent可以格式化C/C++代码，经测试发现，只有Linux格式的文件才能正确格式化，即以LF结尾。&lt;/p&gt;</summary>
    
    
    
    <category term="个人知识中心" scheme="http://www.latelee.org/category/pkc/"/>
    
    
    <category term="工具使用" scheme="http://www.latelee.org/tag/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>C++ map值为结构体的示例</title>
    <link href="http://www.latelee.org/my-library/map-value-for-struct-using-c++.html"/>
    <id>http://www.latelee.org/my-library/map-value-for-struct-using-c++.html</id>
    <published>2020-09-02T15:00:00.000Z</published>
    <updated>2020-12-21T09:16:14.864Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>某一种数据，会有重复记录，后附加各类数据。利用map的唯一性，将重复者过滤。并将附加的数据存储到结构体，方便在代码中使用。后续可写入文件或数据。  </p><a id="more"></a><p>实例：某一路段至少有一个门架，门架有各种数据。简单示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">000250 32021 1057</span><br></pre></td></tr></table></figure><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 分割string</span><br><span class="line">std::vector&lt;std::string&gt; stringSplit(const std::string&amp; s, const std::string&amp; delim)</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; elems;</span><br><span class="line">    size_t pos &#x3D; 0;</span><br><span class="line">    size_t len &#x3D; s.length();</span><br><span class="line">    size_t delim_len &#x3D; delim.length();</span><br><span class="line">    if (delim_len &#x3D;&#x3D; 0) return elems;</span><br><span class="line">    while (pos &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        int find_pos &#x3D; s.find(delim, pos);</span><br><span class="line">        if (find_pos &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            elems.push_back(s.substr(pos, len - pos));</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        elems.push_back(s.substr(pos, find_pos - pos));</span><br><span class="line">        pos &#x3D; find_pos + delim_len;</span><br><span class="line">    &#125;</span><br><span class="line">    return elems;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef struct tGantryDist_t &#123;</span><br><span class="line">    int preDist;</span><br><span class="line">    int nextDist;</span><br><span class="line">&#125; GantryDist_t;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; tmpe</span><br><span class="line">void ReadGantry(const char* filename)</span><br><span class="line">&#123;</span><br><span class="line">    std::fstream f(filename);</span><br><span class="line">    std::string line; </span><br><span class="line">    GantryDist_t gantryDist;</span><br><span class="line">    std::map&lt;std::string, GantryDist_t&gt; tmpGantryM;</span><br><span class="line">    std::vector&lt;std::string&gt; tmpV;</span><br><span class="line"></span><br><span class="line">truewhile (std::getline(f, line))</span><br><span class="line">true&#123;</span><br><span class="line">        tmpV &#x3D; stringSplit(line, &quot; &quot;);</span><br><span class="line">        </span><br><span class="line">        gantryDist.preDist &#x3D; std::stoi(tmpV[1]);</span><br><span class="line">        gantryDist.nextDist &#x3D; std::stoi(tmpV[2]);</span><br><span class="line">        tmpGantryM.insert(std::pair&lt;std::string, GantryDist_t&gt;(tmpV[0].c_str(), gantryDist));</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">    for (auto it: tmpGantryM)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        gantryDist &#x3D; static_cast&lt;GantryDist_t&gt;(it.second);</span><br><span class="line">        printf(&quot;result: %s %d %d\n&quot;, it.first.c_str(), gantryDist.preDist, gantryDist.nextDist);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;某一种数据，会有重复记录，后附加各类数据。利用map的唯一性，将重复者过滤。并将附加的数据存储到结构体，方便在代码中使用。后续可写入文件或数据。  &lt;/p&gt;</summary>
    
    
    
    <category term="我的程序代码" scheme="http://www.latelee.org/category/my-library/"/>
    
    
    <category term="Linux编程" scheme="http://www.latelee.org/tag/Linux%E7%BC%96%E7%A8%8B/"/>
    
    <category term="工程库代码" scheme="http://www.latelee.org/tag/%E5%B7%A5%E7%A8%8B%E5%BA%93%E4%BB%A3%E7%A0%81/"/>
    
    <category term="c&amp;c++" scheme="http://www.latelee.org/tag/c-c/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：一个数据库迁移的代码记录</title>
    <link href="http://www.latelee.org/golang/golang-notes-database-migrate-note.html"/>
    <id>http://www.latelee.org/golang/golang-notes-database-migrate-note.html</id>
    <published>2020-08-31T17:10:36.000Z</published>
    <updated>2020-12-21T09:16:14.900Z</updated>
    
    <content type="html"><![CDATA[<p>实现一个数据库迁移的案子。有些知识点值得记录。</p><a id="more"></a><h1 id="技术框架"><a href="#技术框架" class="headerlink" title="技术框架"></a>技术框架</h1><p>github.com/go-xorm/xorm：数据库操作<br>github.com/denisenkom/go-mssqldb：sqlserver驱动<br>github.com/go-sql-driver/mysql：mysql驱动</p><h1 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h1><p>使用 sql 语句查询原数据库数据，再插入新数据库。<br>查询新数据库表最后一条记录。<br>根据条件是否创建新数据表，再查询新数据库最后一条记录的 ID 值，以此为起点查询旧数据库，因为迁移只需要从已导入的最后一条开始即可，如果表不存在，则从 0 开始。<br>使用回调函数，获取旧数据库，处理数据（或舍弃，或修改，等），再插入到新数据库，直接用 xorm 的结构体即可。xorm 可批量插入，但是旧数据库无法做到批量获取，查询并存储到切片中，到达一定数量（如3000条），再插入新数据库。</p><h1 id="选择记录"><a href="#选择记录" class="headerlink" title="选择记录"></a>选择记录</h1><p>原数据库为 sqlserver，表和列部分有中文，不符合 xorm 要求。只能使用 sql 语句操作。<br>新数据库为 mysql，全英文，可用 xorm 结构体映射，查询、插入较方便。<br>试过将 xorm 的结构体成员变量改为中文，在 Golang 中使用中文作为变量名是可以的，只是反射不成功。  </p><h1 id="实践过程及知识点"><a href="#实践过程及知识点" class="headerlink" title="实践过程及知识点"></a>实践过程及知识点</h1><h2 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; mysql</span><br><span class="line">root:root@tcp(8.8.8.8:3305)&#x2F;mydb?charset&#x3D;utf8&amp;interpolateParams&#x3D;true&amp;parseTime&#x3D;true&amp;loc&#x3D;Local</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; mssql</span><br><span class="line">server&#x3D;8.8.8.8;user id&#x3D;latelee;password&#x3D;123456;database&#x3D;mydb;encrypt&#x3D;disable;</span><br></pre></td></tr></table></figure><p>注意，使用<code>github.com/denisenkom/go-mssqldb</code>时，需要添加<code>encrypt=disable;</code>，否则加不上。  </p><h2 id="xorm小知识"><a href="#xorm小知识" class="headerlink" title="xorm小知识"></a>xorm小知识</h2><p>设置时区：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">engine.DatabaseTZ &#x3D; time.UTC  &#x2F;&#x2F; time.Local</span><br><span class="line">engine.TZLocation &#x3D; time.UTC</span><br></pre></td></tr></table></figure><p>是否显示 sql 语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;engine.ShowSQL(true)</span><br><span class="line">engine.ShowSQL(false)</span><br></pre></td></tr></table></figure><h2 id="xorm结构体映射"><a href="#xorm结构体映射" class="headerlink" title="xorm结构体映射"></a>xorm结构体映射</h2><p>xorm 使用结构体与数据库字段映射，各种操作十分方便。<br>设置完全映射：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">engine.SetMapper(core.SameMapper&#123;&#125;)</span><br></pre></td></tr></table></figure><p>定义示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type TheData struct &#123;</span><br><span class="line">Id   int  &#96;xorm:&quot;int pk not null autoincr &#39;id&#39;&quot;&#96; &#x2F;&#x2F; autoincr</span><br><span class="line">Money sql.NullFloat64 &#96;xorm:&quot;float default null&quot;&#96;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一成员带 id，在数据库即为此名，第二成员不带，将映射为 Money。<br>结构体成员需大写，否则反射失败。  </p><h2 id="新数据库创建"><a href="#新数据库创建" class="headerlink" title="新数据库创建"></a>新数据库创建</h2><p>一般创建表使用其它的方法，但为了方便使用，直接在代码中创建。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var sqlstr string</span><br><span class="line">&#x2F;&#x2F;sqlstr &#x3D; &quot;show tables like &#39;xxx&#39;&quot;</span><br><span class="line">sqlstr &#x3D; fmt.Sprintf(&quot;show tables like &#39;%s&#39;&quot;, newTableName)</span><br><span class="line">_, err &#x3D; engine.SQL(sqlstr).Count()</span><br><span class="line">if err !&#x3D; nil &#123; &#x2F;&#x2F; 没有找到现成函数判断，用返回值</span><br><span class="line">    log.Printf(&quot;table %v exist\n&quot;, newTableName)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    log.Printf(&quot;create table for %v\n&quot;, newTableName)</span><br><span class="line"></span><br><span class="line">    err &#x3D; engine.Sync2(vnewtable)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        log.Println(&quot;create table failed: &quot;, err.Error(), &quot;will exit&quot;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码先判断是否存在数据表，不存在再调用<code>engine.Sync2</code>创建，该函数可同时创建多个数据表。不过似乎没有直接的 API 接口判断是否存在数据表，只好用 sql 语句查询，判断其返回值。  </p><h2 id="数据库为空值"><a href="#数据库为空值" class="headerlink" title="数据库为空值"></a>数据库为空值</h2><p>如果读取到数据库中的空值，会返回错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scan failed: sql: Scan error on column index 26, name &quot;测试空值&quot;: converting driver.Value type string (&quot;NULL&quot;) to a float32: invalid syntax</span><br></pre></td></tr></table></figure><p>此问题可用 sql 包提供的类型解决。如<code>sql.NullString</code>、<code>sql.NullFloat64</code>等。这些类型实际是结构体，包括了<code>Valid</code>成员，通过该值可判断。  </p><h2 id="代码重用"><a href="#代码重用" class="headerlink" title="代码重用"></a>代码重用</h2><p>由于迁移过程是完全一样的，只是数据库、表名、字段等不同。可以将共用部分抽象成函数，具体操作使用回调函数解决。<br>至于不同之处，则由调用者将其传递到共用函数中即可。  </p><h3 id="回调函数定义和使用"><a href="#回调函数定义和使用" class="headerlink" title="回调函数定义和使用"></a>回调函数定义和使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type DataCb func (rows *sql.Rows, engine *xorm.Engine, totalCnt int64) int</span><br><span class="line"></span><br><span class="line">func MigrateDB(olddb, oldtable, newdb string, vnewtable interface&#123;&#125;, datacb DataCb) &#123;</span><br><span class="line">...</span><br><span class="line">datacb(rows, engin, cnt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在回调函数中，根据旧数据库字段扫描，示例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for rows.Next() &#123;</span><br><span class="line">    err :&#x3D; rows.Scan(&amp;a, &amp;b, &amp;c, &amp;d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，Scan 参数个数和数据库的列数相同，否则出错。可直接用新数据库结构体成员，如果不需要，可以使用其它变量。  </p><h3 id="结构体映射"><a href="#结构体映射" class="headerlink" title="结构体映射"></a>结构体映射</h3><p>结构体用指针传递，这样可进行通用处理，即 MigrateDB 不再与具体结构体关联。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">   &#x2F;&#x2F; 获取新表结构体名称</span><br><span class="line">   atype :&#x3D; reflect.TypeOf(vnewtable)</span><br><span class="line">   if atype.Kind() &#x3D;&#x3D; reflect.Ptr &#123; &#x2F;&#x2F; 如果是结构体指针，再获取结构体</span><br><span class="line">trueatype &#x3D; atype.Elem()</span><br><span class="line">&#125;</span><br><span class="line">   &#x2F;&#x2F; 如果还不是结构体，出错</span><br><span class="line">if atype.Kind() !&#x3D; reflect.Struct &#123;</span><br><span class="line">truelog.Println(&quot;Check type error not Struct&quot;)</span><br><span class="line">truereturn</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">   newTableName :&#x3D; atype.Name()</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 取第N个字段及值</span><br><span class="line">   idx :&#x3D; 0</span><br><span class="line">   var newIDName string &#x3D; atype.Field(idx).Name&#x2F;&#x2F; 此处为ID值，如果获取不到tag，选择变量名</span><br><span class="line">   &#x2F;&#x2F; 查找单引号，得到tag</span><br><span class="line">   xormStr :&#x3D; atype.Field(idx).Tag.Get(&quot;xorm&quot;)</span><br><span class="line">   idx1 :&#x3D; strings.Index(xormStr, &quot;&#39;&quot;)</span><br><span class="line">   idx2 :&#x3D; strings.LastIndex(xormStr, &quot;&#39;&quot;)</span><br><span class="line">   </span><br><span class="line">   if idx1 !&#x3D; -1 &amp;&amp; idx2 !&#x3D; -1 &amp;&amp; idx1 &lt; idx2 &#123;</span><br><span class="line">       newIDName &#x3D; xormStr[idx1+1:idx2]</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   log.Println(&quot;debug new table: &quot;, newTableName, newIDName)</span><br></pre></td></tr></table></figure><p>功能有二：获取结构体名称，因为 sql 语句需要使用该名称。获取第 0 个字段名称，结合实际情况，数据库第 0 个字段为 ID，故设计上，将结构体第 0 个字段置为 ID。<br>注意，这里使用结构体指针形式传递，不需要额外声明结构体变量，代码较整洁。    </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;实现一个数据库迁移的案子。有些知识点值得记录。&lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：xorm使用记录</title>
    <link href="http://www.latelee.org/golang/golang-notes-xorm.html"/>
    <id>http://www.latelee.org/golang/golang-notes-xorm.html</id>
    <published>2020-08-31T17:00:00.000Z</published>
    <updated>2020-12-21T09:16:14.900Z</updated>
    
    <content type="html"><![CDATA[<p>xorm使用记录。主要针对 mysql，也会涉及其它的。  </p><a id="more"></a><h2 id="技术总结"><a href="#技术总结" class="headerlink" title="技术总结"></a>技术总结</h2><p>提供通用接口，适用于多种数据库，隐藏细节。但需要手动添加数据库驱动（Golang 本身亦如是）。<br>可以用 Sync2 创建数据表，多次创建只提示警告，不会出错。要自行判断，或者额外创建好表，后续不再创建。<br>需要预先创建数据库，否则即使 Sync2 成功，也不会有数据表。<br>引入 xorm 包，再使用 sql 驱动，但使用下划线，表示只引入不使用包内函数。<br>xorm 的结构体成员要大写。  </p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">go get github.com&#x2F;go-xorm&#x2F;xorm</span><br><span class="line">go get github.com&#x2F;go-xorm&#x2F;core</span><br><span class="line">go get github.com&#x2F;go-xorm&#x2F;cmd&#x2F;xorm</span><br><span class="line">&#x2F;&#x2F; 似乎还有一个xorm.io，待写</span><br><span class="line"></span><br><span class="line">驱动：</span><br><span class="line">go get github.com&#x2F;go-sql-driver&#x2F;mysql &#x2F;&#x2F; mysql</span><br><span class="line">go get github.com&#x2F;mattn&#x2F;go-sqlite3  &#x2F;&#x2F;SQLite</span><br><span class="line">go get github.com&#x2F;denisenkom&#x2F;go-mssqldb &#x2F;&#x2F; sqlserver</span><br><span class="line">go get github.com&#x2F;lunny&#x2F;godbc &#x2F;&#x2F; sqlserver</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="结构体与字段映射"><a href="#结构体与字段映射" class="headerlink" title="结构体与字段映射"></a>结构体与字段映射</h2><p>常用方式：<br>SnakeMapper: 默认方式，驼峰命名，如 <code>UserInfo -&gt; user_info</code>。<br>SameMapper: 相同。<code>UserInfo -&gt; UserInfo</code>。<br>GonicMapper：在SnakeMapper的基础上增加了特例，<code>ID -&gt; id</code>。<br>PrefixMapper：前缀。<br>SuffixMapper：后缀。  </p><p>设置xorm的字段名称和数据库中的一样（包括表名、字段表）<br>engine.SetMapper(core.SameMapper{})</p><p>不建议做太复杂，选择一两种常用的即可。  </p><p>示例1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">结构体：</span><br><span class="line">type User struct &#123;</span><br><span class="line">   Id   int64  &#96;xorm:&quot;int(20) pk not null autoincr &#39;id&#39;&quot;&#96;</span><br><span class="line">   Email string &#96;xorm:&quot;varchar(255) default null&quot;&#96;</span><br><span class="line">   First_name string &#96;xorm:&quot;varchar(255) default null&quot;&#96;</span><br><span class="line">   Last_name string &#96;xorm:&quot;varchar(255) default null&quot;&#96;</span><br><span class="line">   Username string &#96;xorm:&quot;varchar(255) default null&quot;&#96;</span><br><span class="line">&#125;</span><br><span class="line">对应数据表：</span><br><span class="line">mysql&gt; desc user;</span><br><span class="line">+------------+--------------+------+-----+---------+----------------+</span><br><span class="line">| Field      | Type         | Null | Key | Default | Extra          |</span><br><span class="line">+------------+--------------+------+-----+---------+----------------+</span><br><span class="line">| id         | int(20)      | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| email      | varchar(255) | YES  |     | NULL    |                |</span><br><span class="line">| first_name | varchar(255) | YES  |     | NULL    |                |</span><br><span class="line">| last_name  | varchar(255) | YES  |     | NULL    |                |</span><br><span class="line">| username   | varchar(255) | YES  |     | NULL    |                |</span><br><span class="line">+------------+------------</span><br><span class="line">注：结构体名即为表名，表名为小写，字段按驼峰命名，变量加下划线，保留。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 自定义部分字段，即所有字段小写，无下划线</span><br><span class="line">type User2 struct &#123;</span><br><span class="line">   Id   int64  &#96;xorm:&quot;int(20) pk not null autoincr&quot;&#96;</span><br><span class="line">   Email string &#96;xorm:&quot;varchar(255) default null&quot;&#96;</span><br><span class="line">   First_name string &#96;xorm:&quot;varchar(255) default null &#39;firstname&#39;&quot;&#96;</span><br><span class="line">   Last_name string &#96;xorm:&quot;varchar(255) default null &#39;lastname&#39;&quot;&#96;</span><br><span class="line">   Username string &#96;xorm:&quot;varchar(255) default null &#39;username&#39;&quot;&#96;</span><br><span class="line">&#125;</span><br><span class="line">mysql&gt; desc user2;</span><br><span class="line">+-----------+--------------+------+-----+---------+----------------+</span><br><span class="line">| Field     | Type         | Null | Key | Default | Extra          |</span><br><span class="line">+-----------+--------------+------+-----+---------+----------------+</span><br><span class="line">| id        | int(20)      | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| email     | varchar(255) | YES  |     | NULL    |                |</span><br><span class="line">| firstname | varchar(255) | YES  |     | NULL    |                |</span><br><span class="line">| lastname  | varchar(255) | YES  |     | NULL    |                |</span><br><span class="line">| username  | varchar(255) | YES  |     | NULL    |                |</span><br><span class="line">+-----------+--------------+------+-----+---------+----------------+</span><br><span class="line">注：接上，但在变量中设置了字段名称，变量有下划线，但字段没有。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 保存完全一致</span><br><span class="line">type User3 struct &#123;</span><br><span class="line">   Id   int64  &#96;xorm:&quot;int(20) pk not null autoincr&quot;&#96;</span><br><span class="line">   Email string &#96;xorm:&quot;varchar(255) default null&quot;&#96;</span><br><span class="line">   First_name string &#96;xorm:&quot;varchar(255) default null&quot;&#96;</span><br><span class="line">   Last_name string &#96;xorm:&quot;varchar(255) default null&quot;&#96;</span><br><span class="line">   Username string &#96;xorm:&quot;varchar(255) default null&quot;&#96;</span><br><span class="line">&#125;</span><br><span class="line">代码：engine.SetMapper(core.SameMapper&#123;&#125;)</span><br><span class="line">mysql&gt; desc User3; </span><br><span class="line">+------------+--------------+------+-----+---------+----------------+</span><br><span class="line">| Field      | Type         | Null | Key | Default | Extra          |</span><br><span class="line">+------------+--------------+------+-----+---------+----------------+</span><br><span class="line">| Id         | int(20)      | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| Email      | varchar(255) | YES  |     | NULL    |                |</span><br><span class="line">| First_name | varchar(255) | YES  |     | NULL    |                |</span><br><span class="line">| Last_name  | varchar(255) | YES  |     | NULL    |                |</span><br><span class="line">| Username   | varchar(255) | YES  |     | NULL    |                |</span><br><span class="line">+------------+--------------+------+-----+---------+----------------+</span><br><span class="line"></span><br><span class="line">注：表名和字段名完全一致。  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="反向导出结构体"><a href="#反向导出结构体" class="headerlink" title="反向导出结构体"></a>反向导出结构体</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com&#x2F;go-xorm&#x2F;cmd&#x2F;xorm</span><br></pre></td></tr></table></figure><p>会自动安装到 Golang 的 bin 目录，在命令行直接输入 xorm 即可。    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xorm reverse mysql name:password@(ip:port)&#x2F;xxx?charset&#x3D;utf8 .&#x2F;templates&#x2F;goxorm&#x2F;</span><br><span class="line">windows 示例：</span><br><span class="line">xorm reverse mysql root:root@\(172.18.18.18:3305\)&#x2F;mydb?charset&#x3D;utf8 .&#x2F;templates&#x2F;goxorm&#x2F;</span><br><span class="line">注：templates是指$GOPATH&#x2F;src&#x2F;github.com&#x2F;go-xorm&#x2F;cmd&#x2F;xorm&#x2F;templates</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;userc&#96; (</span><br><span class="line"> &#96;信息id&#96; bigint(20) NOT NULL  AUTO_INCREMENT,</span><br><span class="line"> &#96;邮箱地址&#96; varchar(255) DEFAULT NULL,</span><br><span class="line"> &#96;名&#96; varchar(255) DEFAULT NULL,</span><br><span class="line"> &#96;姓&#96; varchar(255) DEFAULT NULL,</span><br><span class="line"> &#96;姓名&#96; varchar(255) DEFAULT NULL,</span><br><span class="line"> PRIMARY KEY (&#96;信息id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line"></span><br><span class="line">转换后：</span><br><span class="line">type Userc struct &#123;</span><br><span class="line">true信息id int64  &#96;xorm:&quot;not null pk autoincr BIGINT(20)&quot;&#96;</span><br><span class="line">true邮箱地址 string &#96;xorm:&quot;VARCHAR(255)&quot;&#96;</span><br><span class="line">true名    string &#96;xorm:&quot;VARCHAR(255)&quot;&#96;</span><br><span class="line">true姓    string &#96;xorm:&quot;VARCHAR(255)&quot;&#96;</span><br><span class="line">true姓名   string &#96;xorm:&quot;VARCHAR(255)&quot;&#96;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="数据库的中文"><a href="#数据库的中文" class="headerlink" title="数据库的中文"></a>数据库的中文</h2><p>测试中文</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type 学生信息表 struct &#123;</span><br><span class="line">true信息id int64  &#96;xorm:&quot;not null pk autoincr BIGINT(20)&quot;&#96;</span><br><span class="line">true邮箱地址 string &#96;xorm:&quot;VARCHAR(255)&quot;&#96;</span><br><span class="line">true名    string &#96;xorm:&quot;VARCHAR(255)&quot;&#96;</span><br><span class="line">true姓    string &#96;xorm:&quot;VARCHAR(255)&quot;&#96;</span><br><span class="line">true姓名   string &#96;xorm:&quot;VARCHAR(255)&quot;&#96;</span><br><span class="line">&#125;</span><br><span class="line">engine.SetMapper(core.SameMapper&#123;&#125;)</span><br><span class="line">engine.Sync2(new(学生信息表))</span><br></pre></td></tr></table></figure><p>结论：可以使用中文变量，但查询数据，会出错，故还是按英文进行</p><h2 id="所遇问题"><a href="#所遇问题" class="headerlink" title="所遇问题"></a>所遇问题</h2><p>如果有小写，会提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: reflect.Value.Interface: cannot return value obtained from unexported field or method</span><br></pre></td></tr></table></figure><p>可以用单引号指定特定名称。</p><p>遇到空值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scan failed: sql: Scan error on column index 26, name &quot;姓名&quot;: converting driver.Value type string (&quot;NULL&quot;) to a float32: invalid syntax</span><br></pre></td></tr></table></figure><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">engine, err :&#x3D; xorm.NewEngine(driverName, dataSourceName)</span><br></pre></td></tr></table></figure><h3 id="sql语句"><a href="#sql语句" class="headerlink" title="sql语句"></a>sql语句</h3><p>支持sql语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">直接查，返回[]map[string][]byte类型的切片</span><br><span class="line">results, err :&#x3D; engine.Query(&quot;select * from user&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 适用增改查</span><br><span class="line">affected, err :&#x3D; engine.Exec(&quot;update user set .... where ...&quot;)</span><br><span class="line"></span><br><span class="line">engine.Sql(&quot;select * from user&quot;).Find()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注：方便根据自定义的语句获取结果</p><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">affected, err :&#x3D; engine.Insert(&amp;struct)</span><br><span class="line">&#x2F;&#x2F; INSERT INTO struct () values ()</span><br><span class="line">affected, err :&#x3D; engine.Insert(&amp;struct1, &amp;struct2)</span><br><span class="line">&#x2F;&#x2F; INSERT INTO struct1 () values ()</span><br><span class="line">&#x2F;&#x2F; INSERT INTO struct2 () values ()</span><br><span class="line">affected, err :&#x3D; engine.Insert(&amp;sliceOfStruct)</span><br><span class="line">&#x2F;&#x2F; INSERT INTO struct () values (),(),()</span><br><span class="line">affected, err :&#x3D; engine.Insert(&amp;struct1, &amp;sliceOfStruct2)</span><br><span class="line">&#x2F;&#x2F; INSERT INTO struct1 () values ()</span><br><span class="line">&#x2F;&#x2F; INSERT INTO struct2 () values (),(),()</span><br></pre></td></tr></table></figure><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">affected, err :&#x3D; engine.Where(...).Delete(&amp;user)</span><br><span class="line">&#x2F;&#x2F; DELETE FROM user Where ...</span><br></pre></td></tr></table></figure><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">affected, err :&#x3D; engine.Update(&amp;user)</span><br><span class="line">&#x2F;&#x2F; UPDATE user SET ...</span><br></pre></td></tr></table></figure><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">查数量</span><br><span class="line">counts, err :&#x3D; engine.Count(&amp;user)</span><br><span class="line">&#x2F;&#x2F; SELECT count(*) AS total FROM user</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查询一条记录，返回结构体</span><br><span class="line">has, err :&#x3D; engine.Get(&amp;user)</span><br><span class="line">&#x2F;&#x2F; SELECT * FROM user LIMIT 1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查询多条记录</span><br><span class="line">sliceOfStructs :&#x3D; new(Struct)</span><br><span class="line">err :&#x3D; engine.Find(sliceOfStructs)</span><br><span class="line">&#x2F;&#x2F; SELECT * FROM user</span><br><span class="line"></span><br><span class="line">err :&#x3D; engine.Iterate(...)</span><br><span class="line">&#x2F;&#x2F; SELECT * FROM user</span><br><span class="line"></span><br><span class="line">rows, err :&#x3D; engine.Rows(...)</span><br><span class="line">&#x2F;&#x2F; SELECT * FROM user</span><br><span class="line">bean :&#x3D; new(Struct)</span><br><span class="line">for rows.Next() &#123;</span><br><span class="line">    err &#x3D; rows.Scan(bean)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有条件的数据库操作"><a href="#有条件的数据库操作" class="headerlink" title="有条件的数据库操作"></a>有条件的数据库操作</h2><h3 id="Id-In"><a href="#Id-In" class="headerlink" title="Id In"></a>Id In</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">engine.Id(1).Get(&amp;user) &#x2F;&#x2F; for single primary key</span><br><span class="line">&#x2F;&#x2F; SELECT * FROM user WHERE id &#x3D; 1</span><br><span class="line">engine.Id(core.PK&#123;1, 2&#125;).Get(&amp;user) &#x2F;&#x2F; for composite primary keys</span><br><span class="line">&#x2F;&#x2F; SELECT * FROM user WHERE id1 &#x3D; 1 AND id2 &#x3D; 2</span><br><span class="line">engine.In(&quot;id&quot;, 1, 2, 3).Find(&amp;users)</span><br><span class="line">&#x2F;&#x2F; SELECT * FROM user WHERE id IN (1, 2, 3)</span><br><span class="line">engine.In(&quot;id&quot;, []int&#123;1, 2, 3&#125;)</span><br><span class="line">&#x2F;&#x2F; SELECT * FROM user WHERE id IN (1, 2, 3)</span><br></pre></td></tr></table></figure><h3 id="Where-And-Or"><a href="#Where-And-Or" class="headerlink" title="Where And Or"></a>Where And Or</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">engine.Where().And().Or().Find()</span><br><span class="line">&#x2F;&#x2F; SELECT * FROM user WHERE (.. AND ..) OR ...</span><br></pre></td></tr></table></figure><h3 id="OrderBy-Asc-Desc"><a href="#OrderBy-Asc-Desc" class="headerlink" title="OrderBy Asc Desc"></a>OrderBy Asc Desc</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">engine.Asc().Desc().Find()</span><br><span class="line">&#x2F;&#x2F; SELECT * FROM user ORDER BY .. ASC, .. DESC</span><br><span class="line">engine.OrderBy().Find()</span><br><span class="line">&#x2F;&#x2F; SELECT * FROM user ORDER BY ..</span><br></pre></td></tr></table></figure><h3 id="Limit-Top"><a href="#Limit-Top" class="headerlink" title="Limit Top"></a>Limit Top</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">engine.Limit().Find()</span><br><span class="line">&#x2F;&#x2F; SELECT * FROM user LIMIT .. OFFSET ..</span><br><span class="line">engine.Top(5).Find()</span><br><span class="line">&#x2F;&#x2F; SELECT TOP 5 * FROM user &#x2F;&#x2F; for mssql</span><br><span class="line">&#x2F;&#x2F; SELECT * FROM user LIMIT .. OFFSET 0 &#x2F;&#x2F;for other databases</span><br></pre></td></tr></table></figure><h3 id="Cols-Omit-Distinct"><a href="#Cols-Omit-Distinct" class="headerlink" title="Cols Omit Distinct"></a>Cols Omit Distinct</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">engine.Cols(&quot;col1, col2&quot;).Find()</span><br><span class="line">&#x2F;&#x2F; SELECT col1, col2 FROM user</span><br><span class="line">engine.Cols(&quot;col1&quot;, &quot;col2&quot;).Where().Update(user)</span><br><span class="line">&#x2F;&#x2F; UPDATE user set col1 &#x3D; ?, col2 &#x3D; ? Where ...</span><br><span class="line">engine.Omit(&quot;col1&quot;).Find()</span><br><span class="line">&#x2F;&#x2F; SELECT col2, col3 FROM user</span><br><span class="line">engine.Omit(&quot;col1&quot;).Insert()</span><br><span class="line">&#x2F;&#x2F; INSERT INTO table (non-col1) VALUES ()</span><br><span class="line">engine.Distinct(&quot;col1&quot;).Find()</span><br><span class="line">&#x2F;&#x2F; SELECT DISTINCT col1 FROM user</span><br></pre></td></tr></table></figure><h3 id="Join-GroupBy-Having"><a href="#Join-GroupBy-Having" class="headerlink" title="Join GroupBy Having"></a>Join GroupBy Having</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">engine.GroupBy(&quot;name&quot;).Having(&quot;name&#x3D;&#39;xlw&#39;&quot;).Find()</span><br><span class="line">&#x2F;&#x2F;SELECT * FROM user GROUP BY name HAVING name&#x3D;&#39;xlw&#39;</span><br><span class="line">engine.Join(&quot;LEFT&quot;, &quot;userdetail&quot;, &quot;user.id&#x3D;userdetail.id&quot;).Find()</span><br><span class="line">&#x2F;&#x2F;SELECT * FROM user LEFT JOIN userdetail ON user.id&#x3D;userdetail.id</span><br></pre></td></tr></table></figure><h2 id="综合应用"><a href="#综合应用" class="headerlink" title="综合应用"></a>综合应用</h2><p>本小节以一些应用场合为例，记录sql函数及xorm函数的示例。<br>为方便使用2种方式，可实现2种接口。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sqlstr :&#x3D; fmt.Sprintf(&quot;show tables like &#39;%s&#39;&quot;, newTableName)</span><br><span class="line">cnt, err :&#x3D; engine.SQL(sqlstr).Count()</span><br><span class="line"></span><br><span class="line">sqlstr :&#x3D; fmt.Sprintf(&quot;select count(*) from %s where %s &gt; %d&quot;, tableName, idName, startID)</span><br><span class="line">err :&#x3D; sqldb.QueryRow(sqlstr).Scan(&amp;totalCnt)</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h1 id="附"><a href="#附" class="headerlink" title="附"></a>附</h1><p>参考：<br><a href="https://www.cnblogs.com/guhao123/p/4159688.html">https://www.cnblogs.com/guhao123/p/4159688.html</a>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;xorm使用记录。主要针对 mysql，也会涉及其它的。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：简单的代码片段</title>
    <link href="http://www.latelee.org/golang/golang-code-slice.html"/>
    <id>http://www.latelee.org/golang/golang-code-slice.html</id>
    <published>2020-08-29T15:03:36.000Z</published>
    <updated>2020-12-21T09:16:14.900Z</updated>
    
    <content type="html"><![CDATA[<p>本文列出简单的代码片段及基础知识。  </p><a id="more"></a><h2 id="简单说明"><a href="#简单说明" class="headerlink" title="简单说明"></a>简单说明</h2><ul><li><p>包<br>import的包从src算，如果在子目录，一定要添加子目录路径。如import “a”，则a一定在src目录下。<br>同一个目录只能有一个包名。但可以有多个文件（使用同一包名）。<br>没有被使用的包，要删除或注释，否则编译不通过。<br>包目录不能与系统包名相同，如系统有sync包，不能再创建sync目录。<br>除for等外，逗号不是必须的，看个人习惯。<br>没有使用的变量，编译不通过。 </p></li><li><p>测试<br>文件名带<code>_test</code>的是测试专用，不能用<code>go run</code>来执行。  </p></li></ul><h2 id="编码小结"><a href="#编码小结" class="headerlink" title="编码小结"></a>编码小结</h2><h3 id="打印："><a href="#打印：" class="headerlink" title="打印："></a>打印：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printfln(&quot;Hello world&quot;);</span><br><span class="line">fmt.Printf(&quot;Hello %v\n&quot;, &quot;world&quot;);</span><br><span class="line"></span><br><span class="line">a :&#x3D; &quot;12345&quot;</span><br><span class="line">fmt.Printf(&quot;% x&quot;, a) &#x2F;&#x2F; 31 32 33 34 35</span><br><span class="line">fmt.Printf(&quot;%q&quot;, a) &#x2F;&#x2F; &quot;12345&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果打印/组装的字符串过多，可用’`‘替换双引号。    </p><p>打印变量类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">引入包：</span><br><span class="line">&quot;reflect&quot;</span><br><span class="line">fmt.Println(reflect.TypeOf(var)) </span><br></pre></td></tr></table></figure><p>组装字符串示例：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要点：补齐字段的用法</span></span><br><span class="line"><span class="comment">// 年月日时分秒</span></span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%.4v%.2v%.2v%.2v%.2v%.2v&quot;</span>, </span><br><span class="line">                   year, month, day, </span><br><span class="line">                   hour, minute, seconds);</span><br></pre></td></tr></table></figure><p>代码片段(用以切换语言时看)：  </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">有传入、输出参数</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrt</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    ret := <span class="number">1.0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        ret = ret - (ret*ret - x) / <span class="number">2</span> / ret</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;类&quot;</span></span><br><span class="line"><span class="keyword">package</span> class</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">true<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空结构体</span></span><br><span class="line"><span class="keyword">type</span> SimpleClass <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// nothing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;类&quot;的形式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *SimpleClass)</span> <span class="title">printf</span><span class="params">()</span></span> &#123;</span><br><span class="line">truefmt.Printf(<span class="string">&quot;%v\n&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大写，包外可见</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SimpleTest</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    c := SimpleClass&#123;&#125;;</span><br><span class="line">    c.printf();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">主函数文件：</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;class&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    class.SimpleTest();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> bit0 == <span class="number">0</span> &#123; <span class="comment">// 注释</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;I&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> bit0 == <span class="number">1</span> &amp;&amp; bit1 == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;S&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> bit0 == <span class="number">1</span> &amp;&amp; bit1 == <span class="number">1</span> &#123; <span class="comment">// 注释</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;U&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 其它</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同一程序代码，生成不同文件执行不同函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">    &quot;path&#x2F;filepath&quot;</span><br><span class="line">    &quot;strings&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    filename :&#x3D; filepath.Base(os.Args[0])</span><br><span class="line">    if strings.Contains(filename, &quot;send&quot;) &#123;</span><br><span class="line">        send()</span><br><span class="line">    &#125; else if strings.Contains(filename, &quot;recv&quot;) &#123;</span><br><span class="line">        recv()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fmt.Println(&quot;do nothing&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过编译命令传递参数。<br>如编译时间，golang 不支持，可以嵌入 C 语言实现，也可以用脚本获取时间，再通过编译命令传递。<br>命令选项为<code>-ldflags &quot;-X &#39;&lt;包名&gt;.&lt;变量名&gt;=值&#39;</code><br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var (</span><br><span class="line">trueBuildTime string</span><br><span class="line">trueVersion string</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func getVersion() string &#123;</span><br><span class="line">truereturn fmt.Sprintf(&quot;  %v build: %v\n&quot;, Version, BuildTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Version&#x3D;&quot;v1.0&quot;</span><br><span class="line">BuildTime&#x3D;&#96;date +&#39;%Y-%m-%d %H:%M:%S&#39;&#96;</span><br><span class="line"></span><br><span class="line"># 写到文件方式</span><br><span class="line">#echo &quot;package cmd&quot; &gt; cmd&#x2F;ver.go</span><br><span class="line">#echo &quot;const BuildTime1 &#x3D; \&quot;$&#123;BuildTime&#125;\&quot;&quot; &gt;&gt; cmd&#x2F;ver.go</span><br><span class="line">#echo &quot;const Version1 &#x3D; \&quot;$&#123;Version&#125;\&quot;&quot; &gt;&gt; cmd&#x2F;ver.go</span><br><span class="line"></span><br><span class="line"># 参数传递方式</span><br><span class="line">GO111MODULE&#x3D;on go build -ldflags &quot;-X &#39;github.com&#x2F;latelee&#x2F;cmdtool&#x2F;cmd.BuildTime&#x3D;$&#123;BuildTime&#125;&#39; -X &#39;github.com&#x2F;latelee&#x2F;cmdtool&#x2F;cmd.Version&#x3D;$&#123;Version&#125;&#39;&quot; -mod vendor -o cmdtool.exe main.go</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文列出简单的代码片段及基础知识。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：测试框架</title>
    <link href="http://www.latelee.org/golang/golang-testing.html"/>
    <id>http://www.latelee.org/golang/golang-testing.html</id>
    <published>2020-08-26T17:05:36.000Z</published>
    <updated>2020-12-21T09:16:14.900Z</updated>
    
    <content type="html"><![CDATA[<p>这篇集中记录一下测试相关的内容。  </p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>创建工程库代码，方便重用。重用方式可使用函数，也可直接引用文件。<br>完成函数，可在 main 函数中调用进行测试。也可以使用 test 框架进行。<br>在大型项目中，可以用 test 进行测试更方便，即不影响业务代码，也保留测试代码。  </p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>测试文件形式为 <code>&lt;文件名&gt;_test.go</code>，源码文件不能以<code>_test.go</code>结尾。<br>引用<code>testing</code>包。有<code>t.Logf</code>等函数。<br>测试用例使用<code>TestFoo</code>、<code>TestBar</code>的形式。<br>同一个目录，可以有多个测试文件，同一测试文件，可以有多个测试用例。但注意，不能出现同名函数。<br>测试文件与实际源码文件名称，可同可不同。  </p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>简单使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test</span><br></pre></td></tr></table></figure><p>结果以 PASS 或 FAIL 等表示。<br>输出详细日志：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test -v</span><br></pre></td></tr></table></figure><p>上述命令会运行该目录下<strong>所有测试文件的所有测试用例</strong>。  </p><p>为方便、简单测试，可指定测试文件和测试用例。如：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test -v -run TestSleep  </span><br></pre></td></tr></table></figure><p>（注：当测试文件包含其它包时，指定测试文件，似乎不成功）  </p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Golang 提供的测试框架，可以方便地对封装的工具函数进行测试。<br>对于实现简单功能的模块而言，可以使用测试框架，也可以编译为二进制，后者在使用上较方便。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇集中记录一下测试相关的内容。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：工程管理</title>
    <link href="http://www.latelee.org/golang/golang-project-manage.html"/>
    <id>http://www.latelee.org/golang/golang-project-manage.html</id>
    <published>2020-08-20T12:04:36.000Z</published>
    <updated>2020-12-21T09:16:14.900Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍Golang的工程管理。  </p><a id="more"></a><h2 id="工程概述"><a href="#工程概述" class="headerlink" title="工程概述"></a>工程概述</h2><p>GOPATH目录下创建三个目录：  </p><ul><li>src 存放源代码，每个工程一个单独的目录</li><li>pkg 编译过后生成的包文件存放目录，根据平台有不同目录，里面有许多.a库，暂未研究。  </li><li>bin 编译后生产的可执行文件和go相关的工具</li></ul><h2 id="工程管理"><a href="#工程管理" class="headerlink" title="工程管理"></a>工程管理</h2><p>golang 查找依赖包路径：<br>当前目录下的vendor目录。<br>向上级目录查找，直到找到src下的vendor目录。<br>在 GOPATH 下面查找依赖包。<br>在 GOROOT 目录下查找。  </p><p>依赖包有几大各类：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">github.com：位于 github.com 上的仓库。  </span><br><span class="line">golang.org：golang官方包</span><br><span class="line">gopkg.in：</span><br><span class="line">google.golang.org：</span><br><span class="line">k8s.io：k8s相关的</span><br></pre></td></tr></table></figure><p>(理论上可创建自定义的名称，不一定要存在，但无法用 go get 获取。)</p><h2 id="笔记三"><a href="#笔记三" class="headerlink" title="笔记三"></a>笔记三</h2><p>根据实际情况和路径，在 src 先创建目录。可不按 github.com 之类。说明：<br>许多开源项目托管于 github.com 上，且依赖其它同样托管在 github 的项目。因此要在 src 下创建 github.com 目录，如 kubeedge 项目，其路径为：github.com\kubeedge\kubeedge 。cobra 项目路径 为 github.com\spf13\cobra，等等。<br>k8s 项目使用的路径为 k8s.io/kubernetes 。这些路径，一般规定好，写到官方文档。<br>内部项目，可自定义路径目录，只要与源码保持一致即可。<br>项目依赖的包，放到项目的 vendor 中，随项目托管。  </p><h3 id="笔记二"><a href="#笔记二" class="headerlink" title="笔记二"></a>笔记二</h3><p>针对第三方依赖包的讨论：<br>对于小工具或测试模块，不同模块，可能使用同一依赖包，故将依赖包下载到 src 目录，以便共用。事实上，依赖包大目录基本为上述几个，大目录不会杂乱。<br>对于大工程和项目，可将依赖包纳入版本管理，也可不纳入。前者仓库体积可能变大，但方便使用，无须再下载依赖包。后者仓库体积小，但需要使用者额外下载，有可能无法成功下载依赖包。此为矛盾之处。二者均可，取决于团队决策。个人偏向将依赖包进行版本管理，虽然体积大，但“开箱即用”，减少后来者工作。 </p><h3 id="笔记一"><a href="#笔记一" class="headerlink" title="笔记一"></a>笔记一</h3><p>不同的包，单独成目录，放到src目录。将GOPATH放到大的版本管理。如本地测试文件，可不提交管理。<br>对于可公开的库，直接提交到的github.com上，在单独目录做测试（可直接运行的）。<br>在src新建foo目录，foo有main.go，另有vendor子目录，vendor有uitls目录，即为utils包，实现模块。在main.go中引用utils包即可。  </p><p>我的golang工程：为方便编写代码，而不显得目录混乱，又能与其它工程区别开。新建 go_test 项目目录，其下有vendor子目录，vendor 即为该项目所依赖的<strong>自编模块</strong>（注：外部依赖不在此列），其下可有各个模块，如utils目录，即为utils包，目录下文件名可不同，实现函数不同，但均属于 utils 包。同时，vendor有mybuff、mylog等包（目录）。由于部分功能可能与第三方库相同，可添加my为前缀，以示区别。  </p><p>该目录放到任意目录均可。这样，go_test 工程可单独使用，同理，还有其它工程。    </p><p>再注：<br>公司项目根目录只能位于GOPATH，其下bin/pkg/src目录，还有readme和其它配置文件。src有自编模块（目录），也有github.com golang.org gopkg.in（但这些放到.gitignore忽略了）。为与公司兼容，将自己的测试工程放到src下的vendor中，再将vendor忽略。  </p><h2 id="工程目录概述"><a href="#工程目录概述" class="headerlink" title="工程目录概述"></a>工程目录概述</h2><p>参考<a href="https://github.com/golang-standards/project-layout">这里</a> 的说明。  </p><h2 id="go-mod-使用"><a href="#go-mod-使用" class="headerlink" title="go mod 使用"></a>go mod 使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">go mod init  &#x2F;&#x2F; 创建go.mod文件</span><br><span class="line"></span><br><span class="line">后可用go build直接编译，如果不存在的包，会自动下载（测试了github.com等地址），下载地址为GOPATH&#x2F;pkg。</span><br><span class="line">如何下载到本工程的vendor下？</span><br><span class="line">矛盾之处：工程本身在github.com下开发，未提交版本，但go guild时会查找，找不到，报错。</span><br><span class="line"></span><br><span class="line">go mod download</span><br><span class="line">下载依赖，默认pkg目录（可共用）</span><br><span class="line"></span><br><span class="line">go mod tidy</span><br><span class="line">同步依赖包，添加需要的，移除多余的</span><br><span class="line"></span><br><span class="line">go mod vendor</span><br><span class="line">将依赖包拷贝到vendor目录</span><br><span class="line"></span><br><span class="line">go get 下载&#x2F;升级依赖</span><br><span class="line"></span><br><span class="line">.mod所在目录：</span><br><span class="line">go build -mod vendor main.go </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">go env -w GO111MODULE&#x3D;off  auto on</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="govendor使用"><a href="#govendor使用" class="headerlink" title="govendor使用"></a>govendor使用</h2><p>使用<code>go get</code>下载的第三方包，会下载到src目录下。  </p><p>下载govendor并安装：<code>go get -u -v github.com/kardianos/govendor</code>。<br>下载包到vendor目录：<code>govendor fetch github.com/golang/glog</code>。(注：自动下载该包相关的依赖包）<br>添加包到vendor目录：<code>govendor add github.com/golang/glog</code>。<br>删除包：<code>govendor remove github.com/golang/glog</code><br>其它命令：  </p><h2 id="gopm使用"><a href="#gopm使用" class="headerlink" title="gopm使用"></a>gopm使用</h2><p>查看工程依赖包工具。  </p><p>下载安装：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -v -u github.com&#x2F;gpmgo&#x2F;gopm</span><br></pre></td></tr></table></figure><p>用法：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前工程依赖</span><br><span class="line">gopm list</span><br><span class="line"># 显示依赖详细信息</span><br><span class="line">gopm list -v</span><br><span class="line"># 列出文件依赖</span><br><span class="line">gopm list -t [file]</span><br><span class="line"># 拉取依赖到缓存目录</span><br><span class="line">gopm get -r xxx</span><br><span class="line"># 仅下载当前指定的包</span><br><span class="line">gopm get -d xxx</span><br><span class="line"># 拉取依赖到$GOPATH</span><br><span class="line">gopm get -g xxx</span><br><span class="line"># 检查更新所有包</span><br><span class="line">gopm get -u xxx</span><br><span class="line"># 拉取到当前所在目录</span><br><span class="line">gopm get -l xxx</span><br><span class="line"># 运行当前目录程序</span><br><span class="line">gopm run</span><br><span class="line"># 生成当前工程的 gopmfile 文件用于包管理</span><br><span class="line">gopm gen -v</span><br><span class="line"># 根据当前项目 gopmfile 链接依赖并执行 go install</span><br><span class="line">gopm install -v</span><br><span class="line"># 更新当前依赖</span><br><span class="line">gopm update -v</span><br><span class="line"># 清理临时文件</span><br><span class="line">gopm clean</span><br><span class="line"># 编译到当前目录</span><br><span class="line">gopm bin</span><br><span class="line"></span><br><span class="line">3. 通过gopm 来安装gin框架</span><br><span class="line"></span><br><span class="line">gopm get -g -v  github.com&#x2F;gin-gonic&#x2F;gin</span><br><span class="line"></span><br><span class="line">4. 安装govendor管理包工具</span><br><span class="line"></span><br><span class="line"> gopm get -g -v github.com&#x2F;kardianos&#x2F;govendor</span><br><span class="line"></span><br><span class="line">5. 通过 govendor 来管理代码包</span><br><span class="line"></span><br><span class="line">6. go run main.go文件，可能会出现缺少golang.org&#x2F;x，提示报错</span><br><span class="line"></span><br><span class="line">&#x2F;root&#x2F;gowork&#x2F;src&#x2F;attendance_project&#x2F;vendor&#x2F;golang.org&#x2F;x&#x2F;sys&#x2F;unix (vendor tree)</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;src&#x2F;go&#x2F;src&#x2F;golang.org&#x2F;x&#x2F;sys&#x2F;unix (from $GOROOT)</span><br><span class="line">&#x2F;root&#x2F;gowork&#x2F;src&#x2F;golang.org&#x2F;x&#x2F;sys&#x2F;unix (from $GOPATH),</span><br><span class="line"></span><br><span class="line">通过 gopm -g golang.org&#x2F;x&#x2F;sys (sys只是其中的一个模块，例如：text,sys等，具体根据提示来安装即可)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="swagger"><a href="#swagger" class="headerlink" title="swagger"></a>swagger</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com&#x2F;swaggo&#x2F;swag&#x2F;cmd&#x2F;swag</span><br><span class="line">(所遇问题：golang.org\x目录的tools和net的git版本有点旧，会自动更新，但连接不上，解决：先删除，从Github.com上下载)</span><br><span class="line"></span><br><span class="line">go get -u github.com&#x2F;swaggo&#x2F;gin-swagger</span><br><span class="line">go get -u github.com&#x2F;swaggo&#x2F;gin-swagger&#x2F;swaggerFiles</span><br><span class="line">go get -u github.com&#x2F;alecthomas&#x2F;template  &#x2F;&#x2F; 文档需要</span><br></pre></td></tr></table></figure><h2 id="格式检查vet"><a href="#格式检查vet" class="headerlink" title="格式检查vet"></a>格式检查vet</h2><p>在VS code中打开go文件，右下角提示goreturns要安装（具体提示未记录），点击安装。<br>当保存go文件时会自动检测语法，并提示。  </p><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><p>1、<a href="https://blog.csdn.net/Nassue_sn/article/details/86718199">Go项目结构推荐</a>。  </p><p>李迟 2020 上半年 起稿并修改 2020.08.20 周四 修改</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍Golang的工程管理。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：开篇</title>
    <link href="http://www.latelee.org/golang/golang-start.html"/>
    <id>http://www.latelee.org/golang/golang-start.html</id>
    <published>2020-08-19T12:03:36.000Z</published>
    <updated>2020-12-21T09:16:14.900Z</updated>
    
    <content type="html"><![CDATA[<p>自去年开始，因工作的关系，需要使用 Golang 进行开发。一来是工作，二来多了解一个新语言，总归是有好处。现在虽然不是主攻 Golang，但可能用来写一些小工具。    </p><a id="more"></a><p>本系列不会系统介绍Golang，只是根据笔者接触的某个点进行记录，可以认为是一个笔记集。  </p><h2 id="一、我对Golang的认识"><a href="#一、我对Golang的认识" class="headerlink" title="一、我对Golang的认识"></a>一、我对Golang的认识</h2><p>Go生态好，模块多，当然，如NodeJS、Python亦多，但不同语言侧重点不同。如Java侧重后台开发，C偏重底层，Pyhthon则是数据分析，爬虫，Go在虚拟化运维方面，但是没有定法，使用哪种语言没有限制，只有方便不方便，快速不快速。  </p><p>有部分包无法下载，需要使用花费一定时间解决。可以使用国内镜像源，使用github下载，等等。  </p><p>虽然 Go 跨平台，但有些特性与系统相关，因为最好使用多个系统测试。如果明确只使用某系统，则无须如此。  </p><p>Go 统一了编码风格，起初还不习惯，但久了发现从语言层级来强制风格也有好处，至少能避免一些低级错误发生。  </p><p>Go 有很多地方属于原创，如 defer，可以在函数返回前做一些注销、关闭等操作（如关闭文件）。    </p><p>笔者在Windows上安装，也在Ubuntu安装（使用vagrant)，为了方便管理，两套系统均使用同一目录作为工程目录。  </p><h2 id="二、Golang-安装"><a href="#二、Golang-安装" class="headerlink" title="二、Golang 安装"></a>二、Golang 安装</h2><h3 id="Golang在Windows系统的安装"><a href="#Golang在Windows系统的安装" class="headerlink" title="Golang在Windows系统的安装"></a>Golang在Windows系统的安装</h3><p>下载：<a href="https://studygolang.com/dl">https://studygolang.com/dl</a>，版本为1.13.4。包名为<code>go1.13.4.windows-amd64.zip</code>。解压到D盘（或其它盘）。</p><p>设置几个环境变量：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GOBIN D:\go\bin</span><br><span class="line">GOROOT D:\go</span><br><span class="line">PATH：%GOBIN%</span><br><span class="line">GOPATH：E:\project\golang</span><br></pre></td></tr></table></figure><p>GOPATH即为工程目录。</p><h3 id="Golang在Linux系统的安装"><a href="#Golang在Linux系统的安装" class="headerlink" title="Golang在Linux系统的安装"></a>Golang在Linux系统的安装</h3><p>直接在命令行下载、解压：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;dl.google.com&#x2F;go&#x2F;go1.13.4.linux-amd64.tar.gz</span><br><span class="line">tar zxf go1.13.4.linux-amd64.tar.gz -C &#x2F;usr&#x2F;local&#x2F;</span><br><span class="line"></span><br><span class="line">国内：</span><br><span class="line">wget https:&#x2F;&#x2F;studygolang.com&#x2F;dl&#x2F;golang&#x2F;go1.15.6.linux-amd64.tar.gz</span><br><span class="line">sudo tar zxf go1.15.6.linux-amd64.tar.gz -C &#x2F;usr&#x2F;local&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改~/.bashrc，添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export GOROOT&#x3D;&#x2F;usr&#x2F;local&#x2F;go</span><br><span class="line">export GOBIN&#x3D;$GOROOT&#x2F;bin</span><br><span class="line">export PATH&#x3D;$PATH:$GOBIN</span><br><span class="line">export GOPATH&#x3D;&#x2F;vagrant&#x2F;golang</span><br><span class="line">export GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.cn</span><br><span class="line">export MYGO&#x3D;$GOPATH&#x2F;src&#x2F;github.com&#x2F;latelee</span><br></pre></td></tr></table></figure><p>注1：在Windows，使用Vagrant启动虚拟机，其工程目录实际为E:\project\，故GOPATH的/vagrant/golang目录，与E:\project\golang实际为同一目录，此情况下，同一套代码在两个系统可同时使用。<br>注2：设置了 GOBIN，当使用 go get 安装包时，会安装到此目录，否则会安装到 GOPATH 的 bin 目录。<br>注3：上面也设置了 MYGO 环境变量，方便快速定位到个人目录。<br>注4：有些项目，会依赖于 golang 版本，一般会有文档说明。  </p><h2 id="三、环境问题"><a href="#三、环境问题" class="headerlink" title="三、环境问题"></a>三、环境问题</h2><h3 id="golang-org包"><a href="#golang-org包" class="headerlink" title="golang.org包"></a>golang.org包</h3><p>因为众所周知的原因，有部分包无法正常访问。需要额外花工夫解决出现的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot find package &quot;golang.org&#x2F;x&#x2F;sys&#x2F;unix&quot; in any of:</span><br></pre></td></tr></table></figure><p>原因：golang.org无法访问<br>解决：github有镜像，可下载，重命名。在$GOPATH)/src目录下执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p  golang.org&#x2F;x</span><br><span class="line">cd golang.org&#x2F;x&#x2F;</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;sys</span><br><span class="line">其它类似的有：</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;crypto</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;text</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot find package &quot;github.com&#x2F;go-playground&#x2F;validator&#x2F;v10&quot;</span><br></pre></td></tr></table></figure><p>go版本太低（1.6），升级为1.13解决。(注：v10的确不存在，但代码的确引用该包)  </p><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>1.13 及以上使用：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env -w GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.cn,direct</span><br></pre></td></tr></table></figure><p>也可以设置环境变量：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;export GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.cn&quot; &gt;&gt; ~&#x2F;.bashrc &amp;&amp; source ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure><p>默认代理：<code>GOPROXY=&quot;https://proxy.golang.org,direct&quot;</code>。  </p><p>参考： <a href="https://github.com/goproxy/goproxy.cn/blob/master/README.zh-CN.md">https://github.com/goproxy/goproxy.cn/blob/master/README.zh-CN.md</a> 。</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>GOROOT 和 GOPATH 不能相同，否则会提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$GOPATH must not be set to $GOROOT. For more details see: &#39;go help gopath&#39;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go env  # 查看go的环境变量</span><br><span class="line">go env -w GO111MODULE&#x3D;off  # 设置环境变量</span><br></pre></td></tr></table></figure><h2 id="四、工程概述"><a href="#四、工程概述" class="headerlink" title="四、工程概述"></a>四、工程概述</h2><p>GOPATH目录下创建三个目录：  </p><ul><li>src 存放源代码，每个工程一个单独的目录</li><li>pkg 编译过后生成的包文件存放目录</li><li>bin 编译后生产的可执行文件和go相关的工具</li></ul><h2 id="五、go简单使用"><a href="#五、go简单使用" class="headerlink" title="五、go简单使用"></a>五、go简单使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">go build</span><br><span class="line">go build foo.go</span><br><span class="line">go run main.go</span><br><span class="line">go get -u github.com&#x2F;xxx&#x2F;yyy</span><br><span class="line">查看环境: go env</span><br><span class="line"></span><br><span class="line">查看包：go doc xxx</span><br></pre></td></tr></table></figure><p>go install 会安装到GOBIN目录，一般项目可不用如此操作。</p><h2 id="六、编码小结"><a href="#六、编码小结" class="headerlink" title="六、编码小结"></a>六、编码小结</h2><p>右大括号<code>&#123;</code>在行尾，如在新一行，编译不通过。<br>一般使用小写+大写方式。<br>函数：大写 导出，小写 包内（跨文件）可见。<br>变量：大写导出，小写包内可见。专用名称，可大写或小写。<br>接口、结构体：大写（一说小+大）。<br>文件名、包名：小写。  </p><p>要慢慢熟悉的：大括号位置、if/for/没有小括号。<br>如果引入的包不使用，又不想删除（后面可能会用到），可以注释掉，也可以调用这些包的函数，放到函数中，但不调用这个函数。<br>格式要求严格，如a为uint16， b为<code>[]byte</code>，<code>a = b[0]</code>出错，需要转换<code>a = uint16(b[0])</code>。另外，<code>a = -1</code>也出错，因为是无符号的。<br>可用 go fmt 格式化代码。  </p><p>基本知识：<br>打印：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printfln(&quot;Hello world&quot;);</span><br><span class="line">fmt.Printf(&quot;Hello %v\n&quot;, &quot;world&quot;);</span><br></pre></td></tr></table></figure><p>代码片段(用以切换语言时看)：  </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">有传入、付出参数</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrt</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    ret := <span class="number">1.0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        ret = ret - (ret*ret - x) / <span class="number">2</span> / ret</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;类&quot;</span></span><br><span class="line"><span class="keyword">package</span> class</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">true<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空结构体</span></span><br><span class="line"><span class="keyword">type</span> SimpleClass <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// nothing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;类&quot;的形式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *SimpleClass)</span> <span class="title">printf</span><span class="params">()</span></span> &#123;</span><br><span class="line">truefmt.Printf(<span class="string">&quot;%v\n&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大写，包外可见</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SimpleTest</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    c := SimpleClass&#123;&#125;;</span><br><span class="line">    c.printf();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">主函数文件：</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;class&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    class.SimpleTest();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="七、小实验"><a href="#七、小实验" class="headerlink" title="七、小实验"></a>七、小实验</h2><p>自实现模块A，存入github.com，A使用到第三方库，<code>go get</code>获取A会自动检测第三方库，如无则自动下载。  </p><h2 id="八、常见错误"><a href="#八、常见错误" class="headerlink" title="八、常见错误"></a>八、常见错误</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.go:8:5: found packages a (a.go) and main (a1.go) in e:\project\golang\src\hello\a</span><br></pre></td></tr></table></figure><p>原因：同一个目录下，有2个包名。<br>解决：只保留一个包名，如必须有2个，则移到另一目录。  </p><p>下载第三方依赖包时，其依赖的包可能存在于本地，但版本过旧，会出错。此时重新更新所有的依赖包即可。  </p><p>PS：工作中切换语言时，先看几眼本文件，以便于思维的切换。  </p><p>李迟  2020.08.19 周三</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;自去年开始，因工作的关系，需要使用 Golang 进行开发。一来是工作，二来多了解一个新语言，总归是有好处。现在虽然不是主攻 Golang，但可能用来写一些小工具。    &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>我的docker随笔29：oracle数据库部署</title>
    <link href="http://www.latelee.org/docker/docker-29-deploy-oracle.html"/>
    <id>http://www.latelee.org/docker/docker-29-deploy-oracle.html</id>
    <published>2020-07-28T15:25:05.000Z</published>
    <updated>2020-12-21T09:16:14.892Z</updated>
    
    <content type="html"><![CDATA[<p>本文涉及：<br>oracle 的容器化部署。  </p><a id="more"></a><p>下载镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com&#x2F;helowin&#x2F;oracle_11g</span><br></pre></td></tr></table></figure><p>镜像列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY                                             TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com&#x2F;helowin&#x2F;oracle_11g   latest              3fa112fd3642        4 years ago         6.85 GB</span><br></pre></td></tr></table></figure><p>启动容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd -p 1521:1521 --name oracle registry.cn-hangzhou.aliyuncs.com&#x2F;helowin&#x2F;oracle_11g</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">数据持久化：</span><br><span class="line">docker run -itd -p 1521:1521 \</span><br><span class="line">--name&#x3D;oracle \</span><br><span class="line">-v $PWD&#x2F;helowin:&#x2F;home&#x2F;oracle&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;helowin \</span><br><span class="line">-v $PWD&#x2F;flash_recovery_area:&#x2F;home&#x2F;oracle&#x2F;app&#x2F;oracle&#x2F;flash_recovery_area \</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com&#x2F;helowin&#x2F;oracle_11g bash</span><br><span class="line"></span><br><span class="line">--restart&#x3D;always </span><br></pre></td></tr></table></figure><p>状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># docker ps</span><br><span class="line">CONTAINER ID        IMAGE                                                  COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">d3b1cd3efbc7        registry.cn-hangzhou.aliyuncs.com&#x2F;helowin&#x2F;oracle_11g   &quot;&#x2F;bin&#x2F;sh -c &#39;&#x2F;home...&quot;   32 seconds ago      Up 6 seconds        0.0.0.0:1521-&gt;1521&#x2F;tcp   oracle</span><br></pre></td></tr></table></figure><p>默认账号和密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#username: system</span><br><span class="line">#password: helowin</span><br></pre></td></tr></table></figure><p>进入容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec oracle bash</span><br></pre></td></tr></table></figure><p>连接数据库。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">source &#x2F;home&#x2F;oracle&#x2F;.bash_profile  </span><br><span class="line"></span><br><span class="line">sqlplus &#x2F;nolog</span><br><span class="line">SQL&gt; conn &#x2F; as sysdba</span><br><span class="line">Connected.</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line">$ sqlplus </span><br><span class="line"></span><br><span class="line">SQL*Plus: Release 11.2.0.1.0 Production on Mon Oct 26 09:17:43 2020</span><br><span class="line"></span><br><span class="line">Copyright (c) 1982, 2009, Oracle.  All rights reserved.</span><br><span class="line"></span><br><span class="line">Enter user-name: system  # 账号</span><br><span class="line">Enter password: # 密码为helowin</span><br><span class="line"></span><br><span class="line">Connected to:</span><br><span class="line">Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit Production</span><br></pre></td></tr></table></figure><p>修改账号密码。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; alter user system identified by system;    ## 账号和密码为system</span><br><span class="line"></span><br><span class="line">User altered.</span><br><span class="line"></span><br><span class="line">SQL&gt; alter user sys identified by sys;  ## 账号和密码为sys</span><br><span class="line"></span><br><span class="line">User altered.</span><br><span class="line"></span><br><span class="line">SQL&gt; </span><br><span class="line">SQL&gt; alter profile default limit password_life_time unlimited;</span><br><span class="line"></span><br><span class="line">Profile altered.</span><br><span class="line"></span><br><span class="line">SQL&gt; exit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ lsnrctl status</span><br><span class="line"></span><br><span class="line">LSNRCTL for Linux: Version 11.2.0.1.0 - Production on 30-AUG-2020 00:54:57</span><br><span class="line"></span><br><span class="line">Copyright (c) 1991, 2009, Oracle.  All rights reserved.</span><br><span class="line"></span><br><span class="line">Connecting to (DESCRIPTION&#x3D;(ADDRESS&#x3D;(PROTOCOL&#x3D;IPC)(KEY&#x3D;EXTPROC1521)))</span><br><span class="line">STATUS of the LISTENER</span><br><span class="line">------------------------</span><br><span class="line">Alias                     LISTENER</span><br><span class="line">Version                   TNSLSNR for Linux: Version 11.2.0.1.0 - Production</span><br><span class="line">Start Date                27-AUG-2020 23:26:21</span><br><span class="line">Uptime                    2 days 1 hr. 28 min. 36 sec</span><br><span class="line">Trace Level               off</span><br><span class="line">Security                  ON: Local OS Authentication</span><br><span class="line">SNMP                      OFF</span><br><span class="line">Listener Parameter File   &#x2F;home&#x2F;oracle&#x2F;app&#x2F;oracle&#x2F;product&#x2F;11.2.0&#x2F;dbhome_2&#x2F;network&#x2F;admin&#x2F;listener.ora</span><br><span class="line">Listener Log File         &#x2F;home&#x2F;oracle&#x2F;app&#x2F;oracle&#x2F;diag&#x2F;tnslsnr&#x2F;d3b1cd3efbc7&#x2F;listener&#x2F;alert&#x2F;log.xml</span><br><span class="line">Listening Endpoints Summary...</span><br><span class="line">  (DESCRIPTION&#x3D;(ADDRESS&#x3D;(PROTOCOL&#x3D;ipc)(KEY&#x3D;EXTPROC1521)))</span><br><span class="line">  (DESCRIPTION&#x3D;(ADDRESS&#x3D;(PROTOCOL&#x3D;tcp)(HOST&#x3D;d3b1cd3efbc7)(PORT&#x3D;1521)))</span><br><span class="line">Services Summary...</span><br><span class="line">Service &quot;helowin&quot; has 1 instance(s).</span><br><span class="line">  Instance &quot;helowin&quot;, status READY, has 1 handler(s) for this service...</span><br><span class="line">Service &quot;helowinXDB&quot; has 1 instance(s).</span><br><span class="line">  Instance &quot;helowin&quot;, status READY, has 1 handler(s) for this service...</span><br><span class="line">The command completed successfully</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><strong>ORA-12528: TNS: 监听程序: 所有适用例程都无法建立新连接。</strong><br>查看状态为BLOCKED：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ lsnrctl status</span><br><span class="line"></span><br><span class="line">LSNRCTL for Linux: Version 11.2.0.1.0 - Production on 26-OCT-2020 11:05:00</span><br><span class="line"></span><br><span class="line">Copyright (c) 1991, 2009, Oracle.  All rights reserved.</span><br><span class="line"></span><br><span class="line">Connecting to (DESCRIPTION&#x3D;(ADDRESS&#x3D;(PROTOCOL&#x3D;IPC)(KEY&#x3D;EXTPROC1521)))</span><br><span class="line">STATUS of the LISTENER</span><br><span class="line">------------------------</span><br><span class="line">Alias                     LISTENER</span><br><span class="line">Version                   TNSLSNR for Linux: Version 11.2.0.1.0 - Production</span><br><span class="line">Start Date                26-OCT-2020 10:11:00</span><br><span class="line">Uptime                    0 days 0 hr. 53 min. 59 sec</span><br><span class="line">Trace Level               off</span><br><span class="line">Security                  ON: Local OS Authentication</span><br><span class="line">SNMP                      OFF</span><br><span class="line">Listener Parameter File   &#x2F;home&#x2F;oracle&#x2F;app&#x2F;oracle&#x2F;product&#x2F;11.2.0&#x2F;dbhome_2&#x2F;network&#x2F;admin&#x2F;listener.ora</span><br><span class="line">Listener Log File         &#x2F;home&#x2F;oracle&#x2F;app&#x2F;oracle&#x2F;diag&#x2F;tnslsnr&#x2F;5041887d0189&#x2F;listener&#x2F;alert&#x2F;log.xml</span><br><span class="line">Listening Endpoints Summary...</span><br><span class="line">  (DESCRIPTION&#x3D;(ADDRESS&#x3D;(PROTOCOL&#x3D;ipc)(KEY&#x3D;EXTPROC1521)))</span><br><span class="line">  (DESCRIPTION&#x3D;(ADDRESS&#x3D;(PROTOCOL&#x3D;tcp)(HOST&#x3D;5041887d0189)(PORT&#x3D;1521)))</span><br><span class="line">Services Summary...</span><br><span class="line">Service &quot;helowin&quot; has 1 instance(s).</span><br><span class="line">  Instance &quot;helowin&quot;, status BLOCKED, has 1 handler(s) for this service...</span><br><span class="line">The command completed successfully</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>默认启动命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;Volumes&quot;: &#123;</span><br><span class="line">                &quot;&#x2F;home&#x2F;oracle&#x2F;app&#x2F;oracle&#x2F;oradata&quot;: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;WorkingDir&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Entrypoint&quot;: [</span><br><span class="line">                &quot;&#x2F;bin&#x2F;sh&quot;,</span><br><span class="line">                &quot;-c&quot;,</span><br><span class="line">                &quot;&#x2F;home&#x2F;oracle&#x2F;app&#x2F;oracle&#x2F;product&#x2F;11.2.0&#x2F;dbhome_2&#x2F;bin&#x2F;dbstart &#x2F;home&#x2F;oracle&#x2F;app&#x2F;oracle&#x2F;product&#x2F;11.2.0&#x2F;dbhome_2 &amp;&amp; tail -f &#x2F;home&#x2F;oracle&#x2F;app&#x2F;oracle&#x2F;product&#x2F;11.2.0&#x2F;dbhome_2&#x2F;startup.log&quot;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/qiuxiangmuyu/p/7895154.html">https://www.cnblogs.com/qiuxiangmuyu/p/7895154.html</a><br><a href="https://www.cnblogs.com/YsirSun/p/13543313.html">https://www.cnblogs.com/YsirSun/p/13543313.html</a><br><a href="https://blog.csdn.net/chenjin_csdn/article/details/106470108">https://blog.csdn.net/chenjin_csdn/article/details/106470108</a><br><a href="https://github.com/oracle/docker-images/tree/master/OracleDatabase/SingleInstance#running-oracle-database-11gr2-express-edition-in-a-docker-container">https://github.com/oracle/docker-images/tree/master/OracleDatabase/SingleInstance#running-oracle-database-11gr2-express-edition-in-a-docker-container</a>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文涉及：&lt;br&gt;oracle 的容器化部署。  &lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="http://www.latelee.org/category/docker/"/>
    
    
    <category term="docker" scheme="http://www.latelee.org/tag/docker/"/>
    
  </entry>
  
  <entry>
    <title>我的docker随笔28：基于容器的升级方案实验</title>
    <link href="http://www.latelee.org/docker/docker-28-update-using-docker.html"/>
    <id>http://www.latelee.org/docker/docker-28-update-using-docker.html</id>
    <published>2020-07-27T15:25:05.000Z</published>
    <updated>2020-12-21T09:16:14.892Z</updated>
    
    <content type="html"><![CDATA[<p>本文涉及：<br>在容器化场合中，如何更快升级。涉及2方面：<br>docker镜像的设计。<br>升级方案。    </p><a id="more"></a><h2 id="docker镜像设计"><a href="#docker镜像设计" class="headerlink" title="docker镜像设计"></a>docker镜像设计</h2><p>充分利用docker镜像分层机制，减小升级的体积，减少流量消耗。    </p><h3 id="基础镜像设计"><a href="#基础镜像设计" class="headerlink" title="基础镜像设计"></a>基础镜像设计</h3><p>基础镜像可直接沿用官方的，也可自行制作，自行制作机动性强，可加定制内容，如nodejs依赖的node_modules目录，C++额外依赖的库（如cuda等）。<br>每次制作，在基础镜像基础上，而不是上一版本。因为docker是基础上一层制作的，即使版本间差别不大，但体积也只增不减。  </p><p>分层测试示例如下。<br>制作二镜像，先做基础，在此基础上制作0.1版本。先下载基础镜像，再下载0.1版本。观察下载过程日志。    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># docker pull latelee&#x2F;nodejs_test:base</span><br><span class="line"></span><br><span class="line">base: Pulling from latelee&#x2F;nodejs_test</span><br><span class="line">3cfb62949d9d: Pull complete </span><br><span class="line">34aecfb75a58: Pull complete </span><br><span class="line">3d83db6658b4: Pull complete </span><br><span class="line">c94ba0b8da75: Pull complete </span><br><span class="line">d7bff1b55288: Pull complete </span><br><span class="line">Digest: sha256:e17eefc913b842d944702fa008c3178e5f5cf6753b102954ee2426ff548aa6c4</span><br><span class="line">Status: Downloaded newer image for latelee&#x2F;nodejs_test:base</span><br><span class="line"></span><br><span class="line"># docker pull latelee&#x2F;nodejs_test:0.1</span><br><span class="line"></span><br><span class="line">0.1: Pulling from latelee&#x2F;nodejs_test</span><br><span class="line">3cfb62949d9d: Already exists </span><br><span class="line">34aecfb75a58: Already exists </span><br><span class="line">3d83db6658b4: Already exists </span><br><span class="line">c94ba0b8da75: Already exists </span><br><span class="line">d7bff1b55288: Already exists </span><br><span class="line">7c1d066698dd: Pull complete </span><br><span class="line">Digest: sha256:f17bec3186ca681be8815adda298b217b6d0c1bcb248a0f57da4b03a8197db43</span><br><span class="line">Status: Downloaded newer image for latelee&#x2F;nodejs_test:0.1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二次下载的，许多层已经存在了，无须再下载，故速度快。在磁盘上，也是重用镜像的，所以会节省空间。  </p><p>其它测试：使用大文件，在基础镜像上制作0.1版本，再在0.1版本上制作0.2(只做小修改)，另再以0.2版本的文件，基于基础镜像做0.11版本，观察三者下载过程。  </p><h3 id="宿主机映射方案"><a href="#宿主机映射方案" class="headerlink" title="宿主机映射方案"></a>宿主机映射方案</h3><p>一般地，容器作为运行环境，宿主机保存数据文件。如web服务即为典型者。这里反其义用之。即把文件放到镜像中，再把宿主机的运行环境映射到容器中，执行之。<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm -v &#x2F;home&#x2F;latelee&#x2F;nodejs&#x2F;nodejs_test&#x2F;node_modules:&#x2F;home&#x2F;node&#x2F;node_modules \</span><br><span class="line">-v &#x2F;usr&#x2F;local&#x2F;bin&#x2F;:&#x2F;home&#x2F;local&#x2F;bin \</span><br><span class="line">-v &#x2F;lib&#x2F;:&#x2F;home&#x2F;lib \</span><br><span class="line">-v &#x2F;usr&#x2F;lib&#x2F;:&#x2F;home&#x2F;usr&#x2F;lib \</span><br><span class="line">nodejsdata sh </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export PATH&#x3D;$PATH:&#x2F;home&#x2F;local&#x2F;bin</span><br><span class="line">export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:&#x2F;home&#x2F;lib</span><br><span class="line">export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:&#x2F;home&#x2F;usr&#x2F;lib</span><br><span class="line"></span><br><span class="line">&#x2F; # node -v</span><br><span class="line">v10.20.1</span><br><span class="line">&#x2F; # cd &#x2F;home&#x2F;node&#x2F;</span><br><span class="line">&#x2F; # node koa_test.js </span><br><span class="line">Running a koa server at localhost:  4000</span><br><span class="line"></span><br><span class="line">docker run -it --rm -v &#x2F;home&#x2F;latelee&#x2F;nodejs&#x2F;nodejs_test&#x2F;node_modules:&#x2F;home&#x2F;node&#x2F;node_modules \</span><br><span class="line">-v &#x2F;usr:&#x2F;usr \</span><br><span class="line">-v &#x2F;bin:&#x2F;bin \</span><br><span class="line">-v &#x2F;lib&#x2F;:&#x2F;lib \</span><br><span class="line">nodejs_test sh </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>尝试使用<code>scratch</code>制作，即只把相关的js文件拷贝到镜像中，不基于busybox等基础镜像，未挂载命令所在目录时提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker: Error response from daemon: OCI runtime create failed: container_linux.go:345: starting container process caused &quot;exec: \&quot;sh\&quot;: executable file not found in $PATH&quot;: unknown.</span><br></pre></td></tr></table></figure><p>挂载（如/bin/目录）后提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">standard_init_linux.go:211: exec user process caused &quot;no such file or directory&quot;</span><br><span class="line">failed to resize tty, using default size</span><br></pre></td></tr></table></figure><p>似乎无法如此实施。此问题尚未研究深。    </p><p>另，想过在容器A中使用容器B的目录，无果，或许无此应用方式。先挂载，再在容器中拷贝到宿主机，似乎可行，但多占用了存储空间，弃之。    </p><p>另一个示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --rm --name nodejsapp -p 3000:3000 -v &#x2F;home&#x2F;node&#x2F;node_modules&#x2F;:&#x2F;home&#x2F;node&#x2F;node_modules \</span><br><span class="line">-v &#x2F;usr&#x2F;:&#x2F;usr \</span><br><span class="line">-v &#x2F;lib&#x2F;:&#x2F;lib \</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com&#x2F;latelee&#x2F;nodejsdata</span><br><span class="line"></span><br><span class="line">提供的：</span><br><span class="line">docker run -itd --rm --name nodejsapp -p 3000:3000 \</span><br><span class="line">-v &#x2F;mnt&#x2F;data:&#x2F;mnt&#x2F;data \</span><br><span class="line">-v &#x2F;home&#x2F;node&#x2F;node_modules&#x2F;:&#x2F;home&#x2F;node&#x2F;node_modules \</span><br><span class="line">-v &#x2F;usr&#x2F;:&#x2F;usr \</span><br><span class="line">-v &#x2F;lib&#x2F;:&#x2F;lib \</span><br><span class="line">nodejsdata</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 arm 上验证通过。前提：arm 板子安装了nodejs环境以及依赖的node_modules。将应用代码做成镜像，下载并运行之。为减小操作，直接挂载成相同目录。  </p><h2 id="升级方案"><a href="#升级方案" class="headerlink" title="升级方案"></a>升级方案</h2><p>参考热启动和冷启动两种方式进行思考。目前只有构思，未动手编码。  </p><h3 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h3><p>云主机为服务器，终端/板子为客户端，两者保持长连接，可用websocket实现。<br>需要升级时（如用CICD触发，或手工触发，或发post请求），服务器收到升级事件，发指令到客户端，客户端执行<code>docker pull</code>命令，判断其返回值，同时判断新镜像是否正常（如下发指令时带md5或crc，也可用docker自身的ID），一切正常启动，监控些许时间后（如30秒~1分钟），容器未退出，方为正常。<br>客户端主动升级，需判断是否连网，可选择深夜升级，或业务非繁忙时段。    </p><h3 id="冷更新"><a href="#冷更新" class="headerlink" title="冷更新"></a>冷更新</h3><p>制作随系统启动的脚本，在脚本中先执行<code>docker pull</code>，如果已是最新版本，会输出docker ID值，并带有<code>Image is up to date for</code>字样，可判断之。否则，会拉取镜像，此时，需先停止容器并删除容器，再启动（是否直接重启容器即可实现，此刻未研究）。此方式，需要重启设备，如果启动时间长，则服务停止时间长。在时间间隔允许情况下，可采用此法，方便。  </p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文镜像已修改，所示者非真实镜像。  </p><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>一个builtroot更新node的记录。  </p><p>前端所所需版本为10.15，builtroot默认是8.15。<br>1、下载alpine版本镜像，取node，其库为musllibc，目标板库为glibc，运行提示<code>Not found</code>，原由是链接器不同。失败。下载armv7版本的镜像，从中取之。体积30MB余，较大。  </p><p>2、观察buitroot配置，确认node为8.15，临时改配置，更新node为10.15，编译失败，重新改为8.15，成功，猜测openssl问题。查找官方代码路径<code>https://git.busybox.net/buildroot/tree/package/nodejs/nodejs.mk?h=2019.05</code>，选择不同版本号，发现 201905 版本较近，从中取配置文件，替换/新加原有目录。其依赖<code>https://git.busybox.net/buildroot/tree/package/nghttp2?h=2019.05</code>。make时下载慢，用云主机下载，再用scp拷贝之。编译依然失败，从提示日志看，还是openssl。想到将buitroot升级到201905，然又与内核等有关联，成本大，弃之。<br>3、恢复用用8.15编译，暂不烧写镜像（一是仅验证，二是耗时），拷贝/usr/bin/node到目标板，拷贝其依赖库libhttp_parser、libuv、libcares三个库。结果：应用程序依赖的sqlite为<code>/sqlite3/lib/binding/node-v64-linux-arm</code>，但是该版本的node认为依赖的是<code>sqlite3/lib/binding/node-v57-linux-arm/node_sqlite3.node</code>，不兼容，失败。<br>4、使用官方预编译版本，地址<code>https://nodejs.org/dist/v10.15.0/</code>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文涉及：&lt;br&gt;在容器化场合中，如何更快升级。涉及2方面：&lt;br&gt;docker镜像的设计。&lt;br&gt;升级方案。    &lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="http://www.latelee.org/category/docker/"/>
    
    
    <category term="docker" scheme="http://www.latelee.org/tag/docker/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu系统远程桌面</title>
    <link href="http://www.latelee.org/pkc/ubuntu-vnc.html"/>
    <id>http://www.latelee.org/pkc/ubuntu-vnc.html</id>
    <published>2020-07-23T16:00:00.000Z</published>
    <updated>2020-12-21T09:16:14.784Z</updated>
    
    <content type="html"><![CDATA[<p>背景：<br>aarch64(arm64)系统，ubuntu 18.04，需在 Windows 远程连接系统桌面。  </p><a id="more"></a><h2 id="源"><a href="#源" class="headerlink" title="源"></a>源</h2><p>使用华为源：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -O &#x2F;etc&#x2F;apt&#x2F;sources.list https:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;repository&#x2F;conf&#x2F;Ubuntu-Ports-bionic.list</span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><h2 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install xrdp</span><br><span class="line">sudo apt-get install vnc4server</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>安装桌面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install xubuntu-desktop</span><br></pre></td></tr></table></figure><p>过程需选择默认桌面，选gdm3（另一为lightdm)。  </p><p>注：最后提示：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Warning: couldn&#39;t identify filesystem type for fsck hook, ignoring.</span><br><span class="line">I: The initramfs will attempt to resume from &#x2F;dev&#x2F;zram7</span><br><span class="line">I: (UUID&#x3D;c88002d8-584d-4dba-a78b-3177ebcdb5c0)</span><br><span class="line">I: Set the RESUME variable to override this.</span><br><span class="line">&#x2F;sbin&#x2F;ldconfig.real: Warning: ignoring configuration file that cannot be opened: &#x2F;etc&#x2F;ld.so.conf.d&#x2F;aarch64-linux-gnu_EGL.conf: No such file or directory</span><br><span class="line">&#x2F;sbin&#x2F;ldconfig.real: Warning: ignoring configuration file that cannot be opened: &#x2F;etc&#x2F;ld.so.conf.d&#x2F;aarch64-linux-gnu_GL.conf: No such file or directory</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;xfce4-session&quot; &gt;~&#x2F;.xsession</span><br><span class="line">sudo service xrdp restart # 启动xrdp服务</span><br></pre></td></tr></table></figure><h2 id="windows连接"><a href="#windows连接" class="headerlink" title="windows连接"></a>windows连接</h2><p>使用远程桌面连接，输入IP地址，点击“选项”，输入用户。等待连接成功。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;背景：&lt;br&gt;aarch64(arm64)系统，ubuntu 18.04，需在 Windows 远程连接系统桌面。  &lt;/p&gt;</summary>
    
    
    
    <category term="个人知识中心" scheme="http://www.latelee.org/category/pkc/"/>
    
    
    <category term="Linux使用" scheme="http://www.latelee.org/tag/Linux%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>oracle操作实例</title>
    <link href="http://www.latelee.org/pkc/oracle-practice.html"/>
    <id>http://www.latelee.org/pkc/oracle-practice.html</id>
    <published>2020-07-18T04:00:00.000Z</published>
    <updated>2020-12-21T09:16:14.788Z</updated>
    
    <content type="html"><![CDATA[<p>记录oracle操作实例，不过查询的较多。由于同时涉及多种数据库，会混入其它库的记录。  </p><a id="more"></a><h2 id="搭建oracle服务"><a href="#搭建oracle服务" class="headerlink" title="搭建oracle服务"></a>搭建oracle服务</h2><p>使用docker搭建。<br>使用navicat连接，成功后，“其它”-&gt;“表空间”-&gt;“新建表空间”。<br>“常规”：名称：fee.ora，大小10，单位G，路径：/home/oracle/app/oracle/product/11.2.0/dbhome_2/dbs/ (注意后面的<code>/</code>)。自动扩展：ON。<br>“存储”：文件类型BIGFILE，大小：10，单位G，扩展区管理LOCAL。<br>“保存”。  </p><p>用户-&gt;用户，“新建用户”，输入用户名称，密码，“保存”。  </p><p>（似乎要创建用户才能看到数据库）</p><h2 id="连接工具"><a href="#连接工具" class="headerlink" title="连接工具"></a>连接工具</h2><p>（注：本节待移动）<br>navicat，该工具可连接多种数据库。  </p><p>可在不同数据库中迁移，“工具”-&gt;“数据传输”。实际发现，此方式迁移的表的字段类型，可能会与原表不一致，如把char改为text，会出错。<br>导出：可导出不同类型文件，如sql文件，txt文件，xml、json，等等。可选要导出的列。  </p><h2 id="navicat-异构数据库同步问题"><a href="#navicat-异构数据库同步问题" class="headerlink" title="navicat 异构数据库同步问题"></a>navicat 异构数据库同步问题</h2><p>1、原数据库导出为txt，再在新数据库导入。在导出过程，默认字段为text，不一定符合要求。<br>2、原数据库导出为sql，再在新数据库导入。sql文件格式不一定通用，要修改，再导入。  </p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>创建的用户没有权限，提示<code>user test lacks create session privilege logon denied</code>。解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqlplus &#x2F;nolog</span><br><span class="line">onn &#x2F;as sysdba</span><br><span class="line">grant create session to test</span><br></pre></td></tr></table></figure><p><code>create table xxx ()</code>缺失右括号。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter user FEE default tablespace FEE quota 500 M on FEE;</span><br></pre></td></tr></table></figure><h2 id="类型对应关系"><a href="#类型对应关系" class="headerlink" title="类型对应关系"></a>类型对应关系</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">SQL Server 数据类型Oracle 数据类型</span><br><span class="line">bigintNUMBER(19,0)</span><br><span class="line">binary(1-2000)RAW(1-2000)</span><br><span class="line">binary(2001-8000)BLOB</span><br><span class="line">bitNUMBER(1)</span><br><span class="line">char(1-2000)CHAR(1-2000)</span><br><span class="line">char(2001-4000)VARCHAR2(2001-4000)</span><br><span class="line">char(4001-8000)CLOB</span><br><span class="line">dateDATE</span><br><span class="line">datetimeDATE</span><br><span class="line">datetime2(0-7)TIMESTAMP(7)（对于 Oracle 9 和 Oracle 10）；VARCHAR(27)（对于 Oracle 8）</span><br><span class="line">datetimeoffset(0-7)TIMESTAMP(7) WITH TIME ZONE（对于 Oracle 9 和 Oracle 10）；VARCHAR(34)（对于 Oracle 8）</span><br><span class="line">decimal(1-38, 0-38)NUMBER(1-38, 0-38)</span><br><span class="line">float(53)FLOAT</span><br><span class="line">floatFLOAT</span><br><span class="line">地理BLOB</span><br><span class="line">geometryBLOB</span><br><span class="line">hierarchyidBLOB</span><br><span class="line">图像BLOB</span><br><span class="line">intNUMBER(10,0)</span><br><span class="line">moneyNUMBER(19,4)</span><br><span class="line">nchar(1-1000)CHAR(1-1000)</span><br><span class="line">nchar(1001-4000)NCLOB</span><br><span class="line">ntextNCLOB</span><br><span class="line">numeric(1-38, 0-38)NUMBER(1-38, 0-38)</span><br><span class="line">nvarchar(1-1000)VARCHAR2(1-2000)</span><br><span class="line">nvarchar(1001-4000)NCLOB</span><br><span class="line">nvarchar(max)NCLOB</span><br><span class="line">realreal</span><br><span class="line">smalldatetimeDATE</span><br><span class="line">intNUMBER(5,0)</span><br><span class="line">smallmoneyNUMBER(10,4)</span><br><span class="line">sql_variantN&#x2F;A</span><br><span class="line">sysnameVARCHAR2(128)</span><br><span class="line">textCLOB</span><br><span class="line">time(0-7)VARCHAR(16)</span><br><span class="line">timestampRAW(8)</span><br><span class="line">tinyintNUMBER(3,0)</span><br><span class="line">uniqueidentifierCHAR(38)</span><br><span class="line">varbinary(1-2000)RAW(1-2000)</span><br><span class="line">varbinary(2001-8000)BLOB</span><br><span class="line">varchar(1-4000)VARCHAR2(1-4000)</span><br><span class="line">varchar(4001-8000)CLOB</span><br><span class="line">varbinary(max)BLOB</span><br><span class="line">varchar(max)CLOB</span><br><span class="line">xmlNCLOB</span><br></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><h4 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">判断字段空或非空（即null）</span><br><span class="line">select * from xxx where foo is null</span><br><span class="line">select * from xxx where foo is not null</span><br></pre></td></tr></table></figure><h4 id="常用查询"><a href="#常用查询" class="headerlink" title="常用查询"></a>常用查询</h4><p>模糊查找：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from MYDB.STATION where name like &#39;%出口%&#39;</span><br></pre></td></tr></table></figure><p>查找交易表中指定的ID，日期和类型，限制5条：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from MYDB.TRADE_INFO </span><br><span class="line">where ID&#x3D;&#39;001250&#39; </span><br><span class="line">and to_char(trans_time, &#39;yyyy-MM-dd HH24:MI:SS&#39;) like &#39;2020-08-08 %&#39; </span><br><span class="line">and TYPE &#x3D; 1 </span><br><span class="line">and rownum &lt; 5</span><br></pre></td></tr></table></figure><p>注:日期转换要用<code>to_char(trans_time, &#39;yyyy-MM-dd HH24:MI:SS&#39;)</code>这种形式。  </p><p>交易时间最早：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">升序</span><br><span class="line">select * from MYDB.TRADE_INFO g where  rownum &lt; 10 order by g.TRANS_TIME</span><br></pre></td></tr></table></figure><p>交易时间最新：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">降序</span><br><span class="line">select * from MYDB.TRADE_INFO g where  rownum &lt; 10 order by g.TRANS_TIME desc</span><br></pre></td></tr></table></figure><p>注：这是错误的，先取10条，再排序，不符合逻辑。但未找到合适的。特别在几千万条的记录中找，耗时。  </p><p>多表查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select a.id, a.id_hex, a.name from TableA A, TableB B where a.name &#x3D;  b.name and A.id_hex&#x3D;&#39;510156&#39;</span><br><span class="line"></span><br><span class="line">select a.id, a.id_hex, a.name from TableA A, TableB B where a.name like &quot;%&quot; || b.name || &quot;%&quot; and A.id_hex&#x3D;&#39;510156&#39;</span><br><span class="line">注：A、B表，各有各的字段，但包含共同的name字段，以此为条件查两表，另一条件为指定id_hex。</span><br><span class="line">第二语句为a的name有多个，但b的name只有一个，属于包含关系。第一语句为相等</span><br></pre></td></tr></table></figure><p>查询去重<br>如果结果有多条，在语句后续添加<code>group by A.id_hex</code>。有时出错，则在select后加DISTINCT关键字。错误示例：    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择列表中的列 &#39;TableA.id_hex&#39; 无效，因为该列没有包含在聚合函数或 GROUP BY 子句中。 (8120)  </span><br></pre></td></tr></table></figure><p>查询指定字段有重复（即超过1个）的记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from AAA where version&#x3D;&#39;001&#39;  group by sta having count(sta)&gt;1</span><br></pre></td></tr></table></figure><h4 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h4><p>导出查询，将结果导出sql。<br>按条件查询，得到结果，再点击“导出结果”（在“运行”附近），可保存得到的结果。此法适用同一表中有不同版本的记录（即同一条记录存在多个版本，重复）。如要保存所有记录，直接导出即可。  </p><p>直接右键某个表，“导出向导…”，可得不同格式文件。“转储SQL文件”，可得含结构和数据，或仅含结构。  </p><p>Win7 64bit 连接数据库  </p><p>1、下载 64 版本的 OCI<br><a href="https://www.oracle.com/database/technologies/instant-client/winx64-64-downloads.html">https://www.oracle.com/database/technologies/instant-client/winx64-64-downloads.html</a><br>版本 SDK 版本（有静态库，用于开发）、Basic 版本（基础包）、ODBC 版本（有用于安装的exe）。压缩包不同，但内含目录一致，解压到当前目录即可。本文用最新版本instantclient_19_8。将压缩后的目录拷贝到指定目录，示例：D:\oracle\instantclient，下用 ORACLE_HOME 代替。   </p><p>2、设置环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ORACLE_HOME D:\oracle\instantclient</span><br><span class="line">NLS_LANG SIMPLIFIED CHINESE_CHINA.ZHS16GBK</span><br><span class="line">TNS_ADMIN D:\oracle\instantclient</span><br><span class="line">Path D:\oracle\instantclient</span><br></pre></td></tr></table></figure><p>修改编辑ORACLE_HOME\tnsnames.ora，如果没有，从别处拷贝一份。格式类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">oracle_inner &#x3D;</span><br><span class="line">  (DESCRIPTION &#x3D;</span><br><span class="line">    (ADDRESS &#x3D; (PROTOCOL &#x3D; TCP)(HOST &#x3D; 192.168.234.100)(PORT &#x3D; 1521))</span><br><span class="line">    (CONNECT_DATA &#x3D;</span><br><span class="line">      (SERVER &#x3D; DEDICATED)</span><br><span class="line">      (SERVICE_NAME &#x3D; helowin)</span><br><span class="line">    )</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>3、安装<br>进入ORACLE_HOME目录，执行odbc_install.exe，最好使用管理员打开cmd，切换该目录，再执行。</p><p>4、配置<br>打开控制面板，找到：<code>管理工具</code>，<code>ODBC数据源</code>或者 ODBC数据源(32 位)，打开之。<br>添加用户DSN: 点击添加按钮，找到对应版本的ODBC，本文为<code>Oracle in instantclient</code>，输入信息，测试连接。  </p><p>5、除外<br>如果ODBC数据源没有找到版本，打开目录 C:\Windows\SysWOW64。双击运行odbcad32.exe。<br>点击添加按钮，找到对应版本的ODBC。点击完成，添加数据源、服务名、用户名（如oracle1、oracle2、my），点击Test Connection，输入密码。成功后，点击“OK”保存。  </p><p>注0：ODBC数据源界面看到的名称，可认为是数据源，在代码中可直接使用，如上述的oracle1等。<br>注1：不同系统，不同版本，结果可能不同。<br>注2：本文安装目录为instantclient，是因为要尝试多种版本，每次改环境变量麻烦。在选择源时只显示<code>Oracle in instantclient</code>，如目录带版本号，则会显示出来。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录oracle操作实例，不过查询的较多。由于同时涉及多种数据库，会混入其它库的记录。  &lt;/p&gt;</summary>
    
    
    
    <category term="个人知识中心" scheme="http://www.latelee.org/category/pkc/"/>
    
    
    <category term="工具使用" scheme="http://www.latelee.org/tag/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    <category term="数据库" scheme="http://www.latelee.org/tag/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库的一些实例记录</title>
    <link href="http://www.latelee.org/pkc/database-practice.html"/>
    <id>http://www.latelee.org/pkc/database-practice.html</id>
    <published>2020-07-18T04:00:00.000Z</published>
    <updated>2020-12-21T09:16:14.788Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些数据库的操作。会涉及多种数据库。  </p><a id="more"></a><h2 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sqlite：</span><br><span class="line">CREATE TABLE IF NOT EXISTS &quot;AAA&quot; (</span><br><span class="line">  &quot;ID&quot; INT NOT NULL ,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">sqlserver:</span><br><span class="line">if not exists (select * from sysobjects where id &#x3D; object_id(&#39;AAA&#39;))</span><br><span class="line">CREATE TABLE &quot;AAA&quot; (</span><br><span class="line">  &quot;ID&quot; INT NOT NULL ,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">主键可有多个（依次排序），使用 PRIMARY KEY (&quot;AAA&quot;, &quot;BBB&quot;) 即可</span><br></pre></td></tr></table></figure><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">oracle    sqlserver   sqlite</span><br><span class="line">VARCHAR2   VARCHAR</span><br><span class="line">CHAR(16 BYTE)  CHAR(16)</span><br><span class="line">FLOAT(126)  FLOAT(53)</span><br><span class="line">NUMBER(3)   INT</span><br><span class="line">DATE        DATETIME</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注：int就是一个整数，不能指定宽度</p><h2 id="出错"><a href="#出错" class="headerlink" title="出错"></a>出错</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一些数据库的操作。会涉及多种数据库。  &lt;/p&gt;</summary>
    
    
    
    <category term="个人知识中心" scheme="http://www.latelee.org/category/pkc/"/>
    
    
    <category term="工具使用" scheme="http://www.latelee.org/tag/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    <category term="数据库" scheme="http://www.latelee.org/tag/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
