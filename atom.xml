<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>迟思堂随笔</title>
  
  <subtitle>李迟的技术主页</subtitle>
  <link href="http://www.latelee.org/atom.xml" rel="self"/>
  
  <link href="http://www.latelee.org/"/>
  <updated>2021-06-04T02:18:55.914Z</updated>
  <id>http://www.latelee.org/</id>
  
  <author>
    <name>李迟</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>李迟2021年5月知识总结</title>
    <link href="http://www.latelee.org/my-library/code-for-2021-05.html"/>
    <id>http://www.latelee.org/my-library/code-for-2021-05.html</id>
    <published>2021-05-29T16:00:00.000Z</published>
    <updated>2021-06-04T02:18:55.914Z</updated>
    
    <content type="html"><![CDATA[<p>本文为 2021 年 5 月知识总结。</p><span id="more"></span><h2 id="编码总结"><a href="#编码总结" class="headerlink" title="编码总结"></a>编码总结</h2><h3 id="web静态服务器"><a href="#web静态服务器" class="headerlink" title="web静态服务器"></a>web静态服务器</h3><p>测试前端时，可直接在浏览器中进行调试，当需要有数据交互时，可搭建简单后台服务，golang 语言创建 web 服务，并指定 Directory目录：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router := gin.New()</span><br><span class="line">router.StaticFS(<span class="string">&quot;/&quot;</span>, http.Dir(conf.Directory))</span><br><span class="line">router.Run(<span class="string">&quot;:&quot;</span> + conf.Port)</span><br></pre></td></tr></table></figure><p>由 golang 实现的简单的 web 服务镜像为<code>latelee/webdemo</code>，根目录为<code>/dist</code>，为<code>80</code>。</p><p>NodeJS 语言创建 web 服务并指定 staticPath 目录：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line">app.use(koastatic(path.join( __dirname, staticPath)));</span><br><span class="line">app.use(router.g_router.routes());</span><br><span class="line">g_webServer = app.listen(&#123;</span><br><span class="line">        <span class="attr">host</span>:SVR_HOST,</span><br><span class="line">        <span class="attr">port</span>:SVR_PORT,</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h2 id="前端后台一点笔记"><a href="#前端后台一点笔记" class="headerlink" title="前端后台一点笔记"></a>前端后台一点笔记</h2><p>html文件，或由渲染工具（ hexo、vuepress 等）渲染得到的 html 文件，需托管于 web 服务器，如 apache、nginx 或 tomcat 这些现成服务器，不同服务器，其根目录不同，体积亦不同。上面实现的也是 web 服务器，但体积会小很多，并且可以直接和后台服务融合。当然，对于模块分工明确的场景，前端页面和后台服务必须位于不同服务器/地区，则另当别论。    </p><h3 id="编码其它"><a href="#编码其它" class="headerlink" title="编码其它"></a>编码其它</h3><p>继续总结 Makefile 知识：<br>上月仅实践了过滤指定文件的做法。本月研究过滤目录的做法，方法较简单，在 find 中直接用<code>grep -v</code>过滤不需要的目录即可。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SRC_DIRS = .</span><br><span class="line">SRCS := $(shell find $(SRC_DIRS) -maxdepth 2 -name &#x27;*.cpp&#x27; -or -name &#x27;*.c&#x27; | grep -v dir_notneed)</span><br></pre></td></tr></table></figure><p>由于考虑到通用性，之前的 Makefile 均直接使用 find 查看源码的方法，因此，会编译指定目录所有源文件。当然也可手动指定源文件方法，略显麻烦而已。<br>如果先查找目录，再查找源文件，由于<code>find</code>找到的目录包含<code>SRC_DIRS</code>自身，再用<code>find</code>找到，还是会找到过滤目录的文件，目前未想到好办法。  </p><p>又看了一些编码规则（其实是 vue），加之接手了几个祖传代码（保留着大量2015年写的不再使用的函数），对其中提到的点比较认同。比如命名，代码首先给自己看，其次用于团队交流（有的项目始终是一个人维护）。 要点：<br>考虑视觉效果，如大写，固定前缀，空行，注释位置，等。<br>避免不常用缩写，缩写团队内达成一致。如返回值，有的写<code>ret</code>，有的写<code>res</code>。  </p><p>扩展：在软件使用上减少用户认知成本，小的范围，如编码，大家统一一套代码方式。大的范围，如一些对话框的关闭按钮位置，有的左上角，有的右上角；如“确定”、“取消”位置也不固定。不过环境太大，无法统一。  </p><p><strong>大道至简，用简单的方法实现功能/需求，才是最好的方法。</strong> 一些奇技淫巧， 如未必要，除自娱自乐外，有人欣赏，也是不错的，但知音难觅。</p><h2 id="一般知识"><a href="#一般知识" class="headerlink" title="一般知识"></a>一般知识</h2><h2 id="研发思考"><a href="#研发思考" class="headerlink" title="研发思考"></a>研发思考</h2><p>最近看了一些面向对象设计原则，单一职责原则、开闭原则，等。一般举例时，以画图（三角形、圆形）为主。 实际中，并不是如此单纯，对于当前项目。  </p><p>代码模式、设计模式，架构模式。</p><p>业务入侵：有时为了方便调试，或出于某此特殊目的，会将一些特殊值（魔数）赋值某些变量或参数，可能会影响生产环境。比如将ID设置为一个不存在的值，但万一后面会出现在正常业务中，会出问题。  扩展：有些设计时需要考虑后续发展计划，有时又不需要过度设计，这个度不好把握，只能靠经验。实例：比如某省的收费站代号，使用3位数字表示，则最大只能有999个，万一超过，可添加代号位数解决，但如果涉及到根本机制问题，牵一发而动全身，风险大大添加。</p><h2 id="本月学习及计划"><a href="#本月学习及计划" class="headerlink" title="本月学习及计划"></a>本月学习及计划</h2><p>看了一些前端、后台、微服务架构、UML的概念和知识，后续要继续看。</p><p>使用 vuepress 构建了 一个静态网站，已部署内部服务器。  </p><p>兜兜转转，从手写到 bootstrap，到一些框架，到 vue，最后还是决定上 vue，拥抱主流，多学一些，保持大脑正常运转。  </p><h2 id="其它点滴"><a href="#其它点滴" class="headerlink" title="其它点滴"></a>其它点滴</h2><p>熬夜比上月多了一些，一是有很多未接触的东西要学，二是要继续熟悉业务和代码，三是白天晚上时间被其它事占用了。每天感觉刚躺床上又起来了。有时候大锤闹着要我陪睡，则会偷懒多睡一点，但更多是他独立睡。  </p><p>很多个深夜，站在阳台，望着天空，听着对面楼的麻将声和外面的汽车声，我在想，该怎么做才能平衡儿子、丈夫、父亲的角色。我的角色里面需不需要有自己？但我的兴趣爱好，在那些角色面前根本占不了位置。一切的根源其实就是钱，学技术，对工作上心也是为了钱，钱多不多我控制不了，自己勤奋不勤奋，这点能控制。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文为 2021 年 5 月知识总结。&lt;/p&gt;</summary>
    
    
    
    <category term="我的程序代码" scheme="http://www.latelee.org/category/my-library/"/>
    
    
    <category term="代码积累" scheme="http://www.latelee.org/tag/%E4%BB%A3%E7%A0%81%E7%A7%AF%E7%B4%AF/"/>
    
    <category term="知识总结" scheme="http://www.latelee.org/tag/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>我的docker随笔32：sftp服务部署</title>
    <link href="http://www.latelee.org/docker/docker-32-deploy-sftp-server.html"/>
    <id>http://www.latelee.org/docker/docker-32-deploy-sftp-server.html</id>
    <published>2021-05-09T16:00:00.000Z</published>
    <updated>2021-06-04T02:18:55.946Z</updated>
    
    <content type="html"><![CDATA[<p>本文涉及一种在容器中部署 sftp 服务的方法。经验证，可达到预期目标，并能应用在实际工作中。    </p><span id="more"></span><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>因工作需要，需部署 sftp 服务器进行数据测试。</p><h2 id="二、技术小结"><a href="#二、技术小结" class="headerlink" title="二、技术小结"></a>二、技术小结</h2><ul><li><p>dockerhub 上相关镜像，直接拉取可用。  </p></li><li><p>运行时需要注意用户名和<code>home</code>目录，如使用<code>foo</code>用户，则需要挂载到<code>/home/foo</code>目录。  </p></li><li><p>需要手动设置ssh key，否则每次重启都会产生新的key。</p></li><li><p>上传权限问题暂未解决。  </p></li></ul><h2 id="三、实践"><a href="#三、实践" class="headerlink" title="三、实践"></a>三、实践</h2><h3 id="3-1-下载"><a href="#3-1-下载" class="headerlink" title="3.1 下载"></a>3.1 下载</h3><p>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull atmoz/sftp</span><br></pre></td></tr></table></figure><p>测试运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">    -v /tmp/upload:/home/foo/upload \</span><br><span class="line">    --name sftp \</span><br><span class="line">    -p 2222:22 -itd atmoz/sftp \</span><br><span class="line">    foo:pass:1000</span><br></pre></td></tr></table></figure><p>注：挂载 <code>tmp/upload</code>到容器<code>home</code>的同名目录下，账号密码分别为<code>foo</code>、<code>pass</code>，<code>UID</code>与执行此命令的主机用户一样，即<code>1000</code>（可通过<code>/etc/passwd</code>文件查看知）。</p><p>测试连接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sftp -P 2222 foo@localhost</span><br><span class="line">foo@localhost&#x27;s password: </span><br><span class="line">Connected to localhost.</span><br><span class="line"><span class="meta">sftp&gt;</span><span class="bash"> ls</span></span><br><span class="line">upload  </span><br><span class="line"><span class="meta">sftp&gt;</span><span class="bash"> <span class="built_in">cd</span> upload/</span></span><br><span class="line"><span class="meta">sftp&gt;</span><span class="bash"> put webdemo</span></span><br><span class="line">Uploading webdemo to /upload/webdemo</span><br><span class="line">remote open(&quot;/upload/webdemo&quot;): Permission denied</span><br></pre></td></tr></table></figure><p>提示权限不足，在容器中修改 upload 目录权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -it sftp bash</span><br><span class="line">root@35f5c9abeb71:/# cd home/</span><br><span class="line">root@35f5c9abeb71:/home/foo# ls -lh</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x. 2 root root 6 May 10 07:05 upload</span><br><span class="line">root@35f5c9abeb71:/home/foo# chmod 777 upload/ -R</span><br><span class="line">root@35f5c9abeb71:/home/foo# ls -lh</span><br><span class="line">total 0</span><br><span class="line">drwxrwxrwx. 2 root root 21 May 10 07:27 upload</span><br></pre></td></tr></table></figure><p>则可以正常上传</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sftp&gt; put webdemo</span><br><span class="line">Uploading webdemo to /upload/webdemo</span><br><span class="line">webdemo                                       100% 6706KB  53.1MB/s   00:00  </span><br><span class="line">sftp&gt; exit</span><br></pre></td></tr></table></figure><h2 id="四、sftp常用命令"><a href="#四、sftp常用命令" class="headerlink" title="四、sftp常用命令"></a>四、sftp常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">登陆：</span><br><span class="line">sftp -P &lt;端口&gt; &lt;用户名&gt;@&lt;IP&gt;</span><br><span class="line"></span><br><span class="line">?：查看帮助</span><br><span class="line">quit：退出</span><br><span class="line">cd lcd：进入某目录 （注：有l前缀表示是宿主机）</span><br><span class="line">ls lls：查看目录</span><br><span class="line">pwd lpwd：查看当前路径</span><br><span class="line">mdir ：创建目录</span><br><span class="line">put：上传文件（目录：-r）</span><br><span class="line">get：下载文件</span><br></pre></td></tr></table></figure><h2 id="五、指定ssh-key"><a href="#五、指定ssh-key" class="headerlink" title="五、指定ssh key"></a>五、指定ssh key</h2><p>默认情况下，每次重新服务，都会产生新的key，需要用户确认（见附录）。可以手动指定key，解决该问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir ssh</span><br><span class="line">cd ssh</span><br><span class="line">ssh-keygen -t ed25519 -f ssh_host_ed25519_key &lt; /dev/null</span><br><span class="line">ssh-keygen -t rsa -b 4096 -f ssh_host_rsa_key &lt; /dev/null</span><br></pre></td></tr></table></figure><p>在运行添加如下参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-v &lt;host-dir&gt;/ssh_host_ed25519_key:/etc/ssh/ssh_host_ed25519_key \</span><br><span class="line">-v &lt;host-dir&gt;/ssh_host_rsa_key:/etc/ssh/ssh_host_rsa_key \</span><br></pre></td></tr></table></figure><h2 id="六、docker-compose部署"><a href="#六、docker-compose部署" class="headerlink" title="六、docker-compose部署"></a>六、docker-compose部署</h2><p>对应的<code>yaml</code>文件如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">sftp:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">atmoz/sftp</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">sftp</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./upload:/home/aftp/</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./ssh/ssh_host_ed25519_key:/etc/ssh/ssh_host_ed25519_key</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./ssh/ssh_host_rsa_key:/etc/ssh/ssh_host_rsa_key</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;2222:22&quot;</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">aftp:passworld:1000</span></span><br></pre></td></tr></table></figure><p>注：本例中将当前目录的<code>upload</code>目录直接挂载到用户的<code>home</code>目录，不似上述在<code>upload</code>目录。这样客户端连接后的根目录就是宿主机的<code>upload</code>目录，较方便。</p><h2 id="七、参考"><a href="#七、参考" class="headerlink" title="七、参考"></a>七、参考</h2><p>sftp 镜像：<a href="https://hub.docker.com/r/atmoz/sftp">https://hub.docker.com/r/atmoz/sftp</a>  </p><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>网上有文章在运行容器命令时添加<code>--privileged=true</code>参数。  </p><p>首次运行时，用<code>sftp</code>命令连接时，需要确认，提示如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &#x27;[localhost]:2222 ([::1]:2222)&#x27; can&#x27;t be established.</span><br><span class="line">ED25526 key fingerprint is SHA256:FUCkkcufctB3fasdf45sszVCaqRQTY7+Qasjw235A+XwCg.</span><br><span class="line">ED25526 key fingerprint is MD5:17:fu:ck:3d:bb:aa:00:35:79:ac:bc:cc:dc:ec:71:bb.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br><span class="line">Warning: Permanently added &#x27;[localhost]:2222&#x27; (ED25526) to the list of known hosts.</span><br></pre></td></tr></table></figure><p>如果重新启动（这样也算是首次运行），则会提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span><br><span class="line">Someone could be eavesdropping on you right now (man-in-the-middle attack)!</span><br><span class="line">It is also possible that a host key has just been changed.</span><br><span class="line">The fingerprint for the ED25519 key sent by the remote host is</span><br><span class="line">SHA256:FTKtctB6yBQasdfasdfasdf3fasdf7+QSBTLyyasdfasdfasdfCg.</span><br><span class="line">Please contact your system administrator.</span><br><span class="line">Add correct host key in /home/lateee/.ssh/known_hosts to get rid of this message.</span><br><span class="line">Offending ED25526 key in /home/lateee/.ssh/known_hosts:4</span><br></pre></td></tr></table></figure><p>此时，需要编辑<code>/home/lateee/.ssh/known_hosts</code>文件，删除对应的那一行信息（本文中，会带有 2222 字样）。  </p><p>疑问：如果使用程序连接，首次出现上述提示，如何输入<code>yes</code>？待研究。  </p><p>在一次用 docker-compose 运行时，客户端连接出现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sftp -P2222 foo@127.0.0.1</span></span><br><span class="line">Connection closed by 127.0.0.1 port 2222</span><br><span class="line">Couldn&#x27;t read packet: Connection reset by peer</span><br></pre></td></tr></table></figure><p>经查，是因为 sftp 服务器目录在 Windows 系统，改为 Linux 系统，问题解决。（为减少虚拟机空间占用，并方便调试，笔者习惯使用虚拟机的共享目录，在 Linux 中操作 Windows 硬盘。）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文涉及一种在容器中部署 sftp 服务的方法。经验证，可达到预期目标，并能应用在实际工作中。    &lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="http://www.latelee.org/category/docker/"/>
    
    
    <category term="docker" scheme="http://www.latelee.org/tag/docker/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：静态资源文件整合：web服务</title>
    <link href="http://www.latelee.org/golang/golang-notes-combine-static-file-1.html"/>
    <id>http://www.latelee.org/golang/golang-notes-combine-static-file-1.html</id>
    <published>2021-05-04T16:01:00.000Z</published>
    <updated>2021-06-04T02:18:55.834Z</updated>
    
    <content type="html"><![CDATA[<p>趁着五一放假，趁着有时间，把欠的一些技术集中研究研究，写写文章，好给自己一个交待。<br>本文研究静态资源文件的在 web 服务器的整合。  </p><span id="more"></span><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>Golang 中的 web 服务框架有很多种，本文选取 gin 实现。gin 实现一个 web 服务仅需几行代码，十分方便。但为了适应更复杂的项目，还需要进行一些改进。<br>web 服务页面的文件，除了 html 外，还有 css、js、图片等文件，为方便管理，将后者放到 static 目录——与前面文章目录保持一致，将前者放到 templates 目录，使用 gin 的 html 模板进行渲染，而且 gin 也支持自定义模板文件，恰好能适合我们的场景。  </p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h3><p>本文使用到的资源文件如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ tree static/</span><br><span class="line">static/</span><br><span class="line">|-- css</span><br><span class="line">|   |-- bootstrap.min.css</span><br><span class="line">|   |-- font-awesome.min.css</span><br><span class="line">|   `-- main.css</span><br><span class="line">|-- favicon.ico</span><br><span class="line">`-- js</span><br><span class="line">    |-- bootstrap.min.js</span><br><span class="line">    |-- jquery-1.8.3.min.js</span><br><span class="line">    |-- jquery-2.0.0.min.js</span><br><span class="line">    `-- main.js</span><br><span class="line"></span><br><span class="line">2 directories, 8 files</span><br><span class="line"></span><br><span class="line">$ tree templates/</span><br><span class="line">templates/</span><br><span class="line">|-- about.html</span><br><span class="line">|-- about.js</span><br><span class="line">|-- index.html</span><br><span class="line">|-- login.html</span><br><span class="line">|-- login.js</span><br><span class="line">`-- nav.js</span><br><span class="line"></span><br><span class="line">0 directories, 6 files</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="通用方式"><a href="#通用方式" class="headerlink" title="通用方式"></a>通用方式</h3><p>为方便对比，先给出通用的 gin 框架，主要代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 直接引用文件形式</span><br><span class="line">func webServerFile() &#123;</span><br><span class="line">    fmt.Println(&quot;gin test...&quot;)</span><br><span class="line">truerouter := gin.Default()</span><br><span class="line">    </span><br><span class="line">    // 似乎这样做，templates下只能有文件，不能有目录</span><br><span class="line">    router.LoadHTMLGlob(&quot;templates/*&quot;)</span><br><span class="line">    </span><br><span class="line">    // 将真实目录做不同前缀，方便引用css js等文件</span><br><span class="line">    // 有些自实现的用html文件或js文件，用html前缀。</span><br><span class="line">    router.StaticFS(&quot;/js&quot;, http.Dir(&quot;static/js&quot;))</span><br><span class="line">    router.StaticFS(&quot;/css&quot;, http.Dir(&quot;static/css&quot;))</span><br><span class="line">    router.StaticFS(&quot;/html&quot;, http.Dir(&quot;templates&quot;))</span><br><span class="line"></span><br><span class="line">    router.GET(&quot;/&quot;, HandleIndex)</span><br><span class="line">    router.GET(&quot;/index&quot;, HandleIndex)</span><br><span class="line">    router.GET(&quot;/about&quot;, HandleAbout)</span><br><span class="line">    router.GET(&quot;/login&quot;, HandleLogin)</span><br><span class="line">    </span><br><span class="line">truerouter.Run(&quot;:8081&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 LoadHTMLGlob 用于加载 html 模板文件，StaticFS 指定静态资源，有两个参数，第一个指定前缀名称（即在 html 或 js 文件中引用时使用的路径，第二个指定真实路径（相对于 web 程序所在目录）。GET 函数用于响应对应的页面，由于响应函数非本文重点，故简单列举如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func HandleIndex(ctx *gin.Context) &#123;</span><br><span class="line">    file := path.Join(gPrefix, &quot;index.html&quot;)</span><br><span class="line">    ctx.HTML(http.StatusOK, file, gin.H&#123;</span><br><span class="line">truetrue&quot;title&quot;:  &quot;Main website&quot;,</span><br><span class="line">true&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：gPrefix 将在下文提及。  </p><h3 id="整合方式"><a href="#整合方式" class="headerlink" title="整合方式"></a>整合方式</h3><p>使用 bindata 方式，与上面示例没有本质区别，只是需要手动设置模板加载规则，指定静态资源文件方式也不同。主要代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 整合文件形式</span><br><span class="line">func webServerBindata() &#123;</span><br><span class="line">    fmt.Println(&quot;gin test.....&quot;)</span><br><span class="line">truerouter := gin.Default()</span><br><span class="line">truet, err := loadTemplate()</span><br><span class="line">trueif err != nil &#123;</span><br><span class="line">truetruepanic(err)</span><br><span class="line">true&#125;</span><br><span class="line">truerouter.SetHTMLTemplate(t)</span><br><span class="line"></span><br><span class="line">    // 下面指定的是静态资源文件，与响应get/post的地址无关系</span><br><span class="line">    fsjs := assetfs.AssetFS&#123;</span><br><span class="line">        Asset:     bindata.Asset,</span><br><span class="line">        AssetDir:  bindata.AssetDir,</span><br><span class="line">        AssetInfo: bindata.AssetInfo,</span><br><span class="line">        Prefix:   &quot;static/js&quot;,</span><br><span class="line">        Fallback: &quot;index.html&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">    router.StaticFS(&quot;/js&quot;, &amp;fsjs)</span><br><span class="line">    </span><br><span class="line">    fscss := assetfs.AssetFS&#123;</span><br><span class="line">        Asset: bindata.Asset, AssetDir: bindata.AssetDir, AssetInfo: bindata.AssetInfo, </span><br><span class="line">        Prefix:   &quot;static/css&quot;,</span><br><span class="line">        Fallback: &quot;index.html&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">    router.StaticFS(&quot;/css&quot;, &amp;fscss)</span><br><span class="line">    </span><br><span class="line">    fshtml := assetfs.AssetFS&#123;</span><br><span class="line">        Asset: bindata.Asset, AssetDir: bindata.AssetDir, AssetInfo: bindata.AssetInfo, </span><br><span class="line">        Prefix:   &quot;templates&quot;,</span><br><span class="line">        Fallback: &quot;index.html&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">    router.StaticFS(&quot;/html&quot;, &amp;fshtml)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    router.StaticFS(&quot;/favicon.ico&quot;, &amp;fshtml)</span><br><span class="line">    </span><br><span class="line">    // 人为添加前缀，因为前面loadTemplate加载的html路径包含有路径前缀，因此加上</span><br><span class="line">    // 如果手动删除，则此处不需要前缀</span><br><span class="line">    //gPrefix = &quot;templates&quot;</span><br><span class="line"></span><br><span class="line">    router.GET(&quot;/&quot;, HandleIndex)</span><br><span class="line">    router.GET(&quot;/index&quot;, HandleIndex)</span><br><span class="line">    router.GET(&quot;/about&quot;, HandleAbout)</span><br><span class="line">    router.GET(&quot;/login&quot;, HandleLogin)</span><br><span class="line"></span><br><span class="line">truerouter.Run(&quot;:8081&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义模板加载函数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func loadTemplate() (*template.Template, error) &#123;</span><br><span class="line">    fmt.Println(&quot;load my template&quot;)</span><br><span class="line">truet := template.New(&quot;&quot;)</span><br><span class="line">    filenames := bindata.AssetNames()</span><br><span class="line">    for _, name := range  filenames &#123;</span><br><span class="line">        if !strings.HasSuffix(name, &quot;.tmpl&quot;) &amp;&amp; !strings.HasSuffix(name, &quot;.html&quot;) &amp;&amp; </span><br><span class="line">           !strings.HasSuffix(name, &quot;.css&quot;) &amp;&amp; !strings.HasSuffix(name, &quot;.js&quot;) &amp;&amp; </span><br><span class="line">           !strings.HasSuffix(name, &quot;.ico&quot;) &#123;</span><br><span class="line">truetruetruecontinue</span><br><span class="line">truetrue&#125;</span><br><span class="line">        //fmt.Println(&quot;got html file: &quot;, name)</span><br><span class="line">        content, err := bindata.Asset(name)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            return nil, err</span><br><span class="line">        &#125;</span><br><span class="line">        t, err = t.New(name).Parse(string(content))</span><br><span class="line">truetrueif err != nil &#123;</span><br><span class="line">truetruetruereturn nil, err</span><br><span class="line">truetrue&#125;</span><br><span class="line">true&#125;</span><br><span class="line">truereturn t, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在生成 bindata.go 时，指定了2处目录，而<code>-prefix</code>选项只能指定一个前缀，于是干脆不加该参数，因此，生成的代码中，前缀也会出现对应的目录，正因为这样，代码才使用了<code>gPrefix = &quot;templates&quot;</code>手动指定前缀。后来手动删除生成代码的前缀，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;s/templates\///g&#x27; bindata/bindata.go</span><br><span class="line">sed -i &#x27;s/static\///g&#x27; bindata/bindata.go</span><br></pre></td></tr></table></figure><p>两者关键代码对比如下图所示（注：左侧为未删除前缀的代码）。<br><img src="/golang/golang-notes-combine-static-file-1/01.png"></p><p>笔者阅读 go-bindata-assetfs 代码尝试添加参数达到目的，未果。  </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://jaycechant.info/2020/go-bindata-golang-static-resources-embedding/">https://jaycechant.info/2020/go-bindata-golang-static-resources-embedding/</a><br><a href="http://blog.hotsun168.com/index.php/archives/18/">http://blog.hotsun168.com/index.php/archives/18/</a><br>1.16 版本新方法：<br><a href="https://www.flysnow.org/2021/02/28/golang-embed-for-web.html">https://www.flysnow.org/2021/02/28/golang-embed-for-web.html</a>  </p><p>2021.5.5 凌晨</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;趁着五一放假，趁着有时间，把欠的一些技术集中研究研究，写写文章，好给自己一个交待。&lt;br&gt;本文研究静态资源文件的在 web 服务器的整合。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：静态资源文件整合：初步使用</title>
    <link href="http://www.latelee.org/golang/golang-notes-combine-static-file-0.html"/>
    <id>http://www.latelee.org/golang/golang-notes-combine-static-file-0.html</id>
    <published>2021-05-04T16:00:00.000Z</published>
    <updated>2021-06-04T02:18:55.834Z</updated>
    
    <content type="html"><![CDATA[<p>趁着五一放假，趁着有时间，把欠的一些技术集中研究研究，写写文章，好给自己一个交待。<br>本文介绍如何在 Golang 中整合静态资源文件，将静态资源文件编译到二进制可执行文件中，这与其它程序的打包可能是一个概念，也可能不是，后续有空研究再补充。  </p><span id="more"></span><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>大概10年前，即2011年，也研究一下这方面的内容，主要针对 C 语言，使用 ARM 板子测试。 那篇文章如下图： </p><p><img src="/golang/golang-notes-combine-static-file-0/1.png"></p><p>当时对技术的兴趣比较浓厚，没想过房子车子的事，现在经常想房子车子，但也被迫对技术感兴趣。因此，使用 Golang 语言重新研究一下。  </p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>经查，有2个类似的工具：go-bindata 和 go-bindata-assetfs。两者可以将文件转换成 golang 语言代码，后者似乎依赖于前者，本着使用的目的，暂未研究细节，看了一下生成的 golang 代码，有对外提供的接口，有文件映射表，有真正存储文件的字节流。  </p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>使用<code>go get</code>命令安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/go-bindata/go-bindata/...</span><br><span class="line">go get -u github.com/elazarl/go-bindata-assetfs/...</span><br></pre></td></tr></table></figure><p>输入对应的命令验证：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go-bindata</span><br><span class="line">go-bindata-assetfs</span><br></pre></td></tr></table></figure><h3 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h3><p>为适合项目目录，本文约定使用 static 目录存放静态资源文件——即需要打包到可执行程序中的文件，生成的代码，存放到 bindata 目录，且其包名亦为 bindata。经研究发现似乎 go-bindata-assetfs 更好一些，因此本文使用该工具，生成命令如下：    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go-bindata-assetfs -o=bindata/bindata.go -pkg=bindata -ignore=&quot;README.md&quot; -prefix=static static/... </span><br></pre></td></tr></table></figure><p><code>-o</code>指定了输出文件，<code>-pkg</code>指定包名（一般与前者保持一致），<code>-ignore</code>指定需忽略的文件，<code>-prefix</code>指定文件路径前缀（本例中，指定了前缀，不需在代码中使用<code>static</code>前缀）。如果不需要如此复杂，可将其生成的文件与包 main 在同一目录，包名亦为 main，可用于简单测试：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go-bindata-assetfs -o=bindata.go -ignore=&quot;README.md&quot; -prefix=static static/...</span><br></pre></td></tr></table></figure><p>为了调试方便——即不需要每次更新文件都要重新编译代码，则可以添加<code>-debug</code>参数，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go-bindata-assetfs -debug -o=bindata.go -ignore=&quot;README.md&quot; -prefix=static static/...</span><br></pre></td></tr></table></figure><p>添加<code>-debug</code>选项后，当修改了原资源文件后，重新运行程序，获取的内容会发生变化，不需要重新生成，方便调试。内部实现原理：在调用 bindataRead 读取文件时，添加文件的绝对路径。如果是非 debug 版本，则不加路径。    </p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>资源文件目录 static 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ tree static/</span><br><span class="line">static/</span><br><span class="line">|-- conf</span><br><span class="line">|   `-- config.toml</span><br><span class="line">|-- html</span><br><span class="line">|   `-- foo.html</span><br><span class="line">`-- libfoo.so</span><br><span class="line"></span><br><span class="line">2 directories, 3 files</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要使用的接口如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 获取所有的文件名称</span><br><span class="line">filenames := bindata.AssetNames()</span><br><span class="line"></span><br><span class="line">// 读取某一文件的内容</span><br><span class="line">filename = &quot;html/foo.html&quot;</span><br><span class="line">content, err = bindata.Asset(filename)</span><br></pre></td></tr></table></figure><p>指定的文件，以<code>static</code>为根目录，其形式与一般的路径无差异。  </p><p>完整测试代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;strings&quot;</span><br><span class="line">    &quot;io/ioutil&quot;</span><br><span class="line">    </span><br><span class="line">    &quot;bindata_test2/bindata&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(&quot;bindata test..&quot;);</span><br><span class="line">    </span><br><span class="line">    // 遍历所有文件，打印文件名，并输出html的内容</span><br><span class="line">    filenames := bindata.AssetNames()</span><br><span class="line">    for _, item := range  filenames &#123;</span><br><span class="line">        fmt.Println(&quot;got file: &quot;, item)</span><br><span class="line"></span><br><span class="line">        if !strings.HasSuffix(item, &quot;.tmpl&quot;) &amp;&amp; !strings.HasSuffix(item, &quot;.html&quot;) &#123;</span><br><span class="line">truetruetruecontinue</span><br><span class="line">truetrue&#125;</span><br><span class="line">        </span><br><span class="line">        content, err := bindata.Asset(item)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            fmt.Printf(&quot;not found file %s: %s\n&quot;, item, err.Error())</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(string(content))</span><br><span class="line">        fmt.Println(&quot;-----------------------------------\n&quot;)</span><br><span class="line">        </span><br><span class="line">true&#125;</span><br><span class="line">    </span><br><span class="line">    // 单独测试</span><br><span class="line">    filename := &quot;assets/foo.html&quot;</span><br><span class="line">    content, err := bindata.Asset(filename)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Printf(&quot;not found file %s: %s\n&quot;, filename, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    filename = &quot;foo.html&quot;</span><br><span class="line">    content, err = bindata.Asset(filename)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Printf(&quot;not found file %s: %s\n&quot;, filename, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    filename = &quot;html/foo.html&quot;</span><br><span class="line">    content, err = bindata.Asset(filename)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Printf(&quot;not found file %s: %s\n&quot;, filename, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    // content 为二进制buf，怎么用？</span><br><span class="line">    </span><br><span class="line">    filename = &quot;conf/config.toml&quot;</span><br><span class="line">    content, err = bindata.Asset(filename)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Printf(&quot;not found file %s: %s\n&quot;, filename, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(string(content))</span><br><span class="line">    </span><br><span class="line">    // 读取so并保存</span><br><span class="line">    filename = &quot;libfoo.so&quot;</span><br><span class="line">    content, err = bindata.Asset(filename)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Printf(&quot;not found file %s: %s\n&quot;, filename, err.Error())</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //filename = &quot;libfoo.so&quot;</span><br><span class="line">    err = ioutil.WriteFile(filename, content, 0755)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Println(&quot;write file error: &quot;, err)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;write file %s ok\n&quot;, filename)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 libfoo.so 文件为例，原文件和保存的文件对比如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ md5sum.exe static/libfoo.so libfoo.so</span><br><span class="line">9416ab261b2867d9acbb563690116885 *static/libfoo.so</span><br><span class="line">9416ab261b2867d9acbb563690116885 *libfoo.so</span><br></pre></td></tr></table></figure><p>两者内容是相同的。  </p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>本文所述方法，有一定范围内可以使用，对于大型项目或多人协作项目，不建议使用。<br>针对该方法，笔者认为可以进行的事有：<br>1、将 web 服务有关的 css、js、html 等整合到可执行二进制文件中，方便部署。在笔者即将实现的 web 服务中，由于功能唯一，又是内部使用，且还只是由笔者个人实现，因此对技术栈拥有完全自主的决定权，通俗地讲，同事和上头不管技术细节，能实现功能即可，为了方便自己，故如此设计。<br>2、动态库整合，如果涉及动态库文件的使用，则可以将动态库打包到可执行文件，在运行时读取并保存到指定目录，再加载。此法将二者绑定一起，无法做到只更新动态库文件，因此需慎重。<br>3、配置文件整合，对于需配置文件的程序而言，在部署时需自带配置文件，或默认首次运行时生成。对于后者，有的直接在代码中固定配置，根据情况写到指定目录，使用本文，则直接将配置文件打包到二进制文件，如不存在，则再写到指定目录。<br>4、其它待探索发现并实施。  </p><p>李迟 2021.5.5 </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;趁着五一放假，趁着有时间，把欠的一些技术集中研究研究，写写文章，好给自己一个交待。&lt;br&gt;本文介绍如何在 Golang 中整合静态资源文件，将静态资源文件编译到二进制可执行文件中，这与其它程序的打包可能是一个概念，也可能不是，后续有空研究再补充。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：调用C++函数的优化</title>
    <link href="http://www.latelee.org/golang/golang-notes-call-cpulsplus-function2.html"/>
    <id>http://www.latelee.org/golang/golang-notes-call-cpulsplus-function2.html</id>
    <published>2021-05-01T16:01:00.000Z</published>
    <updated>2021-06-04T02:18:55.834Z</updated>
    
    <content type="html"><![CDATA[<p>趁着五一放假，趁着有时间，把欠的一些技术集中研究研究，写写文章，好给自己一个交待。<br>本文继续介绍如何在 Golang 中调用 C++ 函数。  </p><span id="more"></span><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>前面文章介绍的方式，在运行时需要指定动态库位置，或将动态库放置系统目录，对笔者而言，还是略有麻烦，本文将使用<code>dl</code>系列函数，在运行时加载动态库，这样就去掉了路径的依赖。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>为减少篇幅，仅摘录必要的源码。  </p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>在动态库版本源码基础上，额外添加封装动态库头文件 c_callso.h：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">int cso_init(char* soname);</span><br><span class="line"></span><br><span class="line">int cso_uninit();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 结构体指针，传入传出</span><br><span class="line">int CSetPointA(Point* point, Point* point1);</span><br><span class="line"></span><br><span class="line">// 调用内部的类</span><br><span class="line">//int FooCall(void);</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>对应实现文件主要代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;dlfcn.h&gt;</span><br><span class="line"></span><br><span class="line">void* g_sohandle = NULL;</span><br><span class="line">    </span><br><span class="line">int cso_init(char* soname)</span><br><span class="line">&#123;</span><br><span class="line">    g_sohandle = dlopen(soname, RTLD_LAZY);</span><br><span class="line">    if (g_sohandle == NULL) return -1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int cso_uninit()</span><br><span class="line">&#123;</span><br><span class="line">    if (g_sohandle != NULL) dlclose(g_sohandle);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int CSetPointA(Point* point, Point* point1)</span><br><span class="line">&#123;</span><br><span class="line">    typedef int (*ptr)(Point*, Point*);</span><br><span class="line"></span><br><span class="line">    printf(&quot;in c file call so\n&quot;);</span><br><span class="line"></span><br><span class="line">    ptr fptr = (ptr)dlsym(g_sohandle, &quot;FooSetPointA&quot;);</span><br><span class="line"></span><br><span class="line">    return (*fptr)(point, point1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，CSetPointA 函数就是对接 FooSetPointA 函数的，仅做简单的封装。  </p><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><p>Golang 测试完整代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">#cgo LDFLAGS: -ldl</span><br><span class="line"></span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &quot;c_callso.h&quot;</span><br><span class="line">#include &quot;c_callso.c&quot;</span><br><span class="line">*/</span><br><span class="line">import &quot;C&quot;</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;unsafe&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    csoname = &quot;./libfoo.so1&quot;</span><br><span class="line">    //csoname = &quot;./aXi3n0fr1.rd&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func so_test() &#123;</span><br><span class="line">    fmt.Println(&quot;go c++ so test&quot;)</span><br><span class="line">    </span><br><span class="line">    soname := C.CString(csoname)</span><br><span class="line">    ret := C.cso_init(soname)</span><br><span class="line">    if ret != 0 &#123;</span><br><span class="line">        fmt.Println(&quot;cso_init failed &quot;, ret)</span><br><span class="line">        return </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    defer C.free(unsafe.Pointer(soname))</span><br><span class="line">    defer C.cso_uninit()</span><br><span class="line"></span><br><span class="line">    // C形式 结构体</span><br><span class="line">    var myPoint, myPoint1 C.Point</span><br><span class="line">    myPoint.x = 100;</span><br><span class="line">    myPoint.y = 200;</span><br><span class="line">    myPoint.pinname = C.CString(&quot;Hello &quot;) // 指针形式</span><br><span class="line"></span><br><span class="line">    defer C.free(unsafe.Pointer(myPoint.pinname))</span><br><span class="line"></span><br><span class="line">    // 固定长度数组，麻烦点</span><br><span class="line">    arr := [16]C.char&#123;&#125;</span><br><span class="line">    mystr := &quot;Hell &quot;</span><br><span class="line">    for i := 0; i &lt; len(mystr) &amp;&amp; i &lt; 15; i++ &#123;</span><br><span class="line">        arr[i] = C.char(mystr[i])</span><br><span class="line">    &#125;</span><br><span class="line">    myPoint.inname = arr // 数组形式</span><br><span class="line"></span><br><span class="line">    fmt.Println(&quot;Golang | org struct &quot;, myPoint, &quot;single: &quot;, myPoint.x, myPoint.y, myPoint.pinname)</span><br><span class="line">    </span><br><span class="line">    // 结构体指针 传入传出</span><br><span class="line">    ret = C.CSetPointA(&amp;myPoint, &amp;myPoint1)</span><br><span class="line">    </span><br><span class="line">    // 注：C++中使用字符串数组形式，转成string</span><br><span class="line">    var carr []byte</span><br><span class="line">    //carr = C.GoBytes(myPoint1.name, 100)</span><br><span class="line">    </span><br><span class="line">    for i := range myPoint1.name &#123;</span><br><span class="line">        if myPoint1.name[i] != 0 &#123;</span><br><span class="line">            carr = append(carr, byte(myPoint1.name[i]))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    gostr := string(carr) // 转成go的string</span><br><span class="line">    fmt.Println(&quot;Golang | c++ call ret: &quot;, ret, myPoint1.x, gostr, myPoint1.name)</span><br><span class="line"></span><br><span class="line">    // 注：直接用指针形式转换，此处的指针值，与在C中申请的值，是一致的</span><br><span class="line">    // 注：如果指针没有分配内存，返回string为空，用unsafe.Pointer返回&lt;nil&gt;</span><br><span class="line">    gostr = C.GoString(myPoint1.pname)</span><br><span class="line">    defer C.free(unsafe.Pointer(myPoint1.pname))</span><br><span class="line">    </span><br><span class="line">    fmt.Println(&quot;Golang | out pointer:&quot;, gostr, unsafe.Pointer(myPoint1.pname))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    so_test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与前面文章示例不同的地方，主要是调用了 C.cso_init 初始化动态库，最终调用 cso_uninit 释放。  </p><h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><p>运行时，只需要保持动态库的位置和名称与 Golang 中指定的一致即可，无须设置 LD_LIBRARY_PATH 环境变量。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">go c++ so test</span><br><span class="line">Golang | org struct  &#123;100 200 [72 101 108 108 32 0 0 0 0 0 0 0 0 0 0 0] 0xe2fc10 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] &lt;nil&gt;&#125; single:  100 200 0xe2fc10</span><br><span class="line">in c file call so</span><br><span class="line">C++ | got buf: Hell </span><br><span class="line">C++ | pname: Hello </span><br><span class="line">C++ | ptr: 0xe2fc30</span><br><span class="line">Golang | c++ call ret:  0 101 name in c++ [110 97 109 101 32 105 110 32 99 43 43 0 0 0 0 0]</span><br><span class="line">Golang | out pointer: Hell  | name in c++ malloc 0xe2fc30</span><br></pre></td></tr></table></figure><h2 id="实践总结"><a href="#实践总结" class="headerlink" title="实践总结"></a>实践总结</h2><p>动态库初始化函数<code>cso_init</code>等保留，动态库对外提供的业务接口，尽量少，这样减少 golang 和 C++ 之间的代码接口数量。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文的方法，却增加了源码级别的复杂度，不一定都符合要求，因此仅作参考。<br>Linux 的动态库，其名称一般为 <code>libXXX.so</code>，但经测试，任意名称也是可以的。    </p><p>李迟 2021.5.2 </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;趁着五一放假，趁着有时间，把欠的一些技术集中研究研究，写写文章，好给自己一个交待。&lt;br&gt;本文继续介绍如何在 Golang 中调用 C++ 函数。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：调用C++函数</title>
    <link href="http://www.latelee.org/golang/golang-notes-call-cpulsplus-function.html"/>
    <id>http://www.latelee.org/golang/golang-notes-call-cpulsplus-function.html</id>
    <published>2021-05-01T16:00:00.000Z</published>
    <updated>2021-06-04T02:18:55.834Z</updated>
    
    <content type="html"><![CDATA[<p>趁着五一放假，趁着有时间，把欠的一些技术集中研究研究，写写文章，好给自己一个交待。<br>本文介绍如何在 Golang 中调用 C++ 函数。  </p><span id="more"></span><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>因工作需求，需要将一个工具由终端行的运行方式迁移到 web 上，核心代码由 c++ 动态库实现，另一部门的同事使用 Java 实现了一个版本，部门同事安排我做部署，由于服务器是离线的，且由专人管理，JDK 和 Tomcat 安装稍麻烦，个人操作自由度不够，——一是没有研究过 Java，二来部署麻烦。因此，决定使用 Golang 实现。预计展开的内容有：Golang 调用 C++ 动态库；Golang Web 服务及整合 html/css资源；(大)前端框架使用。  </p><p>本文主要研究 C++ 动态库及函数的调用。  </p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>Golang 只支持 C 语言的编译，对于 C++ 的编译，有2种方法：<br>1、不使用类，在 C++ 代码头文件添加<code>extern &quot;C&quot; &#123;</code>，将函数声明为 C 格式。<br>2、如出现类的情况，再用另外的文件将其封装成 C 格式函数。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="C-C-代码"><a href="#C-C-代码" class="headerlink" title="C/C++代码"></a>C/C++代码</h3><p>没有类的文件，但后缀名为cpp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// bar.h文件：</span><br><span class="line">#ifndef BAR_H</span><br><span class="line">#define BAR_H</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">int bar();</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">// bar.cpp文件：</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;bar.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int bar()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;C | hell bar\n&quot;);</span><br><span class="line">    </span><br><span class="line">    #ifdef MACRO_TEST</span><br><span class="line">    printf(&quot;C | macro...\n&quot;);</span><br><span class="line">    #endif</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有类的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// foo.h for class</span><br><span class="line"></span><br><span class="line">#ifndef FOO_H</span><br><span class="line">#define FOO_H</span><br><span class="line"></span><br><span class="line">class CFoo</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CFoo(int value): m_value(value)&#123;&#125;;</span><br><span class="line">    ~CFoo()&#123;&#125;;</span><br><span class="line">    void Bar();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int m_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">// foo.cpp</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;foo.h&quot;</span><br><span class="line"></span><br><span class="line">void CFoo::Bar(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;C++ Class | %s(): num: %d\n&quot;, __func__, m_value);</span><br><span class="line">  //std::cout&lt;&lt;this-&gt;a&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>封装代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">// foo.h</span><br><span class="line">#ifndef OUT_H</span><br><span class="line">#define OUT_H</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">typedef  struct Point&#123;</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">    char inname[16]; // 传入buff</span><br><span class="line">    char* pinname; // 传入指针</span><br><span class="line">    char name[16]; // 传出buff</span><br><span class="line">    char* pname; // 传出指针</span><br><span class="line">&#125;Point;</span><br><span class="line"></span><br><span class="line">// 普通类型赋值</span><br><span class="line">int FooSetValue(int a, unsigned int b, float c, char* str);</span><br><span class="line"></span><br><span class="line">void PrintString(char* str);</span><br><span class="line"></span><br><span class="line">// 结构体</span><br><span class="line">int FooSetPointC(Point point);</span><br><span class="line">// 结构体指针</span><br><span class="line">int FooSetPoint(Point* point);</span><br><span class="line">// 结构体指针，传入传出</span><br><span class="line">int FooSetPointA(Point* point, Point* point1);</span><br><span class="line"></span><br><span class="line">// 调用内部的类</span><br><span class="line">int FooCall(int num);</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">// out.cpp</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;out.h&quot;</span><br><span class="line">#include &quot;foo.h&quot;</span><br><span class="line"></span><br><span class="line">int FooSetValue(int a, unsigned int b, float c, char* str)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;C++ | base type: %d %d %.4f %s\n&quot;, a, b, c, str);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">void PrintString(char* str)</span><br><span class="line">&#123;</span><br><span class="line">trueprintf(&quot;C++ | string = %s\n&quot;, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int FooSetPointC(Point point)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;C++ | the point in c for value: %d %d \n&quot;,  point.x, point.y);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int FooSetPoint(Point* point)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;C++ | the point in c: %d %d \n&quot;,  point-&gt;x, point-&gt;y);</span><br><span class="line">    </span><br><span class="line">    point-&gt;x = 250;</span><br><span class="line">    point-&gt;y = 500;</span><br><span class="line">    strcpy(point-&gt;name, &quot;name in c++&quot;);</span><br><span class="line">    return 24;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int FooSetPointA(Point* point, Point* point1)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;C++ | got buf: %s\n&quot;, point-&gt;inname);</span><br><span class="line"></span><br><span class="line">    if (point-&gt;pinname != NULL) printf(&quot;C++ | pname: %s\n&quot;, point-&gt;pinname);</span><br><span class="line"></span><br><span class="line">    point1-&gt;x = point-&gt;x+1;</span><br><span class="line">    point1-&gt;y = point-&gt;y+1;</span><br><span class="line">    strcpy(point1-&gt;name, &quot;name in c++&quot;);</span><br><span class="line">    </span><br><span class="line">    point1-&gt;pname = new char[16];</span><br><span class="line">    sprintf(point1-&gt;pname, &quot;%s | name in c++ malloc&quot;, point-&gt;inname);</span><br><span class="line">    //strcpy(point1-&gt;pname, &quot;name in c++ malloc &quot;);</span><br><span class="line">    printf(&quot;C++ | ptr: %p\n&quot;, point1-&gt;pname);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int FooCall(int num)</span><br><span class="line">&#123;</span><br><span class="line">    CFoo * ret = new CFoo(num);</span><br><span class="line">    ret-&gt;Bar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用 Makefile 将上面文件编译为 libfoo.so 动态库。  </p><h3 id="动态库调用"><a href="#动态库调用" class="headerlink" title="动态库调用"></a>动态库调用</h3><p>完整测试代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">#cgo CFLAGS: -I.</span><br><span class="line">#cgo LDFLAGS: -L. -lfoo</span><br><span class="line"></span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;out.h&quot;</span><br><span class="line">*/</span><br><span class="line">import &quot;C&quot;</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;unsafe&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func so_test() &#123;</span><br><span class="line">    fmt.Println(&quot;go c++ so test&quot;)</span><br><span class="line"></span><br><span class="line">    // 简单函数调用</span><br><span class="line">    cstr := C.CString(&quot;call C func&quot;)</span><br><span class="line">    defer C.free(unsafe.Pointer(cstr))</span><br><span class="line">    var i C.int</span><br><span class="line">    i = 100</span><br><span class="line">    C.FooSetValue(i, C.uint(250), C.float(3.14159), cstr)</span><br><span class="line">    C.PrintString(cstr);</span><br><span class="line"></span><br><span class="line">    // C形式 结构体</span><br><span class="line">    var myPoint, myPoint1 C.Point</span><br><span class="line">    myPoint.x = 100;</span><br><span class="line">    myPoint.y = 200;</span><br><span class="line">    myPoint.pinname = C.CString(&quot;Hello &quot;) // 指针形式</span><br><span class="line"></span><br><span class="line">    defer C.free(unsafe.Pointer(myPoint.pinname))</span><br><span class="line"></span><br><span class="line">    // 固定长度数组，麻烦点</span><br><span class="line">    arr := [16]C.char&#123;&#125;</span><br><span class="line">    mystr := &quot;Hell &quot;</span><br><span class="line">    for i := 0; i &lt; len(mystr) &amp;&amp; i &lt; 15; i++ &#123;</span><br><span class="line">        arr[i] = C.char(mystr[i])</span><br><span class="line">    &#125;</span><br><span class="line">    myPoint.inname = arr // 数组形式</span><br><span class="line"></span><br><span class="line">    fmt.Println(&quot;Golang | org struct &quot;, myPoint, &quot;single: &quot;, myPoint.x, myPoint.y, myPoint.pinname)</span><br><span class="line">    </span><br><span class="line">    // 结构体传值</span><br><span class="line">    C.FooSetPointC(myPoint)</span><br><span class="line">    </span><br><span class="line">    // 结构体指针 传入传出</span><br><span class="line">    ret := C.FooSetPointA(&amp;myPoint, &amp;myPoint1)</span><br><span class="line">    </span><br><span class="line">    // 注：C++中使用字符串数组形式，转成string</span><br><span class="line">    var carr []byte</span><br><span class="line">    //carr = C.GoBytes(myPoint1.name, 16)</span><br><span class="line">    </span><br><span class="line">    for i := range myPoint1.name &#123;</span><br><span class="line">        if myPoint1.name[i] != 0 &#123;</span><br><span class="line">            carr = append(carr, byte(myPoint1.name[i]))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    gostr := string(carr) // 转成go的string</span><br><span class="line">    fmt.Println(&quot;Golang | c++ call ret: &quot;, ret, myPoint1.x, gostr, myPoint1.name)</span><br><span class="line"></span><br><span class="line">    // 注：直接用指针形式转换，此处的指针值，与在C中申请的值，是一致的</span><br><span class="line">    // 注：如果指针没有分配内存，返回string为空，用unsafe.Pointer返回&lt;nil&gt;</span><br><span class="line">    gostr = C.GoString(myPoint1.pname)</span><br><span class="line">    defer C.free(unsafe.Pointer(myPoint1.pname))</span><br><span class="line">    </span><br><span class="line">    fmt.Println(&quot;Golang | out pointer:&quot;, gostr, unsafe.Pointer(myPoint1.pname))</span><br><span class="line"></span><br><span class="line">    C.FooCall(250)</span><br><span class="line">    C.FooCall(C.int(250))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    so_test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码要点如下：<br>1、需设置编译参数 LDFLAGS，指定库位置和名称，本例中是当前目录的 libfoo.so。<br>2、需包含相应的头文件，stdlib.h 为 free 函数所在文件。<br>3、内嵌的 C 源码在包的前面，且<code>import &quot;C&quot;</code>后需空一行。<br>4、传递到 C 函数的内存，使用<code>C.CString</code>申请，C 申请的内存使用<code>C.GoString</code>获取，均需要手动释放。  </p><h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><p>在运行前，需要设置动态库路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$PWD</span><br></pre></td></tr></table></figure><p>否则运行时无法找到动态库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test: error while loading shared libraries: libfoo.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">go c++ so test</span><br><span class="line">C++ | base type: 100 250 3.1416 call C func</span><br><span class="line">C++ | string = call C func</span><br><span class="line">Golang | org struct  &#123;100 200 [72 101 108 108 32 0 0 0 0 0 0 0 0 0 0 0] 0x25b2a30 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] &lt;nil&gt;&#125; single:  100 200 0x25b2a30</span><br><span class="line">C++ | the point in c for value: 100 200 </span><br><span class="line">C++ | got buf: Hell </span><br><span class="line">C++ | pname: Hello </span><br><span class="line">C++ | ptr: 0x25b2a50</span><br><span class="line">Golang | c++ call ret:  0 101 name in c++ [110 97 109 101 32 105 110 32 99 43 43 0 0 0 0 0]</span><br><span class="line">Golang | out pointer: Hell  | name in c++ malloc 0x25b2a50</span><br><span class="line">C++ Class | Bar(): num: 250</span><br><span class="line">C++ Class | Bar(): num: 250</span><br></pre></td></tr></table></figure><p>从上述结果中可看出，C 中申请的内存，其指针与在 Go 中获取的指针是一样的，即 0x25b2a50。结构体中的 nil 是因为字段 pname 未赋值。  </p><h3 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h3><p>前面的动态库代码，不能全部内嵌到 Go 代码中，因此选取其中的 bar.h/cpp，测试代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">#cgo CFLAGS: -I. -DMACRO_TEST</span><br><span class="line"></span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;bar.h&quot;</span><br><span class="line">#include &quot;bar.cpp&quot;</span><br><span class="line">*/</span><br><span class="line">import &quot;C&quot;</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;  </span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func cpp_test() &#123;</span><br><span class="line">    fmt.Println(&quot;go c++ so test&quot;)</span><br><span class="line">    C.bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    cpp_test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码要点：<br>1、可用 CFLAGS 指定头文件，添加宏定义等。<br>2、将所有的 C 源码包含到代码中。（存疑：似乎应该是头文件，在编译过程中自动找对应的实现文件，这里包含进来，相当于所有源码都在 Go 代码中）  </p><h3 id="结果分析-1"><a href="#结果分析-1" class="headerlink" title="结果分析"></a>结果分析</h3><p>运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go c++ so test</span><br><span class="line">C | hell bar</span><br><span class="line">C | macro...</span><br></pre></td></tr></table></figure><p>使用此方法，如果修改 C 代码，还需更新包含 C 代码的 go 文件，否则不会被编译。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面对2种形式的调用进行了实践，在功能和使用上各有千秋，对于简单的 C 语言代码（包含C++形式的简单函数），直接使用内嵌的形式会更高效。<br>本文使用的动态库例子，在运行前还需要设置运行路径，当然可以将动态库放到系统目录的，但笔者认为不是正道，下面将去掉动态库路径的依赖。  </p><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>Go 编译时，如果包含有类的文件，编译失败，出错信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">In file included from ./bar.cpp:2:0,</span><br><span class="line">                 from ./main_one.go:17:</span><br><span class="line">./foo.h:6:1: error: unknown type name &#x27;class&#x27;</span><br><span class="line"> class CFoo</span><br><span class="line"> ^</span><br><span class="line">./foo.h:7:1: error: expected &#x27;=&#x27;, &#x27;,&#x27;, &#x27;;&#x27;, &#x27;asm&#x27; or &#x27;__attribute__&#x27; before &#x27;&#123;&#x27; token</span><br><span class="line"> &#123;</span><br><span class="line"> ^</span><br><span class="line">In file included from ./main_one.go:17:0:</span><br><span class="line">./bar.cpp: In function &#x27;FooCall1&#x27;:</span><br><span class="line">./bar.cpp:18:5: error: unknown type name &#x27;CFoo&#x27;</span><br><span class="line">     CFoo * ret = new CFoo(num);</span><br><span class="line">     ^</span><br><span class="line">./bar.cpp:18:18: error: &#x27;new&#x27; undeclared (first use in this function)</span><br><span class="line">     CFoo * ret = new CFoo(num);</span><br><span class="line">                  ^</span><br><span class="line">./bar.cpp:18:18: note: each undeclared identifier is reported only once for each function it appears in</span><br><span class="line">./bar.cpp:18:22: error: expected &#x27;,&#x27; or &#x27;;&#x27; before &#x27;CFoo&#x27;</span><br><span class="line">     CFoo * ret = new CFoo(num);</span><br><span class="line">                      ^</span><br><span class="line">./bar.cpp:19:8: error: request for member &#x27;Bar&#x27; in something not a structure or union</span><br><span class="line">     ret-&gt;Bar();</span><br></pre></td></tr></table></figure><p>李迟 2021.5.2 </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;趁着五一放假，趁着有时间，把欠的一些技术集中研究研究，写写文章，好给自己一个交待。&lt;br&gt;本文介绍如何在 Golang 中调用 C++ 函数。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：生成版本号和编译时间</title>
    <link href="http://www.latelee.org/golang/golang-notes-generate-version-time.html"/>
    <id>http://www.latelee.org/golang/golang-notes-generate-version-time.html</id>
    <published>2021-04-30T16:00:00.000Z</published>
    <updated>2021-06-04T02:18:55.834Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍如何在 Golang 中生成和管理版本号及编译时间。  </p><span id="more"></span><h2 id="一、起因"><a href="#一、起因" class="headerlink" title="一、起因"></a>一、起因</h2><p>笔者手上有几份祖传代码，最早一份90年代末写，次早是 2012 年写的，最新的代码，也是 2016 年写的，版本号倒有，但没有版本管理，虽然看得头大，但也得看。笔者写的程序一般会添加版本号和编译日期时间，也会加上版本控制，以方便追溯和维护。对于 C/C++ 语言，有<code>__DATE__</code>和<code>__TIME_</code>这两个宏定义，但 Golang 没有，因此加版本号还是额外研究。  </p><h2 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h2><p>本文提供2个方法。一是通过编译时加的 ldflags 参数，对变量进行赋赋值；二是通过内嵌 C 语言函数实现。后者可以使用<code>__DATE__</code>和<code>__TIME_</code>，为了统一，均在脚本中生成日期日期，版本号亦在脚本中指定，因为在脚本中定制方便一些。  </p><h2 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h2><h3 id="方法1：Golang变量"><a href="#方法1：Golang变量" class="headerlink" title="方法1：Golang变量"></a>方法1：Golang变量</h3><p>准备：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Version=&quot;v1.0&quot;</span><br><span class="line">BuildTime=`date +&#x27;%Y-%m-%d %H:%M:%S&#x27;`</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">trueBuildTime string</span><br><span class="line">trueVersion string</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func getVersion1() string &#123;</span><br><span class="line">truereturn fmt.Sprintf(&quot;  %v build: %v\n&quot;, Version, BuildTime)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GO111MODULE=on go build -ldflags &quot;-X &#x27;dbtool/cmd.BuildTime=$&#123;BuildTime&#125;&#x27; -X &#x27;dbtool/cmd.Version=$&#123;Version&#125;&#x27;&quot; -mod vendor -o dbtool.exe main.go || exit 1</span><br></pre></td></tr></table></figure><h3 id="方法2：调用C函数"><a href="#方法2：调用C函数" class="headerlink" title="方法2：调用C函数"></a>方法2：调用C函数</h3><p>准备：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Version=&quot;v1.0&quot;</span><br><span class="line">BuildTime=`date +&#x27;%Y-%m-%d %H:%M:%S&#x27;`</span><br><span class="line"></span><br><span class="line">GIT_VERSION=$Version&quot; build: &quot;$BuildTime</span><br><span class="line"></span><br><span class="line">echo &quot;Generated&quot; $VER_FILE &quot;for version:&quot; $GIT_VERSION</span><br><span class="line"></span><br><span class="line">echo &quot;#ifndef PROJECT_VERSION_H&quot; &gt; $VER_FILE</span><br><span class="line">echo &quot;#define PROJECT_VERSION_H&quot; &gt;&gt; $VER_FILE</span><br><span class="line">echo &quot;&quot; &gt;&gt; $VER_FILE</span><br><span class="line">echo &quot;#define VERSION_NUMBER \&quot;$GIT_VERSION\&quot;&quot; &gt;&gt; $VER_FILE</span><br><span class="line">echo &quot;&quot; &gt;&gt; $VER_FILE</span><br><span class="line">echo &quot;#endif&quot; &gt;&gt; $VER_FILE</span><br><span class="line"></span><br><span class="line">echo &quot;Job done!!&quot;</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;version.h&quot;</span><br><span class="line"></span><br><span class="line">char* GetVersion()</span><br><span class="line">&#123;</span><br><span class="line">    static char buffer[64] = &#123;0&#125;;</span><br><span class="line">    </span><br><span class="line">    // 代码中指定版本信息</span><br><span class="line">    snprintf(buffer, 64, &quot; %s build: %s %s\r\n&quot;, &quot;v1.0&quot;, __DATE__, __TIME__);</span><br><span class="line">    // 由脚本生成到文件</span><br><span class="line">    //snprintf(buffer, 64, &quot; %s\r\n&quot;, VERSION_NUMBER);</span><br><span class="line">    </span><br><span class="line">    return buffer;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">import &quot;C&quot;</span><br><span class="line"></span><br><span class="line">// 注：以上代码必须放到 Goalng 正式语句之前，且import &quot;C&quot;后必须空一行</span><br><span class="line"></span><br><span class="line">func getVersion() string &#123;</span><br><span class="line">    name1 := C.GetVersion()</span><br><span class="line">    name := C.GoString(name1)</span><br><span class="line">truereturn fmt.Sprintf(&quot; %v&quot;, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GO111MODULE=on go build -mod vendor -o dbtool.exe main.go || exit 1</span><br></pre></td></tr></table></figure><h2 id="四、测试"><a href="#四、测试" class="headerlink" title="四、测试"></a>四、测试</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./dbtool.exe --version</span><br><span class="line">dbtool.exe version   v1.0 build: 2021-04-04 22:42:07</span><br></pre></td></tr></table></figure><p>BuildTime 使用 date 命令生成日期，可用默认的形式，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./dbtool.exe --version</span><br><span class="line">dbtool.exe version   v1.0 build: Apr  4 2021 22:47:20</span><br></pre></td></tr></table></figure><h2 id="五、维护"><a href="#五、维护" class="headerlink" title="五、维护"></a>五、维护</h2><p>需在编译脚本中修改版本号，可手动修改，也可根据 SVN 或 GIT 版本迭代自动生成（散见于笔者多年前的文章）。</p><h2 id="六、源码仓库"><a href="#六、源码仓库" class="headerlink" title="六、源码仓库"></a>六、源码仓库</h2><p><a href="https://github.com/latelee/cmdtool">https://github.com/latelee/cmdtool</a>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍如何在 Golang 中生成和管理版本号及编译时间。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>vuepress实践录：初步入门</title>
    <link href="http://www.latelee.org/vue/vuepress-learning1.html"/>
    <id>http://www.latelee.org/vue/vuepress-learning1.html</id>
    <published>2021-04-29T16:00:00.000Z</published>
    <updated>2021-06-04T02:18:55.838Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="初试"><a href="#初试" class="headerlink" title="初试"></a>初试</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>安装 yarn，并添加国内源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yarn</span><br><span class="line"></span><br><span class="line">yarn config set registry &quot;https://registry.npm.taobao.org&quot;</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>创建并进入一个新目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir vuepress-starter &amp;&amp; cd vuepress-starter</span><br></pre></td></tr></table></figure><p>初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn init</span><br></pre></td></tr></table></figure><p>注：在 Windows 下用 cmd 执行。用 git bash 会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error An unexpected error occurred: &quot;Can&#x27;t answer a question unless a user TTY&quot;.</span><br></pre></td></tr></table></figure><p>生成如下 package.json</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;vuepress-starter&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;MIT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：可以只使用 cmd 生成 json 文件，或手动写 json 文件。再用回 git bash。  </p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>（官方当前推荐）本地安装 vuepress：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D vuepress</span><br></pre></td></tr></table></figure><p>会生成 node_modules目录（通过 yarn 安装的插件、主题等在此目录）。  </p><p>创建一篇文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir docs &amp;&amp; echo &#x27;# Hello VuePress&#x27; &gt; docs/README.md</span><br></pre></td></tr></table></figure><p>在 package.json 中添加 scripts，以便执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;vuepress dev docs&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;vuepress build docs&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>启动服务器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn dev</span><br></pre></td></tr></table></figure><p>即可用浏览器访问本地 8080 端口，观看效果。  </p><p>如需构建静态页面，执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn build</span><br></pre></td></tr></table></figure><p>注：构建后在 docs 下有 .vuepress/dist目录，dist 即为静态网站文件所在目录。将其放到其它 web 服务器的资源目录中，即为网站。  </p><p>**注意：官方使用 docs 目录作为工程目录，为了不让目录过深，也可以不使用，此时<code>vuepress dev docs</code>改为<code>vuepress dev</code>即可。  </p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>创建目录和文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p docs/.vuepress docs/.vuepress/public</span><br><span class="line">touch .vuepress/config.js</span><br></pre></td></tr></table></figure><p>注：.vuepress 目录为 vuepress 的配置根目录。所有的配置文件均在其下。public 为公共访问目录，可存放 icon、logo等资源，config.js 是配置文件，非常重要。  </p><p>修改 docs/README.md 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">home: true</span><br><span class="line">heroImage: /hero.png</span><br><span class="line">heroText: Hero 标题</span><br><span class="line">tagline: Hero 副标题</span><br><span class="line">actionText: 快速上手 →</span><br><span class="line">actionLink: /zh/guide/</span><br><span class="line">features:</span><br><span class="line">- title: 简洁至上</span><br><span class="line">  details: 以 Markdown 为中心的项目结构，以最少的配置帮助你专注于写作。</span><br><span class="line">- title: Vue驱动</span><br><span class="line">  details: 享受 Vue + webpack 的开发体验，在 Markdown 中使用 Vue 组件，同时可以使用 Vue 来开发自定义主题。</span><br><span class="line">- title: 高性能</span><br><span class="line">  details: VuePress 为每个页面预渲染生成静态的 HTML，同时在页面被加载的时候，将作为 SPA 运行。</span><br><span class="line">footer: MIT Licensed | Copyright © 2018-present Evan You</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">下面是常规 markdown 文件。</span><br><span class="line"># Hello VuePress theme!</span><br><span class="line">这是中文示例。  </span><br><span class="line">上面这句最后空了2个空格，预期效果应为换行。  </span><br><span class="line"></span><br><span class="line">上上面这句后多了一个窄，预期效果应该是空了一行。  </span><br><span class="line"></span><br><span class="line">## 这是二级header</span><br><span class="line"></span><br><span class="line">### This is 三级标题</span><br></pre></td></tr></table></figure><p>config.js 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  title: &#x27;大锤与大妞&#x27;, // 设置网站标题</span><br><span class="line">  description: &#x27;大锤与大妞的网站&#x27;,</span><br><span class="line">  head: [</span><br><span class="line">      [&#x27;link&#x27;, &#123; rel: &#x27;icon&#x27;, href: &#x27;/favicon.ico&#x27; &#125;], // favicon.ico在public目录</span><br><span class="line">  ],</span><br><span class="line">  // markdown 的配置</span><br><span class="line">  markdown: &#123;</span><br><span class="line">      lineNumbers: false // 代码块显示行号</span><br><span class="line">  &#125;,</span><br><span class="line">  themeConfig: &#123;</span><br><span class="line">    logo: &#x27;/logo.png&#x27;,</span><br><span class="line">    // repo: &#x27;https://github.com/latelee&#x27;, // 不使用</span><br><span class="line">    sidebar: &#x27;auto&#x27;,</span><br><span class="line">    sidebarDepth: 2,</span><br><span class="line">    activeHeaderLinks: false, // 默认值：true 禁用活动的标题链接</span><br><span class="line">    // 默认值是 true 。设置为 false 来禁用所有页面的 下一篇 链接</span><br><span class="line">    nextLinks: true,</span><br><span class="line">    // 默认值是 true 。设置为 false 来禁用所有页面的 上一篇 链接</span><br><span class="line">    prevLinks: true,</span><br><span class="line">    smoothScroll: true,</span><br><span class="line">    nav: [</span><br><span class="line">      &#123; text: &#x27;Home&#x27;, link: &#x27;/&#x27; &#125;,</span><br><span class="line">      &#123; text: &#x27;Guide&#x27;, link: &#x27;/guide/&#x27; &#125;,</span><br><span class="line">      &#123; text: &#x27;External&#x27;, link: &#x27;https://google.com&#x27; &#125;,</span><br><span class="line">      // 子导航条</span><br><span class="line">      &#123;</span><br><span class="line">        text: &#x27;Languages&#x27;,</span><br><span class="line">        ariaLabel: &#x27;Language Menu&#x27;,</span><br><span class="line">        items: [</span><br><span class="line">          &#123; text: &#x27;Chinese&#x27;, link: &#x27;/language/chinese/&#x27; &#125;,</span><br><span class="line">          &#123; text: &#x27;Japanese&#x27;, link: &#x27;/language/japanese/&#x27; &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      // 子导航条的分组</span><br><span class="line">      &#123;</span><br><span class="line">        text: &#x27;Languages&#x27;,</span><br><span class="line">        items: [</span><br><span class="line">          &#123; text: &#x27;Group1&#x27;, items: [</span><br><span class="line">            &#123; text: &#x27;Chinese1&#x27;, link: &#x27;/language/chinese/&#x27; &#125;,</span><br><span class="line">            &#123; text: &#x27;Japanese1&#x27;, link: &#x27;/language/japanese/&#x27; &#125;</span><br><span class="line">            ] &#125;,</span><br><span class="line">          &#123; text: &#x27;Group2&#x27;, items: [</span><br><span class="line">            &#123; text: &#x27;Chinese2&#x27;, link: &#x27;/language/chinese/&#x27; &#125;,</span><br><span class="line">            &#123; text: &#x27;Japanese2&#x27;, link: &#x27;/language/japanese/&#x27; &#125;</span><br><span class="line">            ] &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：favicon.ico、logo.png、hero.png等在 public 目录。  </p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>获取默认主题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn vuepress eject</span><br></pre></td></tr></table></figure><p>在当前目录的 .vuepress 有 theme 目录，其下即为默认主题所有文件。<br>将 theme 目录放到 <code>docs/.vuepress</code> 目录下。  </p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>文章加密插件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D @oak-tree-house/vuepress-plugin-encrypt</span><br></pre></td></tr></table></figure><p>参考：<br><a href="https://www.imaegoo.com/2020/vuepress-encrypt/">https://www.imaegoo.com/2020/vuepress-encrypt/</a> <a href="https://szp15.com/2020/02/04/plugin-encrypt-doc/">https://szp15.com/2020/02/04/plugin-encrypt-doc/</a><br>还不成功</p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>路径路由默认使用目录的 README.md 文件。<br>markdown 有扩展功能。<br>vuepress 大部分文件都支持热更新，但有的配置可能不会，如 config.js，需要重启服务。当修改 markdown 文档时，浏览器会自动刷新。<br>主题可继承，从默认主题继承。<br>执行<code>vuepress</code>无命令，使用<code>yarn vuepress</code>代替。  </p><p>markdown 小记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">站内跳转，/表示从根目录开始</span><br><span class="line">[XXX](/doc/foo/XXX.md) </span><br><span class="line">插入当前目录的图片，默认情况下路径和图片名称不能有中文</span><br><span class="line">![XXX](./01.png) </span><br></pre></td></tr></table></figure><p>内嵌 vue 代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 循环，输出1 2 3</span><br><span class="line">&lt;span v-for=&quot;i in 3&quot;&gt;&#123;&#123; i &#125;&#125; &lt;/span&gt;</span><br></pre></td></tr></table></figure><h2 id="问题及解决"><a href="#问题及解决" class="headerlink" title="问题及解决"></a>问题及解决</h2><p>支持中文名称图片。<br>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add markdown-it-disable-url-encode</span><br></pre></td></tr></table></figure><p>在<code>.vuepress/config.js</code>添加：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// .....</span></span><br><span class="line">  <span class="attr">markdown</span>: &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="attr">extendMarkdown</span>: <span class="function"><span class="params">md</span> =&gt;</span> &#123;</span><br><span class="line">      md.use(<span class="built_in">require</span>(<span class="string">&quot;markdown-it-disable-url-encode&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="另一个主题的安装"><a href="#另一个主题的安装" class="headerlink" title="另一个主题的安装"></a>另一个主题的安装</h2><p>下载新版本node <a href="http://npm.taobao.org/mirrors/node/v16.2.0/%EF%BC%8C%E5%8F%8C%E5%87%BB%E5%AE%89%E8%A3%85%E4%B9%8B%E3%80%82">http://npm.taobao.org/mirrors/node/v16.2.0/，双击安装之。</a></p><p>在某目录执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn create vuepress-theme-hope vue-hope</span><br></pre></td></tr></table></figure><p>一路回车即可。进入<code>vue-hope</code>目录，执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn install</span><br></pre></td></tr></table></figure><p>注：该主题依赖的node版本必须高于13.7。  修改后的package.json：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;vuepress-theme-hope-project&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;A project of vuepress-theme-hope&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;MIT&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;vuepress build&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;clean-dev&quot;</span>: <span class="string">&quot;vuepress dev --no-cache&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;vuepress dev&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;eject-theme&quot;</span>: <span class="string">&quot;vuepress eject-hope&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;vuepress&quot;</span>: <span class="string">&quot;^1.8.2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;vuepress-theme-hope&quot;</span>: <span class="string">&quot;^1.17.2&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">启动服务：</span><br><span class="line">yarn run dev</span><br><span class="line">生成网页：</span><br><span class="line">yarn run build</span><br><span class="line">导出主题（在.vuepress下）：</span><br><span class="line">yarn run eject-theme</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考：<a href="https://vuepress-theme-hope.github.io/zh/guide/">https://vuepress-theme-hope.github.io/zh/guide/</a></p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>参考：<br>快速上手：<a href="https://vuepress.vuejs.org/zh/guide/">https://vuepress.vuejs.org/zh/guide/</a><br>主题：<a href="https://vuepress.vuejs.org/zh/theme/">https://vuepress.vuejs.org/zh/theme/</a><br>资源（主题、插件）：<a href="https://github.com/vuepress/awesome-vuepress">https://github.com/vuepress/awesome-vuepress</a><br>默认主题：<a href="https://github.com/vuejs/vuepress">https://github.com/vuejs/vuepress</a> 仓库 <code>packages/@vuepress</code> 目录<br>主题：<br><a href="https://github.com/xuzhongpeng/vuepress-theme-reform">https://github.com/xuzhongpeng/vuepress-theme-reform</a><br><a href="https://github.com/vuepress-reco/vuepress-theme-reco">https://github.com/vuepress-reco/vuepress-theme-reco</a><br><a href="https://github.com/xugaoyi/vuepress-theme-vdoing">https://github.com/xugaoyi/vuepress-theme-vdoing</a>  </p><p>查看 markdown 中支持语法的语言名称：<a href="https://prismjs.com/#languages-list">https://prismjs.com/#languages-list</a>  </p><p>李迟 2021.4.30</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;初试&quot;&gt;&lt;a href=&quot;#初试&quot; class=&quot;headerlink&quot; title=&quot;初试&quot;&gt;&lt;/a&gt;初试&lt;/h2&gt;&lt;h3 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="vue" scheme="http://www.latelee.org/category/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>李迟2021年4月知识总结</title>
    <link href="http://www.latelee.org/my-library/code-for-2021-04.html"/>
    <id>http://www.latelee.org/my-library/code-for-2021-04.html</id>
    <published>2021-04-29T16:00:00.000Z</published>
    <updated>2021-06-04T02:18:55.914Z</updated>
    
    <content type="html"><![CDATA[<p>前言：<br>上一篇类似的文章，是2011年的3月份，看了下当时写的内容，除了代码外，还有其它思考，但后面越来越少了，年纪大了，想的东西少，也没什么好写了，现在重拾起来，觉得十分有必要，可以将每个月的实践、思考记录下来，否则一年过去了，似乎什么也没有学到。  </p><span id="more"></span><h2 id="编码总结"><a href="#编码总结" class="headerlink" title="编码总结"></a>编码总结</h2><h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><p>研究了如何将一些资源文件整合到二进制可执行文件中，后续将系统发文。  </p><h3 id="Nodejs"><a href="#Nodejs" class="headerlink" title="Nodejs"></a>Nodejs</h3><p>excel解析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var xlsx = require(&#x27;node-xlsx&#x27;);</span><br><span class="line"></span><br><span class="line">    var obj = xlsx.parse(&quot;foo.xlsx&quot;); // 支持xls</span><br><span class="line">    var excelObj=obj[0].data; // 0表示第1张表，1为第2张表</span><br><span class="line">    console.log(excelObj) // 根据规则遍历解析，如只有3列，某列为空，某列名称，等</span><br></pre></td></tr></table></figure><p>其它代码片段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 去掉空格、tab、回车换行等</span><br><span class="line">function trim(s)&#123;</span><br><span class="line">    //return s.replace(/(^\s*)|(\s*$)/g, &quot;&quot;);</span><br><span class="line">    return s.replace(/(^\s*)|(\s*$)|([\t\r\n])/g, &quot;&quot;); // |(\ +)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 截取前2字符</span><br><span class="line">gxcode = code.substring(0, 2)</span><br><span class="line">// 截取前4位、第4位后的字符串</span><br><span class="line">code_1 = code.substring(0, 4)</span><br><span class="line">code_2 = code.substring(4)</span><br><span class="line">code_2.trim() // string自带的的去掉前后空格</span><br><span class="line"></span><br><span class="line">多维数组</span><br><span class="line">var outdata = []; // 形式1</span><br><span class="line">var tmpdata = new Array();  // 形式2</span><br><span class="line">tmpdata.code = code</span><br><span class="line">tmpdata.name = district_name</span><br><span class="line"></span><br><span class="line">outdata.push(tmpdata)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用高德地图API获取地点信息（行政区、经纬度、编码等）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">const superagent = require(&quot;superagent&quot;);</span><br><span class="line"></span><br><span class="line">// nameArray地名数组</span><br><span class="line">function getLocationFromWeb(nameArray)</span><br><span class="line">&#123;</span><br><span class="line">    newname = changeName(nameArray) // 如有多个地名，则添加|</span><br><span class="line">    var needbatch=&quot;&quot;</span><br><span class="line">    if (newname.indexOf(&quot;|&quot;) != -1)</span><br><span class="line">    &#123;</span><br><span class="line">        needbatch = &quot;batch=true&amp;&quot; // 高德API一次最多10个地名，batch为true</span><br><span class="line">    &#125;</span><br><span class="line">    var getstr = &quot;https://restapi.amap.com/v3/geocode/geo?address=&quot;</span><br><span class="line">    getstr += newname + &quot;&amp;&quot;</span><br><span class="line">    getstr += needbatch</span><br><span class="line">    getstr += &quot;key=mykey&quot; // mykey为申请的key</span><br><span class="line">    // console.log(&quot;getting : &quot;, newname)</span><br><span class="line"></span><br><span class="line">    // 包含有中文，转义</span><br><span class="line">    var target = encodeURI(getstr)</span><br><span class="line">    // console.log(target)</span><br><span class="line">    let userAgent = userAgents[parseInt(Math.random() * userAgents.length)];</span><br><span class="line">    superagent</span><br><span class="line">    .get(target)</span><br><span class="line">    .set(&#123;&#x27;User-Agent&#x27;: userAgent&#125;)</span><br><span class="line">    .end(function(error, response) &#123;</span><br><span class="line">        if (error == null) // 成功才处理，有时网络不好会请求失败</span><br><span class="line">        &#123;</span><br><span class="line">            var myHtml = response.text;</span><br><span class="line">            var ret = parseHtml(myHtml);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            console.log(&quot;get url failed: %s&quot;, error.errno)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="编码其它"><a href="#编码其它" class="headerlink" title="编码其它"></a>编码其它</h3><p>Makefile 知识总结：<br>一个工程目录中，既有需要编译成 so 所需的文件，又有测试所用的文件，为了方便测试、版本管理，即：so 文件不掺杂测试文件，测试程序使用所有文件编译（不额外调用 .so 函数），在编译时，使用 2 个 Makefile，其中，只编译 so 文件时，将不必要的文件过滤即可，示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SRCS1 := $(shell find $(SRC_DIRS) -maxdepth 2 -name &#x27;*.cpp&#x27; -or -name &#x27;*.c&#x27;)</span><br><span class="line"></span><br><span class="line">NONEEDFILES := ./test.cpp ./time_utils.c</span><br><span class="line">SRCS = $(filter-out $(NONEEDFILES), $(SRCS1))</span><br></pre></td></tr></table></figure><p>上述示例中，test.cpp 和 time_utils.c 是测试所用文件，使用 Makefile 提供的 filter-out 函数将其过滤掉。  </p><p>说明：将所有文件编译到 so 中也可以，但会多了不必要的函数和变量，也多了 main 函数，如果用 dlopen 方式打开，用 dlsym 查看函数的话，是没有影响的，但如将 so 也编译到测试程序中，则 main 会重复定义。  </p><h2 id="一般知识"><a href="#一般知识" class="headerlink" title="一般知识"></a>一般知识</h2><p>github 可以创建 README.md 文件，用于展示个人信息或风采，可参考：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/nate-lin/github-readme-stats</span><br></pre></td></tr></table></figure><p>github 的 person access tokens 似乎变化了，要重新生成。之前做好的自动化工作，不懂还要不能修改。  </p><h2 id="研发思考"><a href="#研发思考" class="headerlink" title="研发思考"></a>研发思考</h2><p>本月无。</p><h2 id="后续计划"><a href="#后续计划" class="headerlink" title="后续计划"></a>后续计划</h2><p>过年时一直在想知识共享平台的构建，稍研究了<code>hexo + wiki主题</code>，但始终觉得不太好用。主要用于公司内部的共享。需支持的功能：文档加密、pdf预览。  </p><h2 id="其它点滴"><a href="#其它点滴" class="headerlink" title="其它点滴"></a>其它点滴</h2><p>趁清明和“三月三”放假期间，抽了部分时间看了下前端的视频，查了些前端的框架。准备在工作上应用上。<br>大二立志不学 Java，要打破了，作为打工人，干就完了。<br>部门迁移，地方更远了，早上无法送大锤上幼儿园了。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前言：&lt;br&gt;上一篇类似的文章，是2011年的3月份，看了下当时写的内容，除了代码外，还有其它思考，但后面越来越少了，年纪大了，想的东西少，也没什么好写了，现在重拾起来，觉得十分有必要，可以将每个月的实践、思考记录下来，否则一年过去了，似乎什么也没有学到。  &lt;/p&gt;</summary>
    
    
    
    <category term="我的程序代码" scheme="http://www.latelee.org/category/my-library/"/>
    
    
    <category term="代码积累" scheme="http://www.latelee.org/tag/%E4%BB%A3%E7%A0%81%E7%A7%AF%E7%B4%AF/"/>
    
    <category term="知识总结" scheme="http://www.latelee.org/tag/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>nvidia TX2 CUDA yolov5环境搭建</title>
    <link href="http://www.latelee.org/ml/nvidia-building-yolov5-for-tx2.html"/>
    <id>http://www.latelee.org/ml/nvidia-building-yolov5-for-tx2.html</id>
    <published>2021-03-10T16:00:00.000Z</published>
    <updated>2021-06-04T02:18:55.874Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录笔者在 nvidia TX2 系统上搭建 yolov5 环境的过程。<br>注意说明的是，本文在文后的文章基础上进行实践，根据自己的经历进行描述和补充。由于能力有限，对本文涉及的知识和相关问题无法回答。<br>本文不涉及 yolo 深度学习方面的内容。  </p><span id="more"></span><p><img src="/ml/nvidia-building-yolov5-for-tx2/1.png" alt="图1">  </p><h2 id="一、要点"><a href="#一、要点" class="headerlink" title="一、要点"></a>一、要点</h2><p>本节对本文进行技术小结。   </p><ul><li>TX2 刷机后，PYthon版本为 3.7.1。  </li><li>保持T X2 联网，因为需要下载。  </li><li>conda 创建环境，命令行前会有环境名称的提示。  </li><li>文后的尝试及记录，建议看看。  </li></ul><h2 id="二、过程"><a href="#二、过程" class="headerlink" title="二、过程"></a>二、过程</h2><h3 id="准备工程源码"><a href="#准备工程源码" class="headerlink" title="准备工程源码"></a>准备工程源码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /opt/nvidia/deepstream/yolo</span><br><span class="line">cd /opt/nvidia/deepstream/yolo</span><br><span class="line">git clone https://github.com/DanaHan/Yolov5-in-Deepstream-5.0.git</span><br><span class="line">git clone https://github.com/wang-xinyu/tensorrtx.git</span><br><span class="line">git clone https://github.com/ultralytics/yolov5.git</span><br></pre></td></tr></table></figure><h3 id="安装-conda"><a href="#安装-conda" class="headerlink" title="安装 conda"></a>安装 conda</h3><p>如无 conda，则安装之。到 <a href="https://github.com/Archiconda/build-tools/releases">https://github.com/Archiconda/build-tools/releases</a> 下载。本文所用安装脚本为 Archiconda3-0.2.3-Linux-aarch64.sh 。下载到系统，再安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chmod +x Archiconda3-0.2.3-Linux-aarch64.sh</span><br><span class="line"></span><br><span class="line">./Archiconda3-0.2.3-Linux-aarch64.sh</span><br><span class="line"></span><br><span class="line">source ~/tx/.bashrc</span><br></pre></td></tr></table></figure><h3 id="创建-conda-环境"><a href="#创建-conda-环境" class="headerlink" title="创建 conda 环境"></a>创建 conda 环境</h3><p>使用如下命令创建名为 yolov5 的 conda 环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ conda create -n yolov5 python</span><br></pre></td></tr></table></figure><p>此过程需要手动输入 y 以安装软件包。安装时长取决于联网速度。  </p><p>成功后，输入<code>conda activate yolov5</code>激活，使用<code>conda deactivate</code>退出。过程日志信息详见文后附录。<br>进入 conda 环境后，命令行前有环境名称 yolov5，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(yolov5) tx@tx-desktop:/opt/nvidia/deepstream/yolo$ </span><br></pre></td></tr></table></figure><h3 id="安装-yolo-依赖库"><a href="#安装-yolo-依赖库" class="headerlink" title="安装 yolo 依赖库"></a>安装 yolo 依赖库</h3><p>切换分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/nvidia/deepstream/yolo/yolov5</span><br><span class="line">git checkout -b v4.0 v4.0</span><br></pre></td></tr></table></figure><p>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install scikit-build</span><br><span class="line">pip install -r requirements.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行后命令，提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Could not find a version that satisfies the requirement torchvision&gt;=0.8.1</span><br><span class="line">ERROR: No matching distribution found for torchvision&gt;=0.8.1</span><br></pre></td></tr></table></figure><p>安装 torchvision：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install torchvision -c pytorch</span><br></pre></td></tr></table></figure><p>在实践中发现该命令无法从官方途径安装。故从源码安装。<br>到 <a href="https://github.com/pytorch/vision/releases">https://github.com/pytorch/vision/releases</a> 下载源码压缩包，本文所用版本 v0.9.0，下载，并安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar xf vision-0.9.0.tar.gz</span><br><span class="line">cd vision-0.9.0</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><p>安装过程可能提示没有 torch 模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ModuleNotFoundError: No module named &#x27;torch&#x27;</span><br></pre></td></tr></table></figure><p>安装之：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install torch</span><br></pre></td></tr></table></figure><p>torchvision编译需要等待一段时间。  </p><p>依赖包安装完成后提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Successfully installed Cython-0.29.22 PyYAML-5.4.1 absl-py-0.12.0 cachetools-4.2.1 chardet-4.0.0 cycler-0.10.0 google-auth-1.27.1 google-auth-oauthlib-0.4.3 grpcio-1.36.1 idna-2.10 kiwisolver-1.3.1 markdown-3.3.4 matplotlib-3.3.4 oauthlib-3.1.0 opencv-python-4.5.1.48 pandas-1.2.3 protobuf-3.15.6 pyasn1-0.4.8 pyasn1-modules-0.2.8 pycocotools-2.0.2 python-dateutil-2.8.1 pytz-2021.1 requests-2.25.1 requests-oauthlib-1.3.0 rsa-4.7.2 scipy-1.6.1 seaborn-0.11.1 six-1.15.0 tensorboard-2.4.1 tensorboard-plugin-wit-1.8.0 thop-0.0.31.post2005241907 tqdm-4.59.0 urllib3-1.26.3 werkzeug-1.0.1</span><br></pre></td></tr></table></figure><p>在yolov5目录下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/nvidia/deepstream/yolo/yolov5</span><br></pre></td></tr></table></figure><p>下载模型文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash weights/download_weights.sh</span><br></pre></td></tr></table></figure><p>默认下载到yolov5目录，有文件：<code>yolov5l.pt yolov5m.pt yolov5s.pt yolov5x.pt</code>。可根据实际情况选，本文使用默认值，即<code>yolov5s.pt</code>文件。拷贝到 weights 目录。  </p><p>继续在 yolov5 目录下，拷贝 gen_wts.py。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ../tensorrtx/yolov5/gen_wts.py ./</span><br></pre></td></tr></table></figure><p>注意，可修改 gen_wts.py 文件，主要修改<code>&#39;weights/yolov5x.pt&#39; &#39;yolov5x.wts&#39;</code>名称。  </p><p>生成wts文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python gen_wts.py </span><br></pre></td></tr></table></figure><p>最终生成文件：yolov5x.wts。将其拷贝到 Yolov5-in-Deepstream-5.0 目录，并切换到该目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp yolov5s.wts ../Yolov5-in-Deepstream-5.0</span><br><span class="line">cd ../Yolov5-in-Deepstream-5.0</span><br></pre></td></tr></table></figure><p>根据实际情况，修改 yolov5.cpp 文件，将 NET 宏改成自己对应的模型。本文使用默认值 s，无须改动。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define NET s  // s m l x</span><br></pre></td></tr></table></figure><p>编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>生成 yolov5 文件，后面将用该文件生成模型和测试。  </p><p>生成engine文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./yolov5 -s</span><br></pre></td></tr></table></figure><p>注意：程序使用了../yolov5x.wts，所以 yolov5x.wts 要拷贝 Yolov5-in-Deepstream-5.0 目录。成功输出如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$sudo ./yolov5 -s</span><br><span class="line">Loading weights: ../yolov5s.wts</span><br><span class="line">Building engine, please wait for a while...</span><br><span class="line">Build engine successfully!</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir ../samples</span><br></pre></td></tr></table></figure><p>从网上下载两张 coco 数据集图片，放到 samples 上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./yolov5 -d  ../samples</span><br></pre></td></tr></table></figure><p>在build可看到有图片文件生成，且标注了，说明成功。  </p><p>将 libmyplugins.so yolov5s.engine 拷贝到 Deepstream 5.0 目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp yolov5x.engine ../Deepstream\ 5.0/</span><br><span class="line">cp libmyplugins.so ../Deepstream\ 5.0/</span><br></pre></td></tr></table></figure><h2 id="Deepstream-测试"><a href="#Deepstream-测试" class="headerlink" title="Deepstream 测试"></a>Deepstream 测试</h2><p>在 Yolov5-in-Deepstream-5.0\Deepstream 5.0\nvdsinfer_custom_impl_Yolo 目录执行<code>make</code>，生成<code>libnvdsinfer_custom_impl_Yolo.so</code>文件。进入 Yolov5-in-Deepstream-5.0\Deepstream 5.0 目录中，修改 config_infer_primary_yoloV5.tx 文件。主要修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model-engine-file=yolov5s.engine --&gt; model-engine-file=yolov5x.engine</span><br><span class="line"></span><br><span class="line">custom-lib-path=objectDetector_Yolo_V5/nvdsinfer_custom_impl_Yolo/libnvdsinfer_custom_impl_Yolo.so --&gt; custom-lib-path=nvdsinfer_custom_impl_Yolo/libnvdsinfer_custom_impl_Yolo.so</span><br></pre></td></tr></table></figure><p>将 DeepStream 的 label.txt 拷贝到当前目录。修改 deepstream_app_config_yoloV5.txt 文件的视频地址。使用官方 deepstream-app 程序测试，执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD_PRELOAD=./libmyplugins.so deepstream-app -c deepstream_app_config_yoloV5.txt</span><br></pre></td></tr></table></figure><p>可得到识别的结果。  </p><h2 id="三、参考资源"><a href="#三、参考资源" class="headerlink" title="三、参考资源"></a>三、参考资源</h2><p>DeepStream5.0系列之yolov5使用： <a href="https://blog.csdn.net/zong596568821xp/article/details/109444343">https://blog.csdn.net/zong596568821xp/article/details/109444343</a><br>pytorch源码：<a href="https://github.com/pytorch/vision/releases">https://github.com/pytorch/vision/releases</a>    </p><h2 id="附1：尝试"><a href="#附1：尝试" class="headerlink" title="附1：尝试"></a>附1：尝试</h2><h3 id="一般错误"><a href="#一般错误" class="headerlink" title="一般错误"></a>一般错误</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ModuleNotFoundError: No module named &#x27;Cython&#x27;</span><br><span class="line">--&gt; python3.7 -m pip install cython</span><br><span class="line"></span><br><span class="line">Could not find a version that satisfies the requirement cmake</span><br><span class="line"></span><br><span class="line">--&gt; python3.7 -m pip install cmake</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="torchvision"><a href="#torchvision" class="headerlink" title="torchvision"></a>torchvision</h3><p>找不到 torchvision 模块提示如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Could not find a version that satisfies the requirement torchvision&gt;=0.8.1</span><br><span class="line">ERROR: No matching distribution found for torchvision&gt;=0.8.1</span><br></pre></td></tr></table></figure><p>选按通用安装方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3.7 -m pip install torchvision </span><br></pre></td></tr></table></figure><p>但错误提示依旧。按网上说法使用如下命令安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install torchvision==0.8.1 -f https://download.pytorch.org/whl/torch_stable.html</span><br></pre></td></tr></table></figure><p>但依然失败。再用<a href="https://pypi.org/project/torchvision/">官方</a> 提供的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install torchvision -c pytorch</span><br></pre></td></tr></table></figure><p>还是失败。究其原因，可能是没有 aarch64 版本的缘故。所以用源码安装。  </p><h3 id><a href="#" class="headerlink" title></a></h3><p>生成 egine 文件时提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Loading weights: ../yolov5x.wts</span><br><span class="line">[03/10/2021-01:00:59] [E] [TRT] (Unnamed Layer* 14) [Convolution]: kernel weights has count 0 but 12800 was expected</span><br><span class="line">[03/10/2021-01:00:59] [E] [TRT] (Unnamed Layer* 14) [Convolution]: count of 0 weights in kernel, but kernel dimensions (1,1) with 160 input channels, 80 output channels and 1 groups were specified. Expected Weights count is 160 * 1*1 * 80 / 1 = 12800</span><br><span class="line">[03/10/2021-01:00:59] [E] [TRT] Parameter check failed at: ../builder/Network.cpp::addScale::482, condition: shift.count &gt; 0 ? (shift.values != nullptr) : (shift.values == nullptr)</span><br><span class="line">yolov5: /opt/nvidia/deepstream/yolo-in-Deepstream-5.0/common.hpp:190: nvinfer1::IScaleLayer* addBatchNorm2d(nvinfer1::INetworkDefinition*, std::map&lt;std::__cxx11::basic_string&lt;char&gt;, nvinfer1::Weights&gt;&amp;, nvinfer1::ITensor&amp;, std::__cxx11::string, float): Assertion `scale_1&#x27; failed.</span><br><span class="line">Aborted</span><br></pre></td></tr></table></figure><p>原因是使用 yolov5x 版本，改为默认的 yolov5s 不再出现。<br>使用 yolov5s.wts  在 AGX Xavier 平台上出现的错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> sudo ./yolov5 -s</span><br><span class="line">Loading weights: ../yolov5s.wts</span><br><span class="line">[03/12/2021-16:06:07] [E] [TRT] (Unnamed Layer* 14) [Convolution]: kernel weights has count 0 but 2048 was expected</span><br><span class="line">[03/12/2021-16:06:07] [E] [TRT] (Unnamed Layer* 14) [Convolution]: count of 0 weights in kernel, but kernel dimensions (1,1) with 64 input channels, 32 output channels and 1 groups were specified. Expected Weights count is 64 * 1*1 * 32 / 1 = 2048</span><br><span class="line">[03/12/2021-16:06:07] [E] [TRT] Parameter check failed at: ../builder/Network.cpp::addScale::482, condition: shift.count &gt; 0 ? (shift.values != nullptr) : (shift.values == nullptr)</span><br><span class="line">yolov5: /opt/nvidia/deepstream/yolo/Yolov5-in-Deepstream-5.0/common.hpp:190: nvinfer1::IScaleLayer* addBatchNorm2d(nvinfer1::INetworkDefinition*, std::map&lt;std::__cxx11::basic_string&lt;char&gt;, nvinfer1::Weights&gt;&amp;, nvinfer1::ITensor&amp;, std::__cxx11::string, float): Assertion `scale_1&#x27; failed.</span><br><span class="line">Aborted</span><br></pre></td></tr></table></figure><p>使用不同平台的 engine 文件的错误(TX2生成，AGX Xavier运行）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ./yolov5 -d  ../samples</span><br><span class="line">[03/12/2021-16:12:13] [E] [TRT] INVALID_CONFIG: The engine plan file is generated on an incompatible device, expecting compute 7.2 got compute 6.2, please rebuild.</span><br><span class="line">[03/12/2021-16:12:13] [E] [TRT] engine.cpp (1546) - Serialization Error in deserialize: 0 (Core engine deserialization failure)</span><br><span class="line">[03/12/2021-16:12:13] [E] [TRT] INVALID_STATE: std::exception</span><br><span class="line">[03/12/2021-16:12:13] [E] [TRT] INVALID_CONFIG: Deserialize the cuda engine failed.</span><br><span class="line">yolov5: /opt/nvidia/deepstream/yolo/Yolov5-in-Deepstream-5.0/yolov5.cpp:534: int main(int, char**): Assertion `engine != nullptr&#x27; failed.</span><br><span class="line">Aborted</span><br></pre></td></tr></table></figure><p>测试时，如果 samples 目录存在非图片时，会提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">740ms</span><br><span class="line">terminate called after throwing an instance of &#x27;cv::Exception&#x27;</span><br><span class="line">  what():  OpenCV(4.1.1) /home/nvidia/host/build_opencv/nv_opencv/modules/imgcodecs/src/loadsave.cpp:662: error: (-2:Unspecified error) could not find a writer for the specified extension in function &#x27;imwrite_&#x27;</span><br></pre></td></tr></table></figure><p>解决：图片后缀需正确，如jpg、png。</p><h3 id="创建-yolo-环境输出日志"><a href="#创建-yolo-环境输出日志" class="headerlink" title="创建 yolo 环境输出日志"></a>创建 yolo 环境输出日志</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">$ conda create -n yolov5 python</span><br><span class="line">Solving environment: done</span><br><span class="line"></span><br><span class="line">## Package Plan ##</span><br><span class="line"></span><br><span class="line">  environment location: /home/tx/archiconda3/envs/yolov5</span><br><span class="line"></span><br><span class="line">  added / updated specs: </span><br><span class="line">    - python</span><br><span class="line"></span><br><span class="line">The following packages will be downloaded:</span><br><span class="line"></span><br><span class="line">    package                    |            build</span><br><span class="line">    ---------------------------|-----------------</span><br><span class="line">    zlib-1.2.11                |       h7b6447c_2         118 KB  c4aarch64</span><br><span class="line">    openssl-1.0.2p             |       h7b6447c_0         3.1 MB  c4aarch64</span><br><span class="line">    sqlite-3.25.2              |       h7ce4240_0         2.2 MB  c4aarch64</span><br><span class="line">    readline-7.0               |       h7ce4240_5         440 KB  c4aarch64</span><br><span class="line">    pip-10.0.1                 |           py37_0         1.7 MB  c4aarch64</span><br><span class="line">    wheel-0.32.1               |           py37_0          34 KB  c4aarch64</span><br><span class="line">    libgcc-ng-7.3.0            |       h5c90dd9_0         5.9 MB  c4aarch64</span><br><span class="line">    libstdcxx-ng-7.3.0         |       h5c90dd9_0         2.5 MB  c4aarch64</span><br><span class="line">    setuptools-40.4.3          |           py37_0         601 KB  c4aarch64</span><br><span class="line">    xz-5.2.4                   |       h7ce4240_4         345 KB  c4aarch64</span><br><span class="line">    certifi-2018.10.15         |           py37_0         137 KB  c4aarch64</span><br><span class="line">    ncurses-6.1                |       h71b71f5_0         1.0 MB  c4aarch64</span><br><span class="line">    tk-8.6.8                   |       hbc83047_0         3.2 MB  c4aarch64</span><br><span class="line">    ca-certificates-2018.03.07 |                0         123 KB  c4aarch64</span><br><span class="line">    python-3.7.2               |       he90a169_0        36.1 MB  c4aarch64</span><br><span class="line">    libffi-3.2.1               |       h71b71f5_5          51 KB  c4aarch64</span><br><span class="line">    libedit-3.1.20170329       |       hc058e9b_2         188 KB  c4aarch64</span><br><span class="line">    ------------------------------------------------------------</span><br><span class="line">                                           Total:        57.8 MB</span><br><span class="line"></span><br><span class="line">The following NEW packages will be INSTALLED:</span><br><span class="line"></span><br><span class="line">    ca-certificates: 2018.03.07-0            c4aarch64</span><br><span class="line">    certifi:         2018.10.15-py37_0       c4aarch64</span><br><span class="line">    libedit:         3.1.20170329-hc058e9b_2 c4aarch64</span><br><span class="line">    libffi:          3.2.1-h71b71f5_5        c4aarch64</span><br><span class="line">    libgcc-ng:       7.3.0-h5c90dd9_0        c4aarch64</span><br><span class="line">    libstdcxx-ng:    7.3.0-h5c90dd9_0        c4aarch64</span><br><span class="line">    ncurses:         6.1-h71b71f5_0          c4aarch64</span><br><span class="line">    openssl:         1.0.2p-h7b6447c_0       c4aarch64</span><br><span class="line">    pip:             10.0.1-py37_0           c4aarch64</span><br><span class="line">    python:          3.7.2-he90a169_0        c4aarch64</span><br><span class="line">    readline:        7.0-h7ce4240_5          c4aarch64</span><br><span class="line">    setuptools:      40.4.3-py37_0           c4aarch64</span><br><span class="line">    sqlite:          3.25.2-h7ce4240_0       c4aarch64</span><br><span class="line">    tk:              8.6.8-hbc83047_0        c4aarch64</span><br><span class="line">    wheel:           0.32.1-py37_0           c4aarch64</span><br><span class="line">    xz:              5.2.4-h7ce4240_4        c4aarch64</span><br><span class="line">    zlib:            1.2.11-h7b6447c_2       c4aarch64</span><br><span class="line"></span><br><span class="line">Proceed ([y]/n)? y</span><br><span class="line"></span><br><span class="line">Preparing transaction: done</span><br><span class="line">Verifying transaction: done</span><br><span class="line">Executing transaction: done</span><br><span class="line">#</span><br><span class="line"># To activate this environment, use</span><br><span class="line">#</span><br><span class="line">#     $ conda activate yolov5</span><br><span class="line">#</span><br><span class="line"># To deactivate an active environment, use</span><br><span class="line">#</span><br><span class="line">#     $ conda deactivate</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="附2：成果"><a href="#附2：成果" class="headerlink" title="附2：成果"></a>附2：成果</h2><p>1、文中涉及的软件包只在 TX2 测试通过，已整合为 aarch64 系统的 docker 镜像，并上传至阿里云仓库备份。<br>Dockerfile：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM busybox </span><br><span class="line">RUN mkdir /yolotools  </span><br><span class="line">COPY vision-0.9.0.tar.gz  /yolotools</span><br><span class="line">COPY yolo.tar.bz2  /yolotools</span><br><span class="line">COPY Archiconda3-0.2.3-Linux-aarch64.sh  /yolotools</span><br></pre></td></tr></table></figure><p>创建并上传：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t registry.cn-hangzhou.aliyuncs.com/latelee/yoloenv:aarch64 .</span><br><span class="line">docker push registry.cn-hangzhou.aliyuncs.com/latelee/yoloenv:aarch64</span><br></pre></td></tr></table></figure><p>镜像说明：yolo.tar.bz2包含了本文的工程源码。运行后查看容器的 <code>/yolotools</code> 目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name foobar registry.cn-hangzhou.aliyuncs.com/latelee/yoloenv:aarch64 sh</span><br><span class="line">docker exec -it foobar ls /yolotools</span><br></pre></td></tr></table></figure><p>在宿主机拷贝文件出来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir tools</span><br><span class="line">docker cp foobar:/yolotools/vision-0.9.0.tar.gz tools</span><br><span class="line">docker cp foobar:/yolotools/yolo.tar.bz2 tools</span><br><span class="line">docker cp foobar:/yolotools/Archiconda3-0.2.3-Linux-aarch64.sh tools</span><br></pre></td></tr></table></figure><h2 id="再附"><a href="#再附" class="headerlink" title="再附"></a>再附</h2><p>一段时间来，github 和 gitlab 官方经常打不开，在访问网站上较耗时。不知何故。  </p><p>李迟 2021.3.12 周五</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文记录笔者在 nvidia TX2 系统上搭建 yolov5 环境的过程。&lt;br&gt;注意说明的是，本文在文后的文章基础上进行实践，根据自己的经历进行描述和补充。由于能力有限，对本文涉及的知识和相关问题无法回答。&lt;br&gt;本文不涉及 yolo 深度学习方面的内容。  &lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://www.latelee.org/category/ml/"/>
    
    
  </entry>
  
  <entry>
    <title>软考路：高项4流水账</title>
    <link href="http://www.latelee.org/code-life/ruankao-pm4.html"/>
    <id>http://www.latelee.org/code-life/ruankao-pm4.html</id>
    <published>2021-03-08T15:00:00.000Z</published>
    <updated>2021-06-04T02:18:55.958Z</updated>
    
    <content type="html"><![CDATA[<p>高项证书已经拿到手了，没有想象中那样高兴，没有请客吃饭，没有做顿大餐犒劳自己，没有人分享喜悦，只有大锤看着证书上的照片，认得是爸爸。周边通过的同事已经把证书提交给公司了，我也将其束之高阁，与旧的证书、毕业证书、四六级成绩单放一起，顺便记录一下跨越大半年的流水账，把此事了了。    </p><span id="more"></span><h2 id="考证之我见"><a href="#考证之我见" class="headerlink" title="考证之我见"></a>考证之我见</h2><p>是否考证，每个人的态度和观念是不同的（这是废话）。笔者个人是会考的，但会有取舍。<br>1、就笔者所学专业而言，是会软考（虽然目前没有什么用）。如一建，消防这类，虽说得钱多，但能力有限，暂不考虑。<br>2、笔者今年 35 了，考一考，试一试，看看自己能力，促进技术学习。——笔者至今还是一名编码工人且不知写到何时。<br>3、家里有娃，看书做笔记，能给娃一个榜样，间中去趟图书馆，让娃也陶冶情操，也是不错的。<br>4、笔者所在单位正式员工高级证书有补贴。证书是资格，可用于评职称（高级证书可作为高工的一个条件），笔者所在单位正式员工评上工程师会聘用。<br>5、证书目前没有任何作用，但不妨碍我去考。学不学是个人能控制的，补不补是公司的事，个人控制不了。种下了因，能不能得果，还要看缘。    </p><h2 id="备考"><a href="#备考" class="headerlink" title="备考"></a>备考</h2><p>2020.7月中下旬<br>调研、思考、决策。最后决定报考高项。  </p><p>2020.8.3<br>报名缴费 204 元。  </p><p>2020.8/9/10/<br>上班、带娃、做家务、备考。  </p><p>2020.11.1<br>打印准考证。<br><img src="/code-life/ruankao-pm4/1.jpg">  </p><p>2020.11.7 周六<br>考试。<br><img src="/code-life/ruankao-pm4/2.jpg">  </p><h2 id="考后"><a href="#考后" class="headerlink" title="考后"></a>考后</h2><p>2020.12.18<br>查成绩。上午分数符合猜测。论文45分。<br><img src="/code-life/ruankao-pm4/3.png">  </p><p>2021.1.8<br>人社部公布分数线，与往年保持一致。45分及格。<br><img src="/code-life/ruankao-pm4/4.png">  </p><p>2021.1.23<br>可在人事考试中心查证书。<br><a href="http://zs.cpta.com.cn/certMng/loginPage.jsp">http://zs.cpta.com.cn/certMng/loginPage.jsp</a><br><a href="http://zscx.gxpta.com.cn/">http://zscx.gxpta.com.cn/</a>  </p><p>2021.2.8<br>可领取证书<br>公告文件：<a href="http://www.gxpta.com.cn/contents/835/7292.html">http://www.gxpta.com.cn/contents/835/7292.html</a>  </p><p><img src="/code-life/ruankao-pm4/5.png">  </p><p>2021.2.9<br>去领证书（农历廿八）。<br><img src="/code-life/ruankao-pm4/6.png">  </p><p><img src="/code-life/ruankao-pm4/7.png">  </p><p>2021.2.19<br>咨询公司人事，回复外包人员未有相关补贴事宜。  </p><p>2021.3.4<br>调查相关补贴政策。<br><a href="http://www.mohrss.gov.cn/sybxs/SYBXSzhengcewenjian/SYBXSdingfangzhengce/201908/t20190813_329426.html">http://www.mohrss.gov.cn/sybxs/SYBXSzhengcewenjian/SYBXSdingfangzhengce/201908/t20190813_329426.html</a><br><a href="https://ggfw.nn12333.com:8081/nnmh/knode/3053">https://ggfw.nn12333.com:8081/nnmh/knode/3053</a>  </p><p>某机构网站介绍广西有补贴政策：  </p><p><img src="/code-life/ruankao-pm4/8.png">  </p><p><img src="/code-life/ruankao-pm4/9.png">  </p><p>2021.3.5<br>办理<br><img src="/code-life/ruankao-pm4/10.png">  </p><p>2021.3.8<br>收到反馈结果：不在政策范围内。<br><img src="/code-life/ruankao-pm4/11.png">  </p><p>李迟 2021.3.15 </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;高项证书已经拿到手了，没有想象中那样高兴，没有请客吃饭，没有做顿大餐犒劳自己，没有人分享喜悦，只有大锤看着证书上的照片，认得是爸爸。周边通过的同事已经把证书提交给公司了，我也将其束之高阁，与旧的证书、毕业证书、四六级成绩单放一起，顺便记录一下跨越大半年的流水账，把此事了了。    &lt;/p&gt;</summary>
    
    
    
    <category term="代码生活" scheme="http://www.latelee.org/category/code-life/"/>
    
    
    <category term="考证" scheme="http://www.latelee.org/tag/%E8%80%83%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>我的docker随笔31：oracle数据库再次部署</title>
    <link href="http://www.latelee.org/docker/docker-31-deploy-oracle-again.html"/>
    <id>http://www.latelee.org/docker/docker-31-deploy-oracle-again.html</id>
    <published>2021-02-25T17:00:00.000Z</published>
    <updated>2021-06-04T02:18:55.946Z</updated>
    
    <content type="html"><![CDATA[<p>本文涉及一种在容器中部署 oracle 数据库的方法。经验证，可达到预期目标，并能应用在实际工作中。    </p><span id="more"></span><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>去年曾经部署过 oracle，当时使用阿里云仓库上的镜像，版本为 11.2， 但一直解决不了永久存储问题，后因其它工作的事没有继续。过年期间到现在，内网（人为地）一直断开，无法访问数据库，对工作造成一定的影响，所以有必完成此事。<br>oracle 官方有创建 docker 的说明（可能是 docker 官方），本文即根据文档进行实践。<br>本文着重实践性，且必须与生产数据库版本、表名尽量保持一致。  </p><h2 id="技术小结"><a href="#技术小结" class="headerlink" title="技术小结"></a>技术小结</h2><ul><li>宿主机挂载的目录必须能让 uid 为 54321 的用户读写。可创建该 uid 的用户，也可直接设置权限为777。  </li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>根据在 github 仓库的 <a href="https://github.com/oracle/docker-images/tree/main/OracleDatabase/SingleInstance">安装说明文档</a> 进行操作。  </p><p>仓库没有提供 oracle 软件（可能是因为太大了），具体的软件下载可访问<a href="https://www.oracle.com/database/technologies/oracle-database-software-downloads.html">此页面</a> ，本文所用版本为 Linux x86-64 ，名称为 LINUX.X64_193000_db_home.zip ，大小为 2.8GB，md5 为 1858bd0d281c60f4ddabd87b1c214a4f。注意，下载需要登录，先进行注册（注册也花了一定时间）。  </p><p>按官方说法需将软件压缩包重命名为：linuxx64_19.3.0_database.zip ，但实际并不需要。将 LINUX.X64_193000_db_home.zip 拷贝到 docker-images/OracleDatabase/SingleInstance/dockerfiles/19.3.0 目录。  </p><h3 id="修改为非CDB方式"><a href="#修改为非CDB方式" class="headerlink" title="修改为非CDB方式"></a>修改为非CDB方式</h3><p>自 12 版本后<br>修改文件所有目录：docker-images/OracleDatabase/SingleInstance/dockerfiles/19.3.0。<br>修改文件 dbca.rsp.tmpl：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">createAsContainerDatabase=false</span><br><span class="line">numberOfPDBs=0</span><br><span class="line">## 注释掉</span><br><span class="line">#pdbName=###ORACLE_PDB###</span><br><span class="line">#pdbAdminPassword=###ORACLE_PWD###</span><br><span class="line"></span><br><span class="line"># em关掉</span><br><span class="line">emConfiguration=NONE</span><br></pre></td></tr></table></figure><p>修改文件 createDB.sh 如下语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER PLUGGABLE DATABASE $ORACLE_PDB SAVE STATE;</span><br><span class="line">EXEC DBMS_XDB_CONFIG.SETGLOBALPORTENABLED (TRUE);</span><br></pre></td></tr></table></figure><p>修改文件 checkDBStatus.sh：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v\\$pdbs</span><br><span class="line">改为</span><br><span class="line">v\\$database</span><br></pre></td></tr></table></figure><h3 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h3><p>进入docker-images/OracleDatabase/SingleInstance/dockerfiles 目录，执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./buildContainerImage.sh -e -i -v 19.3.0</span><br></pre></td></tr></table></figure><p>注：-i表示不校验md5（如检验md5提示某文件找不到，故自行检验）。<br>双核4G虚拟机，耗时约40分钟。20核64G服务器耗时约12分钟。  </p><p>打标签并提交阿里云仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag oracle/database:19.3.0-ee registry.cn-hangzhou.aliyuncs.com/latelee/database:19.3.0-ee</span><br><span class="line">docker push registry.cn-hangzhou.aliyuncs.com/latelee/database:19.3.0-ee</span><br></pre></td></tr></table></figure><h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3><p>官方示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run --name &lt;container name&gt; \</span><br><span class="line">-p &lt;host port&gt;:1521 -p &lt;host port&gt;:5500 \</span><br><span class="line">-e ORACLE_SID=&lt;your SID&gt; \</span><br><span class="line">-e ORACLE_PDB=&lt;your PDB name&gt; \</span><br><span class="line">-e ORACLE_PWD=&lt;your database passwords&gt; \</span><br><span class="line">-e INIT_SGA_SIZE=&lt;your database SGA memory in MB&gt; \</span><br><span class="line">-e INIT_PGA_SIZE=&lt;your database PGA memory in MB&gt; \</span><br><span class="line">-e ORACLE_EDITION=&lt;your database edition&gt; \</span><br><span class="line">-e ORACLE_CHARACTERSET=&lt;your character set&gt; \</span><br><span class="line">-v [&lt;host mount point&gt;:]/opt/oracle/oradata \</span><br><span class="line">oracle/database:19.3.0-ee</span><br></pre></td></tr></table></figure><p>说明：<br>挂载 /opt/oracle/oradata 的目录必须可以由 uid 为 54321 的用户（该用户为容器oracle的 uid）访问，否则容器无法创建目录。实际中，挂载目录权限更改为 777 。<br>变量及默认值：<br>ORACLE_SID ORCLCDB<br>ORACLE_PDB ORCLPDB1<br>ORACLE_PWD 自动随机产生<br>ORACLE_CHARACTERSET AL32UTF8<br>实际：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd \</span><br><span class="line">--name oracle \</span><br><span class="line">-p 1521:1521 \</span><br><span class="line">-e ORACLE_SID=ORCLCDB \</span><br><span class="line">-e ORACLE_PDB=ORCLPDB1 \</span><br><span class="line">-e ORACLE_PWD=123456 \</span><br><span class="line">-e ORACLE_CHARACTERSET=ZHS16GBK \</span><br><span class="line">-e TZ=&quot;Asia/Shanghai&quot; \</span><br><span class="line">-v oracledata:/opt/oracle/oradata \</span><br><span class="line">oracle/database:19.3.0-ee</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">最简单的，无任何功能</span><br><span class="line">docker run -it --rm --name oracle registry.cn-hangzhou.aliyuncs.com/latelee/database:19.3.0-ee bash</span><br><span class="line"></span><br><span class="line">加时区的测试：</span><br><span class="line">docker run -it --rm --name oracle -e TZ=&quot;Asia/Shanghai&quot; registry.cn-hangzhou.aliyuncs.com/latelee/database:19.3.0-ee bash</span><br></pre></td></tr></table></figure><p>实际中使用 docker-compose 启动，docker-compose.yml 文件如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;2&#x27;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  lloracle:</span><br><span class="line">    image: registry.cn-hangzhou.aliyuncs.com/latelee/database:19.3.0-ee</span><br><span class="line">    container_name: lloracle</span><br><span class="line">    shm_size: 4gb</span><br><span class="line">    restart: always</span><br><span class="line">    #command: </span><br><span class="line">    volumes:</span><br><span class="line">      - ./oracle_data/oradata:/opt/oracle/oradata</span><br><span class="line">      - ./oracle_data/dbs:/opt/oracle/product/19c/dbhome_1/dbs</span><br><span class="line">      - ./oracle_data/admin:/opt/oracle/admin</span><br><span class="line">    environment:</span><br><span class="line">      - TZ=Asia/Shanghai</span><br><span class="line">      - ORACLE_SID=ORCLCDB</span><br><span class="line">      - ORACLE_PDB=ORCLPDB1</span><br><span class="line">      - ORACLE_PWD=123456</span><br><span class="line">      - ORACLE_CHARACTERSET=ZHS16GBK</span><br><span class="line">    ports:</span><br><span class="line">      - 1521:1521</span><br><span class="line">    networks:</span><br><span class="line">      - lloracle-net</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  lloracle-net:</span><br><span class="line">    driver: bridge</span><br></pre></td></tr></table></figure><p>注1：INIT_SGA_SIZE、INIT_PGA_SIZE未设置。<br>注2：设置共享内容为2GB（相当于docker的 –shm-size 参数），设置了东八区时区，映射1521端口。字符编码设置为 GBK，非 UTF8。<br>注3：在虚拟机耗时约半小时。<br>注4：在 docker-compose.yml 同一目录下创建三个子目录：oradata、dbs、admin，将三个目录权限改为777。  </p><h3 id="验证服务"><a href="#验证服务" class="headerlink" title="验证服务"></a>验证服务</h3><p>进入容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it lloracle bash</span><br></pre></td></tr></table></figure><p>验证：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ sqlplus / as sysdba</span><br><span class="line"></span><br><span class="line">SQL*Plus: Release 19.0.0.0.0 - Production on Wed Mar 24 15:34:16 2021</span><br><span class="line">Version 19.3.0.0.0</span><br><span class="line"></span><br><span class="line">Copyright (c) 1982, 2019, Oracle.  All rights reserved.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Connected to:</span><br><span class="line">Oracle Database 19c Enterprise Edition Release 19.0.0.0.0 - Production</span><br><span class="line">Version 19.3.0.0.0 </span><br><span class="line"></span><br><span class="line">注：此处没有 Connected to an idle instance.</span><br><span class="line"></span><br><span class="line">SQL&gt; show pdbs;</span><br><span class="line">SQL&gt; select CDB from v$database;   # 显示为NO表示非CDB</span><br><span class="line"></span><br><span class="line">CDB</span><br><span class="line">---</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><h3 id="创建表空间和用户"><a href="#创建表空间和用户" class="headerlink" title="创建表空间和用户"></a>创建表空间和用户</h3><h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><p>进入容器，创建目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it lloracle bash</span><br><span class="line">mkdir /opt/oracle/oradata/FEE_DATA</span><br></pre></td></tr></table></figure><p>注：此处是为了创建 54321 用户权限的目录，也可以在宿主机上创建，再用 chown 修改。  </p><h4 id="在navicat创建表空间和用户名"><a href="#在navicat创建表空间和用户名" class="headerlink" title="在navicat创建表空间和用户名"></a>在navicat创建表空间和用户名</h4><p>使用 navicat 连接 oracle，本次连接参数为：<br>端口：1521<br>服务名：ORCLCDB<br>用户及密码：system/123456  </p><p>结果如图1所示：<br><img src="/docker/docker-31-deploy-oracle-again/1.png" alt="图1"> </p><p>点击“其它”、“表空间”、“新建表空间”。在默认“常规”：名称：system01.dbf，大小1，单位G，路径：’/opt/oracle/oradata/FEE_DATA/‘(注意最后的斜杠)。自动扩展：ON。（疑惑：此处的大小表征的是什么？如果后续数据超过1G会如何？）<br>点击“保存”，输入表空间名: FEE_DATA。  </p><p>点击“用户”、“用户”，“新建用户”，输入用户名称 FEE (大写)，密码 123456，默认表空间选择刚才创建的表空间。“成员属于”，勾选DBA所有项。“保存”。  </p><h4 id="使用新用户连接"><a href="#使用新用户连接" class="headerlink" title="使用新用户连接"></a>使用新用户连接</h4><p>使用 navicat 连接 oracle，本次连接参数为：<br>端口：1521<br>服务名：ORCLCDB<br>用户及密码：FEE/123456  </p><p>结果如图2所示：<br><img src="/docker/docker-31-deploy-oracle-again/2.png" alt="图2"> </p><p>另外，还再次创建另一表空间，另一用户名，再以 FEE 连接，依然可访问另一用户名的表空间。  </p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文使用非 CDB 方式以 docker 运行 oracle19.3，经初步验证，可以正常使用，至于是否可经长期考验，等后续观察。  </p><h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><p>本文完成的镜像如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">registry.cn-hangzhou.aliyuncs.com/latelee/database:19.3.0-ee      # 非cdb版本</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/latelee/database:19.3.0-ee-cdb  # cdb版本</span><br></pre></td></tr></table></figure><h2 id="容器探索"><a href="#容器探索" class="headerlink" title="容器探索"></a>容器探索</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">容器的用户名：</span><br><span class="line"></span><br><span class="line">oracle:x:54321:54321::/home/oracle:/bin/bash</span><br><span class="line"></span><br><span class="line">容器中的环境变量：</span><br><span class="line">$ env</span><br><span class="line">ORACLE_SID=ORCLCDB</span><br><span class="line">INSTALL_FILE_1=LINUX.X64_193000_db_home.zip</span><br><span class="line">ORACLE_BASE=/opt/oracle</span><br><span class="line">CHECK_SPACE_FILE=checkSpace.sh</span><br><span class="line">ORACLE_PDB=ORCLPDB1</span><br><span class="line">PWD_FILE=setPassword.sh</span><br><span class="line">TZ=Asia/Shanghai</span><br><span class="line">SLIMMING=true</span><br><span class="line">RUN_FILE=runOracle.sh</span><br><span class="line">CREATE_DB_FILE=createDB.sh</span><br><span class="line">SHLVL=1</span><br><span class="line">ORACLE_PWD=123456</span><br><span class="line">ORACLE_HOME=/opt/oracle/product/19c/dbhome_1</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>官方仓库：<a href="https://github.com/oracle/docker-images">https://github.com/oracle/docker-images</a><br>修改后的仓库：<a href="https://github.com/latelee/docker-images">https://github.com/latelee/docker-images</a><br><a href="https://github.com/oracle/docker-images/tree/main/OracleDatabase/SingleInstance">安装说明文档</a><br>下载软件：<a href="https://www.oracle.com/database/technologies/oracle-database-software-downloads.html">https://www.oracle.com/database/technologies/oracle-database-software-downloads.html</a><br>共享内存参考：<a href="https://blog.csdn.net/weisubao/article/details/108704236">https://blog.csdn.net/weisubao/article/details/108704236</a><br>Docker安装Oracle19c(NONCDB): <a href="https://www.jianshu.com/p/f0139aff1746">https://www.jianshu.com/p/f0139aff1746</a><br>oracle镜像issue：<a href="https://github.com/oracle/docker-images/issues/791">https://github.com/oracle/docker-images/issues/791</a>  </p><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>构建镜像部分日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Removing intermediate container 2bbee773477c</span><br><span class="line"> ---&gt; f6b8442fcfaa</span><br><span class="line">Step 19/22 : USER oracle</span><br><span class="line"> ---&gt; Running in 85995f303fab</span><br><span class="line">Removing intermediate container 85995f303fab</span><br><span class="line"> ---&gt; 14525605ab30</span><br><span class="line">Step 20/22 : WORKDIR /home/oracle</span><br><span class="line"> ---&gt; Running in b6c49a7101ee</span><br><span class="line">Removing intermediate container b6c49a7101ee</span><br><span class="line"> ---&gt; d56853fe77c1</span><br><span class="line">Step 21/22 : HEALTHCHECK --interval=1m --start-period=5m    CMD &quot;$ORACLE_BASE/$CHECK_DB_FILE&quot; &gt;/dev/null || exit 1</span><br><span class="line"> ---&gt; Running in 656e69b54359</span><br><span class="line">Removing intermediate container 656e69b54359</span><br><span class="line"> ---&gt; c717fbcbc80e</span><br><span class="line">Step 22/22 : CMD exec $ORACLE_BASE/$RUN_FILE</span><br><span class="line"> ---&gt; Running in 730cea346f50</span><br><span class="line">Removing intermediate container 730cea346f50</span><br><span class="line"> ---&gt; 492ae2b9dbf8</span><br><span class="line">Successfully built 492ae2b9dbf8</span><br><span class="line">Successfully tagged oracle/database:19.3.0-ee</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Oracle Database container image for &#x27;ee&#x27; version 19.3.0 is ready to be extended: </span><br><span class="line">    </span><br><span class="line">    --&gt; oracle/database:19.3.0-ee</span><br><span class="line"></span><br><span class="line">  Build completed in 2288 seconds.</span><br></pre></td></tr></table></figure><p>正常启动日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"># docker-compose up</span><br><span class="line">Starting oracle ... done</span><br><span class="line">Attaching to oracle</span><br><span class="line">oracle    | ORACLE EDITION: ENTERPRISE   # ！！！ 版本为商业版</span><br><span class="line">oracle    | ORACLE PASSWORD FOR SYS, SYSTEM AND PDBADMIN: 123456  # ！！！ 密码较简单，下面会出现提示</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | LSNRCTL for Linux: Version 19.0.0.0.0 - Production on 02-MAR-2021 15:42:22</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | Copyright (c) 1991, 2019, Oracle.  All rights reserved.</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | Starting /opt/oracle/product/19c/dbhome_1/bin/tnslsnr: please wait...</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | TNSLSNR for Linux: Version 19.0.0.0.0 - Production</span><br><span class="line">oracle    | System parameter file is /opt/oracle/product/19c/dbhome_1/network/admin/listener.ora</span><br><span class="line">oracle    | Log messages written to /opt/oracle/diag/tnslsnr/153722b1c570/listener/alert/log.xml</span><br><span class="line">oracle    | Listening on: (DESCRIPTION=(ADDRESS=(PROTOCOL=ipc)(KEY=EXTPROC1)))</span><br><span class="line">oracle    | Listening on: (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=0.0.0.0)(PORT=1521)))</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | Connecting to (DESCRIPTION=(ADDRESS=(PROTOCOL=IPC)(KEY=EXTPROC1)))</span><br><span class="line">oracle    | STATUS of the LISTENER</span><br><span class="line">oracle    | ------------------------</span><br><span class="line">oracle    | Alias                     LISTENER</span><br><span class="line">oracle    | Version                   TNSLSNR for Linux: Version 19.0.0.0.0 - Production</span><br><span class="line">oracle    | Start Date                02-MAR-2021 15:42:22</span><br><span class="line">oracle    | Uptime                    0 days 0 hr. 0 min. 0 sec</span><br><span class="line">oracle    | Trace Level               off</span><br><span class="line">oracle    | Security                  ON: Local OS Authentication</span><br><span class="line">oracle    | SNMP                      OFF</span><br><span class="line">oracle    | Listener Parameter File   /opt/oracle/product/19c/dbhome_1/network/admin/listener.ora</span><br><span class="line">oracle    | Listener Log File         /opt/oracle/diag/tnslsnr/153722b1c570/listener/alert/log.xml</span><br><span class="line">oracle    | Listening Endpoints Summary...</span><br><span class="line">oracle    |   (DESCRIPTION=(ADDRESS=(PROTOCOL=ipc)(KEY=EXTPROC1)))</span><br><span class="line">oracle    |   (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=0.0.0.0)(PORT=1521)))  # ！！！端口</span><br><span class="line">oracle    | The listener supports no services</span><br><span class="line">oracle    | The command completed successfully</span><br><span class="line">oracle    | [WARNING] [DBT-06208] The &#x27;SYS&#x27; password entered does not conform to the Oracle recommended standards.</span><br><span class="line">oracle    |    CAUSE: </span><br><span class="line">oracle    | a. Oracle recommends that the password entered should be at least 8 characters in length, contain at least 1 uppercase character, 1 lower case character and 1 digit [0-9].</span><br><span class="line">oracle    | b.The password entered is a keyword that Oracle does not recommend to be used as password</span><br><span class="line">oracle    |    ACTION: Specify a strong password. If required refer Oracle documentation for guidelines.</span><br><span class="line">oracle    | [WARNING] [DBT-06208] The &#x27;SYSTEM&#x27; password entered does not conform to the Oracle recommended standards.</span><br><span class="line">oracle    |    CAUSE: </span><br><span class="line">oracle    | a. Oracle recommends that the password entered should be at least 8 characters in length, contain at least 1 uppercase character, 1 lower case character and 1 digit [0-9].</span><br><span class="line">oracle    | b.The password entered is a keyword that Oracle does not recommend to be used as password</span><br><span class="line">oracle    |    ACTION: Specify a strong password. If required refer Oracle documentation for guidelines.</span><br><span class="line">oracle    | [WARNING] [DBT-06208] The &#x27;PDBADMIN&#x27; password entered does not conform to the Oracle recommended standards.</span><br><span class="line">oracle    |    CAUSE: </span><br><span class="line">oracle    | a. Oracle recommends that the password entered should be at least 8 characters in length, contain at least 1 uppercase character, 1 lower case character and 1 digit [0-9].</span><br><span class="line">oracle    | b.The password entered is a keyword that Oracle does not recommend to be used as password</span><br><span class="line">oracle    |    ACTION: Specify a strong password. If required refer Oracle documentation for guidelines.</span><br><span class="line">oracle    | Prepare for db operation</span><br><span class="line">oracle    | 8% complete</span><br><span class="line">oracle    | Copying database files</span><br><span class="line">oracle    | 31% complete</span><br><span class="line">oracle    | Creating and starting Oracle instance</span><br><span class="line">oracle    | 32% complete</span><br><span class="line">oracle    | 36% complete</span><br><span class="line">oracle    | 40% complete</span><br><span class="line">oracle    | 43% complete</span><br><span class="line">oracle    | 46% complete</span><br><span class="line">oracle    | Completing Database Creation</span><br><span class="line">oracle    | 51% complete</span><br><span class="line">oracle    | 54% complete</span><br><span class="line">oracle    | Creating Pluggable Databases</span><br><span class="line">oracle    | 58% complete</span><br><span class="line">oracle    | 77% complete</span><br><span class="line">oracle    | Executing Post Configuration Actions</span><br><span class="line">oracle    | 100% complete</span><br><span class="line">oracle    | Database creation complete. For details check the logfiles at:</span><br><span class="line">oracle    |  /opt/oracle/cfgtoollogs/dbca/TOLLPDB.</span><br><span class="line">oracle    | Database Information:</span><br><span class="line">oracle    | Global Database Name:TOLLPDB</span><br><span class="line">oracle    | System Identifier(SID):TOLLPDB</span><br><span class="line">oracle    | Look at the log file &quot;/opt/oracle/cfgtoollogs/dbca/TOLLPDB/TOLLPDB0.log&quot; for further details.</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | SQL*Plus: Release 19.0.0.0.0 - Production on Tue Mar 2 16:09:31 2021</span><br><span class="line">oracle    | Version 19.3.0.0.0</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | Copyright (c) 1982, 2019, Oracle.  All rights reserved.</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | </span><br><span class="line">oracle    | Connected to:</span><br><span class="line">oracle    | Oracle Database 19c Enterprise Edition Release 19.0.0.0.0 - Production</span><br><span class="line">oracle    | Version 19.3.0.0.0</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | SQL&gt; </span><br><span class="line">oracle    | System altered.</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | SQL&gt; </span><br><span class="line">oracle    | System altered.</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | SQL&gt; </span><br><span class="line">oracle    | Pluggable database altered.</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | SQL&gt; </span><br><span class="line">oracle    | PL/SQL procedure successfully completed.</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | SQL&gt; Disconnected from Oracle Database 19c Enterprise Edition Release 19.0.0.0.0 - Production</span><br><span class="line">oracle    | Version 19.3.0.0.0</span><br><span class="line">oracle    | The Oracle base remains unchanged with value /opt/oracle</span><br><span class="line">oracle    | #########################</span><br><span class="line">oracle    | DATABASE IS READY TO USE! # ！！！ 数据库可用</span><br><span class="line">oracle    | #########################</span><br><span class="line">oracle    | The following output is now a tail of the alert.log:</span><br><span class="line">oracle    | FEE(3):Completed: ALTER DATABASE DEFAULT TABLESPACE &quot;USERS&quot;</span><br><span class="line">oracle    | 2021-03-02T16:09:31.874025+08:00</span><br><span class="line">oracle    | ALTER SYSTEM SET control_files=&#x27;/opt/oracle/oradata/TOLLPDB/control01.ctl&#x27; SCOPE=SPFILE;</span><br><span class="line">oracle    | 2021-03-02T16:09:31.898097+08:00</span><br><span class="line">oracle    | ALTER SYSTEM SET local_listener=&#x27;&#x27; SCOPE=BOTH;</span><br><span class="line">oracle    |    ALTER PLUGGABLE DATABASE FEE SAVE STATE</span><br><span class="line">oracle    | Completed:    ALTER PLUGGABLE DATABASE FEE SAVE STATE</span><br><span class="line">oracle    | 2021-03-02T16:09:33.007808+08:00</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | XDB initialized.</span><br></pre></td></tr></table></figure><p>停止后第二次启动的日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">Attaching to oracle</span><br><span class="line">oracle    | ORACLE EDITION: ENTERPRISE</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | LSNRCTL for Linux: Version 19.0.0.0.0 - Production on 02-MAR-2021 16:21:58</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | Copyright (c) 1991, 2019, Oracle.  All rights reserved.</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | Starting /opt/oracle/product/19c/dbhome_1/bin/tnslsnr: please wait...</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | TNSLSNR for Linux: Version 19.0.0.0.0 - Production</span><br><span class="line">oracle    | System parameter file is /opt/oracle/product/19c/dbhome_1/network/admin/listener.ora</span><br><span class="line">oracle    | Log messages written to /opt/oracle/diag/tnslsnr/11585b67b20f/listener/alert/log.xml</span><br><span class="line">oracle    | Listening on: (DESCRIPTION=(ADDRESS=(PROTOCOL=ipc)(KEY=EXTPROC1)))</span><br><span class="line">oracle    | Listening on: (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=0.0.0.0)(PORT=1521)))</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | Connecting to (DESCRIPTION=(ADDRESS=(PROTOCOL=IPC)(KEY=EXTPROC1)))</span><br><span class="line">oracle    | STATUS of the LISTENER</span><br><span class="line">oracle    | ------------------------</span><br><span class="line">oracle    | Alias                     LISTENER</span><br><span class="line">oracle    | Version                   TNSLSNR for Linux: Version 19.0.0.0.0 - Production</span><br><span class="line">oracle    | Start Date                02-MAR-2021 16:21:58</span><br><span class="line">oracle    | Uptime                    0 days 0 hr. 0 min. 0 sec</span><br><span class="line">oracle    | Trace Level               off</span><br><span class="line">oracle    | Security                  ON: Local OS Authentication</span><br><span class="line">oracle    | SNMP                      OFF</span><br><span class="line">oracle    | Listener Parameter File   /opt/oracle/product/19c/dbhome_1/network/admin/listener.ora</span><br><span class="line">oracle    | Listener Log File         /opt/oracle/diag/tnslsnr/11585b67b20f/listener/alert/log.xml</span><br><span class="line">oracle    | Listening Endpoints Summary...</span><br><span class="line">oracle    |   (DESCRIPTION=(ADDRESS=(PROTOCOL=ipc)(KEY=EXTPROC1)))</span><br><span class="line">oracle    |   (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=0.0.0.0)(PORT=1521)))</span><br><span class="line">oracle    | The listener supports no services</span><br><span class="line">oracle    | The command completed successfully</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | SQL*Plus: Release 19.0.0.0.0 - Production on Tue Mar 2 16:21:58 2021</span><br><span class="line">oracle    | Version 19.3.0.0.0</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | Copyright (c) 1982, 2019, Oracle.  All rights reserved.</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | Connected to an idle instance.</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | SQL&gt; ORACLE instance started.</span><br><span class="line">oracle    | </span><br><span class="line">oracle    | Total System Global Area 1610609888 bytes</span><br><span class="line">oracle    | Fixed Size                    9135328 bytes</span><br><span class="line">oracle    | Variable Size               402653184 bytes</span><br><span class="line">oracle    | Database Buffers   1191182336 bytes</span><br><span class="line">oracle    | Redo Buffers                  7639040 bytes</span><br><span class="line">oracle    | Database mounted.</span><br><span class="line">oracle    | Database opened.</span><br><span class="line">oracle    | SQL&gt; Disconnected from Oracle Database 19c Enterprise Edition Release 19.0.0.0.0 - Production</span><br><span class="line">oracle    | Version 19.3.0.0.0</span><br><span class="line">oracle    | The Oracle base remains unchanged with value /opt/oracle</span><br><span class="line">oracle    | #########################</span><br><span class="line">oracle    | DATABASE IS READY TO USE!</span><br><span class="line">oracle    | #########################</span><br><span class="line">oracle    | The following output is now a tail of the alert.log:</span><br><span class="line">oracle    | QPI: qopiprep.bat file present</span><br><span class="line">oracle    | 2021-03-02T16:22:33.798020+08:00</span><br><span class="line">oracle    | FEE(3):Opening pdb with no Resource Manager plan active</span><br><span class="line">oracle    | FEE(3):joxcsys_required_dirobj_exists: directory object exists with required path /opt/oracle/product/19c/dbhome_1/javavm/admin/, pid 119 cid 3</span><br><span class="line">oracle    | Pluggable database FEE opened read write</span><br><span class="line">oracle    | 2021-03-02T16:22:35.449498+08:00</span><br><span class="line">oracle    | Starting background process CJQ0</span><br><span class="line">oracle    | 2021-03-02T16:22:35.469509+08:00</span><br><span class="line">oracle    | CJQ0 started with pid=54, OS id=303 </span><br><span class="line">oracle    | Completed: ALTER DATABASE OPEN</span><br><span class="line">oracle    | 2021-03-02T16:22:40.261727+08:00</span><br><span class="line">oracle    | ===========================================================</span><br><span class="line">oracle    | Dumping current patch information</span><br><span class="line">oracle    | ===========================================================</span><br><span class="line">oracle    | Patch Id: 29517242</span><br><span class="line">oracle    | Patch Description: Database Release Update : 19.3.0.0.190416 (29517242)</span><br><span class="line">oracle    | Patch Apply Time: 2019-04-18T15:21:17+08:00</span><br><span class="line">oracle    | Bugs Fixed: 14735102,19697993,20313356,21965541,25806201,25883179,25986062,</span><br><span class="line">oracle    | 26476244,26611353,26872233,27369515,27423500,27666312,27710072,27846298,</span><br><span class="line">oracle    | 27957203,28064977,28072567,28129791,28181021,28210681,28279456,28313275,</span><br></pre></td></tr></table></figure><p>oracledata目录权限不足提示的信息：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> mkdir: cannot create directory &#x27;/opt/oracle/oradata/dbconfig&#x27;: Permission denied</span><br><span class="line">oracle    | mv: cannot stat &#x27;/opt/oracle/product/19c/dbhome_1/dbs/spfileTOLLPDB.ora&#x27;: No such file or directory</span><br><span class="line">oracle    | mv: cannot stat &#x27;/opt/oracle/product/19c/dbhome_1/dbs/orapwTOLLPDB&#x27;: No such file or directory</span><br><span class="line">oracle    | mv: cannot move &#x27;/opt/oracle/product/19c/dbhome_1/network/admin/sqlnet.ora&#x27; to &#x27;/opt/oracle/oradata/dbconfig/TOLLPDB/&#x27;: No such file or directory</span><br><span class="line">oracle    | mv: cannot move &#x27;/opt/oracle/product/19c/dbhome_1/network/admin/listener.ora&#x27; to &#x27;/opt/oracle/oradata/dbconfig/TOLLPDB/&#x27;: No such file or directory</span><br><span class="line">oracle    | mv: cannot move &#x27;/opt/oracle/product/19c/dbhome_1/network/admin/tnsnames.ora&#x27; to &#x27;/opt/oracle/oradata/dbconfig/TOLLPDB/&#x27;: No such file or directory</span><br><span class="line">oracle    | mv: cannot move &#x27;/opt/oracle/product/19c/dbhome_1/install/.docker_enterprise&#x27; to &#x27;/opt/oracle/oradata/dbconfig/TOLLPDB/&#x27;: No such file or directory</span><br><span class="line">oracle    | cp: cannot create regular file &#x27;/opt/oracle/oradata/dbconfig/TOLLPDB/&#x27;: No such file or directory</span><br><span class="line">oracle    | ln: failed to create symbolic link &#x27;/opt/oracle/product/19c/dbhome_1/network/admin/sqlnet.ora&#x27;: File exists</span><br><span class="line">oracle    | ln: failed to create symbolic link &#x27;/opt/oracle/product/19c/dbhome_1/network/admin/listener.ora&#x27;: File exists</span><br><span class="line">oracle    | ln: failed to create symbolic link &#x27;/opt/oracle/product/19c/dbhome_1/network/admin/tnsnames.ora&#x27;: File exists</span><br><span class="line">oracle    | cp: cannot stat &#x27;/opt/oracle/oradata/dbconfig/TOLLPDB/oratab&#x27;: No such file or directory</span><br><span class="line">oracle    | ORACLE_HOME = [/home/oracle] ? ORACLE_BASE environment variable is not being set since this</span><br><span class="line">oracle    | information is not available for the current user ID .</span><br><span class="line">oracle    | You can set ORACLE_BASE manually if it is required.</span><br><span class="line">oracle    | Resetting ORACLE_BASE to its previous value or ORACLE_HOME</span><br><span class="line">oracle    | The Oracle base remains unchanged with value /opt/oracle</span><br><span class="line">oracle    | /opt/oracle/checkDBStatus.sh: line 26: sqlplus: command not found</span><br><span class="line">oracle    | #####################################</span><br><span class="line">oracle    | ########### E R R O R ###############</span><br><span class="line">oracle    | DATABASE SETUP WAS NOT SUCCESSFUL!</span><br><span class="line">oracle    | Please check output for further info!</span><br><span class="line">oracle    | ########### E R R O R ###############</span><br><span class="line">oracle    | #####################################</span><br><span class="line">oracle    | The following output is now a tail of the alert.log:</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="曾经的尝试"><a href="#曾经的尝试" class="headerlink" title="曾经的尝试"></a>曾经的尝试</h2><p><strong>仅备档记录</strong>。 <strong>仅备档记录</strong>。 <strong>仅备档记录</strong>。 </p><p>进入容器，可用如下命令连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sqlplus /nolog</span><br><span class="line"></span><br><span class="line">sqlplus sys/123456@//localhost:1521/tollpdb as sysdba</span><br><span class="line">sqlplus system/123456@//localhost:1521/tollpdb</span><br><span class="line">sqlplus pdbadmin/123456@//localhost:1521/fee  # 注：修改密码，会登录失败，说明已经生效，但用navicat登录不了。</span><br><span class="line"></span><br><span class="line">select * from all_users;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用 navicat 使用 system/123456 可登录（此时应该是cbd)。但用fee和sysdba无法登录。原因未明。  </p><p>查看pdb：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sqlplus sys/123456@//localhost:1521/tollpdb as sysdba</span><br><span class="line"></span><br><span class="line">SQL&gt; show pdbs;</span><br><span class="line"></span><br><span class="line">    CON_ID CON_NAME                       OPEN MODE  RESTRICTED</span><br><span class="line">---------- ------------------------------ ---------- ----------</span><br><span class="line">         2 PDB$SEED                       READ ONLY  NO</span><br><span class="line">         3 FEE                            READ WRITE NO</span><br></pre></td></tr></table></figure><p>注：必须以sysdba登录，system查看提示<code>SP2-0382: The SHOW PDBS command is not available</code>。  </p><p>使用 sysdba 登录做一些操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">sqlplus / as sysdba</span><br><span class="line"></span><br><span class="line">SQL*Plus: Release 19.0.0.0.0 - Production on Wed Mar 3 10:11:26 2021</span><br><span class="line">Version 19.3.0.0.0</span><br><span class="line"></span><br><span class="line">Copyright (c) 1982, 2019, Oracle.  All rights reserved.</span><br><span class="line"></span><br><span class="line">Connected to an idle instance.   # ！！这里应该有错了</span><br><span class="line"></span><br><span class="line">SQL&gt; grant sysdba to system;  # ！！ 执行，但不可用</span><br><span class="line">grant sysdba to system</span><br><span class="line">*</span><br><span class="line">ERROR at line 1:</span><br><span class="line">ORA-01034: ORACLE not available  </span><br><span class="line">Process ID: 0</span><br><span class="line">Session ID: 0 Serial number: 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SQL&gt; show pdbs;               # ！！ 执行，但不可用</span><br><span class="line">ERROR:</span><br><span class="line">ORA-01034: ORACLE not available</span><br><span class="line">Process ID: 0</span><br><span class="line">Session ID: 0 Serial number: 0</span><br><span class="line"></span><br><span class="line">SP2-1545: This feature requires Database availability.</span><br><span class="line"></span><br><span class="line">SQL&gt; startup                  # ！！ 启动，但失败</span><br><span class="line">ORA-01078: failure in processing system parameters</span><br><span class="line">LRM-00109: could not open parameter file &#x27;/opt/oracle/product/19c/dbhome_1/dbs/inittollpdb.ora&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>拷贝一个inittollpdb.ora文件。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ORA-00845: MEMORY_TARGET not supported on this system</span><br><span class="line">共享内存太小了</span><br><span class="line"></span><br><span class="line">默认的init.ora中：memory_target=1G。</span><br><span class="line"></span><br><span class="line">ORA-01102: cannot mount database in EXCLUSIVE mode</span><br></pre></td></tr></table></figure><p>查看数据库是否为 CDB：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select CDB from v$database; -- 如果得到的结果为YES，那么就是CDB的数据库，否则，则不是。</span><br><span class="line">切入要操作的pdb</span><br><span class="line">show pdbs; -- 展示pdb数据库集合</span><br><span class="line">alter session set container=FEE; -- 切入到PDB 数据库</span><br><span class="line">alter session set container=CDB$ROOT; -- 切回到CDB 容器数据库</span><br></pre></td></tr></table></figure><p>2021年2月 开始着手研究，3月完成 李迟</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文涉及一种在容器中部署 oracle 数据库的方法。经验证，可达到预期目标，并能应用在实际工作中。    &lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="http://www.latelee.org/category/docker/"/>
    
    
    <category term="docker" scheme="http://www.latelee.org/tag/docker/"/>
    
  </entry>
  
  <entry>
    <title>nvidia TX2 DeepStream示例</title>
    <link href="http://www.latelee.org/ml/nvidia-deepstream-sample.html"/>
    <id>http://www.latelee.org/ml/nvidia-deepstream-sample.html</id>
    <published>2021-02-06T05:20:00.000Z</published>
    <updated>2021-06-04T02:18:55.890Z</updated>
    
    <content type="html"><![CDATA[<p>nvidia示例。</p><span id="more"></span><p><a href="https://github.com/NVIDIA-AI-IOT/redaction_with_deepstream/">https://github.com/NVIDIA-AI-IOT/redaction_with_deepstream/</a>  </p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例地址：<a href="https://github.com/NVIDIA-AI-IOT/deepstream_reference_apps">https://github.com/NVIDIA-AI-IOT/deepstream_reference_apps</a> 。克隆其到 `/opt/nvidia/deepstream/deepstream_reference_apps 。   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">模型文件：/opt/nvidia/deepstream/deepstream-5.0/samples/models</span><br><span class="line"></span><br><span class="line">示例文档：https://docs.nvidia.com/metropolis/deepstream/dev-guide/text/DS_ref_app_github.html  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">安装依赖：</span><br><span class="line">查看：/opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-app/README  </span><br><span class="line">命令：   </span><br><span class="line">sudo apt-get install libgstreamer-plugins-base1.0-dev libgstreamer1.0-dev \</span><br><span class="line">   libgstrtspserver-1.0-dev libx11-dev libjson-glib-dev</span><br><span class="line">编译：make （验证SDK、依赖是否完备）。  </span><br><span class="line"></span><br><span class="line">将 anomaly 拷贝到 /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/ ：</span><br><span class="line">cp  /opt/nvidia/deepstream/deepstream_reference_apps/anomaly/ /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/ </span><br><span class="line"></span><br><span class="line">进入目录：</span><br><span class="line">cd /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/anomaly</span><br><span class="line">编译库：</span><br><span class="line">cd plugins/gst-dsdirection/</span><br><span class="line">make &amp;&amp; sudo make install</span><br><span class="line"></span><br><span class="line">编辑 ./anomaly/apps/deepstream-anomaly-detection-test/dsanomaly_pgie_config.txt 文件。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2个示例：</span><br><span class="line">cd /opt/nvidia/deepstream/deepstream_reference_apps/anomaly/apps/deepstream-anomaly-detection-test</span><br><span class="line">./deepstream-anomaly-detection-app  /opt/nvidia/deepstream/deepstream/samples/streams/sample_720p.h264</span><br><span class="line"></span><br><span class="line">cd /opt/nvidia/deepstream/deepstream_reference_a</span><br><span class="line">-to-back-detectors</span><br><span class="line">./back-to-back-detectors /opt/nvidia/deepstream/deepstream/samples/streams/sample_720p.h264</span><br></pre></td></tr></table></figure><p>出错及解决：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">nvbuf_utils: Could not get EGL display connection：</span><br><span class="line">临时设置环境环境： export DISPLAY=:0</span><br><span class="line"></span><br><span class="line">One element could not be created. Exiting.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其他Github上的APP例子：</p><p>360度智能停车App</p><p> 演示了一个或者多个360度视角的视频流的矫正功能。从一个CSV文件中读取摄像机矫正参数，然后将矫正后的过道和区域画面，呈现在屏幕上。</p><p><a href="https://github.com/NVIDIA-AI-IOT/deepstream_360_d_smart_parking_application">https://github.com/NVIDIA-AI-IOT/deepstream_360_d_smart_parking_application</a></p><p>DeepStream SDK for Redaction </p><p>重点展示如何在DeepStream里，对一个视频流，同时对人脸区域和车牌区域进行模糊， 也展示了当该DeepStream流水线风格的应用程序在运行的时候，动态的添加删除视频流通道。</p><p><a href="https://github.com/NVIDIA-AI-IOT/redaction_with_deepstream">https://github.com/NVIDIA-AI-IOT/redaction_with_deepstream</a></p><p>异常检测参考应用</p><p>使用并行管道处理2个流的示例应用程序。</p><p><a href="https://github.com/NVIDIA-AI-IOT/deepstream_reference_apps/tree/master/anomaly">https://github.com/NVIDIA-AI-IOT/deepstream_reference_apps/tree/master/anomaly</a></p><p>是否有关于动态流管理的例子吗?</p><p><a href="https://github.com/NVIDIA-AI-IOT/deepstream_reference_apps/tree/master/anomaly">https://github.com/NVIDIA-AI-IOT/deepstream_reference_apps/tree/master/anomaly</a></p><p>里面包括了在管道运行时动态添加或删除通道。</p><p><a href="https://github.com/NVIDIA-AI-IOT/redaction_with_deepstream/">https://github.com/NVIDIA-AI-IOT/redaction_with_deepstream/</a>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;nvidia示例。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://www.latelee.org/category/ml/"/>
    
    
  </entry>
  
  <entry>
    <title>nvidia TX2 使用 SDK Manager工具刷机记录</title>
    <link href="http://www.latelee.org/ml/nvidia-flash-to-tx2-using-sdkmanager.html"/>
    <id>http://www.latelee.org/ml/nvidia-flash-to-tx2-using-sdkmanager.html</id>
    <published>2021-02-05T16:00:00.000Z</published>
    <updated>2021-06-04T02:18:55.874Z</updated>
    
    <content type="html"><![CDATA[<p>本文为使用 nvidia 提供的 SDK Manager（本文称 sdkmanager） 工具下载、烧写 Jetson TX2 的记录。本文根据笔者长时间的摸索经历，以有限的经验对刷机过程及要点进行描述，由于历时较长，<strong>本文所述步骤不保证是完完全全的实际操作顺序，仅供参考。</strong><br>本文不涉及 TX2 特性或功能或深度学习方面内容。<br>笔者仅以本文作记录，由于能力有限，对本文涉及的问题无法回答。  </p><span id="more"></span><h2 id="一、要点"><a href="#一、要点" class="headerlink" title="一、要点"></a>一、要点</h2><p>一些基础要点或要注意的事在此节说明。  </p><ul><li>TX2只支持HDMI接口，只有一个 usb 接口（要用 usbhub扩展）。使用 nvidia 原装 usb 线连接烧写。    </li><li>TX2有四个红色并排的按键，电源键标有POWER BTN，开机需要按稍长时间，板上有绿灯亮时松开即可。由开机键向左分别是强制恢复键 Force Recovery Button、用户定义键 User Defined Button 和复位键 Reset Button。在手动刷机情况下，要分别操作 Force Recovery Button 和 POWER BTN。见后文。  </li><li>sdkmanager 目前只有 Linux 版本，支持 ubuntu16.04 和 ubuntu18.04。使用大屏幕、大内存的好的机器，最好是物理机安装 ubuntu。如是虚拟机，连 usb 线时需要让虚拟机识别到 TX2。   </li><li>sdkmanager 集下载（系统镜像，软件包）、烧写（系统镜像，软件包）、卸载（软件包）、修复（软件包）功能。</li><li>sdkmanager 下载需要使用 nvidia 开发者账号，（免费）注册即可。  </li><li>sdkmanager 有 HOST 端和 TARGET 端之分，可按需下载烧写。如只烧写系统镜像或只安装软件。  </li><li>烧写 Linux 镜像后，需要在板子上做一些设置，如设置账号密码，连接WiFi等，进入系统后，有一网络设备默认IP为 192.168.55.1，该IP在 sdkmanager 中被使用。    </li></ul><h2 id="二、过程"><a href="#二、过程" class="headerlink" title="二、过程"></a>二、过程</h2><h3 id="2-1-环境准备"><a href="#2-1-环境准备" class="headerlink" title="2.1 环境准备"></a>2.1 环境准备</h3><p>sdkmanager 目前只有 Linux 版本。可用 ubuntu16.04 和 ubuntu18.04 发行版。内存最低为8GB，屏幕分辨率 1440x900 以上。内存过小会卡，分辨率过低则界面显示不完整，经测试，在 ubuntu16.04 系统中运行时可点击”View”-&gt;”Zoom Out”缩小界面。<br>需要联网，因为要从 nvidia 官网下载软件包。<br>如果要烧写，则需要使用原装 usb 线连接板子和PC。  </p><h3 id="2-2-注册账号"><a href="#2-2-注册账号" class="headerlink" title="2.2 注册账号"></a>2.2 注册账号</h3><p>下载软件需要注册，地址：<a href="https://developer.nvidia.com/login">https://developer.nvidia.com/login</a> 。<br>注：登录时需要输入账号密码，并点击符合要求的图案（如飞机，车之类的），以证明登录者是人类。  </p><h3 id="2-3-安装运行-sdkmanager"><a href="#2-3-安装运行-sdkmanager" class="headerlink" title="2.3 安装运行 sdkmanager"></a>2.3 安装运行 sdkmanager</h3><p>之前使用 jetpack 工具下载烧写的，目前是使用 sdkmanager，下载地址为：<a href="https://developer.nvidia.com/embedded/jetpack">https://developer.nvidia.com/embedded/jetpack</a> 。安装方式有两种，一是用 SD 卡镜像，二是使用 sdkmanager，即<code>NVIDIA SDK Manager method</code>，TX2 使用方法二。<br>本文使用的文件为<code>sdkmanager_1.4.0-7363_amd64.deb</code>，md5为<code>535b9b2b41248e89b839b6f5a3acb185</code>。安装命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install ./sdkmanager_1.4.0-7363_amd64.deb </span><br></pre></td></tr></table></figure><p>sdkmanager <strong>必须使用普通用户</strong>运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sdkmanager</span><br></pre></td></tr></table></figure><p>稍等片刻即可看到启动界面。如系统系统不满足最低要求会弹出提示框，如图1所示。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/1.png" alt="图1"><br>点击Yes进入登录界面。如图2所示。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/2.png" alt="图2"><br>第三个页面为离线包方式，适用已下载软件包情况，不用登录，选择已经下载好软件包的目录，点击“START”即可开始。第一页面为即本文所用的方式。点击Login，在自动打开的浏览器中输入账号，再输入密码，点击图案验证。建议保存密码减少操作。图3为已经验证即将登录的界面。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/3.png" alt="图3">  </p><p>登录过程中，可能会遇到一些问题，如下：<br>1、提示<code>no SDKs available for your account</code>，网上有说法执行<code>sudo updatedb</code>可解决，笔者验证未成功。<br>2、提示<code>Failed to get client token</code>，重试多次未能解决，未知原因。<br>3、卡在<code>Loading and processing available products...</code>，重试多次可解决。  </p><h3 id="2-4-下载软件"><a href="#2-4-下载软件" class="headerlink" title="2.4 下载软件"></a>2.4 下载软件</h3><p>成功登录后进入第一步骤配置，如图4所示。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/4.png" alt="图4"><br>主要有四项内容，第一为产品目录，即 Jetson，第二为硬件配置，分为主机端和目标板端，本文不使用主机端配置（目前没有需要在主机做开发），由于笔者连接了板子，故图4中已检测到 TX2。也可以手动点击右下角的<code>...</code>选择实际板子型号。第三为系统版本，目前为 4.5 版本。最后是 deepstream，版本为5.0，为可选项，笔者不想在后续单独安装，因此也选上了。  </p><p>点击“CONTINUE”进入第二步骤。如图5所示。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/5.png" alt="图5"><br>软件包括了系统镜像和SDK两大类软件，默认全选，也可分别安装。页面底部有默认下载和安装目录，也可手动指定，默认目录不存在，会提示创建目录。勾选接受协议。如果只希望下载软件，则勾选<code>Download now, Install later.</code>。笔者建议勾选。因为下载十分耗时，且容易出错。<br>点击“CONTINUE”进入第三步骤。图6为即将下载的界面。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/6.png" alt="图6">  </p><p>此时可在 TERMINAL 中查看日志，如图7所示。也可查看<code>~/.nvsdkm/sdkm.log</code>文件（<code>~/.nvsdkm</code>是 sdkmanager 日志所在目录）。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/7.png" alt="图7">  </p><p>经过十分漫长的等待，完成下载，如图8所示。点击 FINISH 退出。<strong>如果下载、安装一并进行，下载完成后进入安装步骤，FINISH 表示最终的完成</strong>。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/8.png" alt="图8">  </p><p>注：<br>1、下载十分耗时，而且容易出错，所以板子不用开机，也不用连接PC。<br>2、sdkmanager 下载速度与网络有关。<br>3、关于下载失败的终极解决方法：<strong>重试，多重试，多次重试，换台电脑试，换个网络再试，隔一段时间重试。</strong><br>4、笔者经过多次尝试，在 sdkmanager 中均无法完整下载，后想到一种笨方法。当 sdkmanager 下载失败时，在默认的下载目录 <code>/home/latelee/Downloads/nvidia/sdkm_downloads</code><br>中查看下载的软件包（有deb包、zip包等，未下载完成的以mtd结尾），再在 sdkmanager 日志中查看软件包的下载地址，一一列出。然后在 Windows 的浏览器中登录 nvidia官网，再粘贴下载地址下载（运行了某种工具以保证官方网站连接畅通）。共63个文件，大的有1.8GB，小的有数十KB。 </p><p>另外，在不同时候下载，个别软件包的版本不同，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NsightSystems-linux-public-2020.5.3.17-0256620.deb</span><br><span class="line">NsightSystems-linux-public-2020.4.2.18-f0b18f6.deb</span><br><span class="line"></span><br><span class="line">nvidia-l4t-jetson-multimedia-api_32.4.4-20201016123640_arm64.deb</span><br><span class="line">nvidia-l4t-jetson-multimedia-api_32.5.0-20210115151051_arm64.deb</span><br></pre></td></tr></table></figure><p>从软件包日期也可看到笔者进行较长时间的尝试。  </p><p>如有兴趣，可到<strong>附3：提示及日志</strong>的<strong>部分下载失败日志</strong>处查看失败日志。  </p><h3 id="2-5-安装软件"><a href="#2-5-安装软件" class="headerlink" title="2.5 安装软件"></a>2.5 安装软件</h3><p>这里的“软件”包括了系统（和驱动）以及 sdk 软件。对于系统而言，实际应该是“烧写”而不是安装。<br>系统镜像（OS镜像）和sdk可分开安装，如果在安装sdk出错，下次重试时，可取消系统的安装，节省时间。本文完全刷机，所以两者均安装。<br>执行之前，sdkmanager 会弹出对话框输入密码，因为有些操作需要 root 权限。<br>真正烧写镜像前，sdkmanager 会创建OS镜像，默认位于<code>~/nvidia/nvidia_sdk</code>目录，如图9所示，第一进度条表示正在创建 Jetson OS 镜像。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/9.png" alt="图9"><br>在此过程，也可点击 TERMINAL 查看日志，如图10所示。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/10.png" alt="图10"><br>注意，从图10可看到下载目录为非默认目录，该目录就是笔者手动下载并拷贝到 Linux 虚拟机中的目录。<br>当 OS 镜像准备完毕后，出现烧写提示。方式有二，图11所示为自动方式，TX2 板子要开机，并且联网，输入 TX2 正在使用的账号密码，注意，IP地址不需要修改，使用默认的即可。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/11.png" alt="图11"><br>当系统损坏无法启动时，可选择手动模式，手动模式需要在板子上按键操作，按键操作为：按住恢复键，再按一次电源键，最后松开恢复键。其界面如图12所示。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/12.png" alt="图12"><br>本文选择自动方式（实际也尝试了手动方式），烧写过程比较耗时。如果超过时间，sdkmanager 会提示，如图13所示。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/13.png" alt="图13"><br>烧写结束之后 TX2 会关机。如果使用虚拟机，此过程要保持鼠标在虚拟机内，以保证 TX2 总能被虚拟机识别。<br>TX2 重新启动后板子显示器出现系统配置界面，第一个界面为接受协议，如图14所示。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/14.png" alt="图14"> </p><p>后续界面依次为：选择语言，选择键盘，连接WiFi（笔者手上没有多余网线，只能用WiFi），选择时区，账号密码（可选自动登录），Nvpmodel模式，除WiFi和账号密码要输入信息外，其它用默认即可。等待片刻自动重启，之后进入系统，此时已经有了基本可用的系统（当然还用不了cuda）。  </p><p>此时可在 TX2 系统中查看板子IP，网络设备 l4tbr0 的 IP 为 192.168.55.1，对应的，PC端网络设备 ens35u1i5 IP 为 192.168.55.100。两系统可互相 ping 通。  </p><p>系统镜像烧写成功后，sdkmanager 进入安装 sdk 阶段（sdk 可单独安装，过程相同）。如图15所示。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/15.png" alt="图15"> </p><p>输入刚才设置的账号和密码。图16为正在安装sdk包界面。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/16.png" alt="图16"> </p><p>再经过一段时间等待，安装成功，如图17所示，点击 FINISH 完成任务。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/17.png" alt="图17"> </p><p>TX2 系统默认桌面如图18所示。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/18.png" alt="图18">   </p><p>注：<br>本节步骤不一定反映实际情况，因为会经常中断。<br>烧写系统镜像过程如果断开，会从头开始，如果已经进行一半，此时系统可能会损坏，如是则要用手动模式。<br>耗时：在下载好软件包情况下，晚8点开始，至12点前结束，期间中断了3次。  </p><h3 id="2-6-验证程序"><a href="#2-6-验证程序" class="headerlink" title="2.6 验证程序"></a>2.6 验证程序</h3><p>前面刷机已经勾选了 DeepStream，可直接使用。进入 TX2 系统，查看 DeepStream 版本信息：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ deepstream-app --version-all</span><br><span class="line">2021-02-04 23:51:41.044864: I tensorflow/stream_executor/platform/default/dso_loader.cc:48] Successfully opened dynamic library libcudart.so.10.2</span><br><span class="line">deepstream-app version 5.0.0</span><br><span class="line">DeepStreamSDK 5.0.0</span><br><span class="line">CUDA Driver Version: 10.2</span><br><span class="line">CUDA Runtime Version: 10.2</span><br><span class="line">TensorRT Version: 7.1</span><br><span class="line">cuDNN Version: 8.0</span><br><span class="line">libNVWarp360 Version: 2.0.1d3</span><br></pre></td></tr></table></figure><p>可用如下命令查看和nvidia有关的插件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gst-inspect-1.0 -a | grep -i nvidia</span><br></pre></td></tr></table></figure><p>编译、运行自带的示例工程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-test1</span><br><span class="line">make</span><br><span class="line">./deepstream-test1-app /opt/nvidia/deepstream/deepstream/samples/streams/sample_720p.h264 </span><br></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Now playing: /opt/nvidia/deepstream/deepstream/samples/streams/sample_720p.h264</span><br><span class="line"></span><br><span class="line">Using winsys: x11 </span><br><span class="line">Opening in BLOCKING MODE</span><br><span class="line">Opening in BLOCKING MODE </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>效果如图19所示。<br><img src="/ml/nvidia-flash-to-tx2-using-sdkmanager/19.png" alt="图19">  </p><h2 id="三、参考资源"><a href="#三、参考资源" class="headerlink" title="三、参考资源"></a>三、参考资源</h2><p>sdkmanager官方使用说明： <a href="https://docs.nvidia.com/sdk-manager/install-with-sdkm-jetson/index.html">https://docs.nvidia.com/sdk-manager/install-with-sdkm-jetson/index.html</a><br>sdkmanager配置：<a href="https://docs.nvidia.com/sdk-manager/sdkm-settings/index.html">https://docs.nvidia.com/sdk-manager/sdkm-settings/index.html</a><br>NVIDIA Jetson TX2 上手指南：<a href="https://blog.csdn.net/qq_36782182/article/details/91488284">https://blog.csdn.net/qq_36782182/article/details/91488284</a>  </p><h2 id="附1：尝试"><a href="#附1：尝试" class="headerlink" title="附1：尝试"></a>附1：尝试</h2><p>本节记录个人的尝试，流行话叫“踩坑”。<br>无物理机，故使用虚拟机，但内存不够大，屏幕不够大（本本是7、8年前买的），分辨率和内存满足不了 sdkmanager 最低要求。<br>先安装使用ubuntu18.04，但 sdkmanager 无法缩小，操作不便，找不到同意协议选项，无法执行。<br>改用之前在 VirtualBox 上安装的 lubuntu1604，其资源占用稍少，但亦无缩小，多次重启，提示<code>The virtual machine &#39;lubuntu1604&#39; has terminated unexpectedly during startup with exit code 1</code>，所有 VirtualBox 虚拟机系统损坏无法使用。<br>最后用 ubuntu16.04，点击标题<code>View</code>中进行缩小。可顺利进行。  </p><h2 id="附2：成果"><a href="#附2：成果" class="headerlink" title="附2：成果"></a>附2：成果</h2><p>1、刷机过程生成的日志已存放 github 备份。<br>2、下载的软件包只在 TX2 测试通过，约6GB，已整合为 docker 镜像，并上传至阿里云仓库备份。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t registry.cn-hangzhou.aliyuncs.com/latelee/deepstream:tx2 .</span><br><span class="line">docker push registry.cn-hangzhou.aliyuncs.com/latelee/deepstream:tx2</span><br></pre></td></tr></table></figure><p>镜像说明：包括 TAEGET 端所有的包以及部分 HOST 端的包。运行后在容器的 <code>/nvidia</code> 目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name foobar registry.cn-hangzhou.aliyuncs.com/latelee/deepstream:tx2 sh</span><br><span class="line">docker exec -it foobar sh</span><br><span class="line">ls /nvidia</span><br></pre></td></tr></table></figure><p>逐一拷贝：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir my_download</span><br><span class="line">docker cp foobar:/nvidia/Tegra_Linux_Sample-Root-Filesystem_R32.5.0_aarch64.tbz2 my_download</span><br><span class="line">docker cp foobar:/nvidia/cuda-repo-l4t-10-2-local-10.2.89_1.0-1_arm64.deb my_download</span><br><span class="line">其它文件类似</span><br></pre></td></tr></table></figure><p>Dockerfile：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM latelee/busybox </span><br><span class="line">RUN mkdir /nvidia  </span><br><span class="line">COPY cuda-repo-cross-aarch64-10-2-local-10.2.89_1.0-1_all.deb  /nvidia</span><br><span class="line">COPY cuda-repo-l4t-10-2-local-10.2.89_1.0-1_arm64.deb  /nvidia</span><br><span class="line">其它文件类似</span><br></pre></td></tr></table></figure><h3 id="附3：提示及日志"><a href="#附3：提示及日志" class="headerlink" title="附3：提示及日志"></a>附3：提示及日志</h3><p>启动显示系统最低要求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Warning</span><br><span class="line">Could not detect SDK Manager&#x27;s minimal system requirement(s):</span><br><span class="line"> - Minimum of 7.5GB of RAM (4.74GB detected)</span><br><span class="line"> - Screen resolution equal or larger than 1440x900 (800x600 detected)</span><br><span class="line"></span><br><span class="line">Do you wish to continue?</span><br></pre></td></tr></table></figure><p>部分下载失败日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">未授权的（一般是之前已经登录，但过期了）</span><br><span class="line">01:49:33 : CUDA on Host: download https://developer.nvidia.com/assets/embedded/secure/tools/files/jetpack-sdks/jetpack-4.4.1/JETPACK_441_b50/ubuntu1604/cuda-repo-ubuntu1604-10-2-local-10.2.89-440.40_1.0-1_amd64.deb failed, retrying 1...</span><br><span class="line">01:49:33 INFO: CUDA on Host: start to download https://developer.nvidia.com/assets/embedded/secure/tools/files/jetpack-sdks/jetpack-4.4.1/JETPACK_441_b50/ubuntu1604/cuda-repo-ubuntu1604-10-2-local-10.2.89-440.40_1.0-1_amd64.deb to /home/ubuntu/Downloads/nvidia/sdkm_downloads/cuda-repo-ubuntu1604-10-2-local-10.2.89-440.40_1.0-1_amd64.deb</span><br><span class="line">01:49:36 ERROR: CUDA on Host: DevZone get download url failed: HTTPError: Response code 401 (Unauthorized).</span><br><span class="line">01:49:36 ERROR: CUDA on Host: Download &#x27;CUDA on Host&#x27; failure</span><br><span class="line">01:49:36 ERROR: CUDA on Host: DevZone get download url failed: HTTPError: Response code 401 (Unauthorized).</span><br><span class="line">01:49:36 ERROR: CUDA on Host: Download &#x27;CUDA on Host&#x27; failure</span><br><span class="line">01:49:36 ERROR: CUDA on Host: download failed</span><br><span class="line"></span><br><span class="line">网络断开的</span><br><span class="line">22:02:21 : CUDA on Host: download https://developer.nvidia.com/assets/embedded/secure/tools/files/jetpack-sdks/jetpack-4.4.1/JETPACK_441_b50/ubuntu1604/cuda-repo-ubuntu1604-10-2-local-10.2.89-440.40_1.0-1_amd64.deb failed, retrying 1...</span><br><span class="line">22:02:21 INFO: CUDA on Host: start to download https://developer.nvidia.com/assets/embedded/secure/tools/files/jetpack-sdks/jetpack-4.4.1/JETPACK_441_b50/ubuntu1604/cuda-repo-ubuntu1604-10-2-local-10.2.89-440.40_1.0-1_amd64.deb to /home/ubuntu/Downloads/nvidia/sdkm_downloads/cuda-repo-ubuntu1604-10-2-local-10.2.89-440.40_1.0-1_amd64.deb</span><br><span class="line">22:02:37 ERROR: CUDA on Host: DevZone get download url failed: RequestError: Client network socket disconnected before secure TLS connection was established.</span><br><span class="line">22:02:37 ERROR: CUDA on Host: Download &#x27;CUDA on Host&#x27; failure</span><br><span class="line">22:02:37 ERROR: CUDA on Host: DevZone get download url failed: RequestError: Client network socket disconnected before secure TLS connection was established.</span><br><span class="line">22:02:37 ERROR: CUDA on Host: Download &#x27;CUDA on Host&#x27; failure</span><br><span class="line">22:02:37 ERROR: CUDA on Host: download failed</span><br><span class="line"></span><br><span class="line">网络有问题的</span><br><span class="line">22:42:24 INFO: DeepStream: start to download https://developer.nvidia.com/assets/embedded/secure/tools/files/jetpack-sdks/jetpack-4.4.1/JETPACK_441_b50_DEEPSTREAM/deepstream-5.0_5.0.1-1_arm64.deb to /home/ubuntu/Downloads/nvidia/sdkm_downloads/deepstream-5.0_5.0.1-1_arm64.deb</span><br><span class="line">22:43:31 ERROR: DeepStream: Head request failed on host: ECONNRESET. Error: socket hang uphttps://developer.download.nvidia.com/assets/embedded/secure/tools/files/jetpack-sdks/jetpack-4.4.1/JETPACK_441_b50_DEEPSTREAM/deepstream-5.0_5.0.1-1_arm64.deb?IQOvXtJ6q2h7wEVW_SUReWVsdQk8i0duzlCSFmayyqE8duPuyZPhND_O1S6yd6hoXuobjaYpB8MKsg-8fadWWALJQBs8m_SAwYpFD9-XvCrw1tt1CCtlt7547_3c0P3GoXqi85jW_LogPq06flT9gCxtYNxjhENTzdQA80uZeV3ZEKh4PUJO9Gvtl1aqWzBugJ1W1T6PwrLIM-GWXQQR3p3idZlx-OltlatQEFGv2cyhXv-Ty2l8dg</span><br><span class="line">22:43:31 ERROR: DeepStream: Download &#x27;DeepStream&#x27; failure</span><br><span class="line">22:43:31 ERROR: DeepStream: Head request failed on host: ECONNRESET. Error: socket hang uphttps://developer.download.nvidia.com/assets/embedded/secure/tools/files/jetpack-sdks/jetpack-4.4.1/JETPACK_441_b50_DEEPSTREAM/deepstream-5.0_5.0.1-1_arm64.deb?IQOvXtJ6q2h7wEVW_SUReWVsdQk8i0duzlCSFmayyqE8duPuyZPhND_O1S6yd6hoXuobjaYpB8MKsg-8fadWWALJQBs8m_SAwYpFD9-XvCrw1tt1CCtlt7547_3c0P3GoXqi85jW_LogPq06flT9gCxtYNxjhENTzdQA80uZeV3ZEKh4PUJO9Gvtl1aqWzBugJ1W1T6PwrLIM-GWXQQR3p3idZlx-OltlatQEFGv2cyhXv-Ty2l8dg</span><br><span class="line">22:43:31 ERROR: DeepStream: Download &#x27;DeepStream&#x27; failure</span><br><span class="line">22:43:31 ERROR: DeepStream: download failed</span><br><span class="line">22:43:31 ERROR: DeepStream: Download &#x27;DeepStream&#x27; failure</span><br><span class="line">22:43:31 ERROR: DeepStream: download failed</span><br><span class="line"></span><br><span class="line">拒绝连接的</span><br><span class="line">22:55:51 INFO: CUDA on Host: start to download https://developer.nvidia.com/assets/embedded/secure/tools/files/jetpack-sdks/jetpack-4.4.1/JETPACK_441_b50/ubuntu1604/cuda-repo-ubuntu1604-10-2-local-10.2.89-440.40_1.0-1_amd64.deb to /home/ubuntu/Downloads/nvidia/sdkm_downloads/cuda-repo-ubuntu1604-10-2-local-10.2.89-440.40_1.0-1_amd64.deb</span><br><span class="line">22:55:51 ERROR: CUDA on Host: The .mtd file is corrupt. Start a new download.</span><br><span class="line">22:55:51 ERROR: CUDA on Host: Download &#x27;CUDA on Host&#x27; failure</span><br><span class="line">22:55:51 ERROR: CUDA on Host: The .mtd file is corrupt. Start a new download.</span><br><span class="line">22:55:51 ERROR: CUDA on Host: Download &#x27;CUDA on Host&#x27; failure</span><br><span class="line">22:55:51 ERROR: CUDA on Host: download failed</span><br><span class="line"></span><br><span class="line">22:57:14 ERROR: DeepStream: DevZone get download url failed: RequestError: connect ECONNREFUSED 128.1.83.20:443.</span><br><span class="line">22:57:14 ERROR: DeepStream: Download &#x27;DeepStream&#x27; failure</span><br><span class="line">22:57:14 ERROR: DeepStream: DevZone get download url failed: RequestError: connect ECONNREFUSED 128.1.83.20:443.</span><br><span class="line">22:57:14 ERROR: DeepStream: Download &#x27;DeepStream&#x27; failure</span><br><span class="line">22:57:14 ERROR: DeepStream: download failed</span><br><span class="line"></span><br><span class="line">连接重置的</span><br><span class="line">00:05:35 ERROR: DeepStream: Head request failed on host: ECONNRESET. Error: read ECONNRESEThttps://developer.download.nvidia.com/assets/embedded/secure/tools/files/jetpack-sdks/jetpack-4.4.1/JETPACK_441_b50_DEEPSTREAM/deepstream-5.0_5.0.1-1_arm64.deb?FlpOvCmigTA5N-TqbXBm-hfRtR6pMsu_xxBikJ2lu_xusmVBC6WA4nupxDJwHA3jAjOiheJW8KuUzRs5xGE-u4HwBi98x5Xc_2pdtZURC-MmgH4a48ptyI0Xy9xkMayuLRdKXdK8hdINsiIlgUGf8uZbtkvFE_KJHO54WgiuyEPLdeoCE3K6AXPvQ0mdYjhMMYzGKrZR04YnZXJp_kZ5lH051Srg7VadNK1_X_g6UxPRuQWwId3cDQ</span><br><span class="line">00:05:35 ERROR: DeepStream: Download &#x27;DeepStream&#x27; failure</span><br><span class="line">00:05:35 ERROR: DeepStream: download failed</span><br><span class="line">00:05:35 : DeepStream: download https://developer.nvidia.com/assets/embedded/secure/tools/files/jetpack-sdks/jetpack-4.4.1/JETPACK_441_b50_DEEPSTREAM/deepstream-5.0_5.0.1-1_arm64.deb failed, retrying 1...</span><br><span class="line"></span><br><span class="line">其它未列举的</span><br></pre></td></tr></table></figure><p>烧写过程中出错，已有下载的包，且md5sum正确，但提示出错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">23:30:53 INFO: NVIDIA Container Runtime with Docker integration (Beta): verifying checksum of /home/latelee/Downloads/nvidia/my_download/nvidia-container-runtime_3.1.0-1_arm64.deb</span><br><span class="line">23:30:53 INFO: NVIDIA Container Runtime with Docker integration (Beta): Found file /home/latelee/Downloads/nvidia/my_download/nvidia-container-runtime_3.1.0-1_arm64.deb with correct checksum, skip downloading.</span><br><span class="line">23:30:53 INFO: NVIDIA Container Runtime with Docker integration (Beta): verifying checksum of /home/latelee/Downloads/nvidia/my_download/nvidia-docker2_2.2.0-1_all.deb</span><br><span class="line">23:30:53 INFO: NVIDIA Container Runtime with Docker integration (Beta): Found file /home/latelee/Downloads/nvidia/my_download/nvidia-docker2_2.2.0-1_all.deb with correct checksum, skip downloading.</span><br><span class="line">23:31:58 SUMMARY: NVIDIA Container Runtime with Docker integration (Beta): Depends on failed component</span><br><span class="line">23:31:58 SUMMARY: NVIDIA Container Runtime with Docker integration (Beta): Depends on failed component</span><br><span class="line">23:31:58 SUMMARY: NVIDIA Container Runtime with Docker integration (Beta): Depends on failed component</span><br><span class="line"></span><br><span class="line">3:30:53 INFO: Multimedia API: verifying checksum of /home/latelee/Downloads/nvidia/my_download/nvidia-l4t-jetson-multimedia-api_32.5.0-20210115151051_arm64.deb</span><br><span class="line">23:30:54 INFO: Multimedia API: Found file /home/latelee/Downloads/nvidia/my_download/nvidia-l4t-jetson-multimedia-api_32.5.0-20210115151051_arm64.deb with correct checksum, skip downloading.</span><br><span class="line">23:31:58 SUMMARY: Multimedia API: Depends on failed component</span><br><span class="line">23:31:58 SUMMARY: Multimedia API: Depends on failed component</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>个人猜测：没有完成所有包的检测，没有做标记，因此有些包的依赖没有记录，所以提示出错。多次从头重试可解决。  </p><p>李迟 2021.2.6 周六</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文为使用 nvidia 提供的 SDK Manager（本文称 sdkmanager） 工具下载、烧写 Jetson TX2 的记录。本文根据笔者长时间的摸索经历，以有限的经验对刷机过程及要点进行描述，由于历时较长，&lt;strong&gt;本文所述步骤不保证是完完全全的实际操作顺序，仅供参考。&lt;/strong&gt;&lt;br&gt;本文不涉及 TX2 特性或功能或深度学习方面内容。&lt;br&gt;笔者仅以本文作记录，由于能力有限，对本文涉及的问题无法回答。  &lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://www.latelee.org/category/ml/"/>
    
    
  </entry>
  
  <entry>
    <title>新年新计划-2021年</title>
    <link href="http://www.latelee.org/the-life/2021-new-plan.html"/>
    <id>http://www.latelee.org/the-life/2021-new-plan.html</id>
    <published>2021-01-31T16:00:00.000Z</published>
    <updated>2021-06-04T02:18:55.970Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>无意间回顾博客目录，发现上一篇新年计划，是2015年2月份写的。一年之计在于春，也开始尝试写写计划。  </p><span id="more"></span><h2 id="心态方面"><a href="#心态方面" class="headerlink" title="心态方面"></a>心态方面</h2><p>承认自己是个普通人，认知有限。赚不到认知以外的钱，学不了能力之外的技术。<br>不用太理会别人的意见和看法。（注：这里有个“太”字）<br>不与不在同一频道的人争论。  </p><h2 id="工作方面"><a href="#工作方面" class="headerlink" title="工作方面"></a>工作方面</h2><p>认真工作，提升存在感。注：今年只跟部门一把手聊过两回，一是试用期考核，领导问我工作怎样。二是在电梯，领导看到我的破包叫我换。<br>和同事和睦相处，对待正式同事，要特别热情友好。<br>对于自己擅长的领域，适当在同事面前展示一二。<br>笑脸迎人，骂不还口，不带情绪办公。争取加班随叫随到，不能者，亦解释。（注：心里骂几句亦可）  </p><h2 id="技能提升方面"><a href="#技能提升方面" class="headerlink" title="技能提升方面"></a>技能提升方面</h2><p>以家庭为重心，少接不熟悉领域的私活。尽量少熬夜，防止寿命减少。<br>阅读几本专业书，可慢，贵在理解和应用。不贪快，不贪多。暂有目标：《重构》第2版。<br>考证：架构师。以考促学，研究和架构，分布式有关的领域基础知识。（注1：是“基础知识”；注2：没提一定必须考过）<br>写一篇论文发表。评一下职称。（注：论文是“发表”，职称没提一定要得）  </p><h2 id="家庭生活方面"><a href="#家庭生活方面" class="headerlink" title="家庭生活方面"></a>家庭生活方面</h2><p>骂不还口。如有脾气或生闷气，不能超过3天。<br>勤力做家务，及时做家务。<br>巩固并提升做菜水平，注重家常。<br>对待小孩，该打还得打，该讲道理要讲，该宠也得宠。<br>给李大锤练耐力（跑步），胆量（未想好）。陪大锤爬山、看夕阳。<br>巩固并继续诗歌（诗词）的教育。开始白话的训练。<br>争取带李大妞去公园玩。  </p><p>李迟 2021.02.01</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;无意间回顾博客目录，发现上一篇新年计划，是2015年2月份写的。一年之计在于春，也开始尝试写写计划。  &lt;/p&gt;</summary>
    
    
    
    <category term="生活掠影" scheme="http://www.latelee.org/category/the-life/"/>
    
    
    <category term="新年计划" scheme="http://www.latelee.org/tag/%E6%96%B0%E5%B9%B4%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>几个共享方法的小结</title>
    <link href="http://www.latelee.org/code-life/backup-works.html"/>
    <id>http://www.latelee.org/code-life/backup-works.html</id>
    <published>2021-01-30T16:00:00.000Z</published>
    <updated>2021-06-04T02:18:55.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文涉及的“共享”实际是不同系统，不同网络，不同地点的文件共享。比如网盘。<br>文中所涉，几乎是笔者使用（过）的方式。随意写写，不一定正确。    </p><span id="more"></span><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在公司编写完的代码，如何方便在家里也能更新到？<br>nvidia的cuda库，国内下载慢，如何下载？<br>某台远程电脑可以到外网下载，下载完后，如何传到自己电脑？<br>k8s部署所用的gcr如何下载？<br>（不）知网的论文如何下载？  </p><h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><h3 id="网盘"><a href="#网盘" class="headerlink" title="网盘"></a>网盘</h3><p>常用方式，可共享给他人，或自用。<br>优点：<br>缺点：云盘为第三方，不一定能随时提供服务，甚至断供。    </p><h3 id="云主机"><a href="#云主机" class="headerlink" title="云主机"></a>云主机</h3><p>使用个人云主机做中转，只要支持ssh或可用浏览器，即可实现共享。<br>云主机自建http服务器，可用浏览器下载。<br>优点：<br>缺点：</p><h3 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h3><p>如gitlab和github等，可在一网络（系统）提交，在另一网络（系统）更新，完成共享。  </p><h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><p>利用dockerhub，在将需要共享的文件做成docker镜像，再上传到网络，再在另一网络（系统）下载。<br>利用dockerhub，在dockerfile中从外网下载，设置自动构建或手动触发，完成docker镜像时，即可下载。<br>如不涉及外网，可使用阿里云docker仓库，添加加速地址，提升速度。  </p><p>如果体积大，构建时，可在dockerfile逐条命令拷贝，这样逐层下载。  </p><p>案例：<br>1.某年安装 cuda 驱动，使用某雷下载，看体积似乎完整，但安装只有部分成功。最终发现md5sum不一致（耗时几天才发现此问题）。解决：编写Dockefile，根据cuda地址下载。提交github，在dockerhub触发构建，生成镜像，下载镜像，运行，从中取文件。    </p><h3 id="墙里墙外"><a href="#墙里墙外" class="headerlink" title="墙里墙外"></a>墙里墙外</h3><p>墙太高了，需要使用梯子，或自建，或购买。如google搜索或google代码，golang有些文档和代码亦在外网。  </p><p>国内一些大厂有镜像网站，可同步国外资源。如淘宝的npm。如ubuntu官方会提供部分大学镜像网站。      </p><p>一些开源项目可能同时在github上有镜像仓库（有的甚至在gitee上也有镜像仓库），可用之。  </p><p>国内一些教育机构（如图书馆）、学校购买了数据库，可下载论文/专利。一般需要注册。（如笔者的图书馆证已经八、九年历史时，虽然证不见了，但账号依然能用。当年独自一人去，后陪女朋友去，现陪大锤去）  </p><p>联系学校老师学长学姐学弟学妹帮忙。  </p><h2 id="文字共享"><a href="#文字共享" class="headerlink" title="文字共享"></a>文字共享</h2><p>文字有纸质的，也有电子的。<br>平时在口袋或背包里放纸和笔，方便记录。有些情况用手机记录方便。<br>涉及金钱时一般写到餐纸上，方便销毁。<br>零散性的东西，可写在github的issue或一些博客平台。<br>系统性的东西，可记云笔记。  </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;本文涉及的“共享”实际是不同系统，不同网络，不同地点的文件共享。比如网盘。&lt;br&gt;文中所涉，几乎是笔者使用（过）的方式。随意写写，不一定正确。    &lt;/p&gt;</summary>
    
    
    
    <category term="代码生活" scheme="http://www.latelee.org/category/code-life/"/>
    
    
  </entry>
  
  <entry>
    <title>工作学习资料备份记录</title>
    <link href="http://www.latelee.org/code-life/backup-works.html"/>
    <id>http://www.latelee.org/code-life/backup-works.html</id>
    <published>2021-01-25T16:00:00.000Z</published>
    <updated>2021-06-04T02:18:55.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>毕业后一直有整理备份的习惯，但不够全面。那一年租房失窃，电脑相机被偷，毕业设计资料和代码全部丢失——那时还没有备份到网络，自此对本地备份的风险有一定认识。后来慢慢迁移到云端，也使用了云笔记。近日，所用的工作电脑固态硬盘损坏，先是windows系统提示备份，接着使用软件扫描硬盘，突然蓝屏，此后无法启动系统，无法访问硬盘。报修，三天后结论是修复不了。根据扫描结果，固态硬盘才通电使用1000小时，就如此挂了，想不明白是什么原因。幸好刚到公司半年左右，积累的资料不多，也没负责重大项目，手上2~3个工程只损失了几天的代码量，可凭记忆手动恢复。但前辈留下的非常多的工作资料就没有了。   </p><p>本文以个人角度记录目录分类和备份方法。  </p><span id="more"></span><h2 id="一些习惯"><a href="#一些习惯" class="headerlink" title="一些习惯"></a>一些习惯</h2><p>原看不惯创建目录使用数字形式，但后来发现挺好的——只要不过份。<br>目录按大类划分。如“公司文档”、“资料”、“开发文档”、“问题集”、“事务”、“项目”。<br>其中公司文档为制度类文件，考勤表，考核表。事务为小任务（如临时任务，维护任务），项目为大任务，时间跨度长。  </p><p>目录可细分，如“事务”类，可按“1 xxx”、“2 xxx”、“3 xxx”排序，或按年份+日期排序。对于类型相似的，可用前缀区别。  </p><p>代码类使用“workshop”、“project”等大目录，<strong>保持目录全为英文</strong>。设置虚拟机的共享目录亦为代码所在目录，如此一来，一份代码，多处使用。实例：<code>E://workshop/project/</code>包含c++工程、MFC工程、nodejs工程、golang工程、Delphi工程，对于xp虚拟机，只使用Delphi工程；linux虚拟机，使用c++、golang工程。  </p><h2 id="一些方法"><a href="#一些方法" class="headerlink" title="一些方法"></a>一些方法</h2><p>根据工作内容划分几大类。总体原则：能放云上放之，涉密放内部仓库。<br>版本管理争取及时提交。  </p><h3 id="代码类"><a href="#代码类" class="headerlink" title="代码类"></a>代码类</h3><p>使用版本管理，如git为主，兼顾svn。<br>工作工程，在公司内部个人账号创建仓库，尽量每天下班提交，允许有调试内容，但日志需写清楚。<br>如果是多人协作项目，向领导请示，可先在个人账号做一临时仓库，后再同步到主仓库。  </p><h3 id="文档类"><a href="#文档类" class="headerlink" title="文档类"></a>文档类</h3><p>使用云盘，如百度。将日常工作文档目录放置其中。注意不能太大，否则同步耗时。<br>考虑自建，如NextClound，已搭建有服务，但云主机容量是个问题。<br>文档类别：<br>正式文档，归入版本管理。<br>个人维护文档：归入版本管理。<br>日常文档，如专利申请，工作汇报等等，云盘。<br>公司制度，资料：云盘。<br>收集资料：云盘。  </p><h3 id="小笔记类"><a href="#小笔记类" class="headerlink" title="小笔记类"></a>小笔记类</h3><p>使用云笔记。如evernote、有道。不涉密者，如数据库常用sql语句，业务基础，问题排查，等等，可放之。      </p><h3 id="个人类"><a href="#个人类" class="headerlink" title="个人类"></a>个人类</h3><p>下面是个人学习研究的记录。<br>个人学习或实践的东西，一般会写文章/笔记/小结。不涉密都会公开，放github仓库，博客使用hexo构建。目前已经创建较完整的目录，涉及各方面，日常使用notepad++或vs code编辑，完成当成一个工程管理，提交文件后，自动触发ci构建并上传到云主机，从而完成网站更新。   </p><p>另外一些不可公开资源或代码（非公司），存放于github私有仓库。  </p><p>对于不同编程语言，学习时有积累的，使用<code>xxx_test</code>形式仓库名称，如<code>shell_test</code>、<code>golang_test</code>、<code>nodejs_test</code>，等等。  </p><p>有些杂记放到 <a href="https://github.com/cststudio/csthinking/issues">https://github.com/cststudio/csthinking/issues</a> 上面。如读书笔记（零散的）、共享资源、想法、思路、要做的事，等等。  </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;毕业后一直有整理备份的习惯，但不够全面。那一年租房失窃，电脑相机被偷，毕业设计资料和代码全部丢失——那时还没有备份到网络，自此对本地备份的风险有一定认识。后来慢慢迁移到云端，也使用了云笔记。近日，所用的工作电脑固态硬盘损坏，先是windows系统提示备份，接着使用软件扫描硬盘，突然蓝屏，此后无法启动系统，无法访问硬盘。报修，三天后结论是修复不了。根据扫描结果，固态硬盘才通电使用1000小时，就如此挂了，想不明白是什么原因。幸好刚到公司半年左右，积累的资料不多，也没负责重大项目，手上2~3个工程只损失了几天的代码量，可凭记忆手动恢复。但前辈留下的非常多的工作资料就没有了。   &lt;/p&gt;
&lt;p&gt;本文以个人角度记录目录分类和备份方法。  &lt;/p&gt;</summary>
    
    
    
    <category term="代码生活" scheme="http://www.latelee.org/category/code-life/"/>
    
    
  </entry>
  
  <entry>
    <title>一个项目工程的重构小结</title>
    <link href="http://www.latelee.org/code-life/refactor-a-project.html"/>
    <id>http://www.latelee.org/code-life/refactor-a-project.html</id>
    <published>2021-01-16T16:00:00.000Z</published>
    <updated>2021-06-04T02:18:55.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首次看到移交到我手上的C++工程那个7千多行代码的文件时，既佩服又担心，前辈的构架能力让我甘拜下风，同时担心能不能胜任。<br>在研究源码的时候，也解决几个线上遗留的问题。愈发觉得有重构的必要——因为这将是我负责的代码。  </p><span id="more"></span><h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><h3 id="重构原则"><a href="#重构原则" class="headerlink" title="重构原则"></a>重构原则</h3><p>不完全重构——那叫重写，一是否定了前辈的功劳，二是接触不久业务不熟，风险大。<br>因此总体原则是逐步重构，部分重构块——比如核心模式，一些算法优化。对于整体流程和部分魔幻式代码，不敢动。<br>在重构过程中，顺便编写测试用例，以保证重构前后结果一致。  </p><h3 id="重构方法"><a href="#重构方法" class="headerlink" title="重构方法"></a>重构方法</h3><p>参数检查及出错处理，统一提前到初始化接口，即新建Init函数。原始系统在代码深处的不同地方做判断。出错尽早返回，不使用深嵌套。<br>参数统一化。如时间，传入为“yyy-MM-ddThh:mm:ss”形式，在代码中需要时间差的地方，转换为time_t格式，再计算。现统一在初始化接口中先转换。在最终转出时间，再转换为字符串。<br>去掉冗余不必要的多余算法步骤。<br>最短路径，在找到终点节点时，即返回，不用再遍历，节省时间。<br>深入研究最短路径的业务使用，调整计算步骤，减少遍历时次数。<br>将部分 C 风格的代码必为 C++ 风格（非全部）。<br>在部分结构体中添加构造函数，去掉 malloc 方式申请内存以及用 memset 初始化，设置好字段默认值，避免多处单独字段的赋值。  </p><p>添加 yaml 配置文件，将编译依赖改为运行时依赖。    </p><p>添加结构体比较函数，输出不同字段，方便新旧接口的对比。  </p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>不拘泥于语言本身，如 C++ 代码也可以用 printf 输出，一是笔者习惯，二是格式化比 cout 容易写。<br>添加额外的测试用例，方便实验测试人员参考。  </p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>耗时和内存占用均有所减少。新旧接口的运行，原接口平均为25ms，新接口为3ms。 </p><h2 id="未解决问题"><a href="#未解决问题" class="headerlink" title="未解决问题"></a>未解决问题</h2><p>同一个接口，根据时间的不同，使用两套不同命名空间的参数，未找到好的解决办法。  </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;首次看到移交到我手上的C++工程那个7千多行代码的文件时，既佩服又担心，前辈的构架能力让我甘拜下风，同时担心能不能胜任。&lt;br&gt;在研究源码的时候，也解决几个线上遗留的问题。愈发觉得有重构的必要——因为这将是我负责的代码。  &lt;/p&gt;</summary>
    
    
    
    <category term="代码生活" scheme="http://www.latelee.org/category/code-life/"/>
    
    
    <category term="问题集" scheme="http://www.latelee.org/tag/%E9%97%AE%E9%A2%98%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>2020年个人总结</title>
    <link href="http://www.latelee.org/the-life/my-2020.html"/>
    <id>http://www.latelee.org/the-life/my-2020.html</id>
    <published>2021-01-07T16:00:00.000Z</published>
    <updated>2021-06-04T02:18:55.970Z</updated>
    
    <content type="html"><![CDATA[<p>2021年的脚步已经来临了。时光荏苒，白驹过隙，日月如梭，岁月不居，时节如流，总结2020年，以此记念。  </p><span id="more"></span><p>今年过得特别快，那个带着大锤陪婆婆在地里看韭菜花的下午，仿佛就在昨天。在犹豫几次后，坐表哥的车到火车站，踏上来南宁的路程。一晃就是一年。  </p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>今年按时间划分，有几大块：过年在家，来南宁上班，小女出生，换工作，复习并考试，上班。<br>喜得一女，对家庭更加看重，在月子期间，请大假，居家，负责买菜做饭、洗衣洗澡晒太阳等事，小女健康无事。<br>主动承担绝大部分事务，承担大锤教育事务。<br>个人时间更少了，导致比去年熬夜更多，时间更长。但早睡一天又能恢复。没有大病小病。<br>换了一次工作，前后面试了2家公司。<br>技术方面没有明显提升。<br>通过软考高项。  </p><h2 id="工作学习"><a href="#工作学习" class="headerlink" title="工作学习"></a>工作学习</h2><p>今年过年假期是历史最久的，年初在家里，除了听广播，担心能不能按时返工外，还完善了Qt的程序。<br>到了5月份，公司还没有发工资的意思，于是找前前同事帮投简历，在6月中旬有回音，请假面试，顺利过关，由于对拖欠工资已经怕了，只有一份工作即可，所以对薪资没有太多要求。最终在六月最后2天入职报到。<br>公司比较大，是大集团公司下属的集团公司，分若干事业部，每个事业部分若干部门，一个部门分若干小组，我在其中一个小组里面做开发。这里的气氛比较好友，但在软件开发上，和我之前接触的不同，虽然人数众多，但各自为战居多，会议不多，又没有交集，以致半年后我连组内的同事还没认全。日常以 QQ 交流为主，不习惯用邮件，很多事务无法回溯，很多事没有流程和文档，靠的是口口相传，我接手的事务完全没版本管理版本，而是使用日期压缩包，而且压缩包随处可见。  </p><p>申请 gitlab 账号后第一件事就是把手上的代码进行版本管理，接着跟负责 git 服务的同事说安装一个插件，这样可以提交代码时通知相关人员，不过没有下文，理由是学习成本大，大家忙。  </p><p>我的事务主要是负责一个 Delphi 工程（工程文件最早的时间为1998年），以及一个和最短路径算法有关的工具。另外就是一些边边角角的事务，这半年来，没有接触到核心业务。主要的事是 Delphi 工程操作优化——实际上就是加了快捷键以减少鼠标点击步骤，把一些繁琐的步骤做到一个按钮中操作。另外重构算法的工程，因此业务不太熟悉，估计年后就完成了。在测试和升级服务过程中，使用代码和脚本把操作都尽量自动化或半自动化，包括自动化测试程序，线上升级自动脚本，等。还抽空做了一个检查 oracle 数据库合规性的工具，考虑良久还是使用 Golang 编写，方便编码，也方便积累自己的经验。在平时工作中，一方面同事讨论时留心记，包括用到的术语和知识及提到的问题，为此重拾了封尘了几年的印象笔记；另一方面把手上的任务做好；第三是工作积极，领导随叫随到，加班也无怨言。  </p><p>我有过3次加班超过半夜的，一次是2点半，一次是1点半，当时我关注倒不是事务本身，而是大锤有没有洗澡，有没有尿床。我对加班并不抗拒，即使真有怨言，也是偷偷心里骂。  </p><p>我们考勤使用钉钉，除了刚到的2天没法打卡，只迟到过一次，且只迟到1分钟。加班累计有十多个小时（晚上7点后打卡自动统计）。问了几位同事，说可以调休，有次大锤打疫苗，我请调休，但助理拒绝，只能请要扣钱的事假。后了解得知，去年年初因为大项目，部门绝大部分人加班，如按加班时长均可请一年假期，故严格控制调休。  </p><p>在7月份，看到同事讨论软考，我也决定报名参加，在不影响工作和家庭情况下，靠着上下班和深夜、周末空闲时间复习，有好几个晚上都想放弃，但还是逼着自己看书做题。考试当天，案例分析时就感觉不妙，到论文时就感觉支撑不住，但我信奉的是坚持到底，再怎么也要写完。考完后我没估分，后面查成绩时，论文刚好45分，准备点击看到分数按钮时，我的手抖了很久。  </p><p>公司的同事，生活档次都比较高，所谈者，是车辆耗油几何，周末去哪，几时收房，哪个公司装修好，哪家商贷便宜，等等。虽然融不到圈子里，但做倾听状，提高知识，还是可以的。  </p><p>我能入职，是因为刚好有人离职了，我填坑。部门100多人，有一半是外包或劳务派遣，我排在最后几位。看到过一些文件，说每年都会有人能转正，但又看到文件说，外包至少要5年才能资格——除非有特殊贡献。在日常开发中并不区分正式员工、劳务派遣人员和外包人员，总体上没有歧视外包，所以不会出现网上不给外包吃零食的现象（当然本来也没零食）。但在行政事务或通知时，会让我时刻不忘外包仔的身份。像群里发的请正式员工到11楼量尺寸定制西装，请正式员工速到5楼领年节福利，还有明确表示外包人员不参加XX活动等。有时只简单称呼“大家”，但我也得分析一下“大家”是不是包含外包人，否则自讨没趣。另外，一些表格也会严格区别——虽然只是标题不同。如果说不被影响肯定是假的，但也不能太过敏感。曾经问过一些外包的同事，原来他们也有类似的感受。<br>后来发现，劳务派遣人员和外包人员是有很多区别的，比如，某些福利，正式员工和劳务派遣人员可以享有，但外包人员没有。而现在公司的劳务派遣人员已经很少了，这也符合劳务派遣比例的有关规定。我的基本工资是1810元——我才知道这是南宁最低工资，另外加上绩效，扣除少数的保险额，加上上有二老下有二小的减免税额，我还不到交个税的程度。  </p><p>正式员工的福利，让我开了眼界，本来我不想关注的，奈何福利时不时听到看到，也慢慢熟悉了。比如，每月有饭卡补贴，先前是每月600块，后提高到800块。还有工作服、电影票、互助金、尽孝金，当然，五险一金肯定多。除此外，一些培训和晋升空间，也偏向正式员工，诸如此类，等等等等。至于更高级别的，限于认知和眼界，还不清楚。  </p><h2 id="家庭生活"><a href="#家庭生活" class="headerlink" title="家庭生活"></a>家庭生活</h2><p>有了大锤的经验教训后，对于大妞或二锤（小名我早就想好了）的到来，我十分上心。在预产期前跟领导请了2个月的大假，虽然没有收入，但帮交了社保，因此即使后来没有补齐之前欠的工资，我也不强求了。 </p><p>我提前到B站看了很多的视频，想象后面要做的事，特别是预防黄疸和肚脐清理，还跑去调研了小孩洗澡的草药。清明假期，大妞出生了——但幸好不是清明当天（否则又有抱怨了）。岳母因工作不能来南宁，我也不能让我妈来，虽然只有我一个人，虽然有些差错，但一切总算顺利，母女平安。住院三天中，凌晨5点从医院赶回来煮饭煮汤，傍晚赶回来买菜煮饭煮汤。在医院床边睡觉也是随叫随醒，但给人的印象就是“只知道睡觉”。  </p><p>月子期间，我负责全部的护理工作，特别是肚脐的消毒。除了刚回来头2天洗了草药水，其它时间都是擦身子，尽量减少肚脐接触水的概率。在肚脐脱落时，想了很多种方法防止感染，跑了很多药店都没买到肚脐贴，最后使用了创可贴，竟也有用。最终平安度过，心里石头也放下了。这个时期，大妞没有出现严重的肠绞疼，没有经常哭闹。我会经常按摩她的肚子，我也享受大妞趴着我肚子睡觉的时光。对于一些育儿经验也有自己的看法，像竖抱、趴床等等，在刚出生几天，我就给大妞做了，一开始只是几秒，慢慢加长时间。有太阳时带去树根晒太阳，旁边大妈看到我带小孩晒太阳，会好奇过来问我各种问题，无非是些老人怎么没有帮带小孩，你怎么没上班之类的。<br>大人方面，就是换着花样做饭菜，粥粉面饭，煮蒸闷炒，基本准时把三餐饭菜送到房间，再抱大妞。自此，我就负责买菜拖地洗衣的事。某段时间，我下班后还没有煮饭，于是马不停蹄，洗菜切菜煮饭煮菜，发挥程序优势，开启多线程处理，但马也有失蹄，有次着急切到手，疼了一周。到年底发现刀工见长了，做的菜的花样也慢慢多，炒的糖色也不苦了。    </p><p>大概2~3个月后，大妞不让我抱了，孩子妈洗澡时，哭得特别严重，一度让人以为我虐待小孩，当然少不了争吵。那时我心态也不好，一方面是没有收入，另一方面是大量支出，再一方面是天天处理杂事。年底后，大概是我勤快买菜拖地而又不反抗的缘故，已经不怎么对我发脾气了。大妞半岁后，我抱她时已经不会哭了，后来逗她时也会笑了。因为孩子妈不放心我带小的，所以今年没有带大妞去外面玩，最多只是到超市买菜。<br>在大妞出生前后，起名的事也闹了很久，孩子妈坚持要跟娘家姓，我父母坚决不同意，我夹在中间，但我也不同意。我的看法是，不同姓的话，兄妹就不是兄妹了，家也不是家了。岳母则支持我，但为这事孩子妈也跟岳母吵了一架，闹得去寻死，在找人的那2个小时里，无数个念头在我脑中闪过，我似乎看到了明天的新闻。万幸半夜前找回来，但家里的东西就遭殃了，我也在外面过了一夜，第二天我煮的面也扔掉。自此后我就怕了，无数次教训着我不能反抗。而且起名的事也得罪父母，说不要回家过年，一时仿徨不知何去何从。最后用了折中的方法，还是跟我姓，但户口不跟我。为了让两孩子的名字听得像兄妹，看了经典和字典，想了很久，最终给大妞起了一个觉得不错的姓名，符合五行，寓意不错，而且拼音缩写和哥哥完全一致。当然有人肯定觉得不好。   </p><p>大妞出生后，孩子妈就唠叨要把大锤接来一起生活，因为总是担心在老家老人乱给零食吃，于是五月底回了趟老家，在老家市区网吧过了一夜，翌日老妈带大锤出来，顺便给大锤办了身份证（这个事也唠叨了几年了），临走时给了老妈5千块钱。到南宁第二天就带大锤去办了张银行卡，存了100块钱，当是小孩婆婆给的红包。办卡时，柜员姐姐问了小孩怎么没上幼儿园，于是临时决定带小孩去看幼儿园。去看了四五家，有2家比较喜欢，一家环境好而贵，一家便宜但一般般，距离都不远不近。最终孩子妈选择环境好的那家。  </p><p>到了8月份，运气非常好，在20%的概率中中签了一家国企幼儿园，费用低一些（但也超过5千了），场地大一些，距离近一些。大锤上幼儿园后，除周末外，每天的时间似乎都按分钟算。早上7点我得起床，7点50分必须把大锤送到学校门口，然后在8点半前赶到公司。上了幼儿园后，能明显感到大锤的进步，虽然不大，但我已经满足了。        </p><p>有小孩后，我就不是自由的了，凡事都会考虑到小孩，包括语言行为。在2个小孩前面要特别注意，既不能让大的感受到冷落，又不让忽视小的。我会一手抱大锤一手抱大妞，跟兄妹俩说话——我十分珍惜这个时刻，因为，我单手快抱不动大锤了，大锤也渐渐不用我抱了。  </p><p>我对小孩的教育比较开放，大原则是尊重小孩成长规律，在此前提下，多教一些，学多一些，但不刻意去强求结果。小孩爱玩、爱闹、要抱、使性子，等，都是天性，只要不过分，我都会允许。小孩是一张白纸，需要大人去填充颜色，是五彩缤纷还是黑白，取决于大人；另一方面，小孩诸多习性和能力，也需要大人引导。这一年感悟尤为深刻。大锤是我的精神寄托，是我早起晚睡的动力。  </p><p>在大锤成长过程中，我也会回忆起自己的童年，我在大锤这个年纪只会玩泥巴，但大锤去了很多公园，见识很多事物。我初中毕业后才第一次接触电话，大一期末才第一次坐火车。这些与现今已不可同日而语，但我又希望大锤可以接触大自然，有机会尝试“也傍桑阴学种瓜”，不过家庭的事从不是我一个做决定。我只能尽量让大锤有个好的童年，但这个“好”，我不知道怎么定义。  </p><p>很久前和罗师傅聊小孩教育，谈到家风家规，我也积累总结，看到好的都写下来，慢慢越来越多。考虑到接受程度，精简后得到几条，在生活中有机会就会跟小孩说。一、承认事实（不刻意回避事实，如打针会疼，摔跤会疼）；二、慢慢进步（不要求马上进步，但要求有进步，有成长。）；三、勇于尝试（尝试了才知道好不好能不能做，不能不试就说不好不做。）；四、允许有错（去尝试，过程中允许犯错做错，从中学习，再进步）。<br>另外罗师傅也提到陶冶小孩情操，他买了书画挂家里，我也买了一些复制的书画——只是不能挂。但大锤只对书法感兴趣，前后买了《赤壁赋》、《滕王阁序》、《心经》、《兰亭集序》。或者是缘分，我和孩子妈姓名的某个字都能在《赤壁赋》找到，并且不止一处，所以在看时，也顺便让大锤找爸妈的名字。<br>对于国学，我并不想让小孩背《三字经》和《弟子规》，我更喜欢教《声律启蒙》和诗歌。这一年，教的诗词主要依据时令（如中秋节）而定，再者选取田园风光、童趣、豪放风格等方面，另外还有一些是个人喜欢的，如蒋捷和韦庄诗歌。教的虽然不多，但间隔一段时间再回顾，以加深印象。大部分诗词是在游玩或路上时读给小孩听，有时触景时也会教，教时并不是强迫记，而是慢慢解释、引导。在中秋节后教他“明月几时有”。在青秀山教他“解落三秋叶”，在人民公园教他“接天莲叶无穷碧”，在晴天时教他“白云千载空悠悠”，在太阳下山时教他“夕阳无限好”。<br>周末只要有空，就会带大锤去了玩，今年去了很多地方，主要集中在免费的地方。趁年底半价，还去了一次动物园，去了两次青秀山。当然最常去的是人民公园，其次是图书馆（每次我借书还书都会带着去）。大锤语言能力还不如其它小朋友，日常中可以明显看出，一是新环境怕生，二是话少不主动表达。因此年末的外出活动，争取和班上的小朋友一起玩。  </p><p>大锤模仿能力非常强，不管好的坏的。因此我也注意日常的说话和行为，有时大人吵架后，也会跟小孩解释和说明（虽然我不想吵，但有时忍不住）。上幼儿园后，一度对炒菜感兴趣，或许是陪我去买菜时日久了自然熟悉，加上外婆买了套厨具给他玩。我切菜时他切菜，我剁肉时他剁肉，还拿他的刀和勺子跟真实的比较。<br>另外，把一些逻辑和计算机思维融入生活。比如，学会穿衣服穿袜子，就是成长（而不是等成长了才学会穿）；天下雨了地板会湿（但地板湿不一定是下雨）。买了汉诺塔和九连环给小孩玩（当然主要是我玩）。在安装铁架、包饺子过程中会讲分类和分工（结构化，流水线，分治等术语当然不会跟小孩讲），等等。    </p><p>至于其它的，就看大人言传身教了。为了让大锤不怕打针抽血，在软考后第二天，带大锤到附近血屋献了400cc，告诉他爸爸用的是大针，抽了很多血，很疼，但爸爸不怕。抽完后，大锤喝了送的牛奶，我拿了送的小锅，各取所需。（注：检查合格，并在一周后被使用了。献血是计划了很久的，前后一共献了1000cc，身体自我感觉无恙。）   </p><h2 id="个人能力"><a href="#个人能力" class="headerlink" title="个人能力"></a>个人能力</h2><p>将所有网站迁移到云主机，全部docker化部署，外加nginx转发，并实现https证书。<br>整理后台程序框架，使用golang语言，集中在gin和cobra中。至于接口，随用随积累。前端看了几行vue代码，但没有继续。<br>持续更新自己的技术网站，虽然数量少了一些，质量也不高，但起码没有敷衍了事，都是对工作和学习的总结记录。<br>集群方面，限于精力没有做。  </p><p>明年重点内容：<br>完成golang后台，前端不做要求。<br>业余研究方向为架构、分布式等方面。如设计模式、设计原则，redis、mysql等。<br>在工作中寻找可以发挥的地方，既能完成工作，又积累技能。  </p><h2 id="个人事"><a href="#个人事" class="headerlink" title="个人事"></a>个人事</h2><p>今年因为疫情，社交比以往更少了，没有约夜宵，也没有和大学同学聚会。<br>和罗师傅参加前领导请的一次吃饭，主要谈未来的业务和项目的可能性，前领导欠的几百万还没还清，听其语气，对公司被迫歇业的事没有了当初的愤慨，而多了几份无奈，一边做项目还债，一边还想着我们几个人。<br>和前同事碰面几次，还是谈业务，谈了很多次，不过没有成的。主要是个人作战力量太单薄了。<br>上半年和老家的叔伯碰面，谈线上买卖菜的项目，但当时只有idea，除此外什么也没有（现在各头部大厂进场，小兵肯定没机会）。<br>给网友的回复比去年少了，一是懒，二是没时间，三是没精力。<br>买了个二手kindle，买了个二手电子表，有闹钟计时，有电波光动能，时间还比较准。<br>上下班路上听听音频，上半年主要有听刑法、逻辑学等，下半年开始听软考的高项。  </p><h2 id="个人反省"><a href="#个人反省" class="headerlink" title="个人反省"></a>个人反省</h2><p>说实话，这么多年，没有进行过认真的反思。<br>我性格偏向软弱，但看到不平事，也会义愤填膺，只是不会站出来，而且接受既定事实。我不擅长吵架，不喜欢争吵，也怕看到别人争吵。我没有花很多时间研究如何吵架，也没有积累吵架经验，所以吵架时我始终在下风。何况在当今社会，男女吵架闹矛盾，不管怎么说，男的始终不占理。人与人的认知不同，生活经历不同，因此对事物看法和感受不同。有人评价我不会带孩子，有人评价我对软件开发的理解不够。<br>在头条或网上的男人，回家只会玩手机打游戏，不会照顾小孩，女的则为母则刚做坚强的人。对此我有自己的思考，但不是人人都有分辨力，如果有人时不时在旁边说别人家生活怎样，别人老公如何，别人去哪里旅游，我不在意也不放心上，但如果是亲人的话，我只能是无何何奈。其实男人就应该以赚钱为第一要义，在新公司听到别人讨论高档次的生活时，我发现已经脱节了。<br>我也有脾气，吃软不吃硬。一边抱怨钱少，一边骂我，一边说我不够大度，我只能一声叹息。我试过为公司的项目写代码到半夜2点，对公司的事十分在上心，因为领导器重，并且我看到希望了。如果别人的错要我背锅，又要我无怨言加班到半夜，又要准时上班，又不给我调休，我肯定不爽。但人本就矛盾，为了钱，还得假装欢笑享受。<br>我希望得到尊重和理解，不过近年来，我不敢已经奢望美好的生活，感觉啥事都低人一等，不管在家还是在公司，比如公司要求周一着正装上班，正式员工都统一一套，我穿着毕业那会儿买的西服，只敢走楼梯。有时下班回去给大妞喂奶没喝完又被骂。只有在欺负大锤时，才觉得有点成就感。    </p><h2 id="杂事"><a href="#杂事" class="headerlink" title="杂事"></a>杂事</h2><p>不知何故，听了几次《琵琶行》，竟也能背下，换作以前那么长的诗都不会看完，或许是有共鸣吧。白居易在出官二年后才“是夕始觉有迁谪意”，我想他之前的许多个时刻，也会感觉到“迁谪意”，只是没有听到琵琶声当晚那么有感触。我有时也会失落孤独，比如，换新工作第一天下班的时候，加班到深夜骑着电驴吹着风回家的时候。回想工作后的十年，我不知是怎么度过的，“今年欢笑复明年”也是有的，就是我陪大锤大妞玩的时候——他们还小，当然需要欢笑。然而更多时候，我都“恬然自安”，没有想过房子车子和未来的事，我忙忙碌碌，终究还是没什么成绩。暮去朝来，秋月春风就这样过去了，我也隐隐有了白头发。  </p><h2 id="流水账"><a href="#流水账" class="headerlink" title="流水账"></a>流水账</h2><p>1月份，回家，听广播，写Qt程序。<br>2月份，来南宁。<br>3月份，上班。面试。<br>4月份，大妞出生，请假2个月陪护。<br>5月份，更新了居住证。回老家带大锤上南宁。带大锤找幼儿园。<br>6月份，上班，面试，换工作。大锤正式上幼儿园。<br>7月份，决定考软考。公司评职称，因无论文及未满一年，未参加。<br>8月份，上班。中签租房对面的幼儿园。<br>9月份，大锤换新幼儿园。公司换新地址，离得更远，起得更早。<br>10月份，带大锤去梧州看爷爷，回老家看奶奶。上班。<br>11月份，参加软考。<br>12月份，上班。      </p><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>希望明年能评上职称。<br>希望明年能通过架构师考试。<br>希望早日上岸，摆脱外包仔身份——虽然遥遥无期。  </p><p>PS：本文编写时，得知软考分数线为45分，以及格线通过，<del>如按同事说法公司有补贴，那明年大锤幼儿园学费就有着落了——问了外包没补贴。</del>  </p><p>李迟 2021.1.8 周五  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2021年的脚步已经来临了。时光荏苒，白驹过隙，日月如梭，岁月不居，时节如流，总结2020年，以此记念。  &lt;/p&gt;</summary>
    
    
    
    <category term="生活掠影" scheme="http://www.latelee.org/category/the-life/"/>
    
    
    <category term="个人总结" scheme="http://www.latelee.org/tag/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>redis笔记2：问题及记录</title>
    <link href="http://www.latelee.org/my-study/redis-note1.html"/>
    <id>http://www.latelee.org/my-study/redis-note1.html</id>
    <published>2021-01-06T16:00:01.000Z</published>
    <updated>2021-06-04T02:18:55.926Z</updated>
    
    <content type="html"><![CDATA[<p>redis 术语、问题等等。从网上收集。    </p><span id="more"></span><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>数据未加载到缓存中，或者缓存同一时间大面积的失效，从而导致所有请求都去查数据库，导致数据库CPU和内存负载过高，甚至宕机。  </p><p>解决：缓存的高可用性、缓存降级、Redis备份和快速预热、提前演练  </p><p>在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。  </p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指查询一个一不存在的数据。例如：从缓存redis没有命中，需要从mysql数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。失去了缓存的意义。  </p><p>解决：<br>如果查询数据库也为空，直接设置一个默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库。设置一个过期时间或者当有值的时候将缓存中的值替换掉即可。<br>可以给key设置一些格式规则，然后查询之前先过滤掉不符合规则的Key。  </p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。</p><p>解决方式也很简单，可以将热点数据设置为永远不过期；或者基于 redis or zookeeper 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据。</p><h2 id="缓存与数据库双写一致"><a href="#缓存与数据库双写一致" class="headerlink" title="缓存与数据库双写一致"></a>缓存与数据库双写一致</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;redis 术语、问题等等。从网上收集。    &lt;/p&gt;</summary>
    
    
    
    <category term="技术杂铺" scheme="http://www.latelee.org/category/my-study/"/>
    
    
    <category term="架构学习" scheme="http://www.latelee.org/tag/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>redis笔记1：集群</title>
    <link href="http://www.latelee.org/my-study/redis-note1.html"/>
    <id>http://www.latelee.org/my-study/redis-note1.html</id>
    <published>2021-01-06T16:00:00.000Z</published>
    <updated>2021-06-04T02:18:55.926Z</updated>
    
    <content type="html"><![CDATA[<p>docker 化部署 redis，主从复制、哨兵、集群实践。  </p><span id="more"></span><p>redis 集群有三种模式：  </p><ul><li>主从模式</li><li>Sentinel模式</li><li>Cluster模式</li></ul><h2 id="技术小结"><a href="#技术小结" class="headerlink" title="技术小结"></a>技术小结</h2><p>使用 docker 部署，需要注意所有容器均在同一网段，容器间使用容器名称访问。  </p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><ul><li>主可写可读，从只读（否则无法保证数据一致性）。主同步数据到从。一主可带多个从，一从只属一个主。  </li><li>从服务挂掉不影响其它从。  </li><li>主挂掉，整个集群不能写，但从依然可读。 </li><li>主只写，从只读，分工减少主的压力。  </li></ul><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>三台服务：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ttredis 6379</span><br><span class="line">ttredis1 6381</span><br><span class="line">ttredis2 6382</span><br><span class="line">ttredis3 6383</span><br></pre></td></tr></table></figure><p>docker-compose.yml文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;2&#x27;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  ttredis:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    container_name: ttredis</span><br><span class="line">    restart: always</span><br><span class="line">    command: redis-server /usr/local/etc/redis/redis.conf</span><br><span class="line">    volumes:</span><br><span class="line">      - ./redisdata0:/data</span><br><span class="line">      - ./redis0.conf:/usr/local/etc/redis/redis.conf</span><br><span class="line">    ports:</span><br><span class="line">      - 6379:6379</span><br><span class="line">    networks:</span><br><span class="line">      - ttredis-net</span><br><span class="line">  ttredis1:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    container_name: ttredis1</span><br><span class="line">    restart: always</span><br><span class="line">    command: redis-server /usr/local/etc/redis/redis.conf</span><br><span class="line">    volumes:</span><br><span class="line">      - ./redisdata1:/data</span><br><span class="line">      - ./redis1.conf:/usr/local/etc/redis/redis.conf</span><br><span class="line">    ports:</span><br><span class="line">      - 6381:6379</span><br><span class="line">    networks:</span><br><span class="line">      - ttredis-net</span><br><span class="line">  ttredis2:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    container_name: ttredis2</span><br><span class="line">    restart: always</span><br><span class="line">    command: redis-server /usr/local/etc/redis/redis.conf</span><br><span class="line">    volumes:</span><br><span class="line">      - ./redisdata2:/data</span><br><span class="line">      - ./redis1.conf:/usr/local/etc/redis/redis.conf</span><br><span class="line">    ports:</span><br><span class="line">      - 6382:6379</span><br><span class="line">    networks:</span><br><span class="line">      - ttredis-net</span><br><span class="line">  ttredis3:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    container_name: ttredis3</span><br><span class="line">    restart: always</span><br><span class="line">    command: redis-server /usr/local/etc/redis/redis.conf</span><br><span class="line">    volumes:</span><br><span class="line">      - ./redisdata3:/data</span><br><span class="line">      - ./redis1.conf:/usr/local/etc/redis/redis.conf</span><br><span class="line">    ports:</span><br><span class="line">      - 6383:6379</span><br><span class="line">    networks:</span><br><span class="line">      - ttredis-net</span><br><span class="line">networks:</span><br><span class="line">  ttredis-net:</span><br><span class="line">    driver: bridge</span><br></pre></td></tr></table></figure><p>说明：<br>1、创建三个容器，分别为ttredis、ttredis1、ttredis2，第一个为主，使用单独的配置文件。第二第三个为从，使用同一配置，但数据目录不同。<br>2、注意端口映射，在容器看来，均为6379(默认)，只是映射到不同端口。<br>3、三个容器在同一网络 ttredis-net 中。  </p><p>主配置文件主要内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bind 0.0.0.0</span><br><span class="line">protected-mode yes</span><br><span class="line">port 6379</span><br><span class="line">requirepass 12345678</span><br><span class="line">appendonly yes</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br></pre></td></tr></table></figure><p>从配置文件主要内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bind 0.0.0.0</span><br><span class="line">protected-mode yes</span><br><span class="line">port 6379</span><br><span class="line">requirepass 12345678</span><br><span class="line">appendonly yes</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"># replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line">#replicaof 127.0.0.1 6379</span><br><span class="line"># for docker</span><br><span class="line">replicaof ttredis 6379</span><br><span class="line">masterauth 12345678</span><br></pre></td></tr></table></figure><p>说明：在从配置文件中，使用 replicaof （注：旧版本为 slaveof）指定主的IP和端口，masterauth 指定主的密码。如是本机，则使用<code>127.0.0.1</code>，本例为容器，故用主的容器名<code>ttredis</code>。由于需要外网机器访问，故绑定 IP 为<code>0.0.0.0</code>。主从密码均为<code>12345678</code>。         </p><p>启动容器并查看状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># docker-compose -f docker-compose.yml up -d</span><br><span class="line"></span><br><span class="line"># docker-compose ps</span><br><span class="line">  Name                Command               State           Ports          </span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line">ttredis    docker-entrypoint.sh redis ...   Up      0.0.0.0:6379-&gt;6379/tcp </span><br><span class="line">ttredis1   docker-entrypoint.sh redis ...   Up      0.0.0.0:6381-&gt;6379/tcp </span><br><span class="line">ttredis2   docker-entrypoint.sh redis ...   Up      0.0.0.0:6382-&gt;6379/tcp </span><br></pre></td></tr></table></figure><p>连接主容器并查看集群：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6379 -a 12345678</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=192.168.224.2,port=6379,state=online,offset=1386,lag=1</span><br><span class="line">slave1:ip=192.168.224.4,port=6379,state=online,offset=1386,lag=1</span><br><span class="line">master_replid:44d65d402d81131ac37867f352a513093263f0aa</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:1386</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:1386</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or set)</span><br><span class="line"></span><br><span class="line">输入值：</span><br><span class="line">set  key1 101</span><br><span class="line">set  key2 102</span><br><span class="line">set  key3 103</span><br><span class="line">set  key4 104</span><br><span class="line">set  key5 105</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查看：</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;key5&quot;</span><br><span class="line">2) &quot;key1&quot;</span><br><span class="line">3) &quot;key2&quot;</span><br><span class="line">4) &quot;key3&quot;</span><br><span class="line">5) &quot;key4&quot;</span><br></pre></td></tr></table></figure><p>在从查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6381&gt; keys *</span><br><span class="line">1) &quot;key3&quot;</span><br><span class="line">2) &quot;key1&quot;</span><br><span class="line">3) &quot;key4&quot;</span><br><span class="line">4) &quot;key2&quot;</span><br><span class="line">5) &quot;key5&quot;</span><br></pre></td></tr></table></figure><p>在主执行 flushall 命令清空所有数据库，从亦被清空。    </p><h2 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h2><h3 id="理论-1"><a href="#理论-1" class="headerlink" title="理论"></a>理论</h3><p>解决主从复制的缺点，即主挂掉整个集群不可写。哨兵可再选一个主出来。  </p><h3 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h3><p>docker-compose.yml文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;2&#x27;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  ttredis:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    container_name: ttredis</span><br><span class="line">    restart: always</span><br><span class="line">    #command: redis-server</span><br><span class="line">    #command: redis-server --requirepass 12345678 --appendonly yes</span><br><span class="line">    command: </span><br><span class="line">    - sh</span><br><span class="line">    - -c</span><br><span class="line">    - |</span><br><span class="line">        redis-server /usr/local/etc/redis/redis.conf &amp;</span><br><span class="line">        redis-sentinel /usr/local/etc/redis/sentinel.conf</span><br><span class="line">    volumes:</span><br><span class="line">      - ./redisdata0:/data</span><br><span class="line">      - ./redis0.conf:/usr/local/etc/redis/redis.conf</span><br><span class="line">      - ./sentinel.conf:/usr/local/etc/redis/sentinel.conf</span><br><span class="line">    ports:</span><br><span class="line">      - 6379:6379</span><br><span class="line">      - 26379:26379</span><br><span class="line">    networks:</span><br><span class="line">      - ttredis-net</span><br><span class="line">  ttredis1:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    container_name: ttredis1</span><br><span class="line">    restart: always</span><br><span class="line">    #command: redis-server</span><br><span class="line">    #command: redis-server --requirepass 12345678 --appendonly yes --replicaof ttredis 6379 --masterauth 12345678</span><br><span class="line">    command: redis-server /usr/local/etc/redis/redis.conf</span><br><span class="line">    volumes:</span><br><span class="line">      - ./redisdata1:/data</span><br><span class="line">      - ./redis1.conf:/usr/local/etc/redis/redis.conf</span><br><span class="line">    ports:</span><br><span class="line">      - 6381:6379</span><br><span class="line">    networks:</span><br><span class="line">      - ttredis-net</span><br><span class="line">  ttredis2:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    container_name: ttredis2</span><br><span class="line">    restart: always</span><br><span class="line">    #command: redis-server</span><br><span class="line">    #command: redis-server --requirepass 12345678 --appendonly yes --replicaof ttredis 6379 --masterauth 12345678</span><br><span class="line">    command: redis-server /usr/local/etc/redis/redis.conf</span><br><span class="line">    volumes:</span><br><span class="line">      - ./redisdata2:/data</span><br><span class="line">      - ./redis1.conf:/usr/local/etc/redis/redis.conf</span><br><span class="line">    ports:</span><br><span class="line">      - 6382:6379</span><br><span class="line">    networks:</span><br><span class="line">      - ttredis-net</span><br><span class="line">  ttredis3:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    container_name: ttredis3</span><br><span class="line">    restart: always</span><br><span class="line">    #command: redis-server</span><br><span class="line">    #command: redis-server --requirepass 12345678 --appendonly yes --replicaof ttredis 6379 --masterauth 12345678</span><br><span class="line">    command: redis-server /usr/local/etc/redis/redis.conf</span><br><span class="line">    volumes:</span><br><span class="line">      - ./redisdata3:/data</span><br><span class="line">      - ./redis1.conf:/usr/local/etc/redis/redis.conf</span><br><span class="line">    ports:</span><br><span class="line">      - 6383:6379</span><br><span class="line">    networks:</span><br><span class="line">      - ttredis-net</span><br><span class="line">networks:</span><br><span class="line">  ttredis-net:</span><br><span class="line">    driver: bridge</span><br></pre></td></tr></table></figure><p>与前述相比，ttredis 中，多了 sentinel.conf 的配置。该配置由 redis-sentinel 使用，因此，command 需要执行2个命令，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">command: </span><br><span class="line">- sh</span><br><span class="line">- -c</span><br><span class="line">- |</span><br><span class="line">    redis-server /usr/local/etc/redis/redis.conf &amp;</span><br><span class="line">    redis-sentinel /usr/local/etc/redis/sentinel.conf</span><br></pre></td></tr></table></figure><p>sentinel.conf 配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protected-mode no</span><br><span class="line"></span><br><span class="line"># The port that this sentinel instance will run on</span><br><span class="line">port 26379</span><br><span class="line">daemonize no</span><br><span class="line">pidfile /var/run/redis-sentinel.pid</span><br><span class="line">logfile &quot;&quot;</span><br><span class="line"></span><br><span class="line">dir /tmp</span><br><span class="line"></span><br><span class="line">sentinel monitor mymaster ttredis 6379 2</span><br><span class="line">sentinel auth-pass mymaster 12345678</span><br><span class="line"></span><br><span class="line"># Default is 30 seconds.</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line">acllog-max-len 128</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"># Default is 3 minutes.</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line">sentinel deny-scripts-reconfig yes</span><br></pre></td></tr></table></figure><p>测试：<br>同上，在主写数据。然后执行<code>docker-compose stop ttredis</code>停用主服务，观察从是否会变成主。<br>注：暂不成功。  </p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>待实践。  </p><h3 id="理论-2"><a href="#理论-2" class="headerlink" title="理论"></a>理论</h3><h3 id="实践-2"><a href="#实践-2" class="headerlink" title="实践"></a>实践</h3><p><a href="https://www.cnblogs.com/lovling/p/12525655.html">https://www.cnblogs.com/lovling/p/12525655.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;docker 化部署 redis，主从复制、哨兵、集群实践。  &lt;/p&gt;</summary>
    
    
    
    <category term="技术杂铺" scheme="http://www.latelee.org/category/my-study/"/>
    
    
    <category term="架构学习" scheme="http://www.latelee.org/tag/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>架构分布式相关知识点</title>
    <link href="http://www.latelee.org/my-study/arch-dist-note.html"/>
    <id>http://www.latelee.org/my-study/arch-dist-note.html</id>
    <published>2021-01-06T16:00:00.000Z</published>
    <updated>2021-06-04T02:18:55.926Z</updated>
    
    <content type="html"><![CDATA[<p>一些知识点汇总</p><span id="more"></span><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>算法：随机，权重，简单轮询，轮询+权重，</p><p>一个权重的示意：</p><p>3台机器（分别为A、B、C），权重分别为5，3，2。按大小排列：<br>1—–5—8–10（前面区间大，表示其权重大）<br>设一[1,10]随机数，依次与5、3、2对比，如小则在该区间，如大，则减去前一数，再比对。看落到哪个区域。举例：<br>随机数为3，与5对比，小，则落到第1区间，即A。<br>随机数为7，与5对比，大，减去5得2，与3对比，小，则落到第2区间，即B。<br>随机数为9，与5对比，大，减去5得4，与3对比，大，减去3得1，与2对比，小，第3区间，即C。  </p><h3 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;一些知识点汇总&lt;/p&gt;</summary>
    
    
    
    <category term="技术杂铺" scheme="http://www.latelee.org/category/my-study/"/>
    
    
    <category term="架构学习" scheme="http://www.latelee.org/tag/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>openssl生成自签证书</title>
    <link href="http://www.latelee.org/pkc/redis-note1.html"/>
    <id>http://www.latelee.org/pkc/redis-note1.html</id>
    <published>2021-01-05T16:00:01.000Z</published>
    <updated>2021-06-04T02:18:55.894Z</updated>
    
    <content type="html"><![CDATA[<p>使用 openssl 生成自签证书。用于程序测试。  </p><span id="more"></span><h2 id="检查-openssl-："><a href="#检查-openssl-：" class="headerlink" title="检查 openssl ："></a>检查 openssl ：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ openssl version</span><br><span class="line">OpenSSL 1.0.2k-fips  26 Jan 2017</span><br></pre></td></tr></table></figure><p>创建三个目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir root server client</span><br></pre></td></tr></table></figure><p>预定义好证书信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBJ=&quot;/C=CN/ST=Guangxi/L=Cenxi/O=cststudio/OU=cststudio/CN=cststudio.com.cn&quot;</span><br></pre></td></tr></table></figure><p>SUBJ 释义：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">字段        含义                本文示例</span><br><span class="line">/C=    Country 国家        CN</span><br><span class="line">/ST=State or Province 省Guangxi</span><br><span class="line">/L=    Location or City 城市Cenxi</span><br><span class="line">/O=    Organization 组织或企业cststudio</span><br><span class="line">/OU=Organization Unit 部门cststudio</span><br><span class="line">/CN=Common Name 域名或IP    cststudio.com.cn</span><br></pre></td></tr></table></figure><h2 id="根证书"><a href="#根证书" class="headerlink" title="根证书"></a>根证书</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cd root</span><br><span class="line"># 生成RSA私钥 pass指定密码</span><br><span class="line">openssl genrsa -des3 -passout pass:1qaz@WSX -out root.pass.key 2048</span><br><span class="line"></span><br><span class="line"># 删除私钥中的密码</span><br><span class="line">openssl rsa -passin pass:1qaz@WSX -in root.pass.key -out root.key</span><br><span class="line">rm -f root.pass.key</span><br><span class="line"></span><br><span class="line"># 生成 CSR(Certificate Signing Request，证书请求文件)</span><br><span class="line">openssl req -new -key root.key -out root.csr -subj &quot;$SUBJ&quot;</span><br><span class="line"></span><br><span class="line"># 生成根证书，-days指定为10年  </span><br><span class="line">openssl x509 -req -days 3650 -CAcreateserial -in root.csr -signkey root.key -out root.crt</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">root.crt  root.csr  root.key</span><br></pre></td></tr></table></figure><h2 id="服务证书"><a href="#服务证书" class="headerlink" title="服务证书"></a>服务证书</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cd ../server/</span><br><span class="line"></span><br><span class="line"># 生成RSA私钥 pass指定密码</span><br><span class="line">openssl genrsa -des3 -passout pass:1qaz@WSX -out server.pass.key 2048</span><br><span class="line"></span><br><span class="line"># 删除私钥中的密码</span><br><span class="line">openssl rsa -passin pass:1qaz@WSX -in server.pass.key -out server.key</span><br><span class="line">rm -f server.pass.key</span><br><span class="line"></span><br><span class="line"># 生成 CSR(Certificate Signing Request，证书请求文件)</span><br><span class="line">openssl req -new -key server.key -out server.csr -subj &quot;$SUBJ&quot;</span><br><span class="line"></span><br><span class="line"># 生成crt证书，-days指定为10年  </span><br><span class="line">openssl x509 -req -days 3650 -CAcreateserial -CA ../root/root.crt -CAkey ../root/root.key  -in server.csr -signkey server.key -out server.crt</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">server.crt  server.csr  server.key</span><br></pre></td></tr></table></figure><h2 id="客户证书"><a href="#客户证书" class="headerlink" title="客户证书"></a>客户证书</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cd ../client/</span><br><span class="line"></span><br><span class="line"># 生成RSA私钥 pass指定密码</span><br><span class="line">openssl genrsa -des3 -passout pass:1qaz@WSX -out client.pass.key 2048</span><br><span class="line"></span><br><span class="line"># 删除私钥中的密码</span><br><span class="line">openssl rsa -passin pass:1qaz@WSX -in client.pass.key -out client.key</span><br><span class="line">rm -f client.pass.key</span><br><span class="line"></span><br><span class="line"># 生成 CSR(Certificate Signing Request，证书请求文件)</span><br><span class="line">openssl req -new -key client.key -out client.csr -subj &quot;$SUBJ&quot;</span><br><span class="line"></span><br><span class="line"># 生成crt证书，-days指定为10年  </span><br><span class="line">openssl x509 -req -days 3650 -CAcreateserial -CA ../root/root.crt -CAkey ../root/root.key  -in client.csr -signkey client.key -out client.crt</span><br><span class="line"></span><br><span class="line">openssl pkcs12 -export -passout pass:123456 -clcerts -in client.crt -inkey client.key -out client.p12</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">client.crt  client.csr  client.key client.p12</span><br></pre></td></tr></table></figure><p>参考：<br><a href="https://www.cnblogs.com/mufeng3421/p/13896400.html">https://www.cnblogs.com/mufeng3421/p/13896400.html</a><br><a href="https://blog.csdn.net/baidu_19338587/article/details/78489028">https://blog.csdn.net/baidu_19338587/article/details/78489028</a>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用 openssl 生成自签证书。用于程序测试。  &lt;/p&gt;</summary>
    
    
    
    <category term="个人知识中心" scheme="http://www.latelee.org/category/pkc/"/>
    
    
    <category term="工具使用" scheme="http://www.latelee.org/tag/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>yaml文件解析：golang篇</title>
    <link href="http://www.latelee.org/my-library/parsing-yaml-in-golang.html"/>
    <id>http://www.latelee.org/my-library/parsing-yaml-in-golang.html</id>
    <published>2020-12-27T16:00:00.000Z</published>
    <updated>2021-06-04T02:18:55.914Z</updated>
    
    <content type="html"><![CDATA[<p>本文使用 golang 库 viper 对 yaml 文件进行解析。  </p><span id="more"></span><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>执行 <code>go get github.com/spf13/viper</code> 安装。<br>golang 中 yaml 文件解析较多。本文选用 viper 进行解析，主要因为笔者的命令终端库使用了 viper 和 cobra，前者解析 yaml 文件，后者进行命令参数的解析，能方便形成程序主体框架。 </p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="yaml-配置文件"><a href="#yaml-配置文件" class="headerlink" title="yaml 配置文件"></a>yaml 配置文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"># yaml测试样例</span><br><span class="line"># null 或 NULL 为关键字，不能写</span><br><span class="line"></span><br><span class="line"># 名称</span><br><span class="line"># 字符串</span><br><span class="line">name: conf file</span><br><span class="line"></span><br><span class="line"># 版本</span><br><span class="line"># 如按浮点，2.0会转换成2</span><br><span class="line"># 如按字符串，保留原样</span><br><span class="line">version: 2.0</span><br><span class="line"></span><br><span class="line"># 布尔类，转换为1或0</span><br><span class="line">need: true</span><br><span class="line"></span><br><span class="line"># 时间</span><br><span class="line">time: 2020-10-03T09:21:13</span><br><span class="line"></span><br><span class="line">empty: nul</span><br><span class="line"></span><br><span class="line"># 对象</span><br><span class="line"># 加双引号会转义\n，即会换行</span><br><span class="line">my:</span><br><span class="line">  name: late \n lee</span><br><span class="line">  name1: &quot;late \n lee&quot;</span><br><span class="line">  age: 99</span><br><span class="line">  </span><br><span class="line"># 块</span><br><span class="line">text: |</span><br><span class="line">  hello</span><br><span class="line">  world!</span><br><span class="line"></span><br><span class="line"># 数组</span><br><span class="line">fruit:</span><br><span class="line">  - apple</span><br><span class="line">  - apple1</span><br><span class="line">  - apple2</span><br><span class="line">  - apple3</span><br><span class="line">  - apple4</span><br><span class="line">  - apple5</span><br><span class="line"></span><br><span class="line"># 多级数组</span><br><span class="line">multi:</span><br><span class="line">  sta:</span><br><span class="line">    - 110 210 ddd 99</span><br><span class="line">    - 133 135 1 2 1588 1509</span><br><span class="line">    - 310-410</span><br><span class="line">    - 333-444</span><br></pre></td></tr></table></figure><p>该示例基本涵盖了大部分的 yaml 格式。包括：字符串，数值、数组、多级map。  </p><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>测试代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">true&quot;os&quot;</span><br><span class="line">true&quot;github.com/spf13/viper&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">truecfgFile string</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">trueif cfgFile != &quot;&quot; &#123;</span><br><span class="line">truetrue// Use config file from the flag.</span><br><span class="line">truetrueviper.SetConfigFile(cfgFile)</span><br><span class="line">true&#125; else &#123;</span><br><span class="line">truetrueviper.AddConfigPath(&quot;./&quot;)</span><br><span class="line">truetrueviper.SetConfigName(&quot;config&quot;)</span><br><span class="line">truetrueviper.SetConfigType(&quot;yaml&quot;)</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">trueviper.AutomaticEnv() // read in environment variables that match</span><br><span class="line"></span><br><span class="line">trueerr := viper.ReadInConfig();</span><br><span class="line">trueif  err != nil &#123;</span><br><span class="line">truetruefmt.Println(&quot;&#x27;config.yaml&#x27; file read error:&quot;, err)</span><br><span class="line">truetrueos.Exit(0)</span><br><span class="line">true&#125;</span><br><span class="line">    name := viper.GetString(&quot;name&quot;)</span><br><span class="line">    version := viper.GetString(&quot;version&quot;)</span><br><span class="line"></span><br><span class="line">    need := viper.GetBool(&quot;need&quot;)</span><br><span class="line">    theTime := viper.GetString(&quot;time&quot;)</span><br><span class="line">    empty := viper.GetString(&quot;empty&quot;)</span><br><span class="line">    text := viper.GetString(&quot;text&quot;)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(&quot;need: %v name: %v=\n version: %v \ntime: %v \nempty: %s \ntext: %v\n&quot;, need, name, version, theTime, empty, text)</span><br><span class="line">    </span><br><span class="line">    name = viper.GetString(&quot;my.name&quot;)</span><br><span class="line">    name1 := viper.GetString(&quot;my.name1&quot;)</span><br><span class="line">    age := viper.GetInt(&quot;my.age&quot;)</span><br><span class="line">    fmt.Printf(&quot;name: %v, name1: %v age: %v \n&quot;, name, name1, age)</span><br><span class="line"></span><br><span class="line">    newSta := viper.GetStringSlice(&quot;multi.sta&quot;)</span><br><span class="line">    for idx, value := range newSta &#123;</span><br><span class="line">        fmt.Printf(&quot;sta[%d]: %v\n&quot;, idx, value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fruit := viper.GetStringSlice(&quot;fruit&quot;)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(&quot;fruit: %v\n&quot;, fruit)</span><br><span class="line">    </span><br><span class="line">    bad := viper.GetString(&quot;bad&quot;)</span><br><span class="line">    bad1 := viper.GetString(&quot;my.bad&quot;)</span><br><span class="line">    fmt.Printf(&quot;bad: %v bad1: %v\n&quot;, bad, bad1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>go build</code>进行编译。<br>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ ./yaml_test.exe</span><br><span class="line">need: true name: conf file=</span><br><span class="line"> version: 2</span><br><span class="line">time: 2020-10-03T09:21:13</span><br><span class="line">empty: nul</span><br><span class="line">text: hello</span><br><span class="line">world!</span><br><span class="line"></span><br><span class="line">name: late \n lee, name1: late</span><br><span class="line"> lee age: 99</span><br><span class="line">sta[0]: 110 210 ddd 99</span><br><span class="line">sta[1]: 133 135 1 2 1588 1509</span><br><span class="line">sta[2]: 310-410</span><br><span class="line">sta[3]: 333-444</span><br><span class="line">fruit: [apple apple1 apple2 apple3 apple4 apple5]</span><br><span class="line">bad:  bad1:</span><br></pre></td></tr></table></figure><h3 id="结果说明"><a href="#结果说明" class="headerlink" title="结果说明"></a>结果说明</h3><p>1、<code>name: &quot;late \n lee&quot;</code> 输出会换行。而 <code>name: late \n lee</code> 则会原样输出。<br>2、参数的值不能为 null 或 NULL，但可以为nul。如果为 null，解析的值为空。<br>3、如果字段不存在，不会报错，解析得到的值为空。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文使用 golang 库 viper 对 yaml 文件进行解析。  &lt;/p&gt;</summary>
    
    
    
    <category term="我的程序代码" scheme="http://www.latelee.org/category/my-library/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
    <category term="工程库代码" scheme="http://www.latelee.org/tag/%E5%B7%A5%E7%A8%8B%E5%BA%93%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>yaml文件解析：nodejs篇</title>
    <link href="http://www.latelee.org/my-library/parsing-yaml-in-nodejs.html"/>
    <id>http://www.latelee.org/my-library/parsing-yaml-in-nodejs.html</id>
    <published>2020-12-26T16:00:01.000Z</published>
    <updated>2021-06-04T02:18:55.914Z</updated>
    
    <content type="html"><![CDATA[<p>本文使用 nodejs 的 yamljs 库对 yaml 文件进行解析。  </p><span id="more"></span><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>直接使用 <code>npm i yamljs</code> 即可安装。  </p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="yaml-配置文件"><a href="#yaml-配置文件" class="headerlink" title="yaml 配置文件"></a>yaml 配置文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"># yaml测试样例</span><br><span class="line"># null 或 NULL 为关键字，不能写</span><br><span class="line"></span><br><span class="line"># 名称</span><br><span class="line"># 字符串</span><br><span class="line">name: conf file</span><br><span class="line"></span><br><span class="line"># 版本</span><br><span class="line"># 如按浮点，2.0会转换成2</span><br><span class="line"># 如按字符串，保留原样</span><br><span class="line">version: 2.0</span><br><span class="line"></span><br><span class="line"># 布尔类，转换为1或0</span><br><span class="line">need: true</span><br><span class="line"></span><br><span class="line"># 时间</span><br><span class="line">time: 2020-10-03T09:21:13</span><br><span class="line"></span><br><span class="line">empty: nul</span><br><span class="line"></span><br><span class="line"># 对象</span><br><span class="line"># 加双引号会转义\n，即会换行</span><br><span class="line">my:</span><br><span class="line">  name: late \n lee</span><br><span class="line">  name1: &quot;late \n lee&quot;</span><br><span class="line">  age: 99</span><br><span class="line">  </span><br><span class="line"># 块</span><br><span class="line">text: |</span><br><span class="line">  hello</span><br><span class="line">  world!</span><br><span class="line"></span><br><span class="line"># 数组</span><br><span class="line">fruit:</span><br><span class="line">  - apple</span><br><span class="line">  - apple1</span><br><span class="line">  - apple2</span><br><span class="line">  - apple3</span><br><span class="line">  - apple4</span><br><span class="line">  - apple5</span><br><span class="line"></span><br><span class="line"># 多级数组</span><br><span class="line">multi:</span><br><span class="line">  sta:</span><br><span class="line">    - 110 210 ddd 99</span><br><span class="line">    - 133 135 1 2 1588 1509</span><br><span class="line">    - 310-410</span><br><span class="line">    - 333-444</span><br></pre></td></tr></table></figure><p>该示例基本涵盖了大部分的 yaml 格式。包括：字符串，数值、数组、多级map。  </p><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>测试代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">npm i yamljs</span><br><span class="line">执行：nodejs test.js</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">YAML = require(&#x27;yamljs&#x27;);</span><br><span class="line"> function main()</span><br><span class="line">&#123;</span><br><span class="line">    // 固定配置文件名 TODO：容错处理</span><br><span class="line">    nativeObject = YAML.load(&#x27;config.yaml&#x27;);</span><br><span class="line">    </span><br><span class="line">    jsonstr = JSON.stringify(nativeObject);</span><br><span class="line">    theJson = JSON.parse(jsonstr, null);</span><br><span class="line">    </span><br><span class="line">    console.log(&quot;alljson: &quot;, theJson);</span><br><span class="line">    console.log(&quot;name: &quot;, theJson.name);</span><br><span class="line">    console.log(&quot;version: &quot;, theJson.version);</span><br><span class="line">    </span><br><span class="line">    console.log(&quot;empty: &quot;, theJson.empty); // nodejs 可处理null值</span><br><span class="line">    console.log(&quot;time: &quot;, theJson.time);</span><br><span class="line">    </span><br><span class="line">    console.log(&quot;name: &quot;, theJson.my.name);</span><br><span class="line">    console.log(&quot;name1: &quot;, theJson.my.name1);</span><br><span class="line">    console.log(&quot;age: &quot;, theJson.my.age);</span><br><span class="line">    </span><br><span class="line">    console.log(&quot;text: &quot;, theJson.text);</span><br><span class="line"></span><br><span class="line">    theText = &quot;&quot;;</span><br><span class="line">    // 数组，遍历</span><br><span class="line">    theJson.multi.sta.forEach(function(v, _, _)&#123;</span><br><span class="line">            theText += v + &#x27;\n&#x27;;</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(&quot;sta &quot;, theText);</span><br><span class="line"></span><br><span class="line">    // 是否需要显示提交日志</span><br><span class="line">    if (theJson.need == true)</span><br><span class="line">    &#123;</span><br><span class="line">        console.log(&quot;need...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// call main</span><br><span class="line">main();</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">$ node test.js</span><br><span class="line">alljson:  &#123; name: &#x27;conf file&#x27;,</span><br><span class="line">  version: 2,</span><br><span class="line">  need: true,</span><br><span class="line">  time: &#x27;2020-10-03T09:21:13.000Z&#x27;,</span><br><span class="line">  empty: &#x27;nul&#x27;,</span><br><span class="line">  my: &#123; name: &#x27;late \\n lee&#x27;, name1: &#x27;late \n lee&#x27;, age: 99 &#125;,</span><br><span class="line">  text: &#x27;hello\nworld!\n&#x27;,</span><br><span class="line">  fruit:</span><br><span class="line">   [ &#x27;apple&#x27;, &#x27;apple1&#x27;, &#x27;apple2&#x27;, &#x27;apple3&#x27;, &#x27;apple4&#x27;, &#x27;apple5&#x27; ],</span><br><span class="line">  multi:</span><br><span class="line">   &#123; sta:</span><br><span class="line">      [ &#x27;110 210 ddd 99&#x27;,</span><br><span class="line">        &#x27;133 135 1 2 1588 1509&#x27;,</span><br><span class="line">        &#x27;310-410&#x27;,</span><br><span class="line">        &#x27;333-444&#x27; ] &#125; &#125;</span><br><span class="line">name:  conf file</span><br><span class="line">version:  2</span><br><span class="line">empty:  nul</span><br><span class="line">time:  2020-10-03T09:21:13.000Z</span><br><span class="line">name:  late \n lee</span><br><span class="line">name1:  late</span><br><span class="line"> lee</span><br><span class="line">age:  99</span><br><span class="line">text:  hello</span><br><span class="line">world!</span><br><span class="line"></span><br><span class="line">bad:  undefined</span><br><span class="line">sta  110 210 ddd 99</span><br><span class="line">133 135 1 2 1588 1509</span><br><span class="line">310-410</span><br><span class="line">333-444</span><br><span class="line"></span><br><span class="line">need...</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="结果说明"><a href="#结果说明" class="headerlink" title="结果说明"></a>结果说明</h3><p>1、可以看到，解析后的 theJson 变量，就是整个配置文件的 json，可以直接使用其中的字段。<br>2、使用 yamljs 解析时，参数的值可以为 null 或 NULL。这点与 yaml-cpp 库不一样。<br>3、如果字段不存在时，得到的结果为 undefined，并不会出现段错误。这点与 yaml-cpp 库也不一样。    </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文使用 nodejs 的 yamljs 库对 yaml 文件进行解析。  &lt;/p&gt;</summary>
    
    
    
    <category term="我的程序代码" scheme="http://www.latelee.org/category/my-library/"/>
    
    
    <category term="nodejs" scheme="http://www.latelee.org/tag/nodejs/"/>
    
    <category term="工程库代码" scheme="http://www.latelee.org/tag/%E5%B7%A5%E7%A8%8B%E5%BA%93%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>yaml文件解析：c++篇</title>
    <link href="http://www.latelee.org/my-library/parsing-yaml-in-c++.html"/>
    <id>http://www.latelee.org/my-library/parsing-yaml-in-c++.html</id>
    <published>2020-12-26T16:00:00.000Z</published>
    <updated>2021-06-04T02:18:55.914Z</updated>
    
    <content type="html"><![CDATA[<p>本文使用 C++ 库 yaml-cpp 对 yaml 文件进行解析。  </p><span id="more"></span><h2 id="下载编译"><a href="#下载编译" class="headerlink" title="下载编译"></a>下载编译</h2><p>下载地址：<a href="https://github.com/jbeder/yaml-cpp/releases/tag/yaml-cpp-0.6.3">https://github.com/jbeder/yaml-cpp/releases/tag/yaml-cpp-0.6.3</a> 。 文件名为：yaml-cpp-yaml-cpp-0.6.3.zip。<br>解压，进入库目录，创建build目录。执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd build</span><br><span class="line">cmake ../</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>在build目录生成 libyaml-cpp.a 文件。将其与源码的 include 目录拷贝至工程目录，在编译时进行链接即可。</p><p>注：cmake须3.0以上。  </p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="yaml-配置文件"><a href="#yaml-配置文件" class="headerlink" title="yaml 配置文件"></a>yaml 配置文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"># yaml测试样例</span><br><span class="line"># null 或 NULL 为关键字，不能写</span><br><span class="line"></span><br><span class="line"># 名称</span><br><span class="line"># 字符串</span><br><span class="line">name: conf file</span><br><span class="line"></span><br><span class="line"># 版本</span><br><span class="line"># 如按浮点，2.0会转换成2</span><br><span class="line"># 如按字符串，保留原样</span><br><span class="line">version: 2.0</span><br><span class="line"></span><br><span class="line"># 布尔类，转换为1或0</span><br><span class="line">need: true</span><br><span class="line"></span><br><span class="line"># 时间</span><br><span class="line">time: 2020-10-03T09:21:13</span><br><span class="line"></span><br><span class="line">empty: nul</span><br><span class="line"></span><br><span class="line"># 对象</span><br><span class="line"># 加双引号会转义\n，即会换行</span><br><span class="line">my:</span><br><span class="line">  name: late \n lee</span><br><span class="line">  name1: &quot;late \n lee&quot;</span><br><span class="line">  age: 99</span><br><span class="line">  </span><br><span class="line"># 块</span><br><span class="line">text: |</span><br><span class="line">  hello</span><br><span class="line">  world!</span><br><span class="line"></span><br><span class="line"># 数组</span><br><span class="line">fruit:</span><br><span class="line">  - apple</span><br><span class="line">  - apple1</span><br><span class="line">  - apple2</span><br><span class="line">  - apple3</span><br><span class="line">  - apple4</span><br><span class="line">  - apple5</span><br><span class="line"></span><br><span class="line"># 多级数组</span><br><span class="line">multi:</span><br><span class="line">  sta:</span><br><span class="line">    - 110 210 ddd 99</span><br><span class="line">    - 133 135 1 2 1588 1509</span><br><span class="line">    - 310-410</span><br><span class="line">    - 333-444</span><br></pre></td></tr></table></figure><p>该示例基本涵盖了大部分的 yaml 格式。包括：字符串，数值、数组、多级map。  </p><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>测试代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;yaml-cpp/yaml.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc,char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    YAML::Node config;</span><br><span class="line">    // 当文件不存在或yaml格式出错时，抛异常</span><br><span class="line">    try &#123;</span><br><span class="line">        config = YAML::LoadFile(&quot;config.yaml&quot;);</span><br><span class="line">    &#125; catch (...) &#123;</span><br><span class="line">        printf(&quot;error loading file, yaml file error or not exist.\n&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 获取类型</span><br><span class="line">    for (YAML::const_iterator it = config.begin(); it != config.end(); ++it) &#123;</span><br><span class="line">        std::string key = it-&gt;first.as&lt;std::string&gt;();</span><br><span class="line">        YAML::Node value = it-&gt;second;</span><br><span class="line">        switch (value.Type()) &#123;</span><br><span class="line">            case YAML::NodeType::Scalar:</span><br><span class="line">            printf(&quot;key: %s scalar\n&quot;, key.c_str());</span><br><span class="line">            break;</span><br><span class="line">            case YAML::NodeType::Sequence:</span><br><span class="line">            printf(&quot;key: %s Sequence\n&quot;, key.c_str());</span><br><span class="line">            cout &lt;&lt; &quot;seq: &quot; &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">            break;</span><br><span class="line">            case YAML::NodeType::Map:</span><br><span class="line">            printf(&quot;key: %s Map\n&quot;, key.c_str());</span><br><span class="line">            break;</span><br><span class="line">            case YAML::NodeType::Null:</span><br><span class="line">            printf(&quot;key: %s Null\n&quot;, key.c_str());</span><br><span class="line">            break;</span><br><span class="line">            case YAML::NodeType::Undefined:</span><br><span class="line">            printf(&quot;key: %s Undefined\n&quot;, key.c_str());</span><br><span class="line">            break;</span><br><span class="line">            // etc.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 顶层</span><br><span class="line">    cout &lt;&lt; &quot;version:&quot; &lt;&lt; config[&quot;version&quot;].as&lt;float&gt;() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;version(str):&quot; &lt;&lt; config[&quot;version&quot;].as&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;need:&quot; &lt;&lt; config[&quot;need&quot;].as&lt;bool&gt;() &lt;&lt; endl; // 输出值为1</span><br><span class="line">    cout &lt;&lt; &quot;time:&quot; &lt;&lt; config[&quot;time&quot;].as&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;empty:&quot; &lt;&lt; config[&quot;empty&quot;].as&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    try &#123;</span><br><span class="line">        printf(&quot;sizeof array: %d\n&quot;, (int)config[&quot;fruit&quot;].size());</span><br><span class="line">        //cout &lt;&lt; &quot;fruit1:\n&quot; &lt;&lt; config[&quot;fruit&quot;] &lt;&lt; endl; // 此处返回 Node</span><br><span class="line">        // 索引方式取</span><br><span class="line">        //for (int i = 0; i &lt; (int)config[&quot;fruit&quot;].size(); i++)</span><br><span class="line">        //&#123;</span><br><span class="line">        //    cout &lt;&lt; &quot;fruit2: &quot; &lt;&lt; config[&quot;fruit&quot;][i].as&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">        //&#125;</span><br><span class="line">        // 单个取</span><br><span class="line">        for (auto item : config[&quot;fruit&quot;])</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;fruit3: &quot; &lt;&lt; item.as&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; catch(...) &#123;</span><br><span class="line">        printf(&quot;fruit not ok.\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    try &#123;</span><br><span class="line">        printf(&quot;new sta: \n&quot;);</span><br><span class="line">        for (auto item : config[&quot;multi&quot;][&quot;sta&quot;])</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%s \n&quot;, item.as&lt;string&gt;().c_str());</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125; catch (...) &#123;</span><br><span class="line">        //printf(&quot;key not exist...\n&quot;);</span><br><span class="line">        //return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 对于不存在的key，似乎只能用try</span><br><span class="line">    try &#123;</span><br><span class="line">        cout &lt;&lt; &quot;bad:&quot; &lt;&lt; config[&quot;bad&quot;].as&lt;int&gt;() &lt;&lt; endl;</span><br><span class="line">    &#125; catch (...) &#123;</span><br><span class="line">        printf(&quot;key bad not exist...\n&quot;);</span><br><span class="line">        //return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; &quot;text:&quot; &lt;&lt; config[&quot;text&quot;].as&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">    // 有两层</span><br><span class="line">    printf(&quot;name: %s \nname1: %s \nage: %d\n&quot;, </span><br><span class="line">            config[&quot;my&quot;][&quot;name&quot;].as&lt;string&gt;().c_str(),</span><br><span class="line">            config[&quot;my&quot;][&quot;name1&quot;].as&lt;string&gt;().c_str(),</span><br><span class="line">            config[&quot;my&quot;][&quot;age&quot;].as&lt;int&gt;());</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">./a.out </span><br><span class="line">key: name scalar</span><br><span class="line">key: version scalar</span><br><span class="line">key: need scalar</span><br><span class="line">key: time scalar</span><br><span class="line">key: empty scalar</span><br><span class="line">key: my Map</span><br><span class="line">key: text scalar</span><br><span class="line">key: fruit Sequence</span><br><span class="line">seq: - apple</span><br><span class="line">- apple1</span><br><span class="line">- apple2</span><br><span class="line">- apple3</span><br><span class="line">- apple4</span><br><span class="line">- apple5</span><br><span class="line">key: multi Map</span><br><span class="line">version:2</span><br><span class="line">version(str):2.0</span><br><span class="line">need:1</span><br><span class="line">time:2020-10-03T09:21:13</span><br><span class="line">empty:nul</span><br><span class="line">sizeof array: 6</span><br><span class="line">fruit3: apple</span><br><span class="line">fruit3: apple1</span><br><span class="line">fruit3: apple2</span><br><span class="line">fruit3: apple3</span><br><span class="line">fruit3: apple4</span><br><span class="line">fruit3: apple5</span><br><span class="line">new sta: </span><br><span class="line">110 210 ddd 99 </span><br><span class="line">133 135 1 2 1588 1509 </span><br><span class="line">310-410 </span><br><span class="line">333-444 </span><br><span class="line"></span><br><span class="line">key bad not exist...</span><br><span class="line">text:hello</span><br><span class="line">world!</span><br><span class="line"></span><br><span class="line">name: late \n lee </span><br><span class="line">name1: late </span><br><span class="line"> lee </span><br><span class="line">age: 99</span><br></pre></td></tr></table></figure><h3 id="结果说明"><a href="#结果说明" class="headerlink" title="结果说明"></a>结果说明</h3><p>1、<code>name: &quot;late \n lee&quot;</code> 输出会换行。而 <code>name: late \n lee</code> 则会原样输出。<br>2、参数的值不能为 null 或 NULL，但可以为nul。<br>3、如果字段不存在或非法，会直接报段错误，因此需要用 <code>try catch</code> 读取。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文使用 C++ 库 yaml-cpp 对 yaml 文件进行解析。  &lt;/p&gt;</summary>
    
    
    
    <category term="我的程序代码" scheme="http://www.latelee.org/category/my-library/"/>
    
    
    <category term="工程库代码" scheme="http://www.latelee.org/tag/%E5%B7%A5%E7%A8%8B%E5%BA%93%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>c++命令行解析库cmdline使用</title>
    <link href="http://www.latelee.org/my-library/cmdline-in-c++.html"/>
    <id>http://www.latelee.org/my-library/cmdline-in-c++.html</id>
    <published>2020-12-25T16:00:00.000Z</published>
    <updated>2021-06-04T02:18:55.914Z</updated>
    
    <content type="html"><![CDATA[<p>之前用过 getopt 函数对主函数参数进行解析，后发现了 cmdline 这个库——说是库，实际只是一个头文件，非常方便集成到程序中。本文对此库进行简单测试。  </p><span id="more"></span><h2 id="下载编译"><a href="#下载编译" class="headerlink" title="下载编译"></a>下载编译</h2><p>cmdline 库地址为：<a href="https://github.com/tanakh/cmdline">https://github.com/tanakh/cmdline</a> 。<br>可直接下载 cmdline.h 头文件使用，也可以下载仓库，编译其中的测试示例。  </p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>测试代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"></span><br><span class="line">如果解析不存在的参数，会报段错误，最好加默认值</span><br><span class="line"></span><br><span class="line">TODO：添加子命令，类似 git log、git status 这样的</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include &quot;cmdline.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool g_bPrint = false;</span><br><span class="line"></span><br><span class="line">// 有些帮助信息过多，使用函数组装</span><br><span class="line">char* getHelp(int type)</span><br><span class="line">&#123;</span><br><span class="line">    static char info[256] = &#123;0&#125;;</span><br><span class="line">    if (type == &#x27;t&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        sprintf(info, </span><br><span class="line">&quot; test type \n \</span><br><span class="line">autotest  - for auto test\n \</span><br><span class="line">dualtest  - for dual version test\n \</span><br><span class="line">more comming up...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return info;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    cmdline::parser theArgs;</span><br><span class="line">    // 一般形式：长命令名、短命令名（如不支持短命令填&#x27;\0&#x27;），描述，是否必填，默认值</span><br><span class="line">    // 如果为必填，则在运行时必须带该参数，否则解析失败</span><br><span class="line">    theArgs.add&lt;string&gt;(&quot;test&quot;, &#x27;t&#x27;, getHelp(&#x27;t&#x27;), false, &quot;auto&quot;);</span><br><span class="line">    theArgs.add&lt;string&gt;(&quot;host&quot;, &#x27;h&#x27;, &quot;host name&quot;, false, &quot;&quot;);</span><br><span class="line">    theArgs.add&lt;int&gt;(&quot;rate&quot;, &#x27;r&#x27;, &quot;rate number&quot;, false, 80, cmdline::range(1, 65535)); // 带默认值、范围的</span><br><span class="line"></span><br><span class="line">    // bool 型，与上述不同，后判断有无该参数</span><br><span class="line">    theArgs.add(&quot;print&quot;, &#x27;p&#x27;, &quot;show message&quot;); // 需要判断是否存在，存在则置标志为true</span><br><span class="line">    </span><br><span class="line">    //theArgs.add(&quot;help&quot;, 0, &quot;print this message1111&quot;);</span><br><span class="line"></span><br><span class="line">    //theArgs.footer(&quot;filename ...&quot;);</span><br><span class="line">    //theArgs.set_program_name(&quot;mytool&quot;);</span><br><span class="line">    theArgs.set_program_name(argv[0]);</span><br><span class="line">    </span><br><span class="line">    // 调整位置，让cmdline误以为第二个参数才是命令</span><br><span class="line">    //theArgs.parse_check(argc-1, &amp;argv[1]);</span><br><span class="line"></span><br><span class="line">    try&#123;</span><br><span class="line">        printf(&quot;test type: %s\n&quot;, theArgs.get&lt;string&gt;(&quot;test&quot;).c_str());</span><br><span class="line">    &#125; catch(const std::exception &amp;e)&#123;&#125;</span><br><span class="line">    try&#123;</span><br><span class="line">        printf(&quot;bad: %s\n&quot;, theArgs.get&lt;string&gt;(&quot;bad&quot;).c_str()); // 不存在的参数</span><br><span class="line">    &#125; catch(const std::exception &amp;e)&#123;</span><br><span class="line">        printf(&quot;param [bad] not exist...\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    try&#123;</span><br><span class="line">        printf(&quot;host: %s\n&quot;, theArgs.get&lt;string&gt;(&quot;host&quot;).c_str());</span><br><span class="line">    &#125; catch(const std::exception &amp;e)&#123;&#125;</span><br><span class="line">    try&#123;</span><br><span class="line">        printf(&quot;rate: %d\n&quot;, theArgs.get&lt;int&gt;(&quot;rate&quot;));</span><br><span class="line">    &#125; catch(const std::exception &amp;e)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    try&#123;</span><br><span class="line">        printf(&quot;rest args: \n&quot;);</span><br><span class="line">        for (int i = 0; i &lt; (int)theArgs.rest().size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            //cout &lt;&lt; theArgs.rest()[i] &lt;&lt; endl;</span><br><span class="line">            printf(&quot;%s\n&quot;, theArgs.rest()[i].c_str());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch(const std::exception &amp;e)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 此法不能判断不存在的参数</span><br><span class="line">    // if (theArgs.exist(&quot;type&quot;))</span><br><span class="line">    // &#123;</span><br><span class="line">    //     printf(&quot;type111: %d\n&quot;, theArgs.get&lt;string&gt;(&quot;type&quot;).c_str());</span><br><span class="line">    // &#125;</span><br><span class="line">    </span><br><span class="line">    // </span><br><span class="line">    if (theArgs.exist(&quot;rate&quot;)) // 非bool类型，似乎也不能如此判断</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;rate111: %d\n&quot;, theArgs.get&lt;int&gt;(&quot;rate&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (theArgs.exist(&quot;print&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        g_bPrint = false;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out </span><br><span class="line">argument number must be longer than 0</span><br><span class="line">usage: ./a.out [options] ... </span><br><span class="line">options:</span><br><span class="line">  -t, --test      test type </span><br><span class="line"> autotest  - for auto test</span><br><span class="line"> dualtest  - for dual version test</span><br><span class="line"> more comming up... (string [=auto])</span><br><span class="line">  -h, --host     host name (string [=])</span><br><span class="line">  -r, --rate     rate number (int [=80])</span><br><span class="line">  -p, --print    show message</span><br><span class="line">  -?, --help     print this message</span><br><span class="line"></span><br><span class="line">$ ./a.out -r 100 -h latelee.org</span><br><span class="line">test type: auto</span><br><span class="line">param [bad] not exist...</span><br><span class="line">host: latelee.org</span><br><span class="line">rest args: </span><br><span class="line">100</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前用过 getopt 函数对主函数参数进行解析，后发现了 cmdline 这个库——说是库，实际只是一个头文件，非常方便集成到程序中。本文对此库进行简单测试。  &lt;/p&gt;</summary>
    
    
    
    <category term="我的程序代码" scheme="http://www.latelee.org/category/my-library/"/>
    
    
    <category term="工程库代码" scheme="http://www.latelee.org/tag/%E5%B7%A5%E7%A8%8B%E5%BA%93%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>golang和C的输出格式化对齐</title>
    <link href="http://www.latelee.org/my-library/printf-format-alignment-in-golang-and-c.html"/>
    <id>http://www.latelee.org/my-library/printf-format-alignment-in-golang-and-c.html</id>
    <published>2020-12-22T16:00:00.000Z</published>
    <updated>2021-06-04T02:18:55.914Z</updated>
    
    <content type="html"><![CDATA[<p>写代码那么多年，对代码，输出日志有一种近似洁癖的要求。对于不整齐、不整洁、命名混乱的代码，真心看不下去，总会想办法去整顿——或用工具，或人工。曾因这个原因耽误时间，虽然想着改，但一时也改不了多少。今年唯一例外的，应该我手上维护的那套98年开始写的 delphi 工程。  </p><p>本文从小处着手，单说一些输出日志的对齐方法。  </p><span id="more"></span><p>在 golang 中，常用的命令行库为 cobra，内部实现了帮助信息的对齐。以 docker 为例，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># docker --help</span><br><span class="line">Usage:  docker [OPTIONS] COMMAND</span><br><span class="line"></span><br><span class="line">A self-sufficient runtime for containers</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --config string      Location of client config files (default &quot;/root/.docker&quot;)</span><br><span class="line">  -D, --debug              Enable debug mode</span><br><span class="line"></span><br><span class="line">Management Commands:</span><br><span class="line">  builder     Manage builds</span><br><span class="line">  config      Manage Docker configs</span><br><span class="line">  container   Manage containers</span><br><span class="line">  context     Manage contexts</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  attach      Attach local standard input, output, and error streams to a running container</span><br><span class="line">  build       Build an image from a Dockerfile</span><br><span class="line">  commit      Create a new image from a container&#x27;s changes</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在自己实现的小型命令终端程序框架时，也使用了 cobra ，但做了一些精简，比如子命令的命令，按官方方法是使用多级子命令形式，但觉得麻烦，将“子命令的命令”作为子命令的参数处理，但如此一来，有些输出信息就不整齐了。<br>为解决问题，参考了 cobra 源码，提炼出核心代码，最终达到预期目标。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ ./cmdtool.exe test</span><br><span class="line">test...</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  foo   just a foo help info</span><br><span class="line">  watch watch config file</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  cmdtool.exe test [flags]</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">  example comming up...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -h, --help       help for test</span><br><span class="line">  -m, --mode int   set the test mode</span><br><span class="line"></span><br><span class="line">Global Flags:</span><br><span class="line">  -c, --config string   config file (config.yaml)</span><br><span class="line">  -o, --output string   specify the output file name</span><br><span class="line">  -p, --print           verbose output</span><br></pre></td></tr></table></figure><p>其中，<code>Available Commands:</code>为自定义函数中的输出，将参数作为子命令的命令。核心代码如下：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// rpad adds padding to the right of a string.</span><br><span class="line">func rpad(s string, padding int) string &#123;</span><br><span class="line">truetemplate := fmt.Sprintf(&quot;%%-%ds&quot;, padding)</span><br><span class="line">truereturn fmt.Sprintf(template, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//返回字符串的</span><br><span class="line">func GetHelpInfo(theCmd []conf.UserCmdFunc) (ret string) &#123;</span><br><span class="line">truevar cmdMaxLen int = 0</span><br><span class="line">trueret = fmt.Sprintf(&quot;Available Commands:\n&quot;);</span><br><span class="line"></span><br><span class="line">truefor _, item := range theCmd &#123;</span><br><span class="line">truetruenameLen := len(item.Name)</span><br><span class="line">truetrueif nameLen &gt; cmdMaxLen &#123;</span><br><span class="line">truetruetruecmdMaxLen = nameLen</span><br><span class="line">truetrue&#125;</span><br><span class="line">true&#125;</span><br><span class="line">true</span><br><span class="line">truefor _, item := range theCmd &#123;</span><br><span class="line">truetrueret += fmt.Sprintf(&quot;  %v %v\n&quot;, rpad(item.Name, cmdMaxLen), item.ShortHelp)</span><br><span class="line">true&#125;</span><br><span class="line">true</span><br><span class="line">truereturn</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>rpad</code>为组装格式化字符串（因此会出现多个<code>%</code>，<code>-</code>为左对齐）函数，输入的<code>padding</code>为一列数据的最大值，该值是遍历用户命令列表的名称，获取得到 的最大长度。用户命令列表如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var theCmd = []conf.UserCmdFunc&#123;</span><br><span class="line">    conf.UserCmdFunc &#123;</span><br><span class="line">        Name: &quot;foo&quot;,</span><br><span class="line">        ShortHelp: &quot;just a foo help info&quot;,</span><br><span class="line">        Func: foo,</span><br><span class="line">    &#125;,</span><br><span class="line">    conf.UserCmdFunc &#123;&quot;watch&quot;, &quot;watch config file&quot;, testWatch,&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依据上述思路，在C中也容易实现类似的对齐需求。示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char fmt[128] = &#123;0&#125;;</span><br><span class="line">sprintf(fmt, &quot;autoTestFee %%s%%-%ds -&gt; %%s%%-%ds vehicleType %%s payFee %%-6d outFee %%-9.2f realFee %%-6d\n&quot;, </span><br><span class="line">              nameLen1+2, nameLen2+2);</span><br><span class="line">// printf(&quot;%s\n&quot;, fmt);</span><br><span class="line">printf(fmt, item-&gt;en, item-&gt;enName, item-&gt;ex, item-&gt;exName, type, payFee, outFee, realFee);</span><br></pre></td></tr></table></figure><p>代码中使用 sprintf 组装格式化字符串，该语句转化后如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;autoTestFee %s%-10s -&gt; %s%-9s vehicleType %s payFee %-6d outFee %-9.2f realFee %-6d\n&quot;  # 数字为示例</span><br></pre></td></tr></table></figure><p>其中 nameLen1 和 nameLen2 分别为 enName 和 exName 列表的最大值（方便对齐）。<br>结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">autoTestFee 100(hello)     -&gt; 200(foobarrrrbbbbbbbbbbb) vehicleType 未名 payFee 2018   outFee 20.00     realFee 2003  </span><br><span class="line">autoTestFee 101(hello)     -&gt; 201(f)                    vehicleType 未名 payFee 2019   outFee 20.00     realFee 2003  </span><br></pre></td></tr></table></figure><p>这样，在搜索日志时就容易分辨了。  </p><p>经测试，如果字符串含有中文且中文长度不等（或中英混合），对齐还是有问题，待后续解决。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;写代码那么多年，对代码，输出日志有一种近似洁癖的要求。对于不整齐、不整洁、命名混乱的代码，真心看不下去，总会想办法去整顿——或用工具，或人工。曾因这个原因耽误时间，虽然想着改，但一时也改不了多少。今年唯一例外的，应该我手上维护的那套98年开始写的 delphi 工程。  &lt;/p&gt;
&lt;p&gt;本文从小处着手，单说一些输出日志的对齐方法。  &lt;/p&gt;</summary>
    
    
    
    <category term="我的程序代码" scheme="http://www.latelee.org/category/my-library/"/>
    
    
    <category term="工程库代码" scheme="http://www.latelee.org/tag/%E5%B7%A5%E7%A8%8B%E5%BA%93%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>架构师考点汇总 UML图</title>
    <link href="http://www.latelee.org/architecture/architect-note-uml.html"/>
    <id>http://www.latelee.org/architecture/architect-note-uml.html</id>
    <published>2020-12-22T16:00:00.000Z</published>
    <updated>2021-06-04T02:18:55.926Z</updated>
    
    <content type="html"><![CDATA[<p>架构师考点汇总 UML各种图，类型</p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;架构师考点汇总 UML各种图，类型&lt;/p&gt;</summary>
    
    
    
    <category term="软件架构" scheme="http://www.latelee.org/category/architecture/"/>
    
    
    <category term="考证" scheme="http://www.latelee.org/tag/%E8%80%83%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>架构师考点汇总 一些技术英文缩写</title>
    <link href="http://www.latelee.org/architecture/architect-note-tech-word.html"/>
    <id>http://www.latelee.org/architecture/architect-note-tech-word.html</id>
    <published>2020-12-22T16:00:00.000Z</published>
    <updated>2021-06-04T02:18:55.926Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>IOC：</p><p>控制反转(Inversion of Control，缩写为IoC)，是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入(Dependency Injection，简称DI)，还有一种方式叫“依赖查找”(Dependency Lookup)。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。</p><p>AOP：</p><p>在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><p>CAS：</p><p>是一种乐观锁机制。CAS是英文单词Compare And Swap的缩写，翻译过来就是比较并替换。CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。</p><p>CAP：</p><p>CAP原则又称CAP定理，指的是在一个分布式系统中，一致性(Consistency)、可用性(Availability)、分区容忍性(Partition tolerance)。CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。</p><p>一致性(C)：在分布式系统中的所有数据备份，在同一时刻是否同样的值。(等同于所有节点访问同一份最新的数据副本)</p><p>可用性(A)：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。(对数据更新具备高可用性)</p><p>分区容忍性(P)：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</p><p>AICD：</p><p>事务属性AICD：</p><p>原子性(Atomicity)：整体不可分割性，要么全做要不全不做。</p><p>一致性(Consistency) ：事务执行前、后数据库状态均一致。</p><p>隔离性(Isolation) ：在事务未提交前，它操作的数据，对其它用户不可见(从其他session读取的数据还是commit之前的数据状态)。</p><p>持久性(Durability)：一旦事务成功，将进行永久的变更，记录与redo日志。</p><p>RC：</p><p>数据库隔离级别，Read Committed(读取提交内容)。</p><p>(1) 这是大多数数据库系统的默认隔离级别(但不是MySQL默认的)</p><p>(2)它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变</p><p>(3)这种隔离级别出现的问题是——不可重复读(Nonrepeatable Read)：不可重复读意味着我们在同一个事务中执行完全相同的select语句时可能看到不一样的结果。</p><p>RR：</p><p>数据库隔离级别，Repeatable Read(可重读)。</p><p>(1)这是MySQL的默认事务隔离级别。</p><p>(2)它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。</p><p>(3)此级别可能出现的问题——幻读(Phantom Read)：当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。</p><p>(4)InnoDB和Falcon存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)机制解决了该问题。</p><p>Binlog：</p><p>是The Binary Log的简称，意思就是二进制的日志文件。binlog是一个二进制格式的文件，用于记录用户对数据库更新的SQL语句信息，例如更改数据库表和更改内容的SQL语句都会记录到binlog里，但是对库表等内容的查询不会记录。默认情况下，binlog日志是二进制格式的，不能使用查看文本工具的命令(比如，cat，vi等)查看，而使用mysqlbinlog解析查看。当有数据写入到数据库时，还会同时把更新的SQL语句写入到对应的binlog文件里，这个文件就是上文说的binlog文件。使用mysqldump备份时，只是对一段时间的数据进行全备，但是如果备份后突然发现数据库服务器故障，这个时候就要用到binlog的日志了。主要作用是用于数据库的主从复制及数据的增量恢复。</p><p>MVCC：</p><p>Multi-Version Concurrency Control 多版本并发控制，MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问;在编程语言中实现事务内存。MVCC是通过保存数据在某个时间点的快照来实现的. 不同存储引擎的MVCC. 不同存储引擎的MVCC实现是不同的,典型的有乐观并发控制和悲观并发控制。</p><p>RESP：</p><p>Redis Serialization Protocol，RESP 是 Redis 序列化协议的简写。它是一种直观的文本协议，优势在于实现异常简 单，解析性能极好。</p><p>COW：</p><p>写入时复制(英语：Copy-on-write，简称COW)是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者(callers)同时请求相同资源(如内存或磁盘上的数据存储)，他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本(private copy)给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的(transparently)。 优点是如果调用者没有修改该资源，就不会有副本(private copy)被建立，因此多个调用者只是读取操作时可以共享同一份资源。</p><p>AMQP：</p><p>即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。Erlang中的实现有 RabbitMQ等。</p><p>SDS：</p><p>简单动态字符串(simple dynamic string，SDS)的抽象类型。字符串是Redis中最为常见的数据存储类型，其底层实现是简单动态字符串sds(simple dynamic string)，是可以修改的字符串。它类似于Java中的ArrayList，它采用预分配冗余空间的方式来减少内存的频繁分配。C语言字符串使用长度为n+1的字符数组来表示长度为n的字符串，并且字符数组的最后一个元素总是空字符’\0’，因为这种字符串表示方式不能满足Redis对字符串在安全性、效率以及功能方面的要求，所以Redis自己构建了SDS，用于满足其需求。在Redis里，C语言字符串只用于一些无须对字符串值进行修改的地方，比如：日志。在Redis中，包含字符串值的键值对都是使用SDS实现的，除此之外，SDS还被用于AOF缓冲区、客户端状态的输入缓冲区。</p><p>DDD：</p><p>DDD(Domain-Driven Design 领域驱动设计)是由Eric Evans最先提出，目的是对软件所涉及到的领域进行建模，以应对系统规模过大时引起的软件复杂性的问题。整个过程大概是这样的，开发团队和领域专家一起通过 通用语言(Ubiquitous Language)去理解和消化领域知识，从领域知识中提取和划分为一个一个的子领域(核心子域，通用子域，支撑子域)，并在子领域上建立模型，再重复以上步骤，这样周而复始，构建出一套符合当前领域的模型。</p><p>RDB：</p><p>Redis支持RDB和AOF两种持久化机制，持久化功能有效地避免因进程退出造成的数据丢失问题，当下次重启时利用之前持久化文件即可实现数据恢复。RDB (Redis DataBase)。RDB 是 Redis 默认的持久化方案。在指定的时间间隔内，执行指定次数的写操作，则会将内存中的数据写入到磁盘中。即在指定目录下生成一个dump.rdb文件。Redis 重启会通过加载dump.rdb文件恢复数据。RDB持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化过程分为手动触发和自动触发。</p><p>AOF：</p><p>Redis支持RDB和AOF两种持久化机制，持久化功能有效地避免因进程退出造成的数据丢失问题，当下次重启时利用之前持久化文件即可实现数据恢复。AOF(append only file)持久化：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令达到恢复数据的目的。AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式。</p><p>ZAB：</p><p>ZAB 协议全称：Zookeeper Atomic Broadcast(Zookeeper 原子广播协议)。ZAB 协议的消息广播过程使用的是一个原子广播协议，类似一个 二阶段提交过程。对于客户端发送的写请求，全部由 Leader 接收，Leader 将请求封装成一个事务 Proposal，将其发送给所有 Follwer ，然后，根据所有 Follwer 的反馈，如果超过半数成功响应，则执行 commit 操作(先提交自己，再发送 commit 给所有 Follwer)。</p><p>ACK：</p><p>ACK消息，Acknowledgement 。是在计算机网上中通信协议的一部分，是设备或是进程发出的消息，回复已收到数据。例如在传输控制协议(TCP，Transmission Control Protocol)中就有用ACK来告知创建链接时有收到SYN数据包、使用链接时有收到数据包，或是在中止链接有收到FIN数据包。</p><p>BIO：</p><p>Blocking Input Output，同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</p><p>NIO：</p><p>NIO是指将IO模式设为“Non-Blocking”模式。NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。</p><p>来源：<a href="https://developer.51cto.com/art/201907/599675.htm">https://developer.51cto.com/art/201907/599675.htm</a>  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;IOC：&lt;/p&gt;
&lt;p&gt;控制反转(Inversion of Control，缩写为IoC)，是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入(Dependency Inject</summary>
      
    
    
    
    <category term="软件架构" scheme="http://www.latelee.org/category/architecture/"/>
    
    
    <category term="考证" scheme="http://www.latelee.org/tag/%E8%80%83%E8%AF%81/"/>
    
    <category term="设计原则" scheme="http://www.latelee.org/tag/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
</feed>
