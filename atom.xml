<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>迟思堂随笔</title>
  
  <subtitle>李迟的技术主页</subtitle>
  <link href="http://www.latelee.org/atom.xml" rel="self"/>
  
  <link href="http://www.latelee.org/"/>
  <updated>2022-01-27T09:13:09.413Z</updated>
  <id>http://www.latelee.org/</id>
  
  <author>
    <name>李迟</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>李迟2022年1月知识总结</title>
    <link href="http://www.latelee.org/my-library/code-for-2022-01.html"/>
    <id>http://www.latelee.org/my-library/code-for-2022-01.html</id>
    <published>2022-01-29T16:00:00.000Z</published>
    <updated>2022-01-27T09:13:09.413Z</updated>
    
    <content type="html"><![CDATA[<p>本文为 2022 年 1 月知识总结。</p><span id="more"></span><h2 id="研发编码"><a href="#研发编码" class="headerlink" title="研发编码"></a>研发编码</h2><h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><p>golang中中文字符长度为3，如下示例中，判断某字段中文开头是否为“广西”二字，如是则舍去，只保留后面的字符串，如“广西岑溪市”变为“岑溪市”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">outName := string([]byte(item.Name[:6]))</span><br><span class="line">klog.Printf(&quot;%s\n&quot;, outName)</span><br><span class="line">if outName == &quot;广西&quot; &#123;</span><br><span class="line">    outName = string([]byte(item.Name[6:]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="编码其它"><a href="#编码其它" class="headerlink" title="编码其它"></a>编码其它</h3><h2 id="其它研究"><a href="#其它研究" class="headerlink" title="其它研究"></a>其它研究</h2><p>windows 10 家庭版，安装某服务器控制，提示“扩展属性不一致”，百思无解，后无意发现与第三方某狗输入法有关，切换输入法或卸载，问题解决。</p><h2 id="工作记录"><a href="#工作记录" class="headerlink" title="工作记录"></a>工作记录</h2><h2 id="本月做的事及计划"><a href="#本月做的事及计划" class="headerlink" title="本月做的事及计划"></a>本月做的事及计划</h2><p>经过一个月紧张的装修、搬家，终于入住新房了，大锤大妞经常房间跑来跑去，很是兴奋。调查了几个菜市场，价格普遍较高，还得在老地方买菜。</p><p>发了年终奖，在卡里呆了几天后，就还了。</p><p>李迟 2022.1.30 周日</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文为 2022 年 1 月知识总结。&lt;/p&gt;</summary>
    
    
    
    <category term="我的程序代码" scheme="http://www.latelee.org/category/my-library/"/>
    
    
    <category term="代码积累" scheme="http://www.latelee.org/tag/%E4%BB%A3%E7%A0%81%E7%A7%AF%E7%B4%AF/"/>
    
    <category term="知识总结" scheme="http://www.latelee.org/tag/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>一建复习摘录</title>
    <link href="http://www.latelee.org/%E4%B8%80%E5%BB%BA/construction-basic-note2.html"/>
    <id>http://www.latelee.org/%E4%B8%80%E5%BB%BA/construction-basic-note2.html</id>
    <published>2022-01-26T16:00:01.000Z</published>
    <updated>2022-01-27T09:13:09.417Z</updated>
    
    <content type="html"><![CDATA[<p>一建复习摘录</p><span id="more"></span><h2 id="1-经济"><a href="#1-经济" class="headerlink" title="1.经济"></a>1.经济</h2><p>考题比较直观，难度不是很大。经济涉及很多考生未接触过的知识点，名词都不认识的话肯定不能通过考试，因此经济要最先学习。近几年经济考公式稍多，其实大多数公式都是由一等比数列求和以及复利公式推导而来，只要记住等比数列求和自己推导即可，如果觉得公式比较长，不妨将1+i用一个字母比如t代替，公式就会短很多。切记不要对所有的知识点都去深入学习，比较专业的知识点，往往不会考，更不要迷上经济了。</p><h3 id="2-法规"><a href="#2-法规" class="headerlink" title="2.法规"></a>2.法规</h3><p>法规是各种社会准则的书面表达，因此有部分人不看书也能通过法规。法规学习要把与社会准则不一致的地方重点标记(这些地方经常考)，容易理解的地方可以适当忽略，相对来讲，法规不难。但近几年法规考题较灵活，陷阱多，不像经济那样看着对了就对了，很可能你看着对的刚好就是个陷阱，因此考试一定要细心，认真审题。</p><h2 id="3-管理"><a href="#3-管理" class="headerlink" title="3.管理"></a>3.管理</h2><p>管理较抽象，较法规要花更多的时间，管理要多做笔记(在教材上最好)，理解较抽象的知识点。建议多做真题，相对来说管理的考点也相对固定，每年很容易考易混淆的知识点和对比的知识点，比如项目结构图、组织结构图那一堆，各种发包方式的特点等。</p><h3 id="4-实务"><a href="#4-实务" class="headerlink" title="4.实务"></a>4.实务</h3><p>考题是最灵活的，也是控制通过率的重要手段。通过近几年的实务考试可以发现，从最初的比较简单的固定的大考点逐渐细化到比较小的考点，这对各位考生来说难度逐渐增大。可以说从最开始的更偏向于进度管理、造价管理这2个大的考点逐渐转向技术部分，而技术部分也由最开始比较集中的几章逐渐分散。</p><p>实务考试要对整本书都比较熟悉，千万不要忽略技术部分，近几年技术部分的分值与管理部分基本持平。对施工不是很熟悉的朋友建议看看施工视频动画。实务一定要多看书，建议最少3遍，最好5遍以上，有的考生甚至看了15遍。</p><h3 id="一般原则"><a href="#一般原则" class="headerlink" title="一般原则"></a>一般原则</h3><p>1、公共课只用1到2个月时间.公共课内容简单，而且都是选择题，秉着谨小慎微的原则做题，及格不成问题，如果担心公共课过不去，可以适当增加时间，但是绝不能超过2个月，否则专业课不过就功亏一篑了。就算第一次公共课没考过，第二年肯定过了，但是专业课没过，第二年的压力会更大。</p><p>2、选择题很重要。可以毫不客气的说，选择题决定成败。我们可以算一笔账，满分160分，选择40，大题120，大题中又有30分是我们没见过的题目，90分之中因为主观题经常有写漏的点，拿个70%差不多，这就是63分，选择题如果能上30分，这就是93分，在那没见过的30分中蒙上一通，基本也就及格了，如果选择能上35分，那么及格是稳稳的事情，但是如果选择题只有25分，那么基本无望了。大题很活，稍有不慎就会掉入陷阱，我们何不把眼前的选择题拿到呢？</p><p>作为过来人的方法：1、花很多时间看书（在工地或者其他原因不方便带书可以用iPad mini看，别说你不习惯），书要看很多遍，案例我看了四遍半。2.加几个活跃质量好的QQ群，参加讨论，很重要，学霸比较多可以帮你梳理思路，一定要参与讨论而不是看别人。3.勤用百度，搞懂各名词，一般问身边人效率太低。4.历年真题多研究。5.平时多动笔。</p><p>公共科目内容繁多，但是考点相对分明，所以建议跟着课件学，冗余无用的知识甚至看都不用去看。分数多、与实务联系密切的章节，如《<a href="https://www.zhihu.com/search?q=%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1391682259%7D">项目管理</a>》的合同管理、进度控制、质量控制，《<a href="https://www.zhihu.com/search?q=%E6%B3%95%E8%A7%84&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1391682259%7D">法规</a>》的发承包、安全生产与质量法律制度，《经济》的工程估价等章节，可以多听两遍课件，或多听一个老师的课，加强理解，加深印象。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一建复习摘录&lt;/p&gt;</summary>
    
    
    
    <category term="一建" scheme="http://www.latelee.org/category/%E4%B8%80%E5%BB%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>一建基础概念</title>
    <link href="http://www.latelee.org/%E4%B8%80%E5%BB%BA/construction-basic-note.html"/>
    <id>http://www.latelee.org/%E4%B8%80%E5%BB%BA/construction-basic-note.html</id>
    <published>2022-01-26T16:00:00.000Z</published>
    <updated>2022-01-27T09:13:09.417Z</updated>
    
    <content type="html"><![CDATA[<p>一建基础概念汇总</p><span id="more"></span><p>考四科</p><p><img src="/%E4%B8%80%E5%BB%BA/construction-basic-note/image-20220127105825682.png" alt="image-20220127154943261"></p><p>一级建造师考试共有《建设工程项目管理》、《建设工程经济》、《建设工程法规及相关知识》、《专业工程管理与实务》四科，考试题型包括单项选择题、多项选择题和案例分析题，选择题310道，案例分析题5道。</p><p>一建具体题型及分值如下：</p><blockquote><p>《建设工程经济》：单选题：60道1分/道；多选题：20道2分/道。<br>《建设工程项目管理》：单选题：70道1分/道；多选题：30道2分/道。<br>《建设工程法规及相关知识》：单选题：70道1分/道；多选题：30道2分/道。<br>《专业工程管理与实务》：单选题：20道1分/道；多选题：10道2分/道；案例题：5道占120分。</p></blockquote><p><strong>一建各专业难度排行，从易到难：</strong></p><p>1、建筑 2、机电 3、公路 4、市政 5、铁路 6、水利水电 7、通讯广电 8、民航机场工程 9、港口与航道工程 10、矿业工程</p><p>广西报名费：公共61/科，实务70/科</p><p>考试成绩实行2年为一个周期的滚动管理办法，参加全部4个科目考试的人员必须在连续的两个考试年度内通过全部科目；免试部分科目的人员必须在一个考试年度内通过应试科目。</p><p><strong>关于教材</strong></p><p>一建考试教材总共有13本，但是考生只需要用到其中的四本，此项考试设《建设工程经济》、《建设工程法规及相关知识》 、《建设工程项目管理》和《专业工程管理与实务》4个科目。《专业工程管理与实务》在剩下的10本挑选其中一本即可。一级建造师考试教材唯一官方出版社是中国建筑工业出版社，购买一级建造师执业资格考试用书请认准“建工版”正版图书。</p><p><strong>考纲</strong></p><p>一建考试大纲并不是每年都改，基本上改动频率为三年一次，每年到考试报名阶段，也就是5月份左右，住建部会公布本年度的考试大纲，可能改动也可能沿用老版本。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一建基础概念汇总&lt;/p&gt;</summary>
    
    
    
    <category term="一建" scheme="http://www.latelee.org/category/%E4%B8%80%E5%BB%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>2021年个人总结</title>
    <link href="http://www.latelee.org/the-life/my-2021.html"/>
    <id>http://www.latelee.org/the-life/my-2021.html</id>
    <published>2022-01-03T16:00:00.000Z</published>
    <updated>2022-01-27T09:13:09.565Z</updated>
    
    <content type="html"><![CDATA[<p>2022年的脚步已经来临了。时光荏苒，白驹过隙，日月如梭，岁月不居，时节如流，又到了一年总结的时候了。<span id="more"></span></p><p>今年过得特别快，很多时候都是忙，各种忙，工作，买房，考证，装修，等等，一下子又到年底了。可以用“意外”一词总结今年。  </p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="2021年计划的复盘"><a href="#2021年计划的复盘" class="headerlink" title="2021年计划的复盘"></a>2021年计划的复盘</h3><p>可能通过工程师职称评审，已经交钱了，正在公示。  </p><p>通过架构师考试，月底应该可以拿到证书。</p><p>带大锤大妞看了几次火车和夕阳。单独带大锤大妞去了一次人民公园。</p><p><del>年初定的目标实现了几个，从中可以看到，我还是有一定的执行力的。我对自己狠起来连自己都怕，但人生在世得和他人交往，只是我在其他人的评价中不高而已。</del></p><h3 id="流水账"><a href="#流水账" class="headerlink" title="流水账"></a>流水账</h3><p>1月份，无。<br>2月份，在南宁过年。<br>3月份，无。<br>4月份，公司搬到五象，离得更远，起得更早。<br>5月份，无。<br>6月份，决定买房。<br>7月份，着手买房事宜。开始评职称。<br>8月份，进行买房。评职称。<br>9月份，进行买房。<br>10月份，带大锤回老家看奶奶。<br>11月份，参加软考，带着大锤献血400cc。<br>12月份，过户，装修，（小量多次）搬家，加班。      </p><h2 id="工作学习"><a href="#工作学习" class="headerlink" title="工作学习"></a>工作学习</h2><p>公司配的电脑发生了2次意外，都是硬盘损坏，年初一次、年底一次，都是在关键时间节点上坏的，第一次是固态硬盘，直接报废掉，除上传内网 git 仓库外，大部分数据丢失，后来换了机械硬盘，摔地上也坏了，现在也不知道能不能修复好。主要工程和文档都上传仓库，因此并没有影响任务进度。</p><p>今年4月份公司搬迁，听说是新建一个子公司，领导说对外包的人来说是好事，除了上班远了一点，让我意外的是有600多块的餐补，我计算一番，除了自己吃的外，每个月还可以花400块在超市买牛奶零食日用品，于我而言这是意外之喜。但意外始终是意外，6月份发布公告，外包人员取消餐补，欢乐的时光总是短暂的，大锤牛奶自由始终是幻想，我又恢复带饭的传统。在本文发表十多天后，又意外发布公告，公司不承担外包人员餐费，需补回所有费用及制卡工本费。迟来的追缴让一切回归实现，但不管怎么说，彼时彼情，还是一段美好的回忆。</p><p>由于部门调整，我接手了2个 c++ 工程。说来奇怪，在接手前没听到同事讨论那些工程有什么隐患，但到了我手上，连续出现问题，而且还是生产环境的，幸好编程语言不陌生，平时也有带电脑回去的习惯，所以没有出现什么重大过失——哪怕是中秋假期。由于有一定经验，在排查诸如段错误、CPU 占用率高等问题时，也是理清思路，在既定时间要求内完成任务。</p><p>上半年一般不怎么忙，我在部门服务器用 docker 部署了几个应用，除去年的 oracle 外，还有 mysql。另外用 vuepress 搭建了一个内部知识平台网站，存放一些必要的经常查询的数据表，这个网站一直被同事使用着，只是由我维护。年中时部门参加 CMMI5 认证，因为我没做项目，领导让我负责一个已经完成的项目的管理工作，实际就是找文档，再按 CMMI5 流程再写各种文档，还要使用指定工具绘制图表，年底通过了评级，持续大半年的努力没有白费——当然我不是主力。在此过程中，参与了若干会议，包括现场培训和视频会议，还搭建了 gitlab 和 jenkins，将内部知识平台实现自动化部署。</p><p>在评职称中，深切感受到人情世故，也感受到同事协助的重要性。去年因为公司政策无法评，年初花了几天赶一篇论文出来，花了600多块钱找中介，但没核对出问题，我倒找了好几处笔误。由于这几年基本一年换一家公司，业绩不好写，只能向前前前前公司要业绩，打听一番，跟人事询问怎么办手续，个中低三下四，态度十分诚恳。要写保证书，要签字，再用午睡时间跑去那边盖章，最终顺利拿到手。因为已经决定买房，所以将档案移到南宁，于是在区级别职改办评审，在8月底截至时间前提交资料，后每隔几天查一下，一直到国庆收假才收到退回的消息，于是连忙修改，翌日完成提交，又等待一个多月，收到交费消息，连忙交钱，直到年底最后一天才看到公示结果。</p><p>今年年初、年中、年底特别忙，免不了加班，尤其是年底，连轴转搞了十多天。对于加班我是不抗拒的，只是希望在年终奖上有所体现。如果以年为单位的话，加班也不算多，即便是12 月份，打卡加班时长近50小时，但在元旦这几天也能平静休息（实际干活）一下。</p><p>总体而言，除了福利和一些必要事务外，这边没有刻意区别正式员工和外包员工，我也慢慢和部分其它同事打成一片，原则是和谁都友好相处，遇事能帮就帮。</p><h2 id="个人技能"><a href="#个人技能" class="headerlink" title="个人技能"></a>个人技能</h2><p>因为考架构师，以考促学，抛开应试这个事实不谈，我也能从中了解架构、分布式等方面的知识，对诸如设计模式、设计原则也有进一步认识。有的能应用到工作上，有的只是业余兴趣看看而已，如分布式，还得在实际中使用才能学到东西，否则就是皮毛而已。<br>至于个人技术，跟去年一样，没有太多提升，研究的并不多。已经将 golang 作为我的第二使用语言了，今年开发了几个小工具（但不涉及高深技术，都是业务类的），还研究了如何调用 C++ 动态库（使用 C 封装了一层），也学习了一段时间 vue，但前端真的不是擅长，一个页面小改动，都要花很多时间。<br>个人学技术和工作用的技术不一定冲突，也不一定要完全一样，我一般是在工作中寻找可以发挥的技术，既能完成工作，又积累技能。</p><p>文章写作方面，CSDN 有记录的约 50 篇，排名一度到400多名，这倒使我有点心虚了，因为自己清楚有几斤几两，很多年前和桂哥比排名，他是2000多，我是4000多，那时就搞了很多文章赶排名，现在却看淡了。年中一个偶然机会加入掘金社区，在活动期间不断发文，前后收获若干奖品，包括但不限于杯子、背包、空调毯、按摩仪、咖啡机，等。当然大部分文章是多年的存货，只有部分是更新的。<br>至于本地编辑工具，目前主要使用 typora，并修改了 hexo 配置，将本地的编辑和网站的部署统一起来。这个工具让我满意的地方是可以直接复制粘贴图片并看到预览（这是我一直想要的功能），真正实现所见即所得，对于中英文URL也友好。工作上因为个人接触的杂事实在太多，所以将笔记集中起来，统一用 gitlab 管理，使用 markdown 格式编写，按事项分类。目前来，个人笔记的编辑方式基本不再修改了。</p><p>公司办公地点由西乡塘搬到五象，离租房更远了，以前上班路上是听不完《金刚经》的，如今能听一遍《金刚经》再加一遍《心经》。考证前，听的视频大部分和架构有关（中文的，英文的），后来改听一些人文方面的，说来也怪，像经济学投资学的内容，我很难听下去，但（B站杨宁老师的）美学和文学理论却听完了。虽然骑车分神，所幸南宁有礼让的习惯，这一年骑着电驴行走大街小巷没碰到别人，也没被别人碰到。</p><p>由于要回归家庭，加上年纪渐大，没有强求一定研究哪些技术，但还是列一下明年重点内容：<br>完善 golang 后台，着手前端开发。<br>对文章发表数量不作要求，原则上有需要时再写。<br>尝试找点技术研究。比如 liteos、分布式涉及的知识点（如网关、转发、高并发等）。    </p><h2 id="家庭生活"><a href="#家庭生活" class="headerlink" title="家庭生活"></a>家庭生活</h2><p>我带大锤时间比较长，大锤也喜欢跟我，大妞也慢慢让我带，只是一年来只有几次是单独带着两小孩去外边玩的。大妞健康成长，有了哥哥陪着，不管是大动作还是语言，学得很快，一岁半时就闹着拿筷子，现在能夹起菜了。唯一不太理想的是，大妞先学会叫爸爸——大锤也是这样，为此没少受唠叨。</p><p>由于过年没回家，趁国庆节带大锤回老家一趟，不知为何，连续两年到10月份，大锤就会咳嗽，花了大几百块钱也没见效，直到年底元旦才好。大锤妈还以为在老家做了什么，吃了什么造成的，一度要求不能再回老家。</p><p>年中决定买房，这不算意外，因为几年前曾计划到深圳拼一番赚个首付，只是因故未付诸行动。现在大锤已经上中班了，房子的事不能再拖了，这是我想了很久下的决定，这个家虽然不是我一个人的，但有些事我还得做。于是跟同学借钱，问了一圈，发现当下形势都不好，或者我的朋友圈里都是上有老下有下，背负很多债务的，但最终还是借到一些。木木借了3万多，后来当中介费，牛哥向银行借了3万，还了我借给妹夫的信用卡的钱。老妈基金，老爸基金，及我这两年干私活的钱、公积金、少量的工资，加起来有20万。说来可悲，工作了11年的我，需要靠借钱才勉强够这点钱。除了那一次看房，以及面签和拿房产证那两次是必须由大锤妈出面外，其它全部由我做，看房，谈价，跑银行，开证明等花了大量时间。起初我想着岳母那边出点钱，后想着那边借点钱，但发生一些事，让我决定不借那边一分钱。前几年持续上交工资给大锤妈，但因为一些原由并没有出钱。这三个钱包基本掏空我和父母的家底。</p><p>其实我可以再多借点钱的，但今年开始要查首付来源，以前是不需要的，为了保证能贷款，就多了一些顾虑。7月份开始看房，看了很多，最终决定买二手房，砍价不是我强项，但也把难处陈述出来，在中介斡旋下，比房东预期的少了3万，比我的预期多了2万。8月份面签，以为很久才能放款——中介和贷款经理也不保证确切的时间点，结果很意外，一个多月时间就放款了，6.1的利率，可能是我信用比较好，6、7张信用卡使用那么多年没逾期，而且很多年已经办了那家银行的信用卡和储蓄卡，也一直在使用着。9月底第一次还款，正式开启房奴生活。因为放款快，导致还没找好房，于是和房东约定以租房形式继续居住，我也体验了短暂的收租生活。相对来说，二手房买卖过程比较顺畅，虽然时间长且麻烦，不管在看房、砍价、签合同，中介、银行、房东都不坑我，除了中介费贵以外，还算上得上好说话，像租金，我和房东就是在微信上确认，没有签字画押，户口迁出也爽快。年底综合各方面回顾，我感觉可能也许大概应该是在这几年最高点买房的，房价高，利率也高，一个月连物业水电燃气，乐观估计也要小5千块，但大锤读书不能耽误，我只能归因于上天要如此对待我，为国接盘，我光荣。</p><p>12月份过户，虽然是二手房，虽然看上去旧了一点，但于我而言就是新房。城里的房子，空调、冰箱、洗衣机、热水器、电视机等似乎是标配。旧家居清理要钱，装修要钱，家具家电要钱，但该买还得买，除了衣柜等部分外，加起来总共花了5千多块。经济上的拮据造就了动手能力的提升，像手机电池和屏幕都是自己买来换，背包破了自己缝，头发长了自己剪。买房后，换锁芯，刷墙壁，洗油烟机，全部是我一人完成。特别是墙壁翻新，过户当天花了一点时间了解乳胶漆的知识后就直接下单，然后上手开搞，因为要通风，所以要提前进行，老爸老妈也支持我自己动手，前后花了5天——包括2天的周末和3个晚上，或许我遗传了父亲的手艺，结果还能看得过去。</p><p>这一个月天公作美，大部分时间是晴天，既忙工作，又搞新房，墙壁刷完后，就是各处清洁了，在大事前，我和大锤妈意见基本达成一致——特别是在省钱这一块，每周周末一家子都来新房干活，当然大锤和大妞有他们自己的活动。月底连续加班，为不影响搬家，只要11点下班我还可以去新房忙活一个钟头，幸好这种日子没有持续太久。某天凌晨回去时，突然发现，这段时间一直做着体力劳动，完全没有时间想其它事，因为体力消耗太大，只想着睡觉。我试图与新房培养感情，但一个月过去了，即使付出了那么多时间，还是没有感觉。</p><p>在网上看到一些新闻报道或自媒体文章，某某一年总结，年薪多少万，房子多少平米，车子多少钱；某地某人有很多栋楼，减免了很多人的房租；某某相亲要求房子140平米，车子要5系以上。和同事夜宵，也必谈房子，谈房子还带着面积。我不太喜欢这种风气，但房地产是重要的支柱产业，对GDP有重要的拉升作用，不可不谈，而轮到我买房后，我也和经常讨论文学的罗师傅聊物业水电这些话题了——实际上，本文就花了重墨在房子上。开始月供后，我的心态变化可谓是断崖式的。6月份公司组织体检，结果显示轻度脂肪肝，还有几个指标也高，于是借机缩食，本来买3个多人的菜，现在买2个多人的菜就行了，其实主要是为了省钱，以前中午带饭还可以挑点菜，后面已经完全不挑了。年底大锤妈问了小区的幼儿园，学期大概是7千左右，比现在的贵了很多，但胜在离家近，但我又得节衣缩食了。</p><p>《灰色轨迹》里有句歌词：我已背上一身苦困后悔与唏嘘。我觉得，苦困和唏嘘是有的，但后悔应该没有，即使有，我也会说服自己不后悔。</p><h2 id="儿女教育"><a href="#儿女教育" class="headerlink" title="儿女教育"></a>儿女教育</h2><p>大锤有时比较调皮，我不愿称之为叛逆，因为有时是听话的。我比较喜欢以身作则，尽量满足小孩的要求，但有时也会烦，会打人。<br>今年没有教太多诗词文给大锤，主要是巩固以前背诵过的。因为大锤会出现背窜的情况，特别是一些韵脚相近的诗句，如果数量上再强加，就适得其反了。但也新背了一些，像《陋室铭》已经会背了。在生活上也有进步，某天晚上发现他能主动叠他的衣服，在玩玩具时能自己说一段故事，但如果直接问在幼儿园学了什么，吃了什么，跟以往一样还是问不出来。<br>除了人文，其它方面的教育比较少。自然科学，可以等大一点再教，日常生活中的现象，或者去科技馆观察，也能了解一二。但像诗词文，得练童子功，但我又不强求要背多少诗歌，要认多少字。当看到夕阳时，能想到几句相关的诗词；能从诗词中受到一些积极的影响，我就满足了。  </p><p>大妞还没到秩序敏感期，当抢不过哥哥时会哭闹一会，听懂的话很多，不挑食。</p><p>明年计划让大锤练字、学成语，再大点，就到科学（科技）方面，打算拿几块板子点LED灯玩一下。大妞暂无计划，因为日常中，两兄妹是一起的，多少能耳濡目染，学到点东西。  </p><h2 id="个人事"><a href="#个人事" class="headerlink" title="个人事"></a>个人事</h2><p>虽然疫情形势依然严峻，但还是进行了必要的社交，于我而言，就是吃饭夜宵。年中时和前同事们约了一次，谈了前公司的事，对评职称帮助很大。软考当天晚上和大学同学吃了一次夜宵。初中语文老师来公干，和在南宁的同学请老师吃饭，一番交谈下来，发现老师的境界和认知，完全是我无法企及的，特别是对子女的教育和对未来的规划，让我受益匪浅。</p><p>我不是自律性很强的人，虽然自4月份至年底每月都有一篇总结，但我并不能保证一直坚持下去。正如我要求自己要锻炼身体，但去年一整年我没有拿过球拍，看到体检结果的当月我买了绳子，但没跳过几次。我曾经筹划写书，但因各种原因停止了。</p><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>希望明年能拿到工程师证书。<br>希望明年可以接点私活做。<br>希望明年能多看点人文类的书或视频。<br>希望早日上岸，摆脱外包仔身份——虽然遥遥无期。  </p><p>过几天就要入住新房了，希望给能家人一个家的感受，至于自己背负的百万债务，则让自己承受。也期望年终奖能体现透支身体加班的劳动付出。</p><p>李迟 2021.1.4 周一 初稿 1.19 补  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2022年的脚步已经来临了。时光荏苒，白驹过隙，日月如梭，岁月不居，时节如流，又到了一年总结的时候了。&lt;/p&gt;</summary>
    
    
    
    <category term="生活掠影" scheme="http://www.latelee.org/category/the-life/"/>
    
    
    <category term="个人总结" scheme="http://www.latelee.org/tag/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>李迟2021年12月知识总结</title>
    <link href="http://www.latelee.org/my-library/code-for-2021-12.html"/>
    <id>http://www.latelee.org/my-library/code-for-2021-12.html</id>
    <published>2021-12-29T16:00:00.000Z</published>
    <updated>2022-01-27T09:13:09.413Z</updated>
    
    <content type="html"><![CDATA[<p>本文为 2021 年 12 月知识总结。</p><span id="more"></span><h2 id="研发编码"><a href="#研发编码" class="headerlink" title="研发编码"></a>研发编码</h2><p>测试发现，不同语言对浮点数的存储和处理不太相同，比如1.5，有的语言存储的可能是1.49999999999，有的可能是1.500000001。这样四舍五入时就会有变化，前者可能变成1，后者可能变成2。结论根据 Delphi 和 C++ 语言的个人测试，但没有找到权威资料，不保证准确性。</p><p>查了关于 0.5 四舍五入的一些资料，有说结果为 1，有说结果为 0 的，后者是因为 0.5 可能存储为 0.499999999999999999，从第一个数值 4 看，其结果为 0，也能说得通。不过根据项目需求，即便是这个值，也应该四舍五入到 1。</p><p>解决：</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>在 sql 语句中，可以在查询时去掉左右的空格，但没有现成的函数，可以先去掉右边空格，再去掉左边空格，但不能去掉中间的空格。比如处理 foo 字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ltrim(rtrim(foo))</span><br></pre></td></tr></table></figure><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>使用 kill 停止指定进程的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep hello | grep -v &#x27;grep&#x27; | awk &#x27;&#123;print $2&#125;&#x27; | xargs kill -9</span><br></pre></td></tr></table></figure><p>一般使用<code>killall 进程名</code>可停止进程（如果有多个相同名称的，也会一起停掉），但有的系统没有该命令，只有<code>kill</code>命令，可使用上述命令达到目标（存在多个匹配的进程，也会一起停掉）。注意，使用<code>grep</code>时，其本身也会出现进程名，因此需要使用<code>-v</code>来过滤。</p><p>监控a.out进程，如果不存在则启动之：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">LOGFILE=runlog.txt</span><br><span class="line"></span><br><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    PID=$(ps aux | grep &quot;./a.out -p 9000&quot; | grep -v &#x27;grep&#x27;)</span><br><span class="line">    if [ &quot;$PID&quot; == &quot;&quot; ]; then</span><br><span class="line">        date &gt;&gt; $LOGFILE</span><br><span class="line">        eco &quot;restart 9000&quot; &gt;&gt; $LOGFILE</span><br><span class="line">        echo &quot;&quot; &gt;&gt; $LOGFILE</span><br><span class="line">        cd foo_9000 &amp;&amp; nohup ./a.out -p 9000 &amp;</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>字符替换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">去掉csv中双引号：</span><br><span class="line">sed -i &#x27;s/&quot;//g&#x27; foo.csv </span><br><span class="line">将csv的逗号换成&#x27; | &#x27;：</span><br><span class="line">sed -i &#x27;s/,/ | /g&#x27; 无标题_new.csv</span><br></pre></td></tr></table></figure><h3 id="编码其它"><a href="#编码其它" class="headerlink" title="编码其它"></a>编码其它</h3><p>最近发现了csv文件的好处和便利。对于代码来说，直接以文本文件处理即可，只需将分隔符设置为逗号(<code>,</code>)，可直接用 excel 打开。原来的做法是使用竖线(<code>|</code>)分隔，因为这样可以对接 Markdown，但需要手工导入到 excel 中，比较麻烦。</p><h2 id="其它研究"><a href="#其它研究" class="headerlink" title="其它研究"></a>其它研究</h2><p>excel中冻结多行多列：</p><p>先鼠标定位到要固定行（或列）的下一行（或列），再点击视图-&gt;冻结窗格即可，取消亦在此处。比如固定前2行，则鼠标定位到A3处，冻结之。</p><h2 id="工作记录"><a href="#工作记录" class="headerlink" title="工作记录"></a>工作记录</h2><p>月底经历了连续10多天高强度的加班工作，不巧电脑硬盘坏了，所幸抢救了重要代码，没有造成进度的明显滞后（但造成身体老化的加速）。</p><p>深刻体会到墨菲定律的威力，年初有了教训，知道可能会出问题，也做了预案，但年底时还是会出问题。复盘了一下，还是没有十分完美的解决方法。根据同事的说法，在领导面前，态度是必须在体现出来的（何况年底）。作为外包仔，只能勤勤恳恳地写代码，上级叫做什么就得做什么。期望着年终奖会有惊喜，也期望着元旦后能给两天休息。</p><h2 id="本月做的事及计划"><a href="#本月做的事及计划" class="headerlink" title="本月做的事及计划"></a>本月做的事及计划</h2><p>本月十分忙碌。上班有各种杂事处理，还得加班，下班还得干活。</p><p>短时间大量接触装修知识，花了很多钱买东西，花了很多时间清洁。作为写了十年代码的工具人，发现原来自己还会刷墙壁，而且效果不错。</p><p>查询了架构师考试成绩，以一个较满意的分数通过了。</p><p>李迟 2021.12.30 周四</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文为 2021 年 12 月知识总结。&lt;/p&gt;</summary>
    
    
    
    <category term="我的程序代码" scheme="http://www.latelee.org/category/my-library/"/>
    
    
    <category term="代码积累" scheme="http://www.latelee.org/tag/%E4%BB%A3%E7%A0%81%E7%A7%AF%E7%B4%AF/"/>
    
    <category term="知识总结" scheme="http://www.latelee.org/tag/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>软考路：2021年系统架构设计师之流水账</title>
    <link href="http://www.latelee.org/architecture/architecture-laundry-list.html"/>
    <id>http://www.latelee.org/architecture/architecture-laundry-list.html</id>
    <published>2021-12-24T16:00:01.000Z</published>
    <updated>2022-01-27T09:13:09.501Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>架构师的分数线还没出来，但根据历史经验，肯定是能拿证了。到时就可以在朋友圈晒出三个证书，并写上：“不会项目管理的架构师不是好程序员”。这句话的真正含义是，我以架构师身份的写代码，本质还是程序员，此曰保持初心。</p><p>最近忙里偷空，把考试的流水账写下来，好结束此事。</p><span id="more"></span><table><thead><tr><th>日期</th><th>学习</th><th>备注</th></tr></thead><tbody><tr><td>2021年底</td><td>开始看书</td><td>买书</td></tr><tr><td>2021.2月春节</td><td>无</td><td>浪费假期了</td></tr><tr><td>2021.4月</td><td>存储计算</td><td></td></tr><tr><td>2021.4月&amp;6月</td><td>CRC和海明码的含义，计算</td><td>好像又忘记了。。。</td></tr><tr><td>2021.8月下旬</td><td>熟记23种设计模式</td><td>何种模式为何分类，后面又忘了</td></tr><tr><td>2021.10月国庆</td><td>无</td><td>带大锤回老家，浪费假期了</td></tr><tr><td>2021.10中旬开始</td><td>刷题</td><td>到各大网站看题目，记录要点</td></tr><tr><td>2021.10.13</td><td>重做一次2018年题目</td><td>记录了几个题目</td></tr><tr><td>2021.10.16&amp;17</td><td>收集最近2年的案例，背了ESB的作用</td><td></td></tr><tr><td>2021.10.23</td><td>刷了近一半的真题</td><td>系分的题也要刷一下</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="备考考试流水"><a href="#备考考试流水" class="headerlink" title="备考考试流水"></a>备考考试流水</h2><h3 id="买书"><a href="#买书" class="headerlink" title="买书"></a>买书</h3><p>2020.11.8、2020.11.12  买书 共三本。  </p><p><img src="/architecture/architecture-laundry-list/books.jpg"></p><h3 id="备考痕迹"><a href="#备考痕迹" class="headerlink" title="备考痕迹"></a>备考痕迹</h3><p><img src="/architecture/architecture-laundry-list/image-20210928090026225.png" alt="image-20210928090026225"></p><p><img src="/architecture/architecture-laundry-list/IMG_20210428_235725.jpg"></p><p><img src="/architecture/architecture-laundry-list/IMG_20210429_001718.jpg"></p><p><img src="/architecture/architecture-laundry-list/IMG_20210519_004030.jpg"></p><h3 id="报名"><a href="#报名" class="headerlink" title="报名"></a>报名</h3><p>2021.8.14   开始报名</p><p>报名表：</p><p><img src="/architecture/architecture-laundry-list/%E6%8A%A5%E5%90%8D.jpg"></p><p>报名缴费 204 元。</p><p><img src="/architecture/architecture-laundry-list/money.jpg" alt="image-20210928090026225"></p><h3 id="准考证"><a href="#准考证" class="headerlink" title="准考证"></a>准考证</h3><p>2021.11.1 可打印准考证，有考试须知。<br><img src="/architecture/architecture-laundry-list/2021%E5%B9%B4%E8%BD%AF%E8%80%83%E5%87%86%E8%80%83%E8%AF%81.png"></p><h3 id="考试"><a href="#考试" class="headerlink" title="考试"></a>考试</h3><p>2021.11.6 周六 上考场</p><p>通行证明：</p><p><img src="/architecture/architecture-laundry-list/%E6%A0%B8%E9%85%B8%E6%8A%A5%E5%91%8A%E9%80%9A%E8%A1%8C%E5%8D%A1.jpg"></p><p>考场：</p><p><img src="/architecture/architecture-laundry-list/%E8%80%83%E5%9C%BA.jpg"></p><h2 id="考后流水"><a href="#考后流水" class="headerlink" title="考后流水"></a>考后流水</h2><h3 id="成绩"><a href="#成绩" class="headerlink" title="成绩"></a>成绩</h3><p>2021.12.20 下午 查成绩</p><p><img src="/architecture/architecture-laundry-list/%E8%BD%AF%E8%80%83%E6%9E%B6%E6%9E%84.png"></p><h3 id="分数线"><a href="#分数线" class="headerlink" title="分数线"></a>分数线</h3><p>2022.01.06 可查分数线</p><p><img src="/architecture/architecture-laundry-list/%E5%88%86%E6%95%B0%E7%BA%BF.png" alt="image-20220115000924329"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;架构师的分数线还没出来，但根据历史经验，肯定是能拿证了。到时就可以在朋友圈晒出三个证书，并写上：“不会项目管理的架构师不是好程序员”。这句话的真正含义是，我以架构师身份的写代码，本质还是程序员，此曰保持初心。&lt;/p&gt;
&lt;p&gt;最近忙里偷空，把考试的流水账写下来，好结束此事。&lt;/p&gt;</summary>
    
    
    
    <category term="软件架构" scheme="http://www.latelee.org/category/architecture/"/>
    
    
    <category term="考证" scheme="http://www.latelee.org/tag/%E8%80%83%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>软考路：2021年系统架构设计师之心得</title>
    <link href="http://www.latelee.org/architecture/architecture-tips.html"/>
    <id>http://www.latelee.org/architecture/architecture-tips.html</id>
    <published>2021-12-23T16:00:02.000Z</published>
    <updated>2022-01-27T09:13:09.501Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>都说等待是难熬的，但我例外，因为事实在太多了，上班一天很快就过去了，下班还得干体力活，不知不觉一个多月过去了。前几天的下午，有消息称可以查成绩了，刷新了很多次，终于登录到系统，点击鼠标时，手还是会抖——恰如去年那般。看到成绩后，认为对得起这一年的备考（从去年年底买书开始至考试，刚好一年时间），也算是实现了年初定的目标之一。</p><p>本文写一下备考过程及一些心得，权作记录。</p><span id="more"></span><h1 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h1><p><strong>上午综合题</strong></p><p>分数是55分，基本符合预期。在考试时，不确定答案的题目，都会圈出来，记录的大概有13题左右——跟去年差不多。计算题和英文题都不难，难的是中间部分的概念题，有很多题都没见过（准确说是没复习到）。</p><p><strong>下午案例分析</strong></p><p>分数62分，超出我的预料。回想起来也没有答得很好，试题一的架构风格，质量效用树的填空题不难，但风格区别答得不好，架构风格选择那题，我选的是解释器。试题二的UML用例和顺序图填空不难，因为题目给了关键信息，但最后那3个术语的概念题没见过（在网上搜索发现有比较多的资料），答题时按字面意见胡扯一通。试题五的填空题、TCP和UDP区别不难，第一小问（传统智能家居管理和云平台家居管理的差别）有点难，但因为前2年搞过互联网的案子，当时搜索过一些资料，凭记忆回答，现在已经想不起来写了什么了。</p><p><strong>下午论文</strong></p><p>分数52分，超出我的预料。我选的是微服务，虽然没真正搞过，但起码docker这些有深入研究，微服务、云计算这些概念是知道的。考试较紧张，整体发挥不好，背景和过程写得不好，但起码把微服务特性写了（题目给有一些），然后按项目的几大模块写，无外是手机端、后端、中间件，等，把restfull、网关、nginx转发、redis写上，最后加上自动化部署（包括gitlab和jenkins），基本把自己这两年接触的知识都写了。洋洋洒洒写了2500字，一直写到考试结束。</p><h1 id="备考篇"><a href="#备考篇" class="headerlink" title="备考篇"></a>备考篇</h1><p>去年考过了项目管理师，今年继续软考路，考的是系统架构设计师，因为作为技术人员，我比较看中这个。</p><p>相比去年，今年的考证是内心驱动的，因为要用证来证明自己。花了204大洋报名，如果通过，可以退税几百（听同事说可退500块，到时看看），虽然截止12月月底我才交800多块的税，但如果能退的钱超过200块，那也有赚的。  </p><p>去年高项考试结束后，就开始着手架构师的考试。粗看大纲和网上的电子书，发现很多技术点和概念是我没接触过的，心里没底，所以前后买了三本书（不过实际上书本没看多少，但考试时确实也考到了书本的知识点）。如果买书标志着开始复习的话，我的备考时间长达一年。</p><p>总体看，我先大概过一遍大纲，知道要考哪些方面的知识，再粗略过一次教程，实际上没吸收到什么内容，主要还是听视频、作笔记。一开始，按类别刷题，到近考试的前2个月，就按年份刷真题，前后刷了2遍。</p><p>由于属于自己的时间实在太少，并没有正经地复习，书本只看过几次，终成摆设，后来调整战略，看了网络公开资料，某度文库有一些有关软件工程的资料，GitHub上也有一些架构师资料，我还加了一些群，从群中也拿了一些资料（后来被踢出来了），然后上B站看免费视频，再下载软某通APP刷真题。B站上高项的视频很多，架构师的却有一定年头了，所幸偶尔刷到较新的视频（2018年的），于是下载到手机中。报班比较贵，说实话，我是不舍得花那个钱的， </p><p>由于上下班通勤时间比较长，合计将近2小时，所以就利用时间来听视频，磨耳机，日积月累，在工作之余学到的知识也慢慢巩固起来，也慢慢理解“架构”一词的含义。架构考试也涉及到项目管理，恰好部门今年要过CMMI5，所以学以致用，同时加深理解。</p><p>刷题一般利用睡前、排队、吃饭的时间，刚开始做错的题比较多，后来慢慢有进步，以至于后来设计模式、架构风格、质量属性的选择题都能全部答对——在没有看完题目情况下。</p><p>另外秉承“好记性不如烂笔头”的原则，我在记事本上手写笔记，顺便练字（应对写论文），但是有些资料有图片或网络上有现成的，因此也用 Markdown 记录下来。做笔记须先看大类，再细化，这样容易构建全局观和知识树。比如设计模式有3大类，每类有若干种。传统架构风格有五类，每类又有若干子类。架构评估有3种，再分若干种。等等。  </p><p>考试复盘发现，架构师的知识点太广泛了，我并没有全部都看到（哪怕已经在书本上），因为记录了的已经有很多了，还是将那些知识点记熟。但有部分还是只看了大概，比如RUP只看了四个阶段的名称，及各个阶段的主要任务，具体细节就没去记。我还认真看了并研究海明码和CRC计算，只是没考。</p><p>但我又不想只学书本的东西，所以也花了一些时间看点其它相关的视频，B站有英文原版的视频，我找了一些介绍架构，UML，重构方面的，顺便练习听力，也解决上午的英文题。对于设计模式，我主要看李老师的教程，除了学习设计模式外，对面向对象编程原则有深层次的理解。</p><p>就我而言，应试必须花时间复习并积累，难啃的地方多看几次，有的知识可以速记，如果一定要给出我的学习方法，无他，唯有多看多记。</p><p>所有这些时间，都是长期硬挤出来的，并没有因为考证耽误工作和照顾小孩，只是今年没有再接过私活。</p><h1 id="考试篇"><a href="#考试篇" class="headerlink" title="考试篇"></a>考试篇</h1><p>考试前几天及当天，我虽然也有看题，但都没有命中，还得靠平时的积累。考试前的准备工作必须要仔细检查。比如准考证、身份证、黑色笔、铅笔、橡皮擦、小刀、（非电子）手表。像今年我考试时，还需要核酸阴性报告、通行卡（我都打印出来备查）。</p><p>字需要练，不要求漂亮，但要求整洁，平时做笔记时最好手写，否则论文那关不好过。</p><p>工具十分重要，像我，由于钢笔坏了，水性笔写字不好看，论文整体版面不够好。又因为戴电子表，被检查出来，还好考试有挂钟。总之，考场上不如去年那样顺畅，多少影响应试心态。</p><h1 id="应试篇"><a href="#应试篇" class="headerlink" title="应试篇"></a>应试篇</h1><p>本节结合考试做一些描述。</p><h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>考试分3科：上午选择题，下午案例分析和论文。不同科目有不同的应付策略。</p><p>根据经验，架构考试会结合系分、网络、高项的知识。因此，在精力允许情况下，可以参考系统分析师（与web、数据库、架构风格有关的）、网络、高项等的试题（当然精力一般都有限）。  </p><p>上午选择题考的范围大，知识点分散，像计算机组成原理、操作系统、网络、数据库，在大学里都是单独的课程，但考试中每一类只有几分，且每年考的点都不懂，因此需要全面学习，当然也有侧重点，有的考点在选择题、案例、论文中都有可能考，是重中之重。但也需要有战略地放弃，像网络的综合布线，数据库的范式等，经过几次的学习复习，还是没记住，于是就放弃了。可根据自己情况做决策，根据经验，每年考试都会出现没有遇到的题目。</p><p>下午案例分析和论文，是在听完视频后再着手的，主要是在网上收集、记录案例真题，同时搜索案例和论文涉及的点。有些知识点做了扩展，比如V模型、MVC，像redis，较全面地了解了（只限于了解），因为网上很多相关的面试题目。Java方面是强记，但不怎么理解，只记得servlet、EJB、各种Bean等名词。近年真题出现过的知识点，需要熟记，以防再出现。个人认为还是靠积累经验，案例题属于主观题，原则是尽量写完所有题目，万一放水就能得分了。  </p><p>对于论文，我直接沿用去年的项目，项目背景和技术点都没变化，因为项目亲自做过，而且印象深刻（包括但不限于跑了大部分充电桩，在路边午休，欠工资，等）。如果没有实践经验，只能靠背了。数字一定要足够，因此平时练字做笔记就有必要了，而且版面要整洁，笔者写完回顾发现有部分语句不通顺，但并没有再涂改。</p><p>案例和论文需要涂填题目号，一定要核对清楚，这两科时间是最紧张的，心态很重要。</p><p>一般情况下会提前几分钟发试卷，此时应该可以看题目。笔者坐到教室最后一个位置（但序号不是最后一个），我拿到试题时，别人估计已经过了几个题目了。 </p><p><strong>软考属于水平评价类考试，一般情况下，只要3科同时达到 45 线就能通过，分数太高没必要（技术好运气好除外），每科都有30分可丢失，在备考时需要有针对性的取舍，而且应试考试有应试考试的规则，不能太纠结细节。另外，这3科是一天内考完，对个人的体力和脑力都是一个不小的挑战。笔者自认能吃苦耐劳，所以这种强度的考试还能应付。</strong></p><h2 id="速记"><a href="#速记" class="headerlink" title="速记"></a>速记</h2><p>本节对一些知识点进行联想记忆，有些是自己总结的，自认为还可以。</p><h3 id="23种设计模式"><a href="#23种设计模式" class="headerlink" title="23种设计模式"></a>23种设计模式</h3><p>设计模式的一点思考：不同模式均有对应的使用场景，模式是应对变化点的，解决稳定中有变化的点。如果所有地方都变化，或所有地方都没变化，那么，不适用设计模式。设计模式不是万能的。  </p><p>设计模式包含三种类型，速记如下。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">创建型：    </span><br><span class="line">速记：单工抽原建 （单工抽元件） </span><br><span class="line"></span><br><span class="line">结构型：  </span><br><span class="line">外观（门面） 组合 享元 装饰 桥接 适配 代理  </span><br><span class="line">速记：外组享装桥适代 （外祖想装桥四代）</span><br><span class="line"></span><br><span class="line">行为型：  </span><br><span class="line">迭代 命令 解释器 访问者 观察者 职责链 中介者 备忘录 策略 状态    </span><br><span class="line">速记：迭命模解访观职，中备策状（爹命摩诘访观止，终被车撞。摩诘是王维的字，观止可理解为古文观止）  </span><br><span class="line"></span><br><span class="line">注：速记可应付选择题的分类题目，但不同模式的应用场景，需要理解，也可应付案例</span><br></pre></td></tr></table></figure><h3 id="模型与图对应关系"><a href="#模型与图对应关系" class="headerlink" title="模型与图对应关系"></a>模型与图对应关系</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">功能模型 －－ 数据图   功据（工具） </span><br><span class="line">数据模型  －－ 实体联系图   数实 （属实）</span><br><span class="line">行为模式 －－ 状态转换图   行状 （形状）</span><br></pre></td></tr></table></figure><h3 id="UML两种图"><a href="#UML两种图" class="headerlink" title="UML两种图"></a>UML两种图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UML静态图：    </span><br><span class="line">组合结构图 对象图 包图 部署图 构件图 类图     </span><br><span class="line">速记：组队包布构类（组队包布够累）  </span><br><span class="line">UML动态图：  </span><br><span class="line">用例图，活动图，状态图，制品图，定时图，交互概观图，通信图(协作图)，顺序图（序列图，时序图）  </span><br><span class="line">速记：用活状，制定交通顺（用活动的桩，来制定交通，一定顺利）  </span><br><span class="line">交互图3种：定通顺</span><br></pre></td></tr></table></figure><h3 id="质量属性"><a href="#质量属性" class="headerlink" title="质量属性"></a>质量属性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">功能性 （Functionality）、性能（Performance）、 可靠性 （Reliability）、可用性（Availability）、安全性（Security）、 互操作性（Inter-operation）  </span><br><span class="line">易用性（Usability）、可测试性（Testability）、可变性（Changeability）、可修改性（Modification）、健壮性（Robustness）     </span><br><span class="line">共11个属性， 记忆：   </span><br><span class="line">效用树 由4个重要的属性组成：  </span><br><span class="line">安全性、可用性、可修改性、性能    －－》记忆：安用改性   </span><br><span class="line">其它的次要：功测靠操易变壮</span><br></pre></td></tr></table></figure><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>软件维护类型：正是预完（正是鱼丸）。</p><p>网络安全五要素：用完抵保控（用完低保空，用完了低保，口袋空了）。</p><p>需求开发：获分定验。需求管理：两控制两跟踪。</p><h1 id="外一篇"><a href="#外一篇" class="headerlink" title="外一篇"></a>外一篇</h1><h2 id="从应试中学到的"><a href="#从应试中学到的" class="headerlink" title="从应试中学到的"></a>从应试中学到的</h2><p>不同的专家/书籍，对相同的事物描述可能不相同，一般地都没有实质性的错误，只是从不同维度描述而已，作为高级考试，一般不扣字眼。不能抬杠，不用钻牛角，因为考试自有其规则，必须那边回答，考试是一回事，实践是另一回事。不管日常工作还是学习，从多维度看问题，思考问题，也是不错的。  </p><p>整体复习了软件研发过程涉及的方方面面，如系统规划（虽然涉及少），需求分析，架构设计，编码，测试。  </p><p>泛化和继承，按一般理解，先有父类，再有子类，此为继承。但实际中往往是从各个类中抽取出共有部分，重新组成父类，此为泛化。  </p><p>天下大势，合久必分，分久必合。很多种都是来来回回迭代发展。从系统粒度上看，从模块、类、构件、服务，再发展到微服务。从设计原则看，类的职责要单一，但设计模式中外观模式又讲究统一接口，其实它们都自有一套内在逻辑，以适应不同的场景。没有最好，只有最适合。  </p><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>重新复习了计算机组成原理、操作系统、网络及数据库，前面三门课加上编译原理，当年学得还可以，数据库一直提不起兴趣，工作后也很少有机会接触到。</p><p>架构在需求之后，编码之前进行，关注的是怎么设计架构达到项目目的（而不是做不做项目），到了架构这一阶段，不再做可行性研究，因为之前已经做过了，也不确认需求是否合理，而是如何做能完成需求。。  </p><p>软件架构主要由需求决定，需求有功能性的和非功能性的，其中非功能性的需求主要就是指质量属性。关注质量属性，功能性需求倒是次要。拓宽视野，在考虑程序时，会自然考虑维护性，扩展性，安全性等方面。</p><p>从教程或视频看，架构似乎不关心系统功能需求，其实这是默认的，因为系统首先体现的就是功能需求，如像web服务器，首先要提供web服务，其次才考虑安全和并发等。功能是最直观的，但架构更关注背后支撑的东西。  </p><p>经济学十大原理之一：人们面临权衡取舍。对应到架构中的术语，是敏感点和权衡点考点。  </p><p>设计模式有一定的应用场景，并不是万能的。  </p><p>架构的设计过程还是比较抽象，并没有像写代码那样能在脑海里过一次。  </p><p>初步了解分布式，负载均衡，redis集群。分布式还没有理解很深，负载均衡写了代码实践了。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;都说等待是难熬的，但我例外，因为事实在太多了，上班一天很快就过去了，下班还得干体力活，不知不觉一个多月过去了。前几天的下午，有消息称可以查成绩了，刷新了很多次，终于登录到系统，点击鼠标时，手还是会抖——恰如去年那般。看到成绩后，认为对得起这一年的备考（从去年年底买书开始至考试，刚好一年时间），也算是实现了年初定的目标之一。&lt;/p&gt;
&lt;p&gt;本文写一下备考过程及一些心得，权作记录。&lt;/p&gt;</summary>
    
    
    
    <category term="软件架构" scheme="http://www.latelee.org/category/architecture/"/>
    
    
    <category term="考证" scheme="http://www.latelee.org/tag/%E8%80%83%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>李迟2021年11月知识总结</title>
    <link href="http://www.latelee.org/my-library/code-for-2021-11.html"/>
    <id>http://www.latelee.org/my-library/code-for-2021-11.html</id>
    <published>2021-11-29T16:00:00.000Z</published>
    <updated>2022-01-27T09:13:09.413Z</updated>
    
    <content type="html"><![CDATA[<p>本文为 2021 年 11 月知识总结。</p><span id="more"></span><h2 id="研发编码"><a href="#研发编码" class="headerlink" title="研发编码"></a>研发编码</h2><h3 id="C-C"><a href="#C-C" class="headerlink" title="C / C++"></a>C / C++</h3><p>无。</p><h3 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h3><p>保留小数点后2位，假定在原数值基础上上浮10%（即1.1倍），但不进位。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 使用Sprintf有些情况会导致四舍五入</span><br><span class="line">newrate1, _ := strconv.ParseFloat(fmt.Sprintf(&quot;%.2f&quot;, item*1.1), 64)</span><br><span class="line"></span><br><span class="line">// 先扩大100位，取整数，再还原成小数，这样不会进位</span><br><span class="line">newrate2 := math.Floor(item*(1+0.10)*100) / 100.0</span><br></pre></td></tr></table></figure><h3 id="Delphi"><a href="#Delphi" class="headerlink" title="Delphi"></a>Delphi</h3><p>写文件示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// 覆盖式写，不存在会创建</span><br><span class="line">function MyWriteFile(filename, str: string):boolean;</span><br><span class="line">var </span><br><span class="line">  filev: TextFile;</span><br><span class="line">  localfilepath,ss: string;</span><br><span class="line">begin</span><br><span class="line">  localfilepath:=gstrAppPath + filename;</span><br><span class="line">  try</span><br><span class="line">      AssignFile(filev, localfilepath);</span><br><span class="line">      ReWrite(filev);</span><br><span class="line">      writeln(filev, str);</span><br><span class="line">      CloseFile(filev);</span><br><span class="line">  finally</span><br><span class="line">  end;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">// 追加形式</span><br><span class="line">function MyAppendFile(filename, str: string):boolean;</span><br><span class="line">var </span><br><span class="line">  filev: TextFile;</span><br><span class="line">  localfilepath,ss: string;</span><br><span class="line">begin</span><br><span class="line">  localfilepath:=gstrAppPath + filename;</span><br><span class="line">  try</span><br><span class="line">    if FileExists(localfilepath) then</span><br><span class="line">    begin</span><br><span class="line">        AssignFile(filev, localfilepath);</span><br><span class="line">        append(filev);</span><br><span class="line">        writeln(filev, str);</span><br><span class="line">        CloseFile(filev);</span><br><span class="line">    end</span><br><span class="line">    else</span><br><span class="line">    begin</span><br><span class="line">      AssignFile(filev, localfilepath);</span><br><span class="line">      ReWrite(filev);</span><br><span class="line">      writeln(filev, str);</span><br><span class="line">      CloseFile(filev);</span><br><span class="line">    end;</span><br><span class="line">  finally</span><br><span class="line">  end;</span><br><span class="line">end;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>读取 ini 文件：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">foo: <span class="keyword">String</span>;</span><br><span class="line">sectionName: TStrings;</span><br><span class="line">myinifile: TIniFile;</span><br><span class="line"></span><br><span class="line">sectionName := TStringList.Create;</span><br><span class="line">myinifile:=Tinifile.Create(gstrAppPath + <span class="string">&#x27;roadtype.ini&#x27;</span>);</span><br><span class="line">foo := myinifile.ReadString(<span class="string">&#x27;foosection&#x27;</span>, <span class="string">&#x27;thecode&#x27;</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">myinifile.ReadSection(<span class="string">&#x27;foosection&#x27;</span>, sectionName);</span><br></pre></td></tr></table></figure><p>注意 TStrings 类型需要先创建才能使用。</p><h3 id="编码其它"><a href="#编码其它" class="headerlink" title="编码其它"></a>编码其它</h3><h3 id="谨慎编码"><a href="#谨慎编码" class="headerlink" title="谨慎编码"></a>谨慎编码</h3><p>似乎逃不过年龄的牢笼，年纪大了，思维力也跟着下降，生活上也免不了因为忘记一些事受到抱怨。对于编码，越来越发觉要写容易识别、理解的代码——性能倒是其次的了。</p><h2 id="其它研究"><a href="#其它研究" class="headerlink" title="其它研究"></a>其它研究</h2><p>excel中标记重复项：开始菜单栏-&gt;条件格式-&gt;突出显示单元格规则-&gt;重复项，可标记出来。</p><p>数字前补充0：设置单元格格式-&gt;数字-&gt;自定义-&gt;在类型中选0，如数字共6位，不足前补0，则填6个0。</p><h2 id="工作记录"><a href="#工作记录" class="headerlink" title="工作记录"></a>工作记录</h2><p>某天因工作需求将golang写的小工具程序发给某局对接人员，被360检查出木马，作为厅级的下属单位反馈的任何事都不敢马虎。上网查了一下，有较多类似的案例，同样是 golang 写的程序，同样报<code>HEUR/QVM.Malware.Gen</code>。首先用一个最简单的<code>helloworld</code>检测，未报错，而该程序就是读取txt文件的数据，再计算，输出结果，不涉及加密、数据库连接、web服务等，实在不知如何被搞。凭着大学看的某安全杂志的知识，想到了加壳脱壳，于是找到 upx 工具，将压缩率调到9，程序体积从 4.5MB下降到 1.5MB，再检查，此时未发现木马，估计是程序的某些库或某些调试信息符合了特征，用 upx 压缩之后就正常了。</p><h2 id="本月做的事及计划"><a href="#本月做的事及计划" class="headerlink" title="本月做的事及计划"></a>本月做的事及计划</h2><p>参加今年的系统架构师考试，考场座位为30人，实到13人，所有人均坚持三场考试。选择题有很多未见过的，论文写了2600字，设计模式未考，整体感觉不太好，但还是希望能通过。<br>继去年传统，考试结束后去献血，带大锤实际感受热血，顺便得了一把伞。<br>坚持在某平台日更发文，除存量文章外，还额外新写了若干篇文章。<br>较粗略了解了蒙氏教育法，因教具太贵，结合家庭实际情况（主要是可用之物）对大锤和大妞进行适当的训练。  </p><p>李迟 2021.11.30 周二</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文为 2021 年 11 月知识总结。&lt;/p&gt;</summary>
    
    
    
    <category term="我的程序代码" scheme="http://www.latelee.org/category/my-library/"/>
    
    
    <category term="代码积累" scheme="http://www.latelee.org/tag/%E4%BB%A3%E7%A0%81%E7%A7%AF%E7%B4%AF/"/>
    
    <category term="知识总结" scheme="http://www.latelee.org/tag/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统资源监控脚本</title>
    <link href="http://www.latelee.org/my-study/linux-cpu-memory-monitor-script.html"/>
    <id>http://www.latelee.org/my-study/linux-cpu-memory-monitor-script.html</id>
    <published>2021-11-28T16:00:00.000Z</published>
    <updated>2022-01-27T09:13:09.425Z</updated>
    
    <content type="html"><![CDATA[<p>本文涉及一些在Linux系统中进行资源监控的方法，其目的是为了在实际工作中监控系统的资源使用情况。</p><span id="more"></span><h2 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h2><p>自上个月开始，断断续续排查了几个疑难 bug，都是在生产环境发现的，兹事体大，必须解决，但限于能力和环境，有的bug并没有即时解决，但总算在一定期限内完成任务，由于时间紧，当时并没有详细记录过程，但过后回想，还是要做些经验总结。本文从进程占用内存脚本开始，对 Linux 资源使用情况的监控展开研究，以方便日后使用。</p><h2 id="监控CPU和内存占用最多的十个进程"><a href="#监控CPU和内存占用最多的十个进程" class="headerlink" title="监控CPU和内存占用最多的十个进程"></a>监控CPU和内存占用最多的十个进程</h2><p>Linux 系统一般使用 ps 命令查看进程资源使用情况，其输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux | head -n 4</span><br><span class="line">USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root          1  0.1  0.1 191136  4172 ?        Ss   14:51   0:02 /usr/lib/systemd/systemd --switched-root --system --deserialize 22</span><br><span class="line">root          2  0.0  0.0      0     0 ?        S    14:51   0:00 [kthreadd]</span><br><span class="line">root          3  0.1  0.0      0     0 ?        S    14:51   0:02 [ksoftirqd/0]</span><br></pre></td></tr></table></figure><p>从输出结果可以看出有CPU、内存、进程ID、进程名称等信息，其中CPU和内存的数值为百分比。</p><p>由此可知核心命令描述如下：</p><p>通过 ps 命令查看进程CPU、内存占用情况，再分别按CPU、内存数值倒序排序，再取前面10个即可。</p><p>查看内存占用最多的十个进程命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep -v PID | sort -rn -k +4 | head -n10</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li><code>grep -v PID</code> 为去掉带 PID 字样的一行，此处表示标题。</li><li><code>sort -rn -k +4</code>，-k +4 表示按第4列（即内存）内容排序，-rn 表示按数值倒序排序。</li><li><code>head -n10</code>表示取前面的10个，亦即占用内存最多的10个进程。</li></ul><p>类似地，对于CPU占用情况，只需要将上面<code>+4</code>改为<code>+3</code>即可，因CPU占用百分比位于第三列。</p><h2 id="监控指定进程的内存"><a href="#监控指定进程的内存" class="headerlink" title="监控指定进程的内存"></a>监控指定进程的内存</h2><p>该脚本是为了应付之前某进程内存泄漏的问题的，完整脚本如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">PROCESS=foobar</span><br><span class="line">LOGFILE=&quot;memlog.txt&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> ((;;))</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">while</span> [ 1 ]</span></span><br><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    PID=$(ps aux | grep $PROCESS | grep -v &#x27;grep&#x27; | awk &#x27;&#123;print $2;&#125;&#x27;)</span><br><span class="line">    if [ &quot;$PID&quot; != &quot;&quot; ]; then</span><br><span class="line">        echo `date +&#x27;%Y-%m-%d %H:%M:%S&#x27;`  &gt;&gt; &quot;$LOGFILE&quot;</span><br><span class="line">        MEM=$(ps aux | grep $PROCESS | grep -v &#x27;grep&#x27; | awk &#x27;&#123;print $5;&#125;&#x27;)</span><br><span class="line">        MEM=&quot;ps mem: &quot;$MEM</span><br><span class="line">        RSS=$(cat /proc/$PID/status | grep RSS)</span><br><span class="line">        echo $PROCESS $MEM $RSS &gt;&gt; &quot;$LOGFILE&quot;</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    echo &quot;System memory info: &quot; $(cat /proc/meminfo | grep -E &#x27;MemTotal|MemFree|Cached&#x27; |grep -v SwapCached|xargs)  &gt;&gt; &quot;$LOGFILE&quot;</span><br><span class="line">    echo &quot;-------------&quot; &gt;&gt; &quot;$LOGFILE&quot;</span><br><span class="line"></span><br><span class="line">    sleep 5</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>注释如下：</p><ul><li>由于要监控某一进程，因此需先指定进程名称。</li><li>再从 ps 列表中查询其 PID 和 内存</li><li>再由 PID 查询其常驻内存大小，该值在<code>/proc/&lt;PID&gt;/status</code>文件中。</li></ul><p>脚本每隔5秒输出一次信息，有时内存泄漏量较小，一般观察数小时、半天可以得到结果。确定存在内存泄漏情况时，再深入代码排查。该脚本对占用内存大小并不做严格计算，因为只是观察内存使用是否稳定，或是否持续增长，是否有跳变。就当时监控情况下，该进程下载文件时内存占用突增，过后恢复稳定状态，但保持几分钟十多KB增长的态势，因此判定内存泄漏。</p><h2 id="判断磁盘占用情况"><a href="#判断磁盘占用情况" class="headerlink" title="判断磁盘占用情况"></a>判断磁盘占用情况</h2><p>本脚本用于磁盘空间使用情况的监控。机制如下：</p><p>指定监控目录，指定空间使用百分比的阈值，当超过时，再删除。根据经验，一般超过 85%~90%时即可删除。该脚本可使用定时任务执行，根据磁盘使用空间，可半天或一天执行一次。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">前提：已挂载目录</span></span><br><span class="line">mount_dir=/mnt/hgfs</span><br><span class="line">percent_in=85</span><br><span class="line">file_del=1000</span><br><span class="line"></span><br><span class="line">count_del=10</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果不存在目录，退出</span></span><br><span class="line">if [ ! -d $mount_dir ]; then </span><br><span class="line">    echo $mount_dir &quot;not found, quit&quot;</span><br><span class="line">    exit</span><br><span class="line">fi </span><br><span class="line"></span><br><span class="line">percent=`df -h | grep $mount_dir | awk &#x27;&#123;print $5&#125;&#x27; | tr -d &#x27;%&#x27;`</span><br><span class="line">dev_file=`df -h | grep $mount_dir | awk &#x27;&#123;print $1&#125;&#x27;`</span><br><span class="line">file_count=`ls -l $mount_dir | wc -l`</span><br><span class="line"></span><br><span class="line">echo $percent $percent_in</span><br><span class="line"><span class="meta">#</span><span class="bash"> 当空间占用百分比大于某个指定值时，删除目录前指定的数量</span></span><br><span class="line">if [ $percent -ge $percent_in ];then</span><br><span class="line">    echo &quot;need to remove file! occupy&quot; $percent&quot;%&quot; &quot;of&quot; $dev_file</span><br><span class="line">    #cd $mount_dir</span><br><span class="line">    #file=`ls | sort | head -$file_del`</span><br><span class="line">    #rm $file</span><br><span class="line">    #cd -</span><br><span class="line">else</span><br><span class="line">    echo &quot;no need to remove file&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 按文件数量判断，用于文件体积小但数量大的情况，因其会占用文件索引</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">if</span> [ <span class="variable">$file_count</span> -ge <span class="variable">$count_del</span> ];<span class="keyword">then</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">    <span class="built_in">echo</span> <span class="string">&quot;need to remove file! occupy total&quot;</span> <span class="variable">$count_del</span> <span class="string">&quot;files of&quot;</span> <span class="variable">$dev_file</span></span></span><br><span class="line">    #cd $mount_dir</span><br><span class="line">    #file=`ls | sort | head -$file_del`</span><br><span class="line">    #rm $file</span><br><span class="line">    #cd -</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">    <span class="built_in">echo</span> <span class="string">&quot;no need to remove file&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">fi</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">file=`ls | sort | head -<span class="variable">$file_del</span>`</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">echo</span> <span class="variable">$file</span></span></span><br><span class="line"></span><br><span class="line">echo &quot;comand complete at&quot; </span><br><span class="line">date</span><br><span class="line">echo &quot;======================================&quot;</span><br></pre></td></tr></table></figure><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>可在脚本中添加邮件通知功能（可用其它程序实现），当出现异常或有重大事件发生时——如CPU占用达100%或删除文件时，不过目前暂未有时间着手。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文涉及一些在Linux系统中进行资源监控的方法，其目的是为了在实际工作中监控系统的资源使用情况。&lt;/p&gt;</summary>
    
    
    
    <category term="技术杂铺" scheme="http://www.latelee.org/category/my-study/"/>
    
    
  </entry>
  
  <entry>
    <title>软考路：2021年系统架构设计师之考试</title>
    <link href="http://www.latelee.org/architecture/architecture-exam.html"/>
    <id>http://www.latelee.org/architecture/architecture-exam.html</id>
    <published>2021-11-07T16:00:00.000Z</published>
    <updated>2022-01-27T09:13:09.501Z</updated>
    
    <content type="html"><![CDATA[<p>周六参加了2021年系统架构设计师的考试，本文记录一下考试过程。</p><span id="more"></span><h2 id="考前"><a href="#考前" class="headerlink" title="考前"></a>考前</h2><p>考前一周有点懈怠了，似乎对考试已经躺平了。看了这个考点发现那个考点没记住，刚想看案例分析，但发现论文还没有准备。<br>周一打印了准考证，看了地图，租房离那个考场学校有一定距离，于是在周二晚上11点骑电车去探路，途经远近闻名的大鸡村，幸好有导航，否则找不到路，因为附近正经的路都在修，后来才发现，只要骑车，不管哪条路都必须经过大鸡村。<br>周四下班蹭同事的车去一家可免费做核酸检查的医院检查。<br>周五打印检查报告和通行卡。晚上准备好笔，橡皮擦，小刀，另外把电车充满电。<br>（后注：进考场时发现，还是有部分人没有准备证明材料的，哪怕准考证上已经写了）  </p><h2 id="考中"><a href="#考中" class="headerlink" title="考中"></a>考中</h2><p>周六早上6点50分起来，大锤跟着起来，他问我是不是要上班，我回答说去考试，他又问能不能陪他玩，我说今天不行。相同的一问一答，外加“为什么”，重复了好几次。穿衣洗漱完毕，我让他乖乖坐着不要吵醒妹妹，然后出发，其时已7点50分了，由于周末早上车不多，因此骑车比较顺畅。路过大鸡村若干外包子摊后，有位大姐十分热情，于是花3块钱买了3个馒头，早上1个，中午2个，加上带了2瓶水，足够支撑了一天。    </p><p>到了考场门口，宇哥、昌哥和法哥已经到了，一边聊一边啃馒头一边慢慢进考场，参加考试的人挺多，有朝气蓬勃的，有白发苍苍的，大家都为了同一个目标聚到了一起。没聊多久，就可以进考场了，排队，拿身份证准考证核酸报告，开手机亮码，测体温。顺利通过后，看布局找考场位置，我在五楼，上去后竟也喘了几口气，上完厕所，看了几页笔记，就进教室了。包须放外面，监考老师核对本人及照片时，跟我对下时间，看到是电子表，就叫脱下来，才发现原来对时间是假的，检查手表是真。进门找到座位坐了下来，脱了外套，外面蓝天白云，是个不错的日子，我心态不能说不错，但至少放得开。</p><h3 id="综合知识"><a href="#综合知识" class="headerlink" title="综合知识"></a>综合知识</h3><p>拿到答题纸后，先写名字和准考证，接着老师发试题，我跟老师提了建议，把教室的挂钟放到中间，方便看时间。等到考试响铃后，正式开始作答。</p><p>前面是操作系统和组成原理，如前趋图、地址换算、嵌入式等，感觉还行，没难度。<br>接着有数据库题，计算自然连接的题较简单，但出了道什么冲突的题，没研究过，留空。我以为会考函数依赖或范式，结果没考。<br>中间部分题目就有难度了，要么考题没接触过，要么是很细的概念题。有AI芯片的四大特征，还有以太网交换机，还有MacCabe复杂度、NDB、SDN、RUP九个核心工作流、数字化转型、内聚耦合。最后的英文出乎意料，我以为会很难，因为做历年真理时，只有2~3个空是对的，重要的关键单词竟然是不认识的。有些题想凭经验或感觉也做不出来，有一题是com对象重用，什么内外部对象的，一共有两空，我在涂完答题卡后审视题目，依然没辙，突然看到两题有一样的答案，于是决定都选它，起码有概率对一半。所有题目都搞完后，还有半个小时，看到有人交卷，于是也交了卷。  </p><p>下楼看到了昌哥和法哥，于是把包放到法哥小车时，再骑车去找吃的，难得有机会吃午餐，包里的馒头就先放一放了。  </p><p>吃完后回到考场附近路边草地上坐着，看笔记，主要是看 web 框架的几个题，背一下架构风格，设计模式，还有论文的背景。  </p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>下午考场换了老师，这次连文具盒也不能拿进去了，因为不是透明的，身上不能带无关的东西，如手机钱包什么的，保温瓶子也不让带，即使是矿泉水瓶，也要撕掉包装纸。<br>案例分析试题发下来后，先快速看一下题目，第一题必答，考架构风格，解释器和管道过滤器、隐式调用的对比，质量效用树比较简单，快速作答，风格对比留空。后面四选二，但嵌入式已经作战略性放弃了，只能三选二，第二题UML建模，考顺序图和几个模型，第四题考数据库和redis还有反规范化，第五题考web架构，初看感觉都不会，但细看题目，有部分题目能回答，相比之下，数据库方面把握不大，最后选了试题二和试题五，先做web架构方面，本以为会考我不熟悉的SSM和SSH，但却考了智能家居，TCP和UDP区别，居然还出现了鸿蒙，恰好2年前搞过某物联网的案子，刚好上个月用 qemu 跑了 LiteOS，有亲切感，而且有个子题目竟然考TCP和UDP的区别。再回到UML图，用例和顺序图的填空还是比较简单，但最后几个模型的对比就不懂了，因为连名词都没看过，但还是按字面意思写，最后准备到点了，急忙补充第一题的风格对比。根据对自己的要求，案例分析必须写完——不管会不会写，最后检查一次姓名准考证号和题目，然后交卷。  </p><h3 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h3><p>交卷后老师及时提醒原则上不能出去，有人提出要看看资料，但老师不允许，因为离下场考试时间太近，去年倒是可以的。但最后争取可以上厕所，我在窗口伸伸腰，看到对面楼的旭哥，他休闲地喝着水，应该是稳操胜券了。<br>论文题目发下来了，我偷偷看了题目，什么面向切面，企业集成，安全，完全不会写，幸好最后一题是微服务，不及多想，就选最后一题。但论文有摘要，去年的高项没有，担心写多或写少，只好慢慢写，斟酌着字数，还好写到摘要格式最后一行。但写项目背景时又卡住了一会，还有些涂改，一点也没有去年那样从容，后来复盘，写得的确不好，主要是准备的内容和题目匹配度不高，要想着怎么布局，紧张起来又忘记一些内容。介绍完背景，再写下微服务特点，回应子题目2，然后分三部分展开写。一直写，倒计15分钟铃响时，就准备收尾了，最后一边按摩手指一边检查，补了一些笔划，发现了一些笔误，但为了卷面整洁，就不管了，打赌阅读老师不会细看。论文一共写了2500多字，因为项目是做过的，并且印象深刻，到目前为止，那是我人生低谷期，被欠着工资不说，还要骑着电车跑各充电站，日晒雨淋的，因此必须要写，如果明年再考，还要继续写。</p><p>出考场后，坐在电车上等昌哥，跟他一起骑电回去，我们讨论才发现，今年竟然没有设计模式，不仅上午题没考，下午的案例和论文也没考。我把 23 种模式及对应的知识点都背下来了，竟然没考。</p><h2 id="考后"><a href="#考后" class="headerlink" title="考后"></a>考后</h2><p>和昌哥分开后，看到群里热火朝天讨论着请客，黄科来南宁闭关了一段时间，晚上有空，老大选了地点，博导也有空，而冠冠和刘总刚从西边的考场出来。于是聚在一起，一是叙同窗情，二是预祝大家都通过考场，接着聊一些经济形势及房子车子孩子的事，老大提到广西高速公路又要涨价了，我才知道有这回事，想到工作，于是说我可能要准备忙了，接着说工作态度的事，我说只要领导来电话，马上接，叫加班，马上去。结果第二天周日中午领导就来电话要做事了，那天下午没得陪大锤睡，只好傍晚时分带大锤大妞去看火车了，当然，周末我不下厨，有人又要不高兴了。</p><p>后面看到群里有人开始找答案来对，我保持不对答案的习惯，在心底里，我肯定是希望通过的，毕竟已经复习了那么久了，但不通过我也能接受。后续还有很多事等着做，要多陪下大锤和大妞，还要借点人文的书，看点美学、社会学方面的课程。</p><p><a href="https://www.educity.cn/rk/2293166.html">https://www.educity.cn/rk/2293166.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;周六参加了2021年系统架构设计师的考试，本文记录一下考试过程。&lt;/p&gt;</summary>
    
    
    
    <category term="软件架构" scheme="http://www.latelee.org/category/architecture/"/>
    
    
    <category term="考证" scheme="http://www.latelee.org/tag/%E8%80%83%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>一个C++工程CPU占用100%问题的排查</title>
    <link href="http://www.latelee.org/my-library/a-cpu-issue-in-c-project.html"/>
    <id>http://www.latelee.org/my-library/a-cpu-issue-in-c-project.html</id>
    <published>2021-11-02T16:00:00.000Z</published>
    <updated>2022-01-27T09:13:09.413Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到一个 C++ 工程CPU占用100%的问题，经过排查，发现原来是不再使用的代码片段的问题，本文记录了排查的过程，并给出示例代码片段。</p><span id="more"></span><h2 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h2><p>某日，运维反馈生产环境某台设备出现问题，某个进程占用 cpu 较高，几乎为 100%，已连续出现几天，现场人员重启过若干次，问题依旧。领导指派我排查。</p><h2 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2><p>首先查看该进程的日志文件，未发现异常。  </p><p>无意间执行 df 命令，发现磁盘已经满了，经查，是另一进程的日志文件占用过高，已近700GB。利用 scp 将部分日志文件迁移到另一台服务器，用 vim打开日志，定位到1000多行发现出错信息：<code>open read pipe failed : Permission denied</code>，定位到文末，也是相同的出错语句，得到结论，该语句频繁输出，导致文件过大，占用空间。</p><p>删除日志文件，磁盘恢复，但 CPU 依然满载，使用了<code>iotop -oP</code>、<code>iostat </code>、<code>pidstat -d 1</code>命令查看，发现还跟 rsyslog 有关。</p><p>网上有相关问题的介绍，根据文章，使用<code>service rsyslog status</code>查看 syslog 的服务状态，输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Oct 29 11:06:57 localhost.localdomain systemd[1]: Starting System Logging Service...</span><br><span class="line">Oct 29 11:06:57 localhost.localdomain rsyslogd[4836]:  [origin software=&quot;rsyslogd&quot; swVersion=&quot;8.24.0-34.el7&quot; x-pid=&quot;4836&quot; x-info=&quot;http://www.rsyslog.com&quot;] start</span><br><span class="line">Oct 29 11:06:57 localhost.localdomain systemd[1]: Started System Logging Service.</span><br><span class="line">Oct 29 11:06:57 localhost.localdomain rsyslogd[4836]: sd_journal_get_cursor() failed: &#x27;Cannot assign requested address&#x27;  [v8.24.0-34.el7]</span><br><span class="line">Oct 29 11:06:57 localhost.localdomain rsyslogd[4836]: imjournal: journal reloaded... [v8.24.0-34.el7 try http://www.rsyslog.com/e/0 ]</span><br><span class="line">Oct 29 11:06:57 localhost.localdomain rsyslogd[4836]: imjournal: journal reloaded... [v8.24.0-34.el7 try http://www.rsyslog.com/e/0 ]</span><br><span class="line">Oct 29 11:06:58 localhost.localdomain rsyslogd[4836]: imjournal: begin to drop messages due to rate-limiting</span><br><span class="line">Oct 29 11:07:00 localhost.localdomain rsyslogd[4836]: sd_journal_get_cursor() failed: &#x27;Cannot assign requested address&#x27;  [v8.24.0-34.el7]</span><br><span class="line">Oct 29 11:07:00 localhost.localdomain rsyslogd[4836]: imjournal: journal reloaded... [v8.24.0-34.el7 try http://www.rsyslog.com/e/0 ]</span><br><span class="line">Oct 29 11:07:00 localhost.localdomain rsyslogd[4836]: imjournal: journal reloaded... [v8.24.0-34.el7 try http://www.rsyslog.com/e/0 ]</span><br><span class="line">Oct 29 11:07:04 localhost.localdomain rsyslogd[4836]: sd_journal_get_cursor() failed: &#x27;Cannot assign requested address&#x27;  [v8.24.0-34.el7]</span><br><span class="line">Oct 29 11:07:04 localhost.localdomain rsyslogd[4836]: imjournal: journal reloaded... [v8.24.0-34.el7 try http://www.rsyslog.com/e/0 ]</span><br><span class="line">Oct 29 11:07:04 localhost.localdomain rsyslogd[4836]: imjournal: journal reloaded... [v8.24.0-34.el7 try http://www.rsyslog.com/e/0 ]</span><br></pre></td></tr></table></figure><p>可知系统的日志服务出现问题。根据网上说法，手动删除<code> /var/lib/rsyslog/imjournal.state</code>文件并重启 rsyslog，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /var/lib/rsyslog/imjournal.state</span><br><span class="line">systemctl restart rsyslog</span><br></pre></td></tr></table></figure><p>随后查看，问题依旧，再重启多次亦然。问题还是未解决。</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>排查代码，发现有几处相同的日志，根据跟踪，发现一个地方可疑，经过测试，的确为该处的问题。出现问题的代码如下（片段示意）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">OpenFifo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == g_pipe)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(access(pipename, F_OK) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mkfifo(pipename, <span class="number">0777</span>) != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;mkfifo %s failed : %s\n&quot;</span>, pipename, strerror(errno));</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        g_pipe = open(pipename,  O_RDWR | O_NONBLOCK);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == g_pipe)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;open read pipe failed : %s\n&quot;</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Recv</span><span class="params">(<span class="keyword">char</span> *buffer, <span class="keyword">int</span> bufferSize, <span class="keyword">int</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == g_pipe)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(OpenFifo() == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(select(g_pipe + <span class="number">1</span>, &amp;fds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        read(g_pipe, buffer + byteread, readsize - byteread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 主循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">false</span> == g_isexit)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 使用 fifo 读取标志</span></span><br><span class="line">        <span class="keyword">if</span> ((len = theFifo-&gt;Recv(buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>, <span class="number">1000</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[len] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(buf, <span class="string">&quot;EXIT&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Get EXIT signal, exit...&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序逻辑较简单，在代码中读取 FIFO 的命令，如是退出指令，则退出程序。具体说就是在主循环中读取某个 FIFO 文件，延时1秒钟（因此主循环没有显式调用 sleep 函数）。在 Recv 函数中会判断 FIFO 文件是否打开，如否，则打开之。但问题正出在此处：<code>printf(&quot;open read pipe failed : %s\n&quot;, strerror(errno))</code>。当 FIFO 文件权限出错时，就会一直打印输出。而该台设备的 FIFO 文件不知何故何时变成为 root 权限，询问未果，于是手动修改权限，CPU 随即恢复正常指标范围。</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>询问原来维护代码的同事，回复说那段代码已不再使用，于是删除之。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>既然定位到了问题，也知道了原由，直接删除不再使用的代码即可。从测试结果看，的确解决了问题。</p><p>从中也可以知道，对于项目代码，需要保持一定的迭代更新或重构工作，至少，已经过时的代码应该删除，使用 git 版本控制工具，可以追溯代码的历史，因此旧代码可以不再保留在当前工程中。</p><p>对于个人的代码，完全可由个人掌控，但在一个研发团队中，还需所有人员达成共识，需要上级的推动和开发人员的实践。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近遇到一个 C++ 工程CPU占用100%的问题，经过排查，发现原来是不再使用的代码片段的问题，本文记录了排查的过程，并给出示例代码片段。&lt;/p&gt;</summary>
    
    
    
    <category term="我的程序代码" scheme="http://www.latelee.org/category/my-library/"/>
    
    
    <category term="工程库代码" scheme="http://www.latelee.org/tag/%E5%B7%A5%E7%A8%8B%E5%BA%93%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>libcurl编译</title>
    <link href="http://www.latelee.org/toolslib/compile-libcurl.html"/>
    <id>http://www.latelee.org/toolslib/compile-libcurl.html</id>
    <published>2021-11-02T15:14:00.000Z</published>
    <updated>2022-01-27T09:13:09.409Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍 libcurl 在 centos 7 和 debian 7 系统中的编译及使用。</p><span id="more"></span><h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><p>下载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/curl/curl/releases/tag/curl-7_66_0</span><br><span class="line">压缩文件名：curl-7.66.0.tar.bz2</span><br></pre></td></tr></table></figure><h2 id="二、编译"><a href="#二、编译" class="headerlink" title="二、编译"></a>二、编译</h2><p>libcurl 编译步骤如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar xf curl-7.66.0.tar.bz2</span><br><span class="line">cd curl-7.66.0</span><br><span class="line">./configure --prefix=/home/highwayx/bin/curl --with-libssh2</span><br><span class="line">make -j</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><blockquote><p>注：ssl默认已使能，这里需要指定libssh2，以便使能 sftp 协议。</p></blockquote><p>32位 debian 7 编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/root/bin/curl --with-libssh2 --disable-ldap  --disable-ldaps --without-librtmp</span><br><span class="line">make -j</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h2><p>curl 使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">查看版本及支持的协议：</span><br><span class="line">$ ./curl --version</span><br><span class="line">curl 7.66.0 (x86_64-pc-linux-gnu) libcurl/7.66.0 OpenSSL/1.0.2k-fips zlib/1.2.7 libssh2/1.8.0</span><br><span class="line">Release-Date: 2019-09-11</span><br><span class="line">Protocols: dict file ftp ftps gopher http https imap imaps pop3 pop3s rtsp scp sftp smb smbs smtp smtps telnet tftp </span><br><span class="line">Features: AsynchDNS HTTPS-proxy IPv6 Largefile libz NTLM NTLM_WB SSL UnixSockets</span><br></pre></td></tr></table></figure><p>如果系统存在多个 curl 库，则会提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ./curl --version</span><br><span class="line">curl 7.66.0 (x86_64-pc-linux-gnu) libcurl/7.29.0 NSS/3.36 zlib/1.2.7 libidn/1.28 libssh2/1.4.3</span><br><span class="line">Release-Date: 2019-09-11</span><br><span class="line">Protocols: dict file ftp ftps gopher http https imap imaps ldap ldaps pop3 pop3s rtsp scp sftp smtp smtps telnet tftp </span><br><span class="line">Features: AsynchDNS IDN IPv6 Largefile libz NTLM NTLM_WB SSL UnixSockets</span><br><span class="line">WARNING: curl and libcurl versions do not match. Functionality may be affected.</span><br><span class="line">./curl: symbol lookup error: ./curl: undefined symbol: curl_mime_free</span><br></pre></td></tr></table></figure><blockquote><p>说明：对比上述两个版本信息，发现虽然协议都支持 sftp，但后者特征（Features）处没有HTTPS-proxy，在运行时使用 sftp 协议，提示该协议不支持。</p></blockquote><h2 id="四、问题及解决"><a href="#四、问题及解决" class="headerlink" title="四、问题及解决"></a>四、问题及解决</h2><p>编译过程中提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3rdparty/curl_x64/lib/libcurl.a(libcurl_la-libssh2.o): In function `ssh_block2waitfor&#x27;:</span><br><span class="line">libssh2.c:(.text+0x268): undefined reference to `libssh2_session_block_directions&#x27;</span><br></pre></td></tr></table></figure><p>在链接时添加<code>-lssh2</code>库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configure: error: libSSH libs and/or directories were not found where specified!</span><br></pre></td></tr></table></figure><p>编译过程中提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3rdparty/curl_x64/lib/libcurl.a(libcurl_la-openssl.o): In function `ossl_recv&#x27;:</span><br><span class="line">openssl.c:(.text+0x3bc): undefined reference to `SSL_read&#x27;</span><br><span class="line">openssl.c:(.text+0x3ee): undefined reference to `SSL_get_error&#x27;</span><br></pre></td></tr></table></figure><p>在链接时添加<code>-lssl</code>库。</p><p>运行过程中提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unsupported protocol</span><br></pre></td></tr></table></figure><p>重新编译，加上<code>--with-libssh2</code>，该库在目录/lib64/中。</p><p>李迟 2021.8.28 周六 凌晨</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍 libcurl 在 centos 7 和 debian 7 系统中的编译及使用。&lt;/p&gt;</summary>
    
    
    
    <category term="工具编译使用" scheme="http://www.latelee.org/category/toolslib/"/>
    
    
  </entry>
  
  <entry>
    <title>李迟2021年10月知识总结</title>
    <link href="http://www.latelee.org/my-library/code-for-2021-10.html"/>
    <id>http://www.latelee.org/my-library/code-for-2021-10.html</id>
    <published>2021-10-30T15:40:00.000Z</published>
    <updated>2022-01-27T09:13:09.413Z</updated>
    
    <content type="html"><![CDATA[<p>本文为 2021 年 11 月知识总结。</p><span id="more"></span><h2 id="研发编码"><a href="#研发编码" class="headerlink" title="研发编码"></a>研发编码</h2><h3 id="C-C"><a href="#C-C" class="headerlink" title="C / C++"></a>C / C++</h3><p>无。</p><h3 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h3><p>写了数字签名、数字信封的测试示例，了解了 RSA 、AES 加解密，知道 AES 的密钥长度必须大于16字节。  </p><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>无。</p><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>监控指定进程的内存使用情况 shell 脚本memonitor.sh：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">PROCESS=myserver</span><br><span class="line">LOGFILE=&quot;/tmp/memlog.txt&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> ((;;))</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">while</span> [ 1 ]</span></span><br><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    PID=$(ps aux | grep $PROCESS | grep -v &#x27;grep&#x27; | awk &#x27;&#123;print $2;&#125;&#x27;)</span><br><span class="line">    if [ &quot;$PID&quot; != &quot;&quot; ]; then</span><br><span class="line">        echo `date +&#x27;%Y-%m-%d %H:%M:%S&#x27;`  &gt;&gt; &quot;$LOGFILE&quot;</span><br><span class="line">        MEM=$(ps aux | grep $PROCESS | grep -v &#x27;grep&#x27; | awk &#x27;&#123;print $5;&#125;&#x27;)</span><br><span class="line">        MEM=&quot;ps mem: &quot;$MEM</span><br><span class="line">        RSS=$(cat /proc/$PID/status | grep RSS)</span><br><span class="line">        echo $PROCESS $MEM $RSS &gt;&gt; &quot;$LOGFILE&quot;</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    echo &quot;System memory info: &quot; $(cat /proc/meminfo | grep -E &#x27;MemTotal|MemFree|Cached&#x27; |grep -v SwapCached|xargs)  &gt;&gt; &quot;$LOGFILE&quot;</span><br><span class="line">    echo &quot;-------------&quot; &gt;&gt; &quot;$LOGFILE&quot;</span><br><span class="line"></span><br><span class="line">    sleep 5</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>注：先获取指定进程ID，再进行条件过滤，得到内存占用。另外还打印系统内存的使用情况。</p><h3 id="编码其它"><a href="#编码其它" class="headerlink" title="编码其它"></a>编码其它</h3><h4 id="Makefile指定运行时动态库路径"><a href="#Makefile指定运行时动态库路径" class="headerlink" title="Makefile指定运行时动态库路径"></a>Makefile指定运行时动态库路径</h4><p>一般地，在编译时分别使用<code>-L</code>和<code>-l</code>来指定所需动态库的目录和名称。如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-L/usr/local/curl/lib/ -lcurl</span><br></pre></td></tr></table></figure><p>此种情况下，如果没有额外设置环境环境LD_LIBRARY_PATH，也没有在<code>/etc/ld.conf.d/xx.conf</code>文件中指定目录的话，会提示动态库未找到。为减少麻烦，可以在编译时用<code>-Wl,-rpath</code>来指定目录（注意其格式），如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-L/usr/local/curl/lib/ -lcurl -Wl,-rpath=/usr/local/curl/lib/</span><br></pre></td></tr></table></figure><p>这样一来，在运行时就不用额外设置目录了。当然，编译环境和运行环境对应的库目录必须相同。</p><h4 id="git-分支管理"><a href="#git-分支管理" class="headerlink" title="git 分支管理"></a>git 分支管理</h4><p>用 git 开发过程中有关分支的管理和合并等，已初步形成一些方式，但对于个人来说略显麻烦。以 gitlab 为例，默认主分支，当出现新需求，创建<code>feature-xx</code>分支，开发之，最后合并到主分支，打上标签；当发现 bug 时，创建<code>bugfix-xx</code>或<code>hotfix-xx</code>分支，改正之，最后合并到主分支。如果在修改 bug1 分支时，又出现 bug2，则在最新的主分支创建 bug2 分支，分别修改提交。至于合并，目前还未遇到，待后面补充。  </p><h4 id="git-版本号"><a href="#git-版本号" class="headerlink" title="git 版本号"></a>git 版本号</h4><p>对于版本号管理一直没有找到好的方法，但大体上确定为<code>x.y.z</code>这种形式，版本号的定义，可在 Makefile，可在单独文件，或直接创建文件<code>version.h</code>来定义，为方便跟踪，有时会添加编译时间。目前有几种：</p><ul><li>用过脚本计算 git 提交了多少次版本，将其作为小版本号，每次测试通过后需发布时，先提交一次版本，再用该版本编译，这样本地版本和远程仓库版本保持一致。开发人员只需修改大版本号即可。</li><li>通过编译日期来确定版本号，之前曾经使用这种方式，即版本号固定，如<code>v1.1.0</code>，后面添加编译日期，日期即为真正版本号。可用脚本自动生成。</li><li>手动维护版本号，如当前已发布<code>v1.0.0</code>版本，则先修改版本号文件为开发版本，如<code>v1.1.0-devel</code>，提交一次，此后的开发均使用该版本号，如确定新版本发布，则修改为<code>v1.1.0</code>。下次迭代开始时，继续修改版本。这种方案需人工介入，如迭代频繁，可能会忘记版本号的修改。</li><li>与上法类似，但在最后确定发布版本时，再修改版本号。</li></ul><h2 id="研发思考"><a href="#研发思考" class="headerlink" title="研发思考"></a>研发思考</h2><p>无。</p><h2 id="其它研究"><a href="#其它研究" class="headerlink" title="其它研究"></a>其它研究</h2><p>集中看了一些 redis 的知识，如缓存雪崩、缓存击穿等概念。但未有足够时间实践，先记概念以便应试。  </p><h2 id="工作记录"><a href="#工作记录" class="headerlink" title="工作记录"></a>工作记录</h2><h3 id="数据长度计算"><a href="#数据长度计算" class="headerlink" title="数据长度计算"></a>数据长度计算</h3><p>某工程有写字符串数据到指定文件的模块，一日运维反馈 32 位系统概率性出现写的数据有不完整的现象。经查，的确只在 32 位系统出现，64 位一切正常，并且只有设备重启时概率性出现（否则以全区的体量，早就被投诉了）。较长时间排查跟踪，发现是某个缓存区越界了。问题代码片段如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> databuf[<span class="number">60</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">sprintf</span>(databuf, <span class="string">&quot;%s/%s,%010d,%010d,%s,0\n&quot;</span>, themouth, theday, writenum1, writenum2, dataTime);</span><br><span class="line">WriteToFile(MIRROR_FILE, databuf, <span class="built_in">strlen</span>(databuf))</span><br></pre></td></tr></table></figure><p>databuf 长度为 60 字节，在某些情况下，sprintf 组装的长度刚好是60字节，此时用 strlen 函数计算长度，在 32 位系统得到的数值是 63（databuf后有额外的字符，其后才是’\0’），而写入的字符串有换行，因此造成一个错觉，认为写数据不完整，实际上是同一字符串，只是越界了。解决问题比较简单，增加长度即可。</p><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>某工程遇到一个内存泄漏问题。经排查，是因为申请的内在指针被放置于全局 map 变量中，但在循环使用前，调用了 clear 函数清除了 key，但并未释放内存。解决之法十分简单，将其删除即可，经观察，问题解决。</p><h3 id="CPU占用高问题"><a href="#CPU占用高问题" class="headerlink" title="CPU占用高问题"></a>CPU占用高问题</h3><p>运维发现某进程占用CPU较高，一直在99%以上，使用 iotop、iostat等工具定位到 journal 服务有问题，以为系统配置方面的问题，但查了半天，最终发现问题集中在某工程的一个 FIFO 模块，经询问得知，该模块为2016年的资产，至今无人修改，当前机制已变，不再适用，但未删除。该模块每隔一秒读取一次某 FIFO 文件，而该文件不知何故变成为 root 权限，故一直打开出错，因为该读取函数会判断是否打开文件，如否则打开之，但权限不足，故一直打开，一直输出打开失败日志，故导致某个日志文件占用近700GB空间，再导致设备磁盘无空间，导致IO性能下降。将权限修改回普通用户，所有性能指标均正常。删除该模块的调用，经观察，已无类似现象。</p><h2 id="本月做的事及计划"><a href="#本月做的事及计划" class="headerlink" title="本月做的事及计划"></a>本月做的事及计划</h2><p>还有一周就考试了，前面浪费了很多时间，需要抽时间出来复习了，否则浪费报名费。等考完了再陪大锤玩。  </p><p>李迟 2021.10.31 周日</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文为 2021 年 11 月知识总结。&lt;/p&gt;</summary>
    
    
    
    <category term="我的程序代码" scheme="http://www.latelee.org/category/my-library/"/>
    
    
    <category term="代码积累" scheme="http://www.latelee.org/tag/%E4%BB%A3%E7%A0%81%E7%A7%AF%E7%B4%AF/"/>
    
    <category term="知识总结" scheme="http://www.latelee.org/tag/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>一个C++工程内存泄漏问题的排查及重现工程</title>
    <link href="http://www.latelee.org/my-library/a-memory-leak-issue-in-c-project.html"/>
    <id>http://www.latelee.org/my-library/a-memory-leak-issue-in-c-project.html</id>
    <published>2021-10-23T15:40:00.000Z</published>
    <updated>2022-01-27T09:13:09.413Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到一个C++工程内存泄漏的问题，经过排查，发现原来是 map 的使用有问题，本文记录了排查的过程，并给出一个类似的工程代码。</p><span id="more"></span><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>某日，运维反馈生产环境某台设备出现问题，经组长排查，有两个工程服务占用内存较多，出现 OOM 被 Linux 系统干掉了。其中一个是我接手的工程，竟达到了 6GB，随即安排我排查。</p><h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><p>首先在本地虚拟机用 cppcheck、valgrind 测试，但没有发现容易看得懂的问题点，像 cppcheck 提示了很多不怎么要紧的问题——其实有大半问题已经在前两个月修正了。而 valgrind提示多的都是第三方库，比如 curl、xml、ssl 等。</p><p>因为没有头绪，也不敢随便动生产环境，所以写了个简单的 shell 脚本，用于监控程序的内存使用情况，并放在生产环境上，观察半天，发现隔1分钟就有少量内存泄漏，大概几十 KB 左右。因此得到存在内存泄漏的结论，但这只是验证猜测而已，因为在问题发现之初就已经把问题引致这方面了。</p><p>由于代码年代久远，错综复杂，几天过去也没头绪，还好发现概率比较小，还有时间排查。</p><p>后经同事指点，将监控程序频率提高，输出内存的同时打印日期时间，将其与工程日志的日期对比，缩小可疑范围，最后定位到传输模块的一个函数。</p><p>该函数使用 malloc 根据某个数据表名称为一个结构体变量指针申请内存，再放到 map 全局变量中，由于外部函数使用到，故不能释放，跟踪发现在类的析构函数中会释放内存，但在程序运行过程并没有进行析构，所以一直没有释放内存。存放到 map 的目的是防止多次申请内存，因为数据表的数量有限——不到十个，因此使用 map，在申请之前会查找 map，如不存在再申请，并存起来。</p><p>业务逻辑上并无问题，后在某个不起眼的地方看到了对该 map 变量的清除操作，即调用 clear 函数。怀疑此函数使用有误，于是写了一个简单的测试程序重现问题。最终得到结论：调用 map 的 clear 函数会清除 key，但如果 key 为指针，则不会释放其指向的内存。这正是问题根本原因所在。</p><h2 id="重现问题"><a href="#重现问题" class="headerlink" title="重现问题"></a>重现问题</h2><p>用于重现问题的测试程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> Name[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">char</span> Name1[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">char</span> Name3[<span class="number">1024</span>];</span><br><span class="line">&#125; TTableStruct;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMapLeak</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CMapLeak();</span><br><span class="line">    ~CMapLeak();</span><br><span class="line">    </span><br><span class="line">    <span class="function">TTableStruct *<span class="title">GetTable</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *TableName)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TableTest</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span> &lt; <span class="built_in">std</span>::<span class="built_in">string</span>, TTableStruct * &gt;m_mTable;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CMapLeak::CMapLeak()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CMapLeak::~CMapLeak()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span> &lt; <span class="built_in">std</span>::<span class="built_in">string</span>, TTableStruct * &gt;::iterator iter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (iter = m_mTable.begin(); iter != m_mTable.end(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        TTableStruct *pStruct = iter-&gt;second;</span><br><span class="line">        <span class="keyword">if</span> (pStruct != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> pStruct;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TTableStruct* <span class="title">CMapLeak::GetTable</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *TableName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TTableStruct *pStruct = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span> &lt; <span class="built_in">std</span>::<span class="built_in">string</span>, TTableStruct * &gt;::iterator iter;</span><br><span class="line">    iter = m_mTable.find(TableName);</span><br><span class="line">    <span class="keyword">if</span> (iter == m_mTable.end())</span><br><span class="line">    &#123;</span><br><span class="line">        pStruct = <span class="keyword">new</span> TTableStruct[<span class="number">100</span>];</span><br><span class="line">        m_mTable[TableName] = pStruct;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NEW!!! struct ptr: %p\n&quot;</span>, pStruct);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pStruct = iter-&gt;second;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;struct ptr: %p\n&quot;</span>, pStruct);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pStruct;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMapLeak::TableTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TTableStruct *pStruct = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> tablename[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//m_mTable.clear(); // !!! 如执行此行，则会清空 map 的 key</span></span><br><span class="line">        <span class="built_in">sprintf</span>(tablename, <span class="string">&quot;table_%d&quot;</span>, (i++)&amp;<span class="number">0x03</span>);</span><br><span class="line">        pStruct = GetTable(tablename);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: struct ptr: %p\n&quot;</span>, tablename, pStruct);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;----------------\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CMapLeak* pLeak = <span class="keyword">new</span> CMapLeak();</span><br><span class="line">    pLeak-&gt;TableTest();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码逻辑比较简单，为模拟生产环境的运行，直接使用死循环执行。先查找 m_mTable，如果 key 不存在则申请内存，否则直接返回已申请的内存。为了方便观察内存使用情况，在结构体中多加了几个数组。</p><p>当对 map 进行 clear 操作时，出现内存泄漏，监控脚本输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">有内存泄漏的：</span><br><span class="line">23:14:31</span><br><span class="line">dataserver ps mem: 13596 VmRSS: 1068 kB</span><br><span class="line">System memory info:  MemTotal: 3861496 kB MemFree: 2413468 kB Cached: 637216 kB</span><br><span class="line">-------------</span><br><span class="line">23:14:36</span><br><span class="line">dataserver ps mem: 15116 VmRSS: 1068 kB</span><br><span class="line">System memory info:  MemTotal: 3861496 kB MemFree: 2412884 kB Cached: 637216 kB</span><br><span class="line">-------------</span><br><span class="line">23:14:41</span><br><span class="line">dataserver ps mem: 16636 VmRSS: 1068 kB</span><br><span class="line">System memory info:  MemTotal: 3861496 kB MemFree: 2413492 kB Cached: 637216 kB</span><br><span class="line">-------------</span><br><span class="line">23:14:46</span><br><span class="line">dataserver ps mem: 18460 VmRSS: 1068 kB</span><br><span class="line">System memory info:  MemTotal: 3861496 kB MemFree: 2413144 kB Cached: 637216 kB</span><br><span class="line">-------------</span><br><span class="line">23:14:52</span><br><span class="line">dataserver ps mem: 19980 VmRSS: 1068 kB</span><br><span class="line">System memory info:  MemTotal: 3861496 kB MemFree: 2412740 kB Cached: 637216 kB</span><br><span class="line">-------------</span><br><span class="line">23:14:57</span><br><span class="line">dataserver ps mem: 21500 VmRSS: 1068 kB</span><br><span class="line">System memory info:  MemTotal: 3861496 kB MemFree: 2413104 kB Cached: 637216 kB</span><br><span class="line">-------------</span><br><span class="line">23:15:02</span><br><span class="line">dataserver ps mem: 23020 VmRSS: 1068 kB</span><br><span class="line">System memory info:  MemTotal: 3861496 kB MemFree: 2413364 kB Cached: 637216 kB</span><br><span class="line">-------------</span><br></pre></td></tr></table></figure><p>如果不调用  clear 函数，则内存占用较稳定：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">23:10:12</span><br><span class="line">dataserver ps mem: 13900 VmRSS: 1068 kB</span><br><span class="line">System memory info:  MemTotal: 3861496 kB MemFree: 2413616 kB Cached: 637212 kB</span><br><span class="line">-------------</span><br><span class="line">23:10:17</span><br><span class="line">dataserver ps mem: 13900 VmRSS: 1068 kB</span><br><span class="line">System memory info:  MemTotal: 3861496 kB MemFree: 2412888 kB Cached: 637212 kB</span><br><span class="line">-------------</span><br><span class="line">23:10:22</span><br><span class="line">dataserver ps mem: 13900 VmRSS: 1068 kB</span><br><span class="line">System memory info:  MemTotal: 3861496 kB MemFree: 2413504 kB Cached: 637212 kB</span><br><span class="line">-------------</span><br><span class="line">23:10:27</span><br><span class="line">dataserver ps mem: 13900 VmRSS: 1068 kB</span><br><span class="line">System memory info:  MemTotal: 3861496 kB MemFree: 2413092 kB Cached: 637212 kB</span><br><span class="line">-------------</span><br><span class="line">23:10:32</span><br><span class="line">dataserver ps mem: 13900 VmRSS: 1068 kB</span><br><span class="line">System memory info:  MemTotal: 3861496 kB MemFree: 2413536 kB Cached: 637212 kB</span><br><span class="line">-------------</span><br><span class="line">23:10:37</span><br><span class="line">dataserver ps mem: 13900 VmRSS: 1068 kB</span><br><span class="line">System memory info:  MemTotal: 3861496 kB MemFree: 2412988 kB Cached: 637212 kB</span><br><span class="line">-------------</span><br><span class="line">23:10:43</span><br><span class="line">dataserver ps mem: 13900 VmRSS: 1068 kB</span><br><span class="line">System memory info:  MemTotal: 3861496 kB MemFree: 2413348 kB Cached: 637212 kB</span><br><span class="line">-------------</span><br><span class="line">23:10:48</span><br><span class="line">dataserver ps mem: 13900 VmRSS: 1068 kB</span><br><span class="line">System memory info:  MemTotal: 3861496 kB MemFree: 2413796 kB Cached: 637212 kB</span><br><span class="line">-------------</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>就目前排查结果看，只需要将原工程清除 map 的 clear 函数去掉即可，但排查过程，还是花了一定的时间。对于手动申请的内存，一定要十分留意其申请释放的操作，必须配对，否则会产生隐藏。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近遇到一个C++工程内存泄漏的问题，经过排查，发现原来是 map 的使用有问题，本文记录了排查的过程，并给出一个类似的工程代码。&lt;/p&gt;</summary>
    
    
    
    <category term="我的程序代码" scheme="http://www.latelee.org/category/my-library/"/>
    
    
    <category term="工程库代码" scheme="http://www.latelee.org/tag/%E5%B7%A5%E7%A8%8B%E5%BA%93%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>李迟2021年9月知识总结</title>
    <link href="http://www.latelee.org/my-library/code-for-2021-09.html"/>
    <id>http://www.latelee.org/my-library/code-for-2021-09.html</id>
    <published>2021-09-30T15:40:00.000Z</published>
    <updated>2022-01-27T09:13:09.413Z</updated>
    
    <content type="html"><![CDATA[<p>本文为 2021 年 9 月知识总结。</p><span id="more"></span><h2 id="研发编码"><a href="#研发编码" class="headerlink" title="研发编码"></a>研发编码</h2><h3 id="C-C"><a href="#C-C" class="headerlink" title="C / C++"></a>C / C++</h3><p>无。</p><h3 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h3><p>跟时间转换有关的几个片段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   exTime := &quot;20210901&quot;</span><br><span class="line">   mytime, _ := time.Parse(&quot;20060102&quot;, exTime)</span><br><span class="line">   fmt.Println(mytime.UTC().Unix(), mytime.Local().Unix())</span><br><span class="line">   </span><br><span class="line">   // 用本地时间格式转</span><br><span class="line">   mytime, _ = time.ParseInLocation(&quot;20060102&quot;, exTime, time.Local)</span><br><span class="line">   fmt.Println(mytime.UTC().Unix(), mytime.Local().Unix())</span><br><span class="line">   </span><br><span class="line">   exTime = &quot;2020-09-17T20:00:27&quot;</span><br><span class="line">   // 时间有2个格式，这里都判断一下</span><br><span class="line">mytime, _ := time.Parse(&quot;2006-01-02 15:04:05&quot;, exTime)</span><br><span class="line">themonth := int(mytime.Month())</span><br><span class="line">// 如果不合法，年月日均为1</span><br><span class="line">if mytime.Year() == 1 &amp;&amp; themonth == 1 &amp;&amp; mytime.Day() == 1 &#123;</span><br><span class="line">truemytime, _ = time.Parse(&quot;2006-01-02T15:04:05&quot;, exTime)</span><br><span class="line">truethemonth = int(mytime.Month())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>golang 转换时间时，时间模板的数值是固定的，必须为<code>2006-01-02T15:04:05</code>中的对应数值，但间隔的字符可以变化，如示例中的<code>20060102</code>。指定时间字符串转换为时间戳时，使用<code>ParseInLocation</code>函数，指定<code>time.Local</code>，否则转换出来的值会加上时区（如东八区）。  </p><p>执行外部命令代码片段：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">删除进程：</span><br><span class="line">appname := &quot;./httpforward_back.exe&quot;</span><br><span class="line">port := 9000</span><br><span class="line">exec.Command(&quot;sh&quot;, &quot;-c&quot;, fmt.Sprintf(&quot;pkill -SIGINT %s&quot;, appname[2:])).Output()</span><br><span class="line">启动进程：</span><br><span class="line">cmd := exec.Command(&quot;sh&quot;, &quot;-c&quot;, fmt.Sprintf(&quot;%s -p %d -i \&quot;run in port %d\&quot; &amp;&quot;, appname, port, port))</span><br><span class="line">err := cmd.Start()</span><br></pre></td></tr></table></figure><p>使用函数<code>exec.Command</code>执行命令时，前面2个的参数为<code>sh</code>和<code>-c</code>，如果不使用，则会出错。删除进程的命令使用<code>killall</code>也是可行的，在外网找了一些帖子，有提到用<code>pkill -SIGINT</code>，所以就用了。使用<code>Start</code>函数是启动进程，不会阻塞。如果要执行的命令需要返回值或等待其执行完毕，可使用<code>Run</code>函数。  </p><p>写文件的示例。<br>需求：在程序中自定义 nginx 的配置文件 nginx.conf 内容，根据参数，添加<code>location</code>中不同的 URL 和对应的 端口。<br>知识点：由于有特殊字符，故使用反引号，阅读和处理都方便。字符串组装使用<code>fmt.Sprintf</code>。调用<code>ioutil.WriteFile</code>写文件。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// 定义config字符串，一些不变的内容在此</span><br><span class="line">var config = `</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">truelog_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">truetruetruetruetruetrue&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">truetruetruetruetruetrue&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line">trueaccess_log  /var/opt/rh/rh-nginx116/log/nginx/access.log  main;</span><br><span class="line">truesendfile        on;</span><br><span class="line">truetcp_nopush      on;</span><br><span class="line">truetcp_nodelay     on;</span><br><span class="line">truekeepalive_timeout  65;</span><br><span class="line">trueserver &#123;</span><br><span class="line">truetruelisten       8080 default_server;</span><br><span class="line">truetruelisten       [::]:8080 default_server;</span><br><span class="line">truetrueserver_name  _;</span><br><span class="line">truetrueroot         /opt/app-root/src;</span><br><span class="line">truetrueinclude      /opt/app-root/etc/nginx.default.d/*.conf;</span><br><span class="line"></span><br><span class="line">truetruelocation / &#123;</span><br><span class="line">truetrue&#125;</span><br><span class="line">truetruelocation /foo/test9000 &#123;</span><br><span class="line">truetruetruefastcgi_pass 127.0.0.1:9000;</span><br><span class="line">truetruetruefastcgi_index index.cgi;</span><br><span class="line">truetruetruefastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">truetruetrueinclude fastcgi.conf;</span><br><span class="line">truetrue&#125;</span><br><span class="line">`</span><br><span class="line">    // 这是配置文件的结束符号</span><br><span class="line">trueconfigend := `</span><br><span class="line">    &#125;</span><br><span class="line">&#125;`</span><br><span class="line">    // 格式化 只针对 location 的地址和端口。</span><br><span class="line">    // 添加多个的话，按格式写即可</span><br><span class="line">trueurl := &quot;test9001&quot;</span><br><span class="line">trueport := 9001</span><br><span class="line">truetmpstr := fmt.Sprintf(`</span><br><span class="line">        location /foo/%s &#123;</span><br><span class="line">truetrue    fastcgi_pass 127.0.0.1:%d;</span><br><span class="line">truetrue    fastcgi_index index.cgi;</span><br><span class="line">truetrue    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">truetrue    include fastcgi.conf;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;`, url, port)</span><br><span class="line"></span><br><span class="line">trueconfig = config + tmpstr + configend</span><br><span class="line"></span><br><span class="line">trueklog.Println(&quot;write and reload nginx&quot;)</span><br><span class="line">trueioutil.WriteFile(&quot;/etc/nginx/nginx.conf&quot;, []byte(config), 0666)</span><br></pre></td></tr></table></figure><p>注：上述配置内容并不完整。  </p><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>在 Dockerfile 中设置环境变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ENV MAVEN_HOME /usr/local/apache-maven-3.8.2</span><br><span class="line"></span><br><span class="line">ENV GOROOT /usr/local/go</span><br><span class="line">ENV GOBIN /usr/local/go/bin</span><br><span class="line">ENV GOPROXY https://goproxy.io,direct</span><br><span class="line"></span><br><span class="line"># seems cant pass $MAVEN_HOME here</span><br><span class="line">ENV PATH $PATH:/usr/local/apache-maven-3.8.2/bin:/usr/local/go/bin</span><br></pre></td></tr></table></figure><p>注：在构建镜像中，观察输出日志，会将物理机的环境变量解析进来，如最后一行的 $PATH 会变为物理上的 $PATH 的具体值。如果使用 Dockerfile 定义的环境变量，似乎不生效。  </p><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h3 id="zip压缩"><a href="#zip压缩" class="headerlink" title="zip压缩"></a>zip压缩</h3><p>对于相同文件/目录，不同时间点用 zip 压缩，得到的 zip 文件，md5 值会不相同（时间间隔非常短则无此现象）。使用<code>-X -D</code>可解决，示例：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -qr -X -D c.zip hello/</span><br></pre></td></tr></table></figure><p>参考 <a href="https://stackoverflow.com/questions/19523063/zip-utility-giving-me-different-md5sum-every-time-in-linux">https://stackoverflow.com/questions/19523063/zip-utility-giving-me-different-md5sum-every-time-in-linux</a>     </p><h3 id="编码其它"><a href="#编码其它" class="headerlink" title="编码其它"></a>编码其它</h3><p>有些工程跟踪较麻烦，有些是因为条理性和逻辑性不够好，也有些是因为线索不明导致的。比如一个 C++ 类，某个业务处理示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ret = get(m_path);  // 使用成员变量m_path</span><br><span class="line">search_dir(m_path);  // 使用成员变量m_path</span><br><span class="line">mysort()    // 不带参数，函数内使用了前面赋值了的成员变量m_path，同时设置了成员变量m_file</span><br><span class="line">changedate(m_file) // 这里直接用m_file传参</span><br></pre></td></tr></table></figure><p>该示例的具体处理见上面的注释，从注释看是没问题，但是，单纯从函数调用及参数，是比较难看到逻辑的，需要跟踪每个函数及对应的成员变量才能理清数据流向。<br>对此，个人看法是：<br>如果类中有工具函数的话，不要使用类成员变量。<br>业务函数中，能从成员变量看到主线。或加上注释。    </p><h2 id="研发知识"><a href="#研发知识" class="headerlink" title="研发知识"></a>研发知识</h2><p>参考一些开源项目的 git 提交日志格式，分为“头部 正文 尾部”三部分。根据实际情况，自己整理一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">头部： 给出本次提交的类型及影响范围。如：格式修改 测试 重构 bug修正  （影响范围）</span><br><span class="line">正文： 描述本次提交的变化，可列表。</span><br><span class="line">尾部：一些备注或注意事项</span><br></pre></td></tr></table></figure><p>实际示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">头部         bug修正（时间同步模块）</span><br><span class="line">正文         时间同步模块减小时间差判断的阈值，避免波动。</span><br><span class="line">尾部（附录）   关闭#1</span><br></pre></td></tr></table></figure><h2 id="研发思考"><a href="#研发思考" class="headerlink" title="研发思考"></a>研发思考</h2><h3 id="适当时候做适当事"><a href="#适当时候做适当事" class="headerlink" title="适当时候做适当事"></a>适当时候做适当事</h3><p>当初想入门后台管理系统，选定 vue + golang 路线。查了很多资料，也下载了很多工程源码，发现学不进去。后来才发现是因为工程太复杂，并不适合新手。遂放弃，至今因其它事缘由，一直未能再动手写。<br>本月开始真正搞组织革新，jenkins 倒好，但 Java 只看了一点语法，工程是 springboot 的，在初期连 IDEA 工程也不懂建立，对于 jdk 那些 1.8、16等版本号也没理解。硬着头皮搞了几天才有点眉目。只感叹 IDEA 太强大了，Java 框架太多太成熟了。但就是因为太成熟了反而不喜欢研究，还是习惯 C++。   </p><h2 id="工作记录"><a href="#工作记录" class="headerlink" title="工作记录"></a>工作记录</h2><p>某工程有自定义的日志函数，有操作 sqlite3 数据库，等等。在设备突然断电再启动后，sqlite3 数据库文件被损坏，经查其二进制，竟然在某个偏移量出现了部分的日志。百思不解，一直未解决。实然没招，后使用 cppcheck 和 valgrind 检查，修正一些编码错误/警告。将没有实质用处的函数删除（调用了但没产生作用）。  </p><p>某工程需要兼容 32 位和 64 位，在 64 位系统中用<code>%ld</code>打印 uint64_t 类型变量，正常，在 32 位系统运行则报段错误，使用<code>%lld</code>打印，但在 64 位又出现警告，无奈，将 uint64_t 改为 long long 类型。幸好是在试点阶段发现，否则影响大了。  </p><p>某工程连接的主备系统两个 sftp 服务器，该工程下载 xml 文件并判断哪个系统的文件版本较新即下载之。后发现同一文件的 md5 值不同，导致不断下载。经查，发现该文件在不同时间打包压缩，即使内容无变化，但压缩的 zip 文件 md5 值变化了。经查，可以通过参数保持 md5 一致。因工程是其它小组负责且用 Java  实现，未知如何修改。  </p><p>某工程需下载远程服务器某个目录的文件，设置一 数组变量<code>char remoteFile[128]</code>，在之前一切安好，但最近切换备份系统后，中秋节前一晚，某生产环境出现错误，无法下载，造成堵车，运维同事联系紧急处理。经查，是因为切换后，远程目录文件长度超过 128 字节了，且只超过2~3字符。试点现场采用的服务器IP比较短（如<code>10.0.45.16</code>），未被发现，但有的服务器IP较长（如<code>10.100.168.231</code>），刚好超过几个字符，于是失败。定位原因后，将相关的变量大小改大，解决问题。  </p><p>参与了某路段开通的一些工作。初期，经工具检查发现某项数据不符合要求，与其它同事确认不影响，在试点测试时，另一服务器工具无法正常工作，数据未更新，问题在上线前2天被发现，并因此加班。<br>复盘后得到经验：与既定规则不符合的，多请教同事，并汇报领导（当初未坚持，也未上报）；参数修改，需多方参与评估（其他同事负责的）；生产环境需要有监控手段。     </p><h2 id="本月做的事及计划"><a href="#本月做的事及计划" class="headerlink" title="本月做的事及计划"></a>本月做的事及计划</h2><p>抽时间完成转发工具编写和测试，研究并实现了一些负载均衡算法。  </p><p>近来发现自己表达能力和思考能力下降了，计划看看非技术类的书。</p><h2 id="其它点滴"><a href="#其它点滴" class="headerlink" title="其它点滴"></a>其它点滴</h2><p>本月首次还贷，正式开始房奴生活。个人的开支须更加节约了。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文为 2021 年 9 月知识总结。&lt;/p&gt;</summary>
    
    
    
    <category term="我的程序代码" scheme="http://www.latelee.org/category/my-library/"/>
    
    
    <category term="代码积累" scheme="http://www.latelee.org/tag/%E4%BB%A3%E7%A0%81%E7%A7%AF%E7%B4%AF/"/>
    
    <category term="知识总结" scheme="http://www.latelee.org/tag/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>LiteOS调研</title>
    <link href="http://www.latelee.org/my-study/liteos-search.html"/>
    <id>http://www.latelee.org/my-study/liteos-search.html</id>
    <published>2021-09-27T16:00:00.000Z</published>
    <updated>2022-01-27T09:13:09.421Z</updated>
    
    <content type="html"><![CDATA[<p>LiteOS调研。  </p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="个人心得"><a href="#个人心得" class="headerlink" title="个人心得"></a>个人心得</h2><p>2020.12.30发布了5.0版本，但网上资料较多是旧的版本，旧版本分有-m和-a系列，新版本统一了，接口也更改了。新版本改动很大，也添加很多组件，可能还是基于该版本开发。    </p><p>CMSIS ARM制定的接口，在LiteOS中有实现，在GD32中也看到有（但似乎没实现）。  </p><p>在模块的 makefile 中，最好用通配符匹配源文件。  </p><p>DemoEntry会初始化众多 demo 和 shell，在内核配置中添加。如不用，则可自定义 app_init 函数。</p><p>目标板的 main 函数基本不用做大改动。  </p><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><h3 id="Windows平台的开发环境及工具"><a href="#Windows平台的开发环境及工具" class="headerlink" title="Windows平台的开发环境及工具"></a>Windows平台的开发环境及工具</h3><h4 id="studio安装"><a href="#studio安装" class="headerlink" title="studio安装"></a>studio安装</h4><p>安装包 HUAWEI-LiteOS-Studio-Setup-x64-xx。实际：<a href="https://gitee.com/LiteOS/LiteOS_Studio/releases/V1.45.9Beta">HUAWEI-LiteOS-Studio V1.45.9 Beta</a>  。  </p><p>中文包下载脚本 <a href="https://liteos.gitee.io/liteos_studio/scripts/extension_download.bat">https://liteos.gitee.io/liteos_studio/scripts/extension_download.bat</a><br>先安装studio，在里面选插件，再选中下载的插件，安装，官方有步骤。  </p><p>安装 stm32 插件。（用 qemu 模拟也要安装之）   </p><p>安装 base 插件。   </p><h4 id="gcc编译器"><a href="#gcc编译器" class="headerlink" title="gcc编译器"></a>gcc编译器</h4><p>安装arm-none-eabi软件。下载<a href="https://liteos.gitee.io/liteos_studio/scripts/GNU_Arm_Embedded_Toolchain_download.bat%E3%80%82">https://liteos.gitee.io/liteos_studio/scripts/GNU_Arm_Embedded_Toolchain_download.bat。</a><br>注：默认下载目录为<code>C:\Users\&lt;用户名&gt;\.huawei-liteos-studio</code>，因后续工程亦需要此目录，故直接使用，如没有，创建之。  </p><h4 id="make工具"><a href="#make工具" class="headerlink" title="make工具"></a>make工具</h4><p>下载 <a href="https://liteos.gitee.io/liteos_studio/scripts/x_pack_windows_build_tools_download.bat">https://liteos.gitee.io/liteos_studio/scripts/x_pack_windows_build_tools_download.bat</a> </p><p>注：不能使用其它的make工具，否则编译不成功。  </p><h4 id="QEMU工具"><a href="#QEMU工具" class="headerlink" title="QEMU工具"></a>QEMU工具</h4><p><a href="https://qemu.weilnetz.de/w64/2021/">https://qemu.weilnetz.de/w64/2021/</a><br>文件名：qemu-w64-setup-20210810.exe<br>需核查 sha512 值。<br>双击exe安装。</p><h4 id="使用小结"><a href="#使用小结" class="headerlink" title="使用小结"></a>使用小结</h4><p>烧录后，有时编译无反响，关闭烧录界面。</p><p>默认只有ST和QEMU系列可配置，其它的系列暂不知如何搞。直接复制默认的配置文件（在LiteOS\tools\build\config目录），无效。  </p><h3 id="Linux平台的开发环境及工具"><a href="#Linux平台的开发环境及工具" class="headerlink" title="Linux平台的开发环境及工具"></a>Linux平台的开发环境及工具</h3><h2 id="QEMU入门实例"><a href="#QEMU入门实例" class="headerlink" title="QEMU入门实例"></a>QEMU入门实例</h2><p>参考：<a href="https://liteos.gitee.io/liteos_studio/#/project_stm32">https://liteos.gitee.io/liteos_studio/#/project_stm32</a>  里面有注意事项。<br>注意要联网。   </p><h3 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h3><p><img src="/my-study/liteos-search/image-20210930154123068.png" alt="image-20210930154123068"></p><p>之后自动下载。提示：<br><img src="/my-study/liteos-search/image-20210930154147598.png" alt="image-20210930154147598"></p><p>下载完后自动打开工程。如无，手动打开。  </p><p><strong>自注： 似乎是把 liteos 整个源码下载了。与默认的仓库文件相比，一些配置修改了。</strong>  </p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>点击齿轮图标<img src="/my-study/liteos-search/image-20210930155319439.png" alt="image-20210930155319439">，快捷键F4配置工程。  </p><p><img src="/my-study/liteos-search/image-20210930155813140.png" alt="image-20210930155813140"></p><p><img src="/my-study/liteos-search/image-20210930162507159.png" alt="image-20210930162507159"></p><p><img src="/my-study/liteos-search/image-20210930162516870.png" alt="image-20210930162516870"></p><p><img src="/my-study/liteos-search/image-20210930162526416.png" alt="image-20210930162526416"></p><p>注：如果默认没有的目标板，也可以手动添加，一般基于某些芯片修改。<br>注：工程源码映射那个地方，暂未搞明白。  </p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>按编译图标，快捷键为F7，成功提示：</p><p>编译成功提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arm-none-eabi-objdump -d d:/project/LiteOS/demo/out/realview-pbx-a9/Huawei_LiteOS.elf &gt;d:/project/LiteOS/demo/out/realview-pbx-a9/Huawei_LiteOS.asm</span><br><span class="line">arm-none-eabi-size d:/project/LiteOS/demo/out/realview-pbx-a9/Huawei_LiteOS.elf</span><br><span class="line">   text    data     bss     dec     hex filename</span><br><span class="line"> 158366     508   53184  212058   33c5a d:/project/LiteOS/demo/out/realview-pbx-a9/Huawei_LiteOS.elf</span><br><span class="line">########################################################################################################</span><br><span class="line">########                      LiteOS build successfully!                                        ########</span><br><span class="line">########################################################################################################</span><br></pre></td></tr></table></figure><p>make 不对应，出错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; Executing task: LiteOSTool: Build &lt;</span><br><span class="line"></span><br><span class="line">&#x27;tr&#x27; 不是内部或外部命令，也不是可运行的程序</span><br><span class="line">或批处理文件。</span><br><span class="line">此时不应有 -lt。</span><br><span class="line">&#x27;tr&#x27; 不是内部或外部命令，也不是可运行的程序</span><br><span class="line">或批处理文件。</span><br><span class="line">此时不应有 -gt。</span><br><span class="line">命令语法不正确。</span><br><span class="line">命令语法不正确。</span><br><span class="line">make: *** [Makefile:38: d:/project/LiteOS/demo/out/realview-pbx-a9] Error 1</span><br><span class="line">make: *** Waiting for unfinished jobs....</span><br><span class="line">make: *** [Makefile:41: d:/project/LiteOS/demo/out/realview-pbx-a9/obj] Error 1</span><br><span class="line">d:/project/LiteOS/demo/kernel/init/los_init.c</span><br><span class="line">此时不应有 dir。</span><br><span class="line">make: *** [Makefile:60: LITEOS_BUILD] Error 255</span><br></pre></td></tr></table></figure><p>注：make使用 mingw 提供的，不符合。  </p><h3 id="烧录"><a href="#烧录" class="headerlink" title="烧录"></a>烧录</h3><p>在工程配置烧录器页面选择<strong>烧录文件</strong>。</p><p><img src="/my-study/liteos-search/image-20210930165840818.png" alt="image-20210930165840818"></p><p>启动信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Executing task: qemu-system-arm.exe -machine &quot;realview-pbx-a9&quot; -smp 4 -m 512M -kernel &quot;d:\project\LiteOS\demo\out\realview-pbx-a9\Huawei_LiteOS.bin&quot; -serial mon:stdio -nographic &lt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">********Hello Huawei LiteOS********</span><br><span class="line"></span><br><span class="line">LiteOS Kernel Version : 5.1.0</span><br><span class="line">Processor   : Cortex-A9 * 4</span><br><span class="line">Run Mode    : SMP</span><br><span class="line">GIC Rev     : GICv1</span><br><span class="line">build time  : Sep 30 2021 17:05:17</span><br><span class="line"></span><br><span class="line">**********************************</span><br><span class="line"></span><br><span class="line">main core booting up...</span><br><span class="line">OsAppInit</span><br><span class="line">releasing 3 secondary cores</span><br><span class="line">cpu 0 entering scheduler</span><br><span class="line">cpu 1 entering scheduler</span><br><span class="line">cpu 3 entering scheduler</span><br><span class="line">cpu 2 entering scheduler</span><br><span class="line">app init!</span><br><span class="line"></span><br><span class="line">Huawei LiteOS # help    ## 注：这是内建的命令</span><br><span class="line">*******************shell commands:*************************</span><br><span class="line"></span><br><span class="line">date          free          help          hwi           memcheck      stack         swtmr         systeminfo</span><br><span class="line">task          uname         watch</span><br></pre></td></tr></table></figure><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>在配置界面，在<strong>调试器</strong>界面指定可执行文件。按 F5 启动调试。  </p><h2 id="bpx-a9研究"><a href="#bpx-a9研究" class="headerlink" title="bpx-a9研究"></a>bpx-a9研究</h2><h3 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h3><p>reset_vector.S，各种初始化（reset_vector、异常处理、OsIrqHandler），跳转到 main 函数。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">b   reset_vector</span><br><span class="line">true--&gt; excstatck_loop_done</span><br><span class="line">truetrue--&gt; cpu_start</span><br><span class="line">truetrue--&gt; enable_scu</span><br><span class="line">truetrue--&gt; board_config // 目标板实现 </span><br><span class="line">truetrue--&gt; main         // 目标板主函数</span><br></pre></td></tr></table></figure><p>board_config：一般赋值系统内存结束地址为某个值，如果注释掉，内存初始化失败。  </p><h3 id="串口打印"><a href="#串口打印" class="headerlink" title="串口打印"></a>串口打印</h3><p>定义宏 LOSCFG_DRIVERS_UART_ARM_PL011，实现文件在 drivers\uart\src\arm_pl011。 </p><h3 id="自定义shell"><a href="#自定义shell" class="headerlink" title="自定义shell"></a>自定义shell</h3><p>DemoEntry 中初始化了 shell，动态注册 shell 必须在此函数之后。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">注册：</span><br><span class="line">#include &quot;shcmd.h&quot;</span><br><span class="line">#include &quot;shell.h&quot;</span><br><span class="line"></span><br><span class="line">__attribute__((weak)) VOID app_init(VOID)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;app init!\n&quot;);    </span><br><span class="line">    DemoEntry();</span><br><span class="line"></span><br><span class="line">    osCmdReg(CMD_TYPE_EX, &quot;foobar&quot;, 0,(CMD_CBK_FUNC)OsShellCmdFooBar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">实现：</span><br><span class="line">INT32 OsShellCmdFooBar(INT32 argc, const CHAR **argv)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;my cmd...\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>安装：<a href="https://liteos.gitee.io/liteos_studio/#/install">https://liteos.gitee.io/liteos_studio/#/install</a>　　<br>qemu示例：<a href="https://juejin.cn/post/6906386181001314317">https://juejin.cn/post/6906386181001314317</a>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;LiteOS调研。  &lt;/p&gt;</summary>
    
    
    
    <category term="技术杂铺" scheme="http://www.latelee.org/category/my-study/"/>
    
    
  </entry>
  
  <entry>
    <title>兆易创新GD32芯片调研</title>
    <link href="http://www.latelee.org/my-study/gd32mcu-search.html"/>
    <id>http://www.latelee.org/my-study/gd32mcu-search.html</id>
    <published>2021-09-27T16:00:00.000Z</published>
    <updated>2022-01-27T09:13:09.425Z</updated>
    
    <content type="html"><![CDATA[<p>兆易创新GD32芯片调研，具体型号：GD32F450ZGT6。  </p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>官网：<a href="http://www.gd32mcu.com/">http://www.gd32mcu.com/</a>  </p><p>GD32F450 系列，基于Arm® Cortex®-M4内核的32位通用微控制器(MCU)  。ARMv7 架构，32位，哈佛结构，可以使用相互独立的总线来读取指令和加载/存储数据。<strong>指令代码和数据都位于相同的存储器地址空间,但在不同的地址范围</strong>。<strong>程序存储器，数据存储器，寄存器和IO端口都在同一个线性的4GB的地址空间之内</strong>。这是CortexR-M4的最大地址范围，因为它的地址总线宽度是32位。此外，为了降低不同客户在相同应用时的软件复杂度，存储映射是按Cortex-M4处理器提供的规则预先定义的。在存储器映射表中，<strong>一部分地址空间</strong>由Arm RCortex-M4的<strong>系统外设所占用</strong>，且不可更改。此外，其余部分地址空间可由芯片供应商定义使用。  </p><p>特性：  </p><p><img src="/my-study/gd32mcu-search/image-20210928155014233.png" alt="image-20210928155014233"></p><p>资料：  </p><p>芯片手册（英文）：<a href="http://www.gd32mcu.com/cn/download/5?kw=GD32F4">http://www.gd32mcu.com/cn/download/5?kw=GD32F4</a>  </p><p>用户手册（中英，看这个基本可以）：<a href="http://www.gd32mcu.com/cn/download/6?kw=GD32F4">http://www.gd32mcu.com/cn/download/6?kw=GD32F4</a>  </p><h3 id="与STM32的兼容性"><a href="#与STM32的兼容性" class="headerlink" title="与STM32的兼容性"></a>与STM32的兼容性</h3><p>针对 GD32F450ZGT6  144Pin  </p><p>网上资料，GD32F450ZGT6 可替换 STM32F407ZGT6。</p><p>GD32F450ZGT6   〈－－〉 STM32F429ZGT6  </p><p>GD和ST对比。  </p><p><img src="/my-study/gd32mcu-search/image-20210928155226706.png" alt="image-20210928155226706"></p><p><img src="/my-study/gd32mcu-search/image-20211006131010602.png" alt="image-20211006131010602"></p><h2 id="开发相关"><a href="#开发相关" class="headerlink" title="开发相关"></a>开发相关</h2><p>预研的：</p><p><a href="https://github.com/LITEOS/LiteOS_Kernel/blob/master/doc/LiteOS_Migration_Guide_gdf450_Keil.md">https://github.com/LITEOS/LiteOS_Kernel/blob/master/doc/LiteOS_Migration_Guide_gdf450_Keil.md</a></p><p><a href="https://www.cirmall.com/bbs/thread-95132-1-1.html">https://www.cirmall.com/bbs/thread-95132-1-1.html</a><br><a href="https://www.cirmall.com/bbs/thread-94857-1-1.html">https://www.cirmall.com/bbs/thread-94857-1-1.html</a><br><a href="https://bbs.huaweicloud.com/blogs/174493">https://bbs.huaweicloud.com/blogs/174493</a>  </p><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><h3 id="库"><a href="#库" class="headerlink" title="库"></a>库</h3><p><a href="http://www.gd32mcu.com/cn/download/7?kw=GD32F4">http://www.gd32mcu.com/cn/download/7?kw=GD32F4</a>  </p><p>具体：GD32F4xx Firmware Library  </p><p>gd32f450i_eval.c封装有板级外设（如点灯）的接口，LiteOS也会用到。  </p><p><a href="https://github.com/SoCXin/GD32F450">https://github.com/SoCXin/GD32F450</a> 仓库有些代码示例，也是从官网获取的。但版本旧了一点。另：该仓库版本与官方基本相同，只是少许改动。    </p><h2 id="LiteOS"><a href="#LiteOS" class="headerlink" title="LiteOS"></a>LiteOS</h2><p>旧版本<br>2018.5.7 删除了GD32的移植指南。  可能是重构了工程，版本是V2。之前是V1.1.2版本。<br>移植基于 Keil，即将 LiteOS的核心代码拷贝到 Keil 中进行开发。</p><p>新版本<br>没有了，参考的移植板子见<code>targets\GD32VF103V_EVAL</code>。<br>统一在 Studio 中，将 GD 的代码拷贝到工程中开发。</p><p>不管何种方式，都要使用固件包，见上面地址。  </p><p>新版本的启动链接脚本和汇编代码，是基于 GCC 的（存疑），与旧版本不同，因与芯片密切相关，没有 LiteOS 的支持，可能难编写。  </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.eet-china.com/mp/a66006.html">https://www.eet-china.com/mp/a66006.html</a>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;兆易创新GD32芯片调研，具体型号：GD32F450ZGT6。  &lt;/p&gt;</summary>
    
    
    
    <category term="技术杂铺" scheme="http://www.latelee.org/category/my-study/"/>
    
    
  </entry>
  
  <entry>
    <title>jekyll使用</title>
    <link href="http://www.latelee.org/pkc/jekyll-usage.html"/>
    <id>http://www.latelee.org/pkc/jekyll-usage.html</id>
    <published>2021-09-25T16:00:00.000Z</published>
    <updated>2022-01-27T09:13:09.385Z</updated>
    
    <content type="html"><![CDATA[<p>jekyll 命令使用。</p><span id="more"></span><h2 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>下载：<a href="https://rubyinstaller.org/downloads/%EF%BC%8C%E6%96%87%E4%BB%B6%EF%BC%9Arubyinstaller-devkit-xx%E3%80%82">https://rubyinstaller.org/downloads/，文件：rubyinstaller-devkit-xx。</a>  </p><p>双击安装。  </p><p>输入<code>ruby -v</code>确认。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/</span><br><span class="line">gem install jekyll</span><br><span class="line">gem install jekyll-paginate</span><br><span class="line">gem install bundler</span><br><span class="line">jekyll -v</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 jekyll 目录构建网站：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bundle exec jekyll b</span><br><span class="line"></span><br><span class="line">## 实时监控文件的变化，实时生成</span><br><span class="line">bundle exec jekyll b --watch</span><br></pre></td></tr></table></figure><p>服务运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bundle exec jekyll serve -H 0.0.0.0 -P 8080</span><br></pre></td></tr></table></figure><h3 id="问题及解决"><a href="#问题及解决" class="headerlink" title="问题及解决"></a>问题及解决</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find_spec_for_exe&#x27;: can&#x27;t find gem bundler (&gt;= 0.a) (Gem::GemNotFoundException)</span><br><span class="line">解决：</span><br><span class="line">bundler版本不一致，将Gemfile.lock中的BUNDLED WITH修改为新安装的版本。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">提示：Could not locate Gemfile</span><br><span class="line">初始化：bundle init</span><br><span class="line">注：效果不好。</span><br></pre></td></tr></table></figure><p>已有Gemfile文件，但里面的版本较旧，移到其它电脑，重新安装，但版本较新。Gemfile不适应。执行<code>jekyll new my-awesome-site</code>生成一个简单网站示例，从中拿到Gemfile，替换之。  </p><p>安装指定版本的bundle：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install bundler -v 1.16.1</span><br></pre></td></tr></table></figure><h2 id="Ubuntu安装"><a href="#Ubuntu安装" class="headerlink" title="Ubuntu安装"></a>Ubuntu安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/</span><br><span class="line">gem install jekyll</span><br><span class="line">gem install jekyll-paginate</span><br><span class="line">gem install bundler</span><br><span class="line">jekyll -v</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;jekyll 命令使用。&lt;/p&gt;</summary>
    
    
    
    <category term="个人知识中心" scheme="http://www.latelee.org/category/pkc/"/>
    
    
    <category term="工具使用" scheme="http://www.latelee.org/tag/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>nginx负载均衡实验笔记</title>
    <link href="http://www.latelee.org/my-study/nginx-load-balnace-note.html"/>
    <id>http://www.latelee.org/my-study/nginx-load-balnace-note.html</id>
    <published>2021-09-23T17:00:00.000Z</published>
    <updated>2022-01-27T09:13:09.429Z</updated>
    
    <content type="html"><![CDATA[<p>本文是nginx负载均衡实验的一些笔记。</p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>前面已经完成了转发的程序，也尝试了一些负载均衡算法，本文对 nginx 的负载均衡做一些简单的测试，有部分实验是为了解答笔者与同事交流时产生的疑惑。  </p><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>本文所用程序，为笔者之前实现的转发程序，实际上任何能响应 post 请求的程序均可。  </p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>本文实验环境如下：<br>虚拟机 Linux 运行容器。<br>虚拟机 Windows 发送 POST 请求。  </p><p>本文使用镜像<code>centos/nginx-116-centos7</code>进行测试。<br>启动命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># $PWD/bin保存了后端的服务，故挂载之</span><br><span class="line">docker run -itd --name nginx -p 8080:8080 -v $PWD/bin:/home/latelee/bin centos/nginx-116-centos7 nginx -g &quot;daemon off;&quot;</span><br></pre></td></tr></table></figure><p>为了配置 nginx，需 root 权限，故使用如下命令进入容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker exec -u root -it nginx bash</span><br></pre></td></tr></table></figure><p>后端服务运行命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/home/latelee/bin/httpforward_back.exe -p 9001 -i &quot;hello in 9001&quot;</span><br><span class="line">/home/latelee/bin/httpforward_back.exe -p 9002 -i &quot;hello in 9002&quot;</span><br><span class="line">/home/latelee/bin/httpforward_back.exe -p 9003 -i &quot;hello in 9003&quot;</span><br></pre></td></tr></table></figure><p>重启 nginx 命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><p>nginx 配置文件如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/nginx/nginx.conf &lt;&lt;-EOF </span><br><span class="line">worker_processes auto;</span><br><span class="line">error_log /var/opt/rh/rh-nginx116/log/nginx/error.log;</span><br><span class="line">pid /var/opt/rh/rh-nginx116/run/nginx/nginx.pid;</span><br><span class="line"></span><br><span class="line"># Load dynamic modules. See /opt/rh/rh-nginx116/root/usr/share/doc/README.dynamic.</span><br><span class="line">include /opt/rh/rh-nginx116/root/usr/share/nginx/modules/*.conf;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    log_format  main  &#x27;[$time_local] $remote_addr: &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; [$upstream_addr $upstream_status $upstream_response_time ms $request_time ms]&#x27;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/opt/rh/rh-nginx116/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    tcp_nopush      on;</span><br><span class="line">    tcp_nodelay     on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    types_hash_max_size 2048;</span><br><span class="line">    proxy_connect_timeout 10;</span><br><span class="line"></span><br><span class="line">    include       /etc/opt/rh/rh-nginx116/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    # Load modular configuration files from the /etc/nginx/conf.d directory.</span><br><span class="line">    # See http://nginx.org/en/docs/ngx_core_module.html#include</span><br><span class="line">    # for more information.</span><br><span class="line">    include /opt/app-root/etc/nginx.d/*.conf;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       8080 default_server;</span><br><span class="line">        listen       [::]:8080 default_server;</span><br><span class="line">        server_name  _;</span><br><span class="line">        root         /opt/app-root/src;</span><br><span class="line"></span><br><span class="line">        # Load configuration files for the default server block.</span><br><span class="line">        include      /opt/app-root/etc/nginx.default.d/*.conf;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://foobar;</span><br><span class="line">            proxy_set_header Host $proxy_host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        location /fee/sleep &#123;</span><br><span class="line">            proxy_pass http://foobar;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    upstream foobar &#123;</span><br><span class="line">      server 127.0.0.1:9001;</span><br><span class="line">      server 127.0.0.1:9002;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    #upstream foobar &#123;</span><br><span class="line">    #  server 127.0.0.1:9001 weight=3;</span><br><span class="line">    #  server 127.0.0.1:9002 weight=1;</span><br><span class="line">    #&#125;</span><br><span class="line">    </span><br><span class="line">    #upstream foobar &#123;</span><br><span class="line">    #    ip_hash;</span><br><span class="line">    #    server 127.0.0.1:9001;</span><br><span class="line">    #    server 127.0.0.1:9002;</span><br><span class="line">    #    server 127.0.0.1:9003;</span><br><span class="line">    #&#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该配置文件主要设置了上游服务<code>foobar</code>的IP和端口。再进行具体 URL 的映射，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">        proxy_pass http://foobar; </span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">    location /fee/sleep &#123;</span><br><span class="line">        proxy_pass http://foobar; </span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><p>下面主要针对<code>upstream foobar</code>部分进行修改，达到使用不同算法的实验目的。  </p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>为了进行实验，需启动若干个终端进入容器，如：修改配置并重启 nginx，执行程序，观察日志，等等。<br>查看访问日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f /var/opt/rh/rh-nginx116/log/nginx/access.log</span><br></pre></td></tr></table></figure><p>在另一终端（可在Windows或虚拟机中）执行如下请求命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://192.168.28.11:8080/ -X POST -F  &quot;file=@sample.json&quot;</span><br></pre></td></tr></table></figure><p>下面给出配置和相应的日志和观察到的现象。  </p><h3 id="基础的实验"><a href="#基础的实验" class="headerlink" title="基础的实验"></a>基础的实验</h3><h4 id="默认轮询"><a href="#默认轮询" class="headerlink" title="默认轮询"></a>默认轮询</h4><p>配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream foobar &#123;</span><br><span class="line">  server 127.0.0.1:9001;</span><br><span class="line">  server 127.0.0.1:9002;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[21/Sep/2021:04:47:26 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.000 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:04:47:27 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9001 200 0.001 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:04:47:29 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9001 200 0.002 ms 0.003 ms]</span><br><span class="line">[21/Sep/2021:04:47:31 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.001 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:04:47:34 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.001 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:04:47:35 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9001 200 0.001 ms 0.001 ms]</span><br></pre></td></tr></table></figure><p>结论： 9001 和 9002 依次出现。  </p><h4 id="加权轮询"><a href="#加权轮询" class="headerlink" title="加权轮询"></a>加权轮询</h4><p>配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream foobar &#123;</span><br><span class="line">  server 127.0.0.1:9001 weight=4;</span><br><span class="line">  server 127.0.0.1:9002 weight=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[21/Sep/2021:04:52:17 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9001 200 0.000 ms 0.000 ms]</span><br><span class="line">[21/Sep/2021:04:52:18 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9001 200 0.001 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:04:52:18 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9001 200 0.000 ms 0.000 ms]</span><br><span class="line">[21/Sep/2021:04:52:19 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9001 200 0.001 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:04:52:20 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.001 ms 0.001 ms]</span><br></pre></td></tr></table></figure><p>结论： 9001 和 9002 依次出现 4 次和 1 次。<br><strong>注：经测试发现，nginx 加权轮询本身就是平滑加权轮询，此处为了演示，特意将权重值扩大。</strong>  </p><h4 id="平滑加权轮询"><a href="#平滑加权轮询" class="headerlink" title="平滑加权轮询"></a>平滑加权轮询</h4><p>配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream foobar &#123;</span><br><span class="line">  server 127.0.0.1:9001 weight=2;</span><br><span class="line">  server 127.0.0.1:9002 weight=5;</span><br><span class="line">  server 127.0.0.1:9003 weight=3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">第一轮：</span><br><span class="line">[21/Sep/2021:05:00:39 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.001 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:05:00:39 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.001 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:05:00:40 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9003 200 0.001 ms 0.000 ms]</span><br><span class="line">[21/Sep/2021:05:00:41 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9003 200 0.000 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:05:00:42 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9001 200 0.008 ms 0.009 ms]</span><br><span class="line">[21/Sep/2021:05:00:43 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.001 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:05:00:44 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.001 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:05:00:44 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9001 200 0.000 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:05:00:45 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.000 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:05:00:46 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9003 200 0.001 ms 0.001 ms]</span><br><span class="line"></span><br><span class="line">第二轮</span><br><span class="line">[21/Sep/2021:05:03:24 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.001 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:05:03:25 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9001 200 0.001 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:05:03:26 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.000 ms 0.000 ms]</span><br><span class="line">[21/Sep/2021:05:03:27 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9003 200 0.000 ms 0.000 ms]</span><br><span class="line">[21/Sep/2021:05:03:28 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.000 ms 0.000 ms]</span><br><span class="line">[21/Sep/2021:05:03:29 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.001 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:05:03:30 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9003 200 0.002 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:05:03:31 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9001 200 0.001 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:05:03:31 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.000 ms 0.000 ms]</span><br><span class="line">[21/Sep/2021:05:03:32 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.001 ms 0.001 ms]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结论： 从权重上看，9001、9002 和 9003 保持配置中的值，即依次出现 2、5、3 次。从顺序上看，权重大的服务器并没有集中出现，三者轮询相对较均匀。从2轮实验结果看，每一次的轮询，某个服务器出现的顺序并不相同。  </p><p>与前面自实现平滑算法对比如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">自实现：</span><br><span class="line">2 3 1 2 2 3 2 1 3 2 </span><br><span class="line">nginx的：</span><br><span class="line">2 2 3 3 1 2 2 1 2 3</span><br><span class="line">2 1 2 3 2 2 3 1 2 2</span><br></pre></td></tr></table></figure><p>可以看到，二者还是有区别的。  </p><h4 id="ip-hash-轮询"><a href="#ip-hash-轮询" class="headerlink" title="ip_hash 轮询"></a>ip_hash 轮询</h4><p>配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream foobar &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server 127.0.0.1:9001;</span><br><span class="line">    server 127.0.0.1:9002;</span><br><span class="line">    server 127.0.0.1:9003;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为模拟不同的 IP 访问，在虚拟机、物理机以及其它的容器中发送 POST 请求，观察日志。如下：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[21/Sep/2021:06:59:55 +0000] 127.0.0.1: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.29.0&quot; [127.0.0.1:9003 200 0.002 ms 0.042 ms]</span><br><span class="line">[21/Sep/2021:06:59:55 +0000] 127.0.0.1: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.29.0&quot; [127.0.0.1:9003 200 0.001 ms 0.041 ms]</span><br><span class="line">[21/Sep/2021:06:59:56 +0000] 127.0.0.1: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.29.0&quot; [127.0.0.1:9003 200 0.001 ms 0.041 ms]</span><br><span class="line">[21/Sep/2021:07:02:20 +0000] 172.17.0.1: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.29.0&quot; [127.0.0.1:9002 200 0.001 ms 0.041 ms]</span><br><span class="line">[21/Sep/2021:07:02:23 +0000] 172.17.0.1: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.29.0&quot; [127.0.0.1:9002 200 0.001 ms 0.044 ms]</span><br><span class="line">[21/Sep/2021:07:03:20 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.001 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:07:03:21 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.001 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:07:03:22 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.000 ms 0.000 ms]</span><br><span class="line">[21/Sep/2021:07:03:22 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.001 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:07:03:54 +0000] 172.17.0.3: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.29.0&quot; [127.0.0.1:9002 200 0.000 ms 0.042 ms]</span><br><span class="line">[21/Sep/2021:07:04:07 +0000] 172.17.0.3: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.29.0&quot; [127.0.0.1:9002 200 0.002 ms 0.042 ms]</span><br><span class="line">[21/Sep/2021:07:04:08 +0000] 172.17.0.3: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.29.0&quot; [127.0.0.1:9002 200 0.002 ms 0.044 ms]</span><br><span class="line">[21/Sep/2021:07:04:42 +0000] 192.168.28.11: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.29.0&quot; [127.0.0.1:9002 200 0.001 ms 0.042 ms]</span><br><span class="line">[21/Sep/2021:07:04:49 +0000] 192.168.28.11: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.29.0&quot; [127.0.0.1:9002 200 0.001 ms 0.042 ms]</span><br><span class="line">[21/Sep/2021:07:04:50 +0000] 192.168.28.11: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.29.0&quot; [127.0.0.1:9002 200 0.002 ms 0.043 ms]</span><br></pre></td></tr></table></figure><p>结论：其中<code>127.0.0.1</code>为 nginx 所在容器的本地 IP，<code>172.17.0.3</code>是另一容器，<code>192.168.28.5</code>是物理机，<code>192.168.28.11</code>是虚拟机。从日志中看，每个源 IP 均由相同端口的服务响应。但不知为何，9001 端口服务没有被轮询到。  </p><h3 id="自定义的实验"><a href="#自定义的实验" class="headerlink" title="自定义的实验"></a>自定义的实验</h3><p>下面是一些笔者一直想做的实验。</p><h4 id="后端服务未启动访问－返回502"><a href="#后端服务未启动访问－返回502" class="headerlink" title="后端服务未启动访问－返回502"></a>后端服务未启动访问－返回502</h4><p>模拟场合：所有的后端服务均未启动，但在 nginx 配置文件中指定了后端服务。<br>nginx 访问日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[21/Sep/2021:06:43:48 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 502 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9003, 127.0.0.1:9002, 127.0.0.1:9001 502, 502, 502 0.000, 0.000, 0.001 ms 0.001 ms]</span><br></pre></td></tr></table></figure><p>curl 请求返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://192.168.28.11:8080/ -X POST -F  &quot;file=@sample.json&quot;</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100   493  100   157  100   336  78500   164k --:--:-- --:--:-- --:--:--  481k&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;502 Bad Gateway&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;502 Bad Gateway&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx/1.16.1&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>结论：返回 502，注意，访问日志中提示了所有的后端服务均返回 502，猜测 nginx已经做了一次轮询。  </p><h4 id="服务处理中突然－返回502，当次服务失败"><a href="#服务处理中突然－返回502，当次服务失败" class="headerlink" title="服务处理中突然－返回502，当次服务失败"></a>服务处理中突然－返回502，当次服务失败</h4><p>模拟场合：某服务在处理请求中突然停止服务（如出现段错误或断电）。<br>为了模拟该情况，特意实现一个 sleep 请求，该请求中延时 4 秒，以方便停止服务。<br>nginx 访问日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[21/Sep/2021:06:49:18 +0000] 192.168.28.5: &quot;POST /fee/sleep HTTP/1.1&quot; 502 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9001 502 3.035 ms 3.035 ms]</span><br></pre></td></tr></table></figure><p>可以看到，其响应处理耗时 3 秒多，因为笔者在大概 3 秒时才停止后端服务。  </p><p>curl 请求返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://192.168.28.11:8080/fee/sleep -X POST -F  &quot;file=@sample.json&quot;</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100   493  100   157  100   336     40     85  0:00:03  0:00:03 --:--:--   125&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;502 Bad Gateway&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;502 Bad Gateway&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx/1.16.1&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>结论：对于请求者而言，返回信息与上一实验相同，但在访问日志看到，只有 9001 才提示 502，但还有其它后端服务在运行，因此，再请求时，能返回正常，此时 nginx 会找正常工作的机器。  </p><h4 id="在处理中重新配置-nginx－会等待该处理完成"><a href="#在处理中重新配置-nginx－会等待该处理完成" class="headerlink" title="在处理中重新配置 nginx－会等待该处理完成"></a>在处理中重新配置 nginx－会等待该处理完成</h4><p>模拟场合：在多台后端服务中，需停止部分并升级，再启动，再升级其它的服务。<br>先将两台服务器权重扩大，如 9001 为 10， 9002 为 1，保证请求大部分转发到 9001 端口。在请求处理中，修改 nginx 配置，去掉 9001 服务，再重启 nginx。观察。  </p><p>结论：nginx 等待 9001 服务处理完请求，后续请求不再转发该服务。因此确保在处理中的请求一定能处理完毕。    </p><h4 id="设置超时响应时间"><a href="#设置超时响应时间" class="headerlink" title="设置超时响应时间"></a>设置超时响应时间</h4><p>配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    proxy_pass http://foobar;</span><br><span class="line">    proxy_set_header Host $proxy_host;</span><br><span class="line">    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_connect_timeout 1;</span><br><span class="line">    proxy_read_timeout    1;</span><br><span class="line">    proxy_send_timeout    1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注： 不知如何实验。因为是来 gin 框架实现，有对应的响应函数，一旦进入，就认为响应了，直接用前面 sleep 模式的，也不行。  </p><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><p>不能在<code>upstream</code>里面的 IP 地址加上 URL 后缀。否则提示  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx: [emerg] invalid host in upstream &quot;127.0.0.1:9001/foobar&quot; in /etc/opt/rh/rh-nginx116/nginx/nginx.conf:54</span><br></pre></td></tr></table></figure><p>可以在<code>location</code>地址添加对应的 URL，如<code>location /foobar</code>。  </p><p>为方便观察请求日志，需要设置 nginx 日志，本文配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log_format  main  &#x27;[$time_local] $remote_addr: &quot;$request&quot; &#x27;</span><br><span class="line">                  &#x27;$status &quot;$http_referer&quot; &#x27;</span><br><span class="line">                  &#x27;&quot;$http_user_agent&quot; [$upstream_addr $upstream_status $upstream_response_time ms $request_time ms]&#x27;;</span><br></pre></td></tr></table></figure><h2 id="备忘"><a href="#备忘" class="headerlink" title="备忘"></a>备忘</h2><p>是否可以用 nginx 屏蔽客户端对真实Web服务器的直接访问？好像网上还没有相关方案。  </p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>许久前，在看分布式的视频时，里面介绍了负载均衡，雪花算法，一致性哈希算法，等，让笔者大开眼界，趁着中秋佳节无法外出，集中夜晚时间研究研究，从自实现的基于请求内容的转发工具，到 nginx 的负载均衡算法，基本过了一次。至于其它的知识，暂时未有计划。  </p><p>2021.9.23 凌晨</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是nginx负载均衡实验的一些笔记。&lt;/p&gt;</summary>
    
    
    
    <category term="技术杂铺" scheme="http://www.latelee.org/category/my-study/"/>
    
    
    <category term="架构学习" scheme="http://www.latelee.org/tag/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：使用gin框架实现转发功能：一些负载均衡算法的实现</title>
    <link href="http://www.latelee.org/golang/golang-notes-print-structure.html"/>
    <id>http://www.latelee.org/golang/golang-notes-print-structure.html</id>
    <published>2021-09-22T14:01:00.000Z</published>
    <updated>2022-01-27T09:13:09.321Z</updated>
    
    <content type="html"><![CDATA[<p>近段时间需要实现一个转发 post 请求到指定后端服务的小工具，由于一直想学习 gin 框架，所以就使用这个框架进行尝试，预计会产生几篇文章。本文研究一些负载均衡算法的实现。    </p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文实现的负载均衡纯粹是为了笔者的一个念想，并不具有实际指导意义。  </p><p>本文假定有一个后端服务 URL 的数组，因此，在实现上，仅是输出数组的索引值。权重数组每个索引值对应一个后端服务。比如”1 3 3”，表示有3台服务器，第1台权重为1，第2、3台权重均为3。    </p><h2 id="算法实现及测试结果"><a href="#算法实现及测试结果" class="headerlink" title="算法实现及测试结果"></a>算法实现及测试结果</h2><p>负载均衡有很多类型，如：随机、加权随机；简单轮询、加权轮询、平滑加权轮询，等。本文仅实现几种轮询算法，并且按请求次序递增，不使用随机数。  </p><h3 id="简单轮询算法"><a href="#简单轮询算法" class="headerlink" title="简单轮询算法"></a>简单轮询算法</h3><p>算法描述：  </p><p>按请求先后轮询服务器。接收到第一次请求，转发到第1台服务器，第二次请求，转发到第2台服务器，依次类推，如果轮询到最后一台服务器，再转发第一台。  </p><p>代码：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var lb_index int = 0</span><br><span class="line"></span><br><span class="line">// 简单轮询</span><br><span class="line">func getOneServerUrlForLB_RR(exTime string) (url string) &#123;</span><br><span class="line"></span><br><span class="line">    url = &quot;&quot;</span><br><span class="line">    count := conf.TotalPort //len(conf.BackInfo)</span><br><span class="line"></span><br><span class="line">    if lb_index &gt;= count &#123;</span><br><span class="line">        lb_index = 0</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(&quot;indx: &quot;, lb_index, count)</span><br><span class="line">    url = fmt.Sprintf(&quot;http://127.0.0.1:%d&quot;, conf.BackPorts[lb_index])</span><br><span class="line">    fmt.Println(&quot;got url: &quot;, url)</span><br><span class="line"></span><br><span class="line">    lb_index += 1</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加权轮询算法"><a href="#加权轮询算法" class="headerlink" title="加权轮询算法"></a>加权轮询算法</h3><p>一个权重的示意：</p><p>3台机器（分别为A、B、C），权重分别为5，3，2。排列（注：按设置的权重先后列出）：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   5       3    2</span><br><span class="line">1       5     8   10</span><br><span class="line">| ----- | --- | -- |</span><br><span class="line">   A       B     C</span><br></pre></td></tr></table></figure><p>某一区间大，表示该服务器的权重大。<br>设一数，其值在1~10之间，即范围在权重总和之内，依次与5、3、2对比，如小则在该区间，如大，则减去前一数，再比对。看落到哪个区域。<br>举例：<br>设该数为3，与5对比，小，则落到第1区间，即选择服务器 A。<br>设该数为7，与5对比，大，取下一区间，即减去5，得2，与3对比，小，则落到第2区间，即选择服务器 B。<br>设该数为9，与5对比，大，减去5得4，与3对比，大，减去3得1，与2对比，小，第3区间，即选择服务器 C。  </p><p>注意，我们关注的是某个区间出现的次数，并不关注是哪一个索引。以轮询 10 次为例，只要保证A、B、C服务器分别访问了5、3、2次即可。最简单的算法，就是将这次 10 次依次分配到A、B、C服务器。  </p><p>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">测试用，假定有3组IP，每组分配好权重，根据请求顺序，按权重分配</span></span><br><span class="line"><span class="comment">可以认为，IP总数为权重总值，只是部分重复了，所以请求循环的次数就是权重总值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 因为测试，所以直接赋值，测试的总数不超过 conf.TotalPort</span></span><br><span class="line"><span class="comment">// conf.Weights 示例：[3]int&#123;2, 5, 3&#125;， 数组索引0表示第1个后端，1表示第2个后端</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIndex_WRR</span><span class="params">(offset <span class="keyword">int</span>, totalWeight <span class="keyword">int</span>)</span> <span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不指定，使用随机</span></span><br><span class="line">    <span class="keyword">if</span> offset == <span class="number">-1</span> &#123;</span><br><span class="line">        rand.Seed(time.Now().UnixNano())</span><br><span class="line">        offset = rand.Int() % totalWeight</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fmt.Println(&quot;total: &quot;, totalWeight, offset)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注：这里关注的是某个索引值的次数，与顺序无关</span></span><br><span class="line">    <span class="keyword">for</span> index, w := <span class="keyword">range</span> conf.Weights &#123;</span><br><span class="line">        <span class="keyword">if</span> offset &lt; w &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">        offset -= w</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getOneServerUrlForLB_WRR</span><span class="params">(exTime <span class="keyword">string</span>)</span> <span class="params">(url <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    url = <span class="string">&quot;&quot;</span></span><br><span class="line">    count := conf.TotalPort</span><br><span class="line"></span><br><span class="line">    totalWeight := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, w := <span class="keyword">range</span> conf.Weights &#123;</span><br><span class="line">        totalWeight += w</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    count = totalWeight <span class="comment">// 注：按权重总数轮询</span></span><br><span class="line">    <span class="keyword">if</span> lb_index &gt;= count &#123;</span><br><span class="line">        lb_index = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    new_lb_index := getIndex_WRR(lb_index, totalWeight)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lb_index == <span class="number">100</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;indx: &quot;</span>, lb_index, new_lb_index, count)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d &quot;</span>, new_lb_index)</span><br><span class="line"></span><br><span class="line">    url = fmt.Sprintf(<span class="string">&quot;http://127.0.0.1:%d&quot;</span>, conf.BackPorts[new_lb_index])</span><br><span class="line">    fmt.Println(<span class="string">&quot;got url: &quot;</span>, url)</span><br><span class="line"></span><br><span class="line">    lb_index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./httpforward.exe -w &quot;5 3 2&quot;</span><br><span class="line">0 0 0 0 0 1 1 1 2 2 0 0 0 0 0 1 1 1 2 2</span><br><span class="line"></span><br><span class="line">./httpforward.exe -w &quot;1 3 3&quot;</span><br><span class="line">0 1 1 1 2 2 2 0 1 1 1 2 2 2</span><br><span class="line"></span><br><span class="line">./httpforward.exe -w &quot;5 3 1&quot;</span><br><span class="line">0 0 0 0 0 1 1 1 2 0 0 0 0 0 1 1 1 2</span><br></pre></td></tr></table></figure><p>为了数据可靠，轮询了2遍，下同。  </p><h3 id="平滑加权轮询算法"><a href="#平滑加权轮询算法" class="headerlink" title="平滑加权轮询算法"></a>平滑加权轮询算法</h3><p>上述算法并不考虑服务器处理在效率，比如前面5次均在A服务器，其它服务器均为空闲状态，由此引出平滑加权轮询算法。笔者暂未参透该算法的证明过程，因此本文不涉及。  </p><p>设置如下变量：<br>总权重值：totalWeight，其值固定。<br>固定权重数组：Weights，其值固定。<br>当前权重数组 CurrentWeights，其值可变。<br>当前权重数组最大值 maxWeight，CurrentWeights数组的最大值。  </p><p>算法步骤：<br>0、某次请求到来。<br>1、判断当前权重数组（对应下表<strong>当前权重1</strong>）值是否全为0，如是，则用固定权重初始化之。<br>2、查获当前权重数组，获取最大值，对应的索引，即为需要返回的服务器。<br>3、将第2步的索引对应的值，减去权重总和，其它索引的值保持不变。（对应下表<strong>当前权重2</strong>）<br>4、 将第3步得到的当前权重数组的每个值，加上对应的固定权重值。<br>5、回到第1步，重复。  </p><p>假定有3台服务器A、B、C，其权重依次为 5、1、1，权重总和为7。演算过程如下：     </p><p>初始时，当前权重为[0,0,0]，则用固定权重[5,1,1]初始化之。<br>此时，最大值为5，索引为0，返回服务器A。<br>将[5,1,1]的索引0值减去权重总和7，得到[-2,1,1]。<br>将[-2,1,1]加上[5,1,1]，得到新的当前权重[3,2,2]。<br>此时，最大值为3，索引为0，返回服务器A。<br>将[3,2,2]的索引0值减去权重总和7，得到[-4,2,2]。<br>将[-4,2,2]加上[5,1,1]，得到新的当前权重[1,3,3]。<br>（下略）  </p><p>总体过程如下表：  </p><table><thead><tr><th>请求次数</th><th>当前权重1</th><th>返回服务器</th><th>当前权重2</th></tr></thead><tbody><tr><td>0</td><td>[0, 0,0]</td><td>－－</td><td>初始化为[5, 1, 1]</td></tr><tr><td>1</td><td>[5, 1, 1]</td><td>A</td><td>[-2, 1, 1]</td></tr><tr><td>2</td><td>[3, 2, 2]</td><td>A</td><td>[-4, 2, 2]</td></tr><tr><td>3</td><td>[1, 3, 3]</td><td>B</td><td>[1, -4, 3]</td></tr><tr><td>4</td><td>[6, -3, 4]</td><td>A</td><td>[-1, -3, 4]</td></tr><tr><td>5</td><td>[4, -2, 5]</td><td>C</td><td>[4, -2, -2]</td></tr><tr><td>6</td><td>[9, -1, -1]</td><td>A</td><td>[2, -1, -1]</td></tr><tr><td>7</td><td>[7, 0, 0]</td><td>A</td><td>[0, 0, 0]</td></tr><tr><td>8</td><td>[5, 1, 1]</td><td>A</td><td>[-2, 1, 1]</td></tr></tbody></table><p>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 平滑加权</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIndex_SWRR</span><span class="params">(offset <span class="keyword">int</span>, totalWeight <span class="keyword">int</span>)</span> <span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    initflag := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0.判断是否全为0</span></span><br><span class="line">    <span class="keyword">for</span> _, w := <span class="keyword">range</span> conf.CurrentWeights &#123;</span><br><span class="line">        <span class="keyword">if</span> w == <span class="number">0</span> &#123;</span><br><span class="line">            initflag++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全为0，则需要初始化</span></span><br><span class="line">    <span class="keyword">if</span> initflag == <span class="built_in">len</span>(conf.CurrentWeights) &#123;</span><br><span class="line">        <span class="keyword">for</span> idx, w := <span class="keyword">range</span> conf.Weights &#123;</span><br><span class="line">            conf.CurrentWeights[idx] = w</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 查询当前权重表最大者，并取该索引，即为所需结果</span></span><br><span class="line">    maxWeight := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> idx, w := <span class="keyword">range</span> conf.CurrentWeights &#123;</span><br><span class="line">        <span class="keyword">if</span> w &gt; maxWeight &#123;</span><br><span class="line">            maxWeight = w</span><br><span class="line">            index = idx</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 最大的那个权重，其值减去总权重</span></span><br><span class="line">    conf.CurrentWeights[index] = maxWeight - totalWeight</span><br><span class="line">    <span class="comment">// fmt.Println(&quot;current222: &quot;, conf.CurrentWeights)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 新的当前权重，所对应的值加上初始权重</span></span><br><span class="line">    <span class="comment">// 为下次循环计算打下基础</span></span><br><span class="line">    <span class="keyword">for</span> idx, w := <span class="keyword">range</span> conf.Weights &#123;</span><br><span class="line">        conf.CurrentWeights[idx] += w</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getOneServerUrlForLB_SWRR</span><span class="params">(exTime <span class="keyword">string</span>)</span> <span class="params">(url <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    url = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    totalWeight := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, w := <span class="keyword">range</span> conf.Weights &#123;</span><br><span class="line">        totalWeight += w</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注：按权重总数轮询</span></span><br><span class="line">    <span class="keyword">if</span> lb_index &gt;= totalWeight &#123;</span><br><span class="line">        lb_index = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    new_lb_index := getIndex_SWRR(lb_index, totalWeight)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lb_index == <span class="number">100</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;indx1: &quot;</span>, lb_index, new_lb_index, totalWeight)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d &quot;</span>, new_lb_index)</span><br><span class="line">    url = fmt.Sprintf(<span class="string">&quot;http://127.0.0.1:%d&quot;</span>, conf.BackPorts[new_lb_index])</span><br><span class="line">    <span class="comment">//fmt.Println(&quot;got url: &quot;, url)</span></span><br><span class="line"></span><br><span class="line">    lb_index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">./httpforward.exe -w &quot;5 1 1&quot;</span><br><span class="line">0 0 1 0 2 0 0 0 0 1 0 2 0 0 </span><br><span class="line"></span><br><span class="line">./httpforward.exe -w &quot;1 3 3&quot;</span><br><span class="line">1 2 0 1 2 1 2 1 2 0 1 2 1 2</span><br><span class="line"></span><br><span class="line">./httpforward.exe -w &quot;5 3 1&quot;</span><br><span class="line">0 1 0 2 0 1 0 1 0 0 1 0 2 0 1 0 1 0 </span><br><span class="line"></span><br><span class="line">./httpforward.exe -w &quot;2 5 3&quot;</span><br><span class="line">1 2 0 1 1 2 1 0 2 1 1 2 0 1 1 2 1 0 2 1</span><br></pre></td></tr></table></figure><p>从结果上看，权重保持着比例，但响应的服务器分布较平衡，即不会出现权重大的服务器集中处理请求的情况。某次测试 nginx 的负载均衡，似乎默认便是此种方法，但算法实现不同，测试发现，在保持权重比例情况下，不同的服务器出现的顺序不同，未深究原因。  </p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文主要根据网络的相关资料整理并用 golang 代码实现负载均衡部分算法。  </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/wsw-seu/p/11336634.html">https://www.cnblogs.com/wsw-seu/p/11336634.html</a><br><a href="https://juejin.cn/post/6844903793012768781">https://juejin.cn/post/6844903793012768781</a>  </p><p>李迟 2021.9.22 晚</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;近段时间需要实现一个转发 post 请求到指定后端服务的小工具，由于一直想学习 gin 框架，所以就使用这个框架进行尝试，预计会产生几篇文章。本文研究一些负载均衡算法的实现。    &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：使用gin框架实现转发功能：利用nginx转发</title>
    <link href="http://www.latelee.org/golang/golang-notes-print-structure.html"/>
    <id>http://www.latelee.org/golang/golang-notes-print-structure.html</id>
    <published>2021-09-19T18:01:00.000Z</published>
    <updated>2022-01-27T09:13:09.321Z</updated>
    
    <content type="html"><![CDATA[<p>近段时间需要实现一个转发 post 请求到指定后端服务的小工具，由于一直想学习 gin 框架，所以就使用这个框架进行尝试，预计会产生几篇文章。本文研究如何利用 nginx 容器和后端服务进行转发工具的测试。    </p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>转发的工具实现起来比较简单，但为了验证，还需要使用其它工具配合，本文自编后端程序，并使用 nginx 实现多个后端程序的转发。<br>为方便理解，下面给出示例图。<br>不使用 nginx 实现转发如下图所示：<br><img src="/golang/golang-notes-print-structure/1.png"></p><p>使用 nginx 实现转发如下图所示：<br><img src="/golang/golang-notes-print-structure/2.png"></p><p>注1：两个图片相近，注意图中 URL 的变化。<br>注2：在本文中，客户端可以跨过 nginx 直接访问后端的服务，在实际中似乎不太好，因只做演示，故不再深入考虑。  </p><h2 id="后端服务"><a href="#后端服务" class="headerlink" title="后端服务"></a>后端服务</h2><p>前面文章已经实现了简单的后端服务响应函数，此处不再列出。需要注意的是，因本系列转发和后端均用同一套代码，如果要在程序中启动后端服务，必须修改后端服务可执行文件名称，参考前文代码。  </p><h2 id="nginx容器启动及重启"><a href="#nginx容器启动及重启" class="headerlink" title="nginx容器启动及重启"></a>nginx容器启动及重启</h2><p>本文使用镜像<code>centos/nginx-116-centos7</code>进行测试。简单启动如下：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name nginx -p 8080:8080 -v $PWD:/opt/bin centos/nginx-116-centos7 bash</span><br></pre></td></tr></table></figure><p>实践中使用<code>docker-compose</code>启动，docker-compose.yml文件如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;2&#x27;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  nginx:</span><br><span class="line">    image: centos/nginx-116-centos7</span><br><span class="line">    container_name: nginx</span><br><span class="line">    command: /bin/bash -c &quot;/home/latelee/bin/run.sh&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - $PWD/bin:/home/latelee/bin</span><br><span class="line">      - $PWD/nginx/log:/var/opt/rh/rh-nginx116/log/nginx</span><br><span class="line">      - $PWD/nginx/etc:/etc/nginx</span><br><span class="line">      - /etc/localtime:/etc/localtime</span><br><span class="line">    #environment:</span><br><span class="line">    #  - ORACLE_HOME=/work/instantclient_12_1</span><br><span class="line">    #  - TNS_ADMIN=$ORACLE_HOME</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:8080</span><br><span class="line">      - 8090:8090</span><br></pre></td></tr></table></figure><p>注：后端服务程序（和启动脚本）以及 nginx 配置文件均放到主机目录，因为这样更容易更新。</p><p>为了在容器启动时运行自定义的命令，需要关闭 nginx 服务的后台执行，启动脚本 run.sh 内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">echo &quot;run...&quot;</span><br><span class="line">cd /home/latelee/bin</span><br><span class="line"></span><br><span class="line">nginx -g &quot;daemon off;&quot;&amp;</span><br><span class="line"></span><br><span class="line">sleep 1</span><br><span class="line">./httpforward.exe -p 8090 </span><br></pre></td></tr></table></figure><p>关于在容器中启动 nginx 的方法，官方 docker 有介绍：   </p><blockquote><p>If you add a custom CMD in the Dockerfile, be sure to include -g daemon off; in the CMD in order for nginx to stay in the foreground, so that Docker can track the process properly (otherwise your container will stop immediately after starting)!  </p></blockquote><p>大意是说，当我们自定义启动命令时，必须添加<code>-g daemon off</code>，否则自定义命令启动完毕后，容器就会自动退出。  </p><p>启动容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>查看日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose logs -f</span><br></pre></td></tr></table></figure><p>默认情况下 nginx 已经启动了。如果修改了配置。可以重启容器，也可以在容器内重启，重启命令为<code>nginx -s reload</code>。<code>nginx -s</code>仅支持4个参数：<code>stop, quit, reopen, reload</code>，官方文档将其称为信号（signal）。如果执行<code>nginx -s stop</code>停止 nginx，再次重启，会提示<code>nginx: [error] open() &quot;/var/opt/rh/rh-nginx116/run/nginx/nginx.pid&quot; failed (2: No such file or directory)</code>。因此，修改 nginx 配置后，使用<code>reload</code>即可。  </p><h2 id="nginx-转发的一些测试"><a href="#nginx-转发的一些测试" class="headerlink" title="nginx 转发的一些测试"></a>nginx 转发的一些测试</h2><p>在笔者环境中，不论在容器内，还是在物理机，nginx 配置文件为<code>/etc/nginx/nginx.conf</code>（注：实际，nginx 还会读取<code>/etc/nginx/conf.d</code>目录，但不在本文讨论范围），修改该文件后，必须执行<code>nginx -s reload</code>重启 nginx。<br>对于 location 的配置，一般如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location /fee/9000 &#123;</span><br><span class="line">        proxy_pass http://127.0.0.1:9000;</span><br><span class="line">        proxy_set_header Host $proxy_host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送到 nginx 服务器的请求，如果 URL 为<code>/fee/9000</code>，则转发到本地的 9000 端口的服务。（注：<code>/fee/9000</code>还可以继续添加后缀 URL，但不是本次讨论的范围），其它转发类似。<br>经测试，直接用<code>proxy_pass</code>字段指定后端服务地址即可。如下：    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /fee/9000 &#123;</span><br><span class="line">        proxy_pass http://127.0.0.1:9000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试中发现，当使用上述转发规则时，后端程序必须实现<code>/fee/9000</code>的响应，即在容器中能正常请求<code>http://127.0.0.1:9000/fee/9000</code>。如果不实现，会提示 404。而本文的后端不能响应带后缀的URL。    </p><p>经查，在后端程序 URL 后添加斜杠<code>/</code>可解决问题，如下：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /fee/9000 &#123;</span><br><span class="line">        proxy_pass http://127.0.0.1:9000/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两者对比如下：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">不加斜杠：http://127.0.0.1:8080/fee/9000  --&gt; http://127.0.0.1:9000/fee/9000</span><br><span class="line">添加斜杠：http://127.0.0.1:8080/fee/9000  --&gt; http://127.0.0.1:9000/</span><br><span class="line"></span><br><span class="line">添加斜杠的扩展：http://127.0.0.1:8080/fee/9000/foo  --&gt; http://127.0.0.1:9000/foo</span><br></pre></td></tr></table></figure><p>对于笔者的应用，请求后端程序的URL必须是<code>http://127.0.0.1:9000/</code>的形式，不能再额外添加后缀，由于对 nginx 研究未深，暂不展开讨论。  </p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>请求命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://192.168.28.11:8090/fee/test -X POST -F  &quot;file=@sample.json&quot;</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100   434  100    98  100   336   3920  13440 --:--:-- --:--:-- --:--:-- 18083&#123;&quot;code&quot;:0,&quot;data&quot;:&#123;&quot;result&quot;:&quot;ok in back end server, port: 9001 info: run in port 9001&quot;&#125;,&quot;msg&quot;:&quot;ok&quot;&#125;</span><br></pre></td></tr></table></figure><p>转发工具：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx    | got url:  http://127.0.0.1:8080/fee/9001</span><br><span class="line">nginx    | [GIN] 2021/09/14 - 01:32:17 | 200 |   10.002826ms |    192.168.28.5 | POST     &quot;/fee/test&quot;</span><br></pre></td></tr></table></figure><p>nginx 日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">==&gt; nginx/log/access.log &lt;==</span><br><span class="line">127.0.0.1 - - [14/Sep/2021:01:32:17 +0800] &quot;POST /fee/9001 HTTP/1.1&quot; 200 98 &quot;-&quot; &quot;Go-http-client/1.1&quot; &quot;-&quot;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文中，自编的转发工具要管理和配置后端程序以及 nginx，即启动若干后端程序，根据规则分配端口号（从9000开始）和 URL，将其写到 nginx 配置文件，最后重启 nginx 服务。——当然，这些都是使用较简单的方法。<br>在启动后端程序中，由于笔者使用相同的代码，因此花了一些时间排查问题。<br>在测试 nginx 转发 URL 时，也花了较多的时间（前后大概2个深夜的时间）。  </p><p>在后续中，笔者将研究如何自实现负载均衡算法。——计划做此事已了大半年，趁此机会抽点时间搞下。  </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>关于转发 URL 的讨论 <a href="https://stackoverflow.com/questions/42997684/nginx-on-docker-doesnt-work-with-location-url">https://stackoverflow.com/questions/42997684/nginx-on-docker-doesnt-work-with-location-url</a><br>nginx镜像：  <a href="https://hub.docker.com/_/nginx">https://hub.docker.com/_/nginx</a>  </p><p>李迟 2021.9.19 凌晨</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;近段时间需要实现一个转发 post 请求到指定后端服务的小工具，由于一直想学习 gin 框架，所以就使用这个框架进行尝试，预计会产生几篇文章。本文研究如何利用 nginx 容器和后端服务进行转发工具的测试。    &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：使用gin框架实现转发功能：管理后端服务启动</title>
    <link href="http://www.latelee.org/golang/golang-notes-gin-httpforward1.html"/>
    <id>http://www.latelee.org/golang/golang-notes-gin-httpforward1.html</id>
    <published>2021-09-18T15:51:00.000Z</published>
    <updated>2022-01-27T09:13:09.321Z</updated>
    
    <content type="html"><![CDATA[<p>近段时间需要实现一个转发 post 请求到指定后端服务的小工具，由于一直想学习 gin 框架，所以就使用这个框架进行尝试，预计会产生几篇文章。本文研究如何管理后端服务。  </p><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在启动 gin 服务前，先启动所有的后端服务进程，并且分配好端口，为简单起见，本文根据请求时间带的月份来转发，后端服务端口从 9000 开始。因此，需启动 13 个服务，端口从 9000 到 9012，如请求时间为9月份，则转发到 9009 端口的服务，对于非法月份，则统一转发到 9000 端口。   </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>添加<code>/</code>的响应，主要是为了后续方便使用 nginx。  </li><li>分配好端口，启动后端服务。</li><li>根据请求时间选择一个后端 URL。  </li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="主要接口代码"><a href="#主要接口代码" class="headerlink" title="主要接口代码"></a>主要接口代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">func RunWebServer(args []string) &#123;</span><br><span class="line">    runWebOnlyPost()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func runWebOnlyPost() &#123;</span><br><span class="line">    </span><br><span class="line">    // 先执行其它业务，再到http</span><br><span class="line">    restartAll()</span><br><span class="line"></span><br><span class="line">truerouter := gin.New()</span><br><span class="line">truerouter.Use(gin.Logger())</span><br><span class="line">truerouter.Use(gin.Recovery())</span><br><span class="line"></span><br><span class="line">truetestRouter(router)</span><br><span class="line"></span><br><span class="line">trueklog.Println(&quot;Server started at &quot;, conf.Port)</span><br><span class="line">truerouter.Run(&quot;:&quot; + conf.Port)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func testRouter(r *gin.Engine) &#123;</span><br><span class="line">truefmt.Println(&quot;test post...&quot;)</span><br><span class="line">    </span><br><span class="line">    r.POST(&quot;/foobar/test&quot;, foobar_test)</span><br><span class="line">    r.POST(&quot;/foobar/test_back&quot;, foobar_test_back)</span><br><span class="line">    // 注：此处直接响应端口的访问，因为实际中使用nginx转发的</span><br><span class="line">truer.POST(&quot;/&quot;, fee_test_back)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上一版本基础上添加<code>restartAll</code>函数。下面给出实现。  </p><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><p><code>restartAll</code>函数实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">停止后端服务（如有），</span><br><span class="line">启动后端服务，同时分配端口</span><br><span class="line">*/</span><br><span class="line">func restartAll() &#123;</span><br><span class="line">true// 通过端口限定，仅作测试</span><br><span class="line">truethePort, _ := strconv.Atoi(conf.Port)</span><br><span class="line">trueif thePort &gt;= 9000 &#123;</span><br><span class="line">truetruereturn</span><br><span class="line">true&#125;</span><br><span class="line">trueklog.Println(&quot;restartAll...&quot;)</span><br><span class="line"></span><br><span class="line">trueappname := &quot;./httpforward_back&quot;</span><br><span class="line"></span><br><span class="line">trueklog.Printf(&quot;try to kill backend server %s\n&quot;, appname[2:])</span><br><span class="line">true// exec.Command(&quot;sh&quot;, &quot;-c&quot;, fmt.Sprintf(&quot;pkill -SIGINT %s&quot;, appname[2:])).Output()</span><br><span class="line">trueexec.Command(&quot;sh&quot;, &quot;-c&quot;, fmt.Sprintf(&quot;killall %s&quot;, appname[2:])).Output()</span><br><span class="line"></span><br><span class="line">true// os.Exit(0)</span><br><span class="line">true// 假定有12个端口，即12个后端服务，但额外有一个防止出错的端口</span><br><span class="line">truestartport := 9000</span><br><span class="line">trueconf.BackPorts = []int&#123;&#125;</span><br><span class="line">truefor i := 0; i &lt; 13; i++ &#123;</span><br><span class="line">truetrueport := startport + i</span><br><span class="line">truetrueklog.Println(&quot;run in port: &quot;, port)</span><br><span class="line">truetrueconf.BackPorts = append(conf.BackPorts, port)</span><br><span class="line">truetrue// note：使用系自带的接口，只启动，不等待，必须用&#x27;sh -c&#x27;格式，且不能合并</span><br><span class="line">truetruecmd := exec.Command(&quot;sh&quot;, &quot;-c&quot;, fmt.Sprintf(&quot;%s -p %d -i \&quot;run in port %d\&quot; &amp;&quot;, appname, port, port))</span><br><span class="line">truetrueerr := cmd.Start()</span><br><span class="line">truetrueif err != nil &#123;</span><br><span class="line">truetruetrueklog.Printf(&quot;!! NOTE !! server on port %d start failed: %v\n&quot;, port, err.Error())</span><br><span class="line">truetrue&#125;</span><br><span class="line">true&#125;</span><br><span class="line">truefmt.Printf(&quot;run %d backend server ok\n&quot;, len(conf.BackPorts))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>转发实现函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">func foobar_test(ctx *gin.Context) &#123;</span><br><span class="line"></span><br><span class="line">true// 2种方式都可，但 ctx.Request.FormFile 可以得到文件句柄，可直接拷贝</span><br><span class="line">true//file, err := ctx.FormFile(&quot;file&quot;)</span><br><span class="line">truefile, header, err := ctx.Request.FormFile(&quot;file&quot;)</span><br><span class="line">trueif err != nil &#123;</span><br><span class="line">truetruectx.JSON(http.StatusBadRequest, gin.H&#123;</span><br><span class="line">truetruetrue&quot;error&quot;: err,</span><br><span class="line">truetrue&#125;)</span><br><span class="line">truetruereturn</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">true// 拿到文件和长度，后面使用到</span><br><span class="line">truevar jsonfilename string = header.Filename</span><br><span class="line">truemysize := header.Size</span><br><span class="line">truefmt.Printf(&quot;filename: %s size: %d\n&quot;, jsonfilename, mysize)</span><br><span class="line"></span><br><span class="line">trueif err != nil &#123;</span><br><span class="line">truetruectx.JSON(http.StatusBadRequest, gin.H&#123;</span><br><span class="line">truetruetrue&quot;error&quot;: err,</span><br><span class="line">truetrue&#125;)</span><br><span class="line">truetruereturn</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">true// 处理json文件</span><br><span class="line">truejsonbuf := make([]byte, mysize)</span><br><span class="line">true_, err = file.Read(jsonbuf)</span><br><span class="line">true// 注：读取了文件，要回到文件头，否则就没有内容了，因此这里用seek</span><br><span class="line">truefile.Seek(0, 0)</span><br><span class="line"></span><br><span class="line">truevar data map[string]interface&#123;&#125;</span><br><span class="line">trueerr = json.Unmarshal(jsonbuf, &amp;data)</span><br><span class="line">true//fmt.Println(&quot;unmarshal: &quot;, err, data)</span><br><span class="line"></span><br><span class="line">truevar exTime string</span><br><span class="line">trueexTime1 := data[&quot;exTime&quot;]</span><br><span class="line">true// 如果出口时间没有，出错</span><br><span class="line">trueif exTime1 == nil &#123;</span><br><span class="line">truetruefmt.Println(&quot;exTime not found!&quot;)</span><br><span class="line"></span><br><span class="line">truetruectx.JSON(</span><br><span class="line">truetruetruehttp.StatusOK,</span><br><span class="line">truetruetruegin.H&#123;</span><br><span class="line">truetruetruetrue&quot;code&quot;: -1,</span><br><span class="line">truetruetruetrue&quot;msg&quot;:  &quot;failed&quot;,</span><br><span class="line">truetruetruetrue&quot;data&quot;: gin.H&#123;</span><br><span class="line">truetruetruetruetrue&quot;result&quot;: &quot;exTime not found&quot;,</span><br><span class="line">truetruetruetrue&#125;,</span><br><span class="line">truetruetrue&#125;,</span><br><span class="line">truetrue)</span><br><span class="line">truetruereturn</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">trueexTime = exTime1.(string)</span><br><span class="line">true// exTime不合法</span><br><span class="line">trueif len(exTime) == 0 &#123;</span><br><span class="line">truetruectx.JSON(</span><br><span class="line">truetruetruehttp.StatusOK,</span><br><span class="line">truetruetruegin.H&#123;</span><br><span class="line">truetruetruetrue&quot;code&quot;: -1,</span><br><span class="line">truetruetruetrue&quot;msg&quot;:  &quot;failed&quot;,</span><br><span class="line">truetruetruetrue&quot;data&quot;: gin.H&#123;</span><br><span class="line">truetruetruetruetrue&quot;result&quot;: &quot;exTime is empty&quot;,</span><br><span class="line">truetruetruetrue&#125;,</span><br><span class="line">truetruetrue&#125;,</span><br><span class="line">truetrue)</span><br><span class="line"></span><br><span class="line">truetruereturn</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">truefmt.Printf(&quot;exTime: %s\n&quot;, exTime)</span><br><span class="line"></span><br><span class="line">true// 此处选择一个URL</span><br><span class="line"></span><br><span class="line">trueurl := getOneServerUrl(exTime)</span><br><span class="line">true// 返回空，可能后端服务未启动或内部错误</span><br><span class="line">trueif len(url) == 0 &#123;</span><br><span class="line">truetruectx.JSON(</span><br><span class="line">truetruetruehttp.StatusOK,</span><br><span class="line">truetruetruegin.H&#123;</span><br><span class="line">truetruetruetrue&quot;code&quot;: -1,</span><br><span class="line">truetruetruetrue&quot;msg&quot;:  &quot;failed&quot;,</span><br><span class="line">truetruetruetrue&quot;data&quot;: gin.H&#123;</span><br><span class="line">truetruetruetruetrue&quot;result&quot;: &quot;ant get backend server url&quot;,</span><br><span class="line">truetruetruetrue&#125;,</span><br><span class="line">truetruetrue&#125;,</span><br><span class="line">truetrue)</span><br><span class="line"></span><br><span class="line">truetruereturn</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">trueresp, err := post_data_gin(url, jsonfilename, file)</span><br><span class="line">true// 返回空，可能后端服务未启动或内部错误</span><br><span class="line">trueif len(resp) == 0 &#123;</span><br><span class="line">truetruectx.JSON(</span><br><span class="line">truetruetruehttp.StatusOK,</span><br><span class="line">truetruetruegin.H&#123;</span><br><span class="line">truetruetruetrue&quot;code&quot;: -1,</span><br><span class="line">truetruetruetrue&quot;msg&quot;:  &quot;failed&quot;,</span><br><span class="line">truetruetruetrue&quot;data&quot;: gin.H&#123;</span><br><span class="line">truetruetruetruetrue&quot;result&quot;: fmt.Sprintf(&quot;backend server error: %s&quot;, err.Error()), //&quot;backend server error: &quot; + err.Error(),</span><br><span class="line">truetruetruetrue&#125;,</span><br><span class="line">truetruetrue&#125;,</span><br><span class="line">truetrue)</span><br><span class="line"></span><br><span class="line">truetruereturn</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">true// 解析返回字符切片，得到map，当成json，赋值给gin</span><br><span class="line">truevar data1 map[string]interface&#123;&#125;</span><br><span class="line">trueerr = json.Unmarshal(resp, &amp;data1)</span><br><span class="line">true//fmt.Println(&quot;muti unmarshal: &quot;, err, data1)</span><br><span class="line"></span><br><span class="line">truectx.JSON(http.StatusOK, data1)</span><br><span class="line"></span><br><span class="line">truereturn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getOneServerUrl</code>函数实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">// 根据时间选择一个后端服务器URL</span><br><span class="line">func getOneServerUrl(exTime string) (url string) &#123;</span><br><span class="line">trueurl = &quot;&quot;</span><br><span class="line">trueif len(exTime) == 0 &#123;</span><br><span class="line">truetruereturn</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">true// 时间有2个格式，这里都判断一下</span><br><span class="line">truemytime, _ := time.Parse(&quot;2006-01-02T15:04:05&quot;, exTime)</span><br><span class="line">truethemonth := int(mytime.Month())</span><br><span class="line">true// 如果不合法，年月日均为1</span><br><span class="line">trueif mytime.Year() == 1 &amp;&amp; themonth == 1 &amp;&amp; mytime.Day() == 1 &#123;</span><br><span class="line">truetruemytime, _ = time.Parse(&quot;2006-01-02 15:04:05&quot;, exTime)</span><br><span class="line">truetrue// 还是不合法</span><br><span class="line">truetrueif mytime.Year() == 1 &amp;&amp; themonth == 1 &amp;&amp; mytime.Day() == 1 &#123;</span><br><span class="line">truetruetruethemonth = 0</span><br><span class="line">truetrue&#125; else &#123;</span><br><span class="line">truetruetruethemonth = int(mytime.Month())</span><br><span class="line">truetrue&#125;</span><br><span class="line">true&#125;</span><br><span class="line">trueif themonth &gt;= len(conf.BackPorts) &#123;</span><br><span class="line">truetruethemonth = 0</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">trueurl = fmt.Sprintf(&quot;http://127.0.0.1:%d&quot;, conf.BackPorts[themonth])</span><br><span class="line">truefmt.Println(&quot;got url: &quot;, url)</span><br><span class="line"></span><br><span class="line">truereturn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> 模拟后台的仅获取file字段的json，不作其它处理</span><br><span class="line"> curl http://127.0.0.1:84/foobar/test_back -X POST -F  &quot;file=@sample.json&quot;</span><br><span class="line">*/</span><br><span class="line">func foobar_test_back(ctx *gin.Context) &#123;</span><br><span class="line">true// 2种方式都可，但 ctx.Request.FormFile 可以得到文件句柄，可直接拷贝</span><br><span class="line">true//file, err := ctx.FormFile(&quot;file&quot;)</span><br><span class="line">truefile, header, err := ctx.Request.FormFile(&quot;file&quot;)</span><br><span class="line">trueif err != nil &#123;</span><br><span class="line">truetruectx.JSON(</span><br><span class="line">truetruetruehttp.StatusBadRequest,</span><br><span class="line">truetruetruegin.H&#123;</span><br><span class="line">truetruetruetrue&quot;code&quot;: -1,</span><br><span class="line">truetruetruetrue&quot;msg&quot;:  &quot;failed&quot;,</span><br><span class="line">truetruetruetrue&quot;data&quot;: gin.H&#123;</span><br><span class="line">truetruetruetruetrue&quot;result&quot;: &quot;failed in back end server, port:&quot; + conf.Port,</span><br><span class="line">truetruetruetrue&#125;,</span><br><span class="line">truetruetrue&#125;,</span><br><span class="line">truetrue)</span><br><span class="line"></span><br><span class="line">truetruereturn</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">true// 拿到文件和长度，后面使用到</span><br><span class="line">truevar myfile string = header.Filename</span><br><span class="line">truemysize := header.Size</span><br><span class="line">truefmt.Printf(&quot;filename: %s size: %d\n&quot;, myfile, mysize)</span><br><span class="line"></span><br><span class="line">trueif mysize &lt;= 0 &#123;</span><br><span class="line">truetruectx.JSON(</span><br><span class="line">truetruetruehttp.StatusBadRequest,</span><br><span class="line">truetruetruegin.H&#123;</span><br><span class="line">truetruetruetrue&quot;code&quot;: -1,</span><br><span class="line">truetruetruetrue&quot;msg&quot;:  &quot;failed&quot;,</span><br><span class="line">truetruetruetrue&quot;data&quot;: gin.H&#123;</span><br><span class="line">truetruetruetruetrue&quot;result&quot;: &quot;failed in back end server, json size 0, port: &quot; + conf.Port,</span><br><span class="line">truetruetruetrue&#125;,</span><br><span class="line">truetruetrue&#125;,</span><br><span class="line">truetrue)</span><br><span class="line"></span><br><span class="line">truetruereturn</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">true// 此处可保存文件</span><br><span class="line"></span><br><span class="line">true/////////////////////////////////////////</span><br><span class="line">true// 处理json文件</span><br><span class="line">truejsonbuf := make([]byte, mysize)</span><br><span class="line">true_, err = file.Read(jsonbuf)</span><br><span class="line">true// 注：读取了文件，要回到文件头，否则就没有内容了，因此这里用seek</span><br><span class="line">truefile.Seek(0, 0)</span><br><span class="line">true//fmt.Printf(&quot;read %d %v\n%v\n&quot;, n, err, string(jsonbuf));</span><br><span class="line"></span><br><span class="line">truevar data map[string]interface&#123;&#125;</span><br><span class="line">trueerr = json.Unmarshal(jsonbuf, &amp;data)</span><br><span class="line">true//fmt.Println(&quot;unmarshal: &quot;, err, data)</span><br><span class="line"></span><br><span class="line">truevar exTime string</span><br><span class="line">trueexTime1 := data[&quot;exTime&quot;]</span><br><span class="line">true// 如果出口时间没有，出错</span><br><span class="line">trueif exTime1 == nil &#123;</span><br><span class="line">truetruefmt.Println(&quot;exTime not found!&quot;)</span><br><span class="line"></span><br><span class="line">truetruectx.JSON(</span><br><span class="line">truetruetruehttp.StatusOK,</span><br><span class="line">truetruetruegin.H&#123;</span><br><span class="line">truetruetruetrue&quot;queryState&quot;:   0, // 0表示失败</span><br><span class="line">truetruetruetrue&quot;massage&quot;:      &quot;exTime not found&quot;,</span><br><span class="line">truetruetruetrue&quot;provinceFees&quot;: gin.H&#123;&#125;,</span><br><span class="line">truetruetrue&#125;,</span><br><span class="line">truetrue)</span><br><span class="line"></span><br><span class="line">truetruereturn</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">trueexTime = exTime1.(string)</span><br><span class="line">truefmt.Println(&quot;extime: &quot;, exTime)</span><br><span class="line">true/////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">true//保存成功返回正确的Json数据</span><br><span class="line">truectx.JSON(</span><br><span class="line">truetruehttp.StatusOK,</span><br><span class="line">truetruegin.H&#123;</span><br><span class="line">truetruetrue&quot;code&quot;: 0,</span><br><span class="line">truetruetrue&quot;msg&quot;:  &quot;ok&quot;,</span><br><span class="line">truetruetrue&quot;data&quot;: gin.H&#123;</span><br><span class="line">truetruetruetrue&quot;result&quot;: &quot;ok in back end server, port: &quot; + conf.Port + &quot; info: &quot; + conf.BackInfo,</span><br><span class="line">truetruetrue&#125;,</span><br><span class="line">truetrue&#125;,</span><br><span class="line">true)</span><br><span class="line"></span><br><span class="line">truereturn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>本文使用 sample.json 文件测试，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">true&quot;enID&quot;: &quot;ID250&quot;,</span><br><span class="line">true&quot;exID&quot;: &quot;ID251&quot;,</span><br><span class="line">    &quot;exTime&quot;: &quot;2020-09-17T20:00:27&quot;,</span><br><span class="line">true&quot;type&quot;: 1,</span><br><span class="line">true&quot;money&quot;: 250.44,</span><br><span class="line">true&quot;distance&quot;: 274050</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为简单起见，将可执行文件拷贝一份，命名为<code>httpforward_back</code>。</p><p>先运行 84 端口服务，会自动启动所有的后端进程。打印如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># ./httpforward.exe -p 84</span><br><span class="line">[2021-09-09 14:56:40.691 restart.go:26] restartAll...</span><br><span class="line">[2021-09-09 14:56:40.691 restart.go:38] try to kill backend server httpforward_back</span><br><span class="line">[2021-09-09 14:56:40.700 restart.go:55] run in port:  9000</span><br><span class="line">[2021-09-09 14:56:40.707 restart.go:55] run in port:  9001</span><br><span class="line">[2021-09-09 14:56:40.712 restart.go:55] run in port:  9002</span><br><span class="line">[2021-09-09 14:56:40.729 restart.go:55] run in port:  9003</span><br><span class="line">[2021-09-09 14:56:40.732 restart.go:55] run in port:  9004</span><br><span class="line">[2021-09-09 14:56:40.761 restart.go:55] run in port:  9005</span><br><span class="line">[2021-09-09 14:56:40.768 restart.go:55] run in port:  9006</span><br><span class="line">[2021-09-09 14:56:40.783 restart.go:55] run in port:  9007</span><br><span class="line">[2021-09-09 14:56:40.803 restart.go:55] run in port:  9008</span><br><span class="line">[2021-09-09 14:56:40.807 restart.go:55] run in port:  9009</span><br><span class="line">[2021-09-09 14:56:40.809 restart.go:55] run in port:  9010</span><br><span class="line">[2021-09-09 14:56:40.811 restart.go:55] run in port:  9011</span><br><span class="line">[2021-09-09 14:56:40.849 restart.go:55] run in port:  9012</span><br><span class="line">run 13 backend server ok</span><br><span class="line">[GIN-debug] [WARNING] Running in &quot;debug&quot; mode. Switch to &quot;release&quot; mode in production.</span><br><span class="line"> - using env:   export GIN_MODE=release</span><br><span class="line"> - using code:  gin.SetMode(gin.ReleaseMode)</span><br><span class="line"></span><br><span class="line">test post...</span><br><span class="line">[GIN-debug] POST   /foobar/test                 --&gt; goweb/cmd/gin.fee_test (3 handlers)</span><br><span class="line">[GIN-debug] POST   /foobar/test_back            --&gt; goweb/cmd/gin.fee_test_back (3 handlers)</span><br><span class="line">[GIN-debug] POST   /                         --&gt; goweb/cmd/gin.fee_test_back (3 handlers)</span><br><span class="line">[2021-09-09 14:56:40.885 busy.go:77] Server started at  84</span><br><span class="line">[GIN-debug] Listening and serving HTTP on :84</span><br></pre></td></tr></table></figure><p>启动一终端，执行测试命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:84/foobar/ -X POST -F  &quot;file=@sample.json&quot;</span><br></pre></td></tr></table></figure><p>可以修改<code>sample.json</code>文件的<code>exTime</code>观察转发的端口和返回值 </p><p>84 服务打印：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">filename: sample.json size: 133</span><br><span class="line">exTime: 2020-09-17T20:00:27</span><br><span class="line">got url:  http://127.0.0.1:9009</span><br><span class="line">[GIN] 2021/09/09 - 14:56:44 | 200 |    3.664936ms |    192.168.28.5 | POST     &quot;/foobar/test&quot;</span><br><span class="line"></span><br><span class="line">filename: sample.json size: 133</span><br><span class="line">exTime: 2020-12-17T20:00:27</span><br><span class="line">got url:  http://127.0.0.1:9012</span><br><span class="line">[GIN] 2021/09/09 - 15:04:30 | 200 |    2.465313ms |    192.168.28.5 | POST     &quot;/foobar/test&quot;</span><br></pre></td></tr></table></figure><p>测试命令返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100   434  100    98  100   336  16333  56000 --:--:-- --:--:-- --:--:-- 72333&#123;&quot;code&quot;:0,&quot;data&quot;:&#123;&quot;result&quot;:&quot;ok in back end server, port: 9009 info: run in port 9009&quot;&#125;,&quot;msg&quot;:&quot;ok&quot;&#125;</span><br><span class="line"></span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100   434  100    98  100   336   5764  19764 --:--:-- --:--:-- --:--:-- 27125&#123;&quot;code&quot;:0,&quot;data&quot;:&#123;&quot;result&quot;:&quot;ok in back end server, port: 9012 info: run in port 9012&quot;&#125;,&quot;msg&quot;:&quot;ok&quot;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也可直接向后端服务请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://127.0.0.1:85/foobar/test_back -X POST -F  &quot;file=@sample.json&quot;</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100   361  100    63  100   298  63000   291k --:--:-- --:--:-- --:--:--  352k&#123;&quot;code&quot;:0,&quot;data&quot;:&#123;&quot;result&quot;:&quot;ok in back end server&quot;&#125;,&quot;msg&quot;:&quot;ok&quot;&#125;</span><br></pre></td></tr></table></figure><p>2021.9.18 夜</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;近段时间需要实现一个转发 post 请求到指定后端服务的小工具，由于一直想学习 gin 框架，所以就使用这个框架进行尝试，预计会产生几篇文章。本文研究如何管理后端服务。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：使用gin框架实现转发功能：上传文件并转发</title>
    <link href="http://www.latelee.org/golang/golang-notes-gin-httpforward1.html"/>
    <id>http://www.latelee.org/golang/golang-notes-gin-httpforward1.html</id>
    <published>2021-09-17T14:40:00.000Z</published>
    <updated>2022-01-27T09:13:09.321Z</updated>
    
    <content type="html"><![CDATA[<p>近段时间需要实现一个转发 post 请求到指定后端服务的小工具，由于一直想学习 gin 框架，所以就使用这个框架进行尝试，预计会产生几篇文章。本文先研究如何在 gin 框架中实现上传和转发功能。  </p><span id="more"></span><h2 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h2><p>一后台 web 服务，有众多历史版本，本身运行无问题，但后来需求变更，需将不同的历史版本单独运行，并指定不同端口。对外相当于有众多的服务。在请求 post 中带有日期时间，需要根据该日期时间将请求转发到不同的端口的后端服务。注意，post 请求是直接使用文件的形式，对文件名称有特定要求。  </p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>nginx可以根据端口来转发，但本文是根据请求的内容转发的，因此需要实现一个转发工具。即先读取外部请求的文件内容，解析得到时间，再根据时间，转发到不同的端口服务中。要解决的问题：<br>如何做到既解析 post 请求，又要将该请求原封不动地发到后端服务？后端服务返回的数据，如何原封不动地返回请求者？<br>如何管理后端服务？如果使用额外的脚本，则添加了运维部署的步骤，略有麻烦。故考虑在转发工具中实现。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>使用工具进行 post 请求，并且指定文件名。可用 postman 或 curl，本文使用后者。  </li></ul><p>转发函数：    </p><ul><li>利用 ctx.Request.FormFile 得到文件名称、文件内容，此时，可以使用 gin 提供的 SaveUploadedFile 函数保存文件，也可以调用  io.Copy 保存。前者省事。  </li><li>调用再次转发函数。  </li><li>将再次转发函数返回值转换成 json 形式，返回 post 请求工具。  </li></ul><p>再次转发函数：  </p><ul><li>利用 multipart 包创建文件，将上一步得到的文件拷贝进去。  </li><li>再用 http 库发送请求。注意需要设置格式。  </li><li>最后读取请求的返回值，再返回，注意，内容为字节形式。  </li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="主要接口代码"><a href="#主要接口代码" class="headerlink" title="主要接口代码"></a>主要接口代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func RunWebServer(args []string) &#123;</span><br><span class="line">    runWebOnlyPost()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func runWebOnlyPost() &#123;</span><br><span class="line">truerouter := gin.New()</span><br><span class="line">truerouter.Use(gin.Logger())</span><br><span class="line">truerouter.Use(gin.Recovery())</span><br><span class="line"></span><br><span class="line">truetestRouter(router)</span><br><span class="line"></span><br><span class="line">trueklog.Println(&quot;Server started at &quot;, conf.Port)</span><br><span class="line">truerouter.Run(&quot;:&quot; + conf.Port)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func testRouter(r *gin.Engine) &#123;</span><br><span class="line">truefmt.Println(&quot;test post...&quot;)</span><br><span class="line">    </span><br><span class="line">    r.POST(&quot;/foobar/test&quot;, foobar_test)</span><br><span class="line">    r.POST(&quot;/foobar/test_back&quot;, foobar_test_back) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line"> curl http://127.0.0.1:84/foobar/test -X POST -F  &quot;file=@sample.json&quot;</span><br><span class="line"> </span><br><span class="line"> 临时：</span><br><span class="line"> file读取了一次，再读就没有内容了，字节数为0</span><br><span class="line">*/</span><br><span class="line">func foobar_test(ctx *gin.Context) &#123;</span><br><span class="line">    </span><br><span class="line">    // 2种方式都可，但 ctx.Request.FormFile 可以得到文件句柄，可直接拷贝</span><br><span class="line">    //file, err := ctx.FormFile(&quot;file&quot;)</span><br><span class="line">    file, header, err := ctx.Request.FormFile(&quot;file&quot;)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        ctx.JSON(http.StatusBadRequest, gin.H&#123;</span><br><span class="line">        &quot;error&quot;: err,</span><br><span class="line">        &#125;)</span><br><span class="line">        return</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    //fmt.Printf(&quot;Request: %+v\n&quot;, ctx.Request);</span><br><span class="line">    //fmt.Printf(&quot;Formfile: %+v | %+v |||  %v %v\n&quot;, file, header, err, reflect.TypeOf(file));</span><br><span class="line">    </span><br><span class="line">    // 拿到文件和长度，后面使用到</span><br><span class="line">    var jsonfilename string = header.Filename</span><br><span class="line">    mysize := header.Size</span><br><span class="line">    fmt.Printf(&quot;filename: %s size: %d\n&quot;, jsonfilename, mysize);</span><br><span class="line">    </span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        ctx.JSON(http.StatusBadRequest, gin.H&#123;</span><br><span class="line">        &quot;error&quot;: err,</span><br><span class="line">        &#125;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 处理json文件 </span><br><span class="line">    // 注：如果读取了文件，再转发，就没有内容了，所以这里不读取</span><br><span class="line">    </span><br><span class="line">    // 指向后端的服务URL</span><br><span class="line">    url := &quot;http://127.0.0.1:85/foobar/test_back&quot;</span><br><span class="line">    resp := post_data_gin(url, jsonfilename, file);</span><br><span class="line"></span><br><span class="line">    // 解析返回字符切片，得到map，当成json，赋值给gin</span><br><span class="line">    var data1 map[string]interface&#123;&#125;</span><br><span class="line">    err = json.Unmarshal(resp, &amp;data1)</span><br><span class="line">    //fmt.Println(&quot;muti unmarshal: &quot;, err, data1)</span><br><span class="line">    </span><br><span class="line">    ctx.JSON(http.StatusOK, data1)</span><br><span class="line">    </span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> 模拟后台的仅获取file字段的json，不作其它处理</span><br><span class="line"> curl http://127.0.0.1:84/foobar/test_back -X POST -F  &quot;file=@sample.json&quot;</span><br><span class="line">*/</span><br><span class="line">func foobar_test_back(ctx *gin.Context) &#123;</span><br><span class="line">    </span><br><span class="line">    // 2种方式都可，但 ctx.Request.FormFile 可以得到文件句柄，可直接拷贝</span><br><span class="line">    //file, err := ctx.FormFile(&quot;file&quot;)</span><br><span class="line">    _, header, err := ctx.Request.FormFile(&quot;file&quot;)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        ctx.JSON(</span><br><span class="line">            http.StatusBadRequest,</span><br><span class="line">            gin.H&#123;</span><br><span class="line">                &quot;code&quot;: -1,</span><br><span class="line">                &quot;msg&quot;:  &quot;failed&quot;,</span><br><span class="line">                &quot;data&quot;: gin.H&#123;</span><br><span class="line">                    &quot;result&quot;: &quot;failed in back end server&quot;,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 拿到文件和长度，后面使用到</span><br><span class="line">    var myfile string = header.Filename</span><br><span class="line">    mysize := header.Size</span><br><span class="line">    fmt.Printf(&quot;filename: %s size: %d\n&quot;, myfile, mysize);</span><br><span class="line">    </span><br><span class="line">    if mysize &lt;= 0 &#123;</span><br><span class="line">        ctx.JSON(</span><br><span class="line">            http.StatusBadRequest,</span><br><span class="line">            gin.H&#123;</span><br><span class="line">                &quot;code&quot;: -1,</span><br><span class="line">                &quot;msg&quot;:  &quot;failed&quot;,</span><br><span class="line">                &quot;data&quot;: gin.H&#123;</span><br><span class="line">                    &quot;result&quot;: &quot;failed in back end server, json size 0&quot;,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 此处可保存文件</span><br><span class="line"></span><br><span class="line">    //保存成功返回正确的Json数据</span><br><span class="line">    ctx.JSON(</span><br><span class="line">truetruehttp.StatusOK,</span><br><span class="line">truetruegin.H&#123;</span><br><span class="line">truetruetrue&quot;code&quot;: 0,</span><br><span class="line">truetruetrue&quot;msg&quot;:  &quot;ok&quot;,</span><br><span class="line">truetruetrue&quot;data&quot;: gin.H&#123;</span><br><span class="line">truetruetruetrue&quot;result&quot;: &quot;ok in back end server&quot;,</span><br><span class="line">truetruetrue&#125;,</span><br><span class="line">truetrue&#125;,</span><br><span class="line">true)</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为测试方便，文中实现的 gin 框架程序在运行时可指定端口。因此，代码中实现了2个 url 的响应函数。  </p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>本文使用 sample.json 文件测试，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">true&quot;enID&quot;: &quot;ID250&quot;,</span><br><span class="line">true&quot;exID&quot;: &quot;ID251&quot;,</span><br><span class="line">    &quot;exTime&quot;: &quot;2020-09-17T20:00:27&quot;,</span><br><span class="line">true&quot;type&quot;: 1,</span><br><span class="line">true&quot;money&quot;: 250.44,</span><br><span class="line">true&quot;distance&quot;: 274050</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先运行 84 端口服务（称为 84 服务），此为对外的服务。再运行 85 端口服务（称为 85 服务），此为模拟后端的服务。<br>启动一终端，执行测试命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:84/foobar/ -X POST -F  &quot;file=@sample.json&quot;</span><br></pre></td></tr></table></figure><p>84 服务打印：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[2021-08-25 23:51:19.424 busy.go:79] Server started at  84</span><br><span class="line">[GIN-debug] Listening and serving HTTP on :84</span><br><span class="line">filename: sample.json size: 95</span><br><span class="line">io copy: 95 &lt;nil&gt;</span><br><span class="line">[GIN] 2021/08/25 - 23:53:59 | 200 |      3.0002ms |       127.0.0.1 | POST     &quot;/foobar/test&quot;</span><br></pre></td></tr></table></figure><p>85 服务打印：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[GIN-debug] Listening and serving HTTP on :85</span><br><span class="line">filename: sample.json size: 95</span><br><span class="line">[GIN] 2021/08/25 - 23:53:59 | 200 |            0s |       127.0.0.1 | POST     &quot;/foobar/test_back&quot;</span><br></pre></td></tr></table></figure><p>测试命令返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100   361  100    63  100   298  31500   145k --:--:-- --:--:-- --:--:--  352k&#123;&quot;code&quot;:0,&quot;data&quot;:&#123;&quot;result&quot;:&quot;ok in back end server&quot;&#125;,&quot;msg&quot;:&quot;ok&quot;&#125;</span><br></pre></td></tr></table></figure><p>也可直接向后端服务请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://127.0.0.1:85/fee/test_back -X POST -F  &quot;file=@sample.json&quot;</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100   361  100    63  100   298  63000   291k --:--:-- --:--:-- --:--:--  352k&#123;&quot;code&quot;:0,&quot;data&quot;:&#123;&quot;result&quot;:&quot;ok in back end server&quot;&#125;,&quot;msg&quot;:&quot;ok&quot;&#125;</span><br></pre></td></tr></table></figure><p>2021.9.17 夜</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;近段时间需要实现一个转发 post 请求到指定后端服务的小工具，由于一直想学习 gin 框架，所以就使用这个框架进行尝试，预计会产生几篇文章。本文先研究如何在 gin 框架中实现上传和转发功能。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>新公司入职这一年</title>
    <link href="http://www.latelee.org/the-life/one-year-in-new-company%EF%BC%8D2021.html"/>
    <id>http://www.latelee.org/the-life/one-year-in-new-company%EF%BC%8D2021.html</id>
    <published>2021-09-16T15:50:59.000Z</published>
    <updated>2022-01-27T09:13:09.565Z</updated>
    
    <content type="html"><![CDATA[<p>自去年8月正式入职至今天，整整一年了。值此之际，写一写入职一年来的事。<br>一年前，有很多家事、小孩事等烦心事，对未来也忧心忡忡，现在，看着会叫爸爸的李大锤越来越顽皮，心里石头也放下了。<br>这一年，体验过几次民族大道的午夜，也见过几次民族大道的夕阳。路过繁华闹市，也路过冷清小巷。  </p><span id="more"></span><h2 id="偶然机遇"><a href="#偶然机遇" class="headerlink" title="偶然机遇"></a>偶然机遇</h2><p>2017年5月初，与覃博士约在万象城喝咖啡，喝着戒了多年的咖啡，与覃博进行会谈。以我水平，技术上没有任何问题。——这点自信我是有的。当时我要求的薪酬是10K，这个价格我还是小心翼翼地提出来，毕竟在广西这种小地方呆久了，不敢开太高。那时因为家事，一度曾去深圳发展，又一度下定决心在南宁不到处跑了，毕业7年了，还是逃不出南宁。经过几次交流，虽然薪酬没有达到我的期望值，但给了我希望，因为这是一个初创的公司，我相信有我发挥的地方。——后来才知道，当时还没办理营业执照，公司还未装修完。  </p><p>辗转到了7月中旬，我还在继续陪小孩，以减少老婆的工作量。但还是每天去一次公司当监工，在此过程，学习了很多知识，也见识了各种扯皮。还好最终顺利结束，机房、空调、灯、桌椅等验收通过。  </p><p>营业执照是8月8日那天审批通过的，也宣示公司正式成立了。  </p><h2 id="技术管理"><a href="#技术管理" class="headerlink" title="技术管理"></a>技术管理</h2><p>新公司一切都是新的，成立那天，只有CEO、CTO、一名行政，以及一个我。然后慢慢制定考勤制度、机房制度，再到招聘，申请域名，申请企业邮箱，申请备案，等。我几乎都参与了。这些，我都有了解或熟悉，真是冥冥中有天意。但我也不是一下子全部展示出来，像面试的流程，技巧，也是慢慢让领导看到我的能力。以至于后来，C开发、JAVA开发、测试人员、嵌入式人员，都由我面试，直到后面人员到位，我才专注于某些方面的面试。  </p><p>这一年来，面试过的人，根据记录，大约有50多个，各式的人也遇到过，有不授受单休的；有关注天使轮，产品盈利点的；有对公司管理方式和产品指手画脚的；也遇到过很多年轻人，在深圳工作三年回南宁发展要价10K的。  </p><p>虽然我没有正式当过领导，但以前也是经过半年的磨练，在带人、沟通方面有了很大提高。</p><h2 id="基础设施"><a href="#基础设施" class="headerlink" title="基础设施"></a>基础设施</h2><p>综合看，这一年时间来，在管理人、公司杂事和技术构建中，都花费不少时间。但这都是必须付出的。  </p><p>这一年，经历了物理机部署到docker部署应用的全面进化。建立以gitlab+jenkins为核心的CICD系统。建立了编程规范、技术管理规范等制度流程。</p><p>未来争取将自己从杂事中抽身出来，专注于核心的事务。</p><h2 id="个人技能"><a href="#个人技能" class="headerlink" title="个人技能"></a>个人技能</h2><p>说实话，这一年来的技能没有提升多少，嵌入式Linux基本上已经不搞了，偶尔指导同事而已。但是docker是新学的，也发现docker的确能带来很多的便利。现在docker基本上可以说上手了，各种应用没问题。但是k8s却用得不多，因为时间关系，没有太专注于k8s。而微服务架构这方面，还不能说入门，只是有个概念。</p><p>从公司职位划分来说，我负责公司运维系统，但直到现在，后台服务人手还是不够，基础功能未完善，还要继续充当开发人员角色。</p><h2 id="个人生活"><a href="#个人生活" class="headerlink" title="个人生活"></a>个人生活</h2><p>每周上六天班，每周有三天加班到晚上10点，工作强度能接受，只是时间跨度大，与老婆孩子呆在一起的时间少。当然，呆的时间长了，或多或少都有矛盾，从这点看，加班还是有好处的。</p><p>也正是因为工作时间长，加上要带小孩，个人业余时间被压缩得很少，这一年，文章写得少了，视频也不录了，淘宝店铺也不更新，网友的问题也少回复了。当然，外快也就没有了。</p><p>有一段时间，早上大锤醒得早，就带他到楼顶晒太阳，看房东小孩养的小乌龟，玩一会就要去上班了。晚上加班回来，老婆孩子已经熟睡了。<br>这一年，当大锤生病时，得请假和老婆带着他一起去医院，老婆抱小孩，我排队、拿药。</p><p>这一年，每次大锤打预防针时，得提前去社区医院排队，我抱小孩，老婆拿包。因为这样，不影响上班时间。</p><p>这一年，看着他酣睡的小脸蛋，看着他蹒跚学步，这都是幸福的事。而当听到他第一次叫爸时，我觉得什么辛苦都值得。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>感谢老东家，将近6年的工作经历，无论是核心技能还是职场经验，都让我学到了不少东西，这些东西，不是薪水所能比拟的。但人是要生活——而不是生存的，所以我选择离开。</p><p>感谢新公司CEO，感谢他的赏识，也感谢提供舞台让我发挥，给我技术成就感和物质成就感带来希望。</p><p>机会是留给有准备的人的。是金子的，总会发亮。<br>——我想，是时候了。</p><p>李迟 2018.8.9 深夜</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;自去年8月正式入职至今天，整整一年了。值此之际，写一写入职一年来的事。&lt;br&gt;一年前，有很多家事、小孩事等烦心事，对未来也忧心忡忡，现在，看着会叫爸爸的李大锤越来越顽皮，心里石头也放下了。&lt;br&gt;这一年，体验过几次民族大道的午夜，也见过几次民族大道的夕阳。路过繁华闹市，也路过冷清小巷。  &lt;/p&gt;</summary>
    
    
    
    <category term="生活掠影" scheme="http://www.latelee.org/category/the-life/"/>
    
    
    <category term="个人总结" scheme="http://www.latelee.org/tag/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>李迟2021年8月知识总结</title>
    <link href="http://www.latelee.org/my-library/code-for-2021-08.html"/>
    <id>http://www.latelee.org/my-library/code-for-2021-08.html</id>
    <published>2021-08-31T15:40:00.000Z</published>
    <updated>2022-01-27T09:13:09.413Z</updated>
    
    <content type="html"><![CDATA[<p>本文为 2021 年 8 月知识总结。</p><span id="more"></span><h2 id="编码总结"><a href="#编码总结" class="headerlink" title="编码总结"></a>编码总结</h2><h3 id="C-C"><a href="#C-C" class="headerlink" title="C / C++"></a>C / C++</h3><p>产生随机数示例二则。<br>产生给出范围，并指定数量的随机数。即给定数组（实为向量），其内可预先定义有数值，也可以为空，产生随机数时，需保留原定义的数值（如有），且新的随机数不能与已有的数值相同，已有的值包括原定义的和新产生的。如已有数值 250，则该函数不能再生成 250 这个数。      </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 产生[a~b)之间 n 个随机数，且随机数不同</span><br><span class="line">// 注：包含a本身，但不包含b，当指定数量 n 大于[a~b)范围时，使用范围值</span><br><span class="line">// result可预先设置一些固定的值，即随机数一定包含那些值</span><br><span class="line">int genRandom(std::vector&lt;int&gt;&amp; result, int a, int b, int n)</span><br><span class="line">&#123;</span><br><span class="line">    int total = b - a;</span><br><span class="line">    if (n &gt; total) n = total;</span><br><span class="line"></span><br><span class="line">    int i = 0;</span><br><span class="line">    bool found = false;</span><br><span class="line">    // 注：使用tmp临时保存，如直接用result，得到的容量会多一些</span><br><span class="line">    std::vector&lt;int&gt; tmp;</span><br><span class="line">    tmp.resize(n);</span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        //公式：a + rand() % n，其中n为整数的范围，a为起始值</span><br><span class="line">        tmp[i] =  a + rand() % total;</span><br><span class="line">        // 将生成的值取已有的值对比，如不同，才保存</span><br><span class="line">        found = false;</span><br><span class="line">        for (int j = 0; j &lt; (int)result.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (tmp[i] == result[j])</span><br><span class="line">            &#123;</span><br><span class="line">                found = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!found)</span><br><span class="line">        &#123;</span><br><span class="line">            result.push_back(tmp[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &gt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅产生指定范围内的一个随机数。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int genRandom(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    int total = b - a;</span><br><span class="line"></span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    </span><br><span class="line">    return a + rand() % total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串分割示例。<br>自动去掉字符串前后空格，自动去掉不合法的分隔方式。如：<code>|| 11 |22|33||</code>，原字符串前后分隔符多余，而第字符串有空格。本函数能解析出<code>11、22、33</code>三个有效字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">std::string&amp; trim(std::string &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">    if (s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s.erase(0, s.find_first_not_of(&quot; &quot;));</span><br><span class="line">    s.erase(s.find_last_not_of(&quot; &quot;) + 1);</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line">void splitString(std::vector &lt;std::string&gt; &amp;elems, const std::string &amp; s, const std::string &amp; delim)</span><br><span class="line">&#123;</span><br><span class="line">    // std::vector &lt; std::string &gt; elems;</span><br><span class="line">    size_t pos = 0;</span><br><span class="line">    size_t len = s.length();</span><br><span class="line">    size_t delim_len = delim.length();</span><br><span class="line"></span><br><span class="line">    std::string tmp;</span><br><span class="line">    if (delim_len == 0)</span><br><span class="line">        return;</span><br><span class="line">    while (pos &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        int find_pos = s.find(delim, pos);</span><br><span class="line">        if (find_pos &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = s.substr(pos, len - pos);</span><br><span class="line">            tmp = trim(tmp);</span><br><span class="line">            if(!tmp.empty()) elems.push_back(tmp);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = s.substr(pos, find_pos - pos);</span><br><span class="line">        tmp = trim(tmp);</span><br><span class="line">        if(!tmp.empty()) elems.push_back(tmp);</span><br><span class="line">        pos = find_pos + delim_len;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义打印日志添加 printf 格式检查：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void LogInfo(const char * fmt, ...)  __attribute__((format(printf, 1, 2)));</span><br></pre></td></tr></table></figure><p>添加后，可以防止<code>LogInfo</code>参数类型不匹配或缺少参数情况的发生。</p><h3 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h3><p>着手实现转发功能。</p><h3 id="delphi"><a href="#delphi" class="headerlink" title="delphi"></a>delphi</h3><p>在调试发现提示查询某天日志时，数据库出错。SQL Server 提示<code>[SQL Server]从 varchar 数据类型到 datetime 数据类型的转换产生一个超出范围的值。</code>。oracle 提示<code>ORA-01847: 月份中日的值必须介于 1 和当月最后一日之间</code>。经查，是如下代码出现问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">year:=YearOf(DateTimePicker1.Date);</span><br><span class="line">month:=MonthOfTheYear(DateTimePicker1.Date);</span><br><span class="line">day:=DayOfTheMonth(DateTimePicker1.Date);</span><br><span class="line">datastr:=format(&#x27;%.4d-&#x27;,[year])+format(&#x27;%.2d-&#x27;,[month])+format(&#x27;%.2d&#x27;,[day]);</span><br><span class="line"></span><br><span class="line">datastr1:=format(&#x27;%.4d-&#x27;,[year])+format(&#x27;%.2d-&#x27;,[month])+format(&#x27;%.2d&#x27;,[day-1]);</span><br><span class="line">datastr2:=format(&#x27;%.4d-&#x27;,[year])+format(&#x27;%.2d-&#x27;,[month])+format(&#x27;%.2d&#x27;,[day+1]);</span><br></pre></td></tr></table></figure><p>代码片段先获取当前日期的年、月、日数值，再通过将算术加减计算前一天和后一天，并组装成字符串。当在月初1号或月尾30（或31）时，就出现问题，此时当前日期、前一天、后一天这三个日期值为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2021-08-01 2021-08-00 2021-08-02  </span><br><span class="line">2021-08-31 2021-08-30 2021-08-32  </span><br></pre></td></tr></table></figure><p>可以看到出现了<code>00</code>和<code>32</code>的非法值。日期不能直接用算术的方式加减。而是使用 TDateTime 类型的变量进行加减。如下：</p><pre><code>var tdate, tdate1, tdate2: TDateTime;    tdate := DateTimePicker1.DateTime;    tdate1 := tdate-1;    tdate2 := tdate+1;        // 调用YearOf MonthOfTheYear DayOfTheMonth 函数</code></pre><h3 id="编码其它"><a href="#编码其它" class="headerlink" title="编码其它"></a>编码其它</h3><p>本月对 delphi 工程进行了一次维护，效率较低且无甚好解决方案。一是必须在虚拟机 xp 中使用固定 IDE 进行界面编辑和工程编译；二是 xp 的 IDE 不好用；三是资料较少（年代久远）；四是工程大部分用法为旧式，一时难以理解；五是历经廿载的积累及若干代工程师的维护，在搜索代码时，不时能看到1998、2008、2016、2019字样，一种厚重的历史感扑面而来。在前辈面前不敢造次，改代码时战战兢兢，生怕行差踏错。由于其有较高的使用价值，因此依然要学习并掌握。  </p><h2 id="一般知识"><a href="#一般知识" class="headerlink" title="一般知识"></a>一般知识</h2><h2 id="研发思考"><a href="#研发思考" class="headerlink" title="研发思考"></a>研发思考</h2><p>继续搞 CMMI 5，着重数据，有很多数据还没理解，根据模板填，不知含义。文档工作量比编码还大。    </p><h2 id="本月学习及计划"><a href="#本月学习及计划" class="headerlink" title="本月学习及计划"></a>本月学习及计划</h2><p>没有集中学习。计划抽时间搞一下请求转发方面的东西。  </p><h2 id="其它点滴"><a href="#其它点滴" class="headerlink" title="其它点滴"></a>其它点滴</h2><p>休息严重不足。<br>为了开收入证明，跑了 2 趟集团总部，从南宁东南方向到西北方向，单程1小时间。均为中午时分跑。<br>为评职称，到前前前前单位盖章，单程耗时50分钟。到当前外包单位盖章，单程耗时30分钟。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文为 2021 年 8 月知识总结。&lt;/p&gt;</summary>
    
    
    
    <category term="我的程序代码" scheme="http://www.latelee.org/category/my-library/"/>
    
    
    <category term="代码积累" scheme="http://www.latelee.org/tag/%E4%BB%A3%E7%A0%81%E7%A7%AF%E7%B4%AF/"/>
    
    <category term="知识总结" scheme="http://www.latelee.org/tag/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>cppcheck 和 valgrind 编译及使用</title>
    <link href="http://www.latelee.org/toolslib/compile-cppcheck-and-valgrind.html"/>
    <id>http://www.latelee.org/toolslib/compile-cppcheck-and-valgrind.html</id>
    <published>2021-08-28T14:14:00.000Z</published>
    <updated>2022-01-27T09:13:09.409Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍cppcheck 和 valgrind 编译及使用。</p><span id="more"></span><h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><p>下载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http://cppcheck.net/ 版本 2.5</span><br><span class="line">具体地址：  </span><br><span class="line">https://codeload.github.com/danmar/cppcheck/tar.gz/2.5</span><br><span class="line"></span><br><span class="line">https://www.valgrind.org/downloads/ 版本：3.17.0</span><br><span class="line">具体地址：  </span><br><span class="line">https://sourceware.org/pub/valgrind/valgrind-3.17.0.tar.bz2</span><br></pre></td></tr></table></figure><h2 id="二、编译"><a href="#二、编译" class="headerlink" title="二、编译"></a>二、编译</h2><p>cppcheck 编译步骤如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tar xf cppcheck-2.5.tar.gz </span><br><span class="line">cd cppcheck-2.5/</span><br><span class="line">make -j</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">cmake --build .</span><br><span class="line">cd ../../</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Makefile322: *** FILESDIR must be set!</span><br><span class="line"></span><br><span class="line">分析：</span><br><span class="line">BIN=$(DESTDIR)$(PREFIX)/bin</span><br><span class="line"></span><br><span class="line">修改：</span><br><span class="line">FILESDIR=/usr/local/share/Cppcheck</span><br><span class="line">PREFIX=/usr/local</span><br></pre></td></tr></table></figure><p>valgrind 编译步骤如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar xf valgrind-3.17.0.tar.bz2 </span><br><span class="line">cd valgrind-3.17.0</span><br><span class="line">./autogen.sh    注：缺少这步会出现 valgrind: failed to start tool &#x27;memcheck&#x27; for platform &#x27;amd64-linux&#x27;: No such file or directory</span><br><span class="line">./configure --prefix=/tmp/valgrind</span><br><span class="line">make -j</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>如果运行已编译好的 valgrind，提示<code>valgrind: failed to start tool &#39;memcheck&#39; for platform &#39;amd64-linux&#39;: No such file or directory</code>另一解决方法。其原因是未配置库目录，示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export VALGRIND_LIB=/home/latelee/valgrind/lib/valgrind</span><br></pre></td></tr></table></figure><p>注：库似乎在<code>/usr/local/lib/valgrind</code>目录</p><h2 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h2><p>cppcheck使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cppcheck ./ --enable=all --suppress=&#x27;*:src/uuid/*&#x27; --suppress=&#x27;*:src/crypto/*&#x27;  --suppress=&#x27;*:src/xml/*&#x27; --suppress=&#x27;*:src/zip/*&#x27; --suppress=variableScope  2&gt;&amp;1 | tee check_result.txt</span><br><span class="line"></span><br><span class="line">cppcheck --enable=all 2&gt;&amp;1 | tee check_result.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>valgrind 使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">valgrind --log-file=./valgrind_report.txt --leak-check=full --show-leak-kinds=all --show-reachable=no --track-origins=yes ./a.out</span><br><span class="line"></span><br><span class="line">valgrind --tool=memcheck --leak-check=full ./test</span><br><span class="line"></span><br><span class="line">valgrind --leak-check=full ls -l</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="四、问题及解决"><a href="#四、问题及解决" class="headerlink" title="四、问题及解决"></a>四、问题及解决</h2><p>将在虚拟机编译好的 valgrind 以及对应的库拷贝到板子上运行，提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind: failed to start tool &#x27;memcheck&#x27; for platform &#x27;amd64-linux&#x27;: No such file or directory</span><br></pre></td></tr></table></figure><p>按网上解决方法设置环境变量 VALGRIND_LIB：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export VALGRIND_LIB=&quot;/usr/local/lib/valgrind&quot;</span><br><span class="line">VALGRIND_LIB=/usr/local/lib/valgrind /usr/local/bin/valgrind  --h</span><br></pre></td></tr></table></figure><p>再运行，错误依旧。</p><p>将源码拷贝到板子上编译，亦是一样。 </p><p>设置环境变量 VALGRIND_LIB，其值为 <code>.in_place</code>目录的路径。如下示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export VALGRIND_LIB=/home/toll/valgrind-3.17.0/.in_place</span><br></pre></td></tr></table></figure><p>注：后面重启了，VALGRIND_LIB 没有值，但 valgrind 也能正常，原因未知。  </p><p>李迟 2021.8.28 周六 凌晨</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍cppcheck 和 valgrind 编译及使用。&lt;/p&gt;</summary>
    
    
    
    <category term="工具编译使用" scheme="http://www.latelee.org/category/toolslib/"/>
    
    
  </entry>
  
  <entry>
    <title>我的docker随笔37：使用gitlab和jenkins实现CICD</title>
    <link href="http://www.latelee.org/docker/docker-37-using-gitlab-jenkins-for-cicd.html"/>
    <id>http://www.latelee.org/docker/docker-37-using-gitlab-jenkins-for-cicd.html</id>
    <published>2021-08-27T16:00:00.000Z</published>
    <updated>2022-01-27T09:13:09.537Z</updated>
    
    <content type="html"><![CDATA[<p>本文涉及一种利用容器部署 gitlab 和 jenkins 服务实现持续集成（CICD）的方法，其目的是为了在实际工作中使用代码托管及自动化操作。  </p><span id="more"></span><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>因工作需要，需部署  gitlab 和 jenkins 服务器进行 CICD 测试，换个高大上的名称，叫“组织革新”。本文记录个人的实践，但不涉及部署的具体步骤。  </p><h2 id="二、技术小结"><a href="#二、技术小结" class="headerlink" title="二、技术小结"></a>二、技术小结</h2><ul><li>不同工程，配置不同，本文使用 C++ 工程为例进行实验。</li><li>在配置 jenkins 时，建议经常使用页面下方的“应用”，随时保存设置好的参数，以防不测。</li></ul><h2 id="三、gitlab和jenkins联调"><a href="#三、gitlab和jenkins联调" class="headerlink" title="三、gitlab和jenkins联调"></a>三、gitlab和jenkins联调</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>实现CICD分几个阶段：使用 gitlab 托管代码，使用 jenkins 进行编译、打包以及发布。两个服务器各有项目对应，同时要进行必要的配置。不同项目，配置方式不尽相同。本节的配置原则上按顺序进行，因此会在 gitlab 和 jenkins 之间来回切换，故先行说明。</p><h3 id="3-2-前置条件"><a href="#3-2-前置条件" class="headerlink" title="3.2 前置条件"></a>3.2 前置条件</h3><h4 id="3-2-1-允许本地网络请求"><a href="#3-2-1-允许本地网络请求" class="headerlink" title="3.2.1 允许本地网络请求"></a>3.2.1 允许本地网络请求</h4><p>使用 root 用户登录 gitlab 服务器，在管理员配置选项选择<strong>网络(Setting)**页面，在</strong>外发请求（Outbound requests）<strong>中，选择“</strong>允许Webhook和服务对本地网络的请求(Allow requests to the local network from web hooks and services)**”，保存。如图1所示。</p><p>进行该设置的目的是因为本文的 gitlab 和 jenkins 服务均在同一物理服务器上使用 docker 部署。如果不设置，则在 gitlab 中设置 webhooks 时会提示<code>Url is blocked: Requests to the local network are not allowed</code>。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/1.png" alt="image-20210828022642996"></p><p><strong>说明：如果jenkins和gitlab不在同一服务器，则不需要进行此设置。</strong></p><h4 id="3-2-2-关闭-CSFR"><a href="#3-2-2-关闭-CSFR" class="headerlink" title="3.2.2 关闭 CSFR"></a>3.2.2 关闭 CSFR</h4><p>进入 jenkins 容器，找到<code>/usr/local/bin/jenkins.sh</code>文件，找到 exec java 行，在<code>-Duser.home=&quot;$JENKINS_HOME&quot;</code>后添加<code> -Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION=true</code>，完整的一行语句如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec java -Duser.home=&quot;$JENKINS_HOME&quot; -Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION=true &quot;$&#123;java_opts_array[@]&#125;&quot; -jar $&#123;JENKINS_WAR&#125; &quot;$&#123;jenkins_opts_array[@]&#125;&quot; &quot;$@</span><br></pre></td></tr></table></figure><blockquote><p>说明：在笔者定制的 jenkins 镜像中已经进行该修改了。</p></blockquote><p>进行该设置，是因为高版本 Jenkins 无法在界面关闭跨站请求伪造保护（CSRF），因此在 gitlab 进行 webhooks 时会认证失败。提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hook executed successfully but returned HTTP 403</span><br></pre></td></tr></table></figure><p>关闭之后，再次进入 CSFR 页面，提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This configuration is unavailable because the System property hudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION is set to true.</span><br></pre></td></tr></table></figure><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/1.1.png" alt="image-20211020161017526"></p><p>说明修改成功。</p><blockquote><p>对于物理机部署的 jenkins，则在 /etc/sysconfig/jenkins 文件中找到 JENKINS_JAVA_OPTIONS， 设置如下：</p><p>JENKINS_JAVA_OPTIONS=”-Djava.awt.headless=true -Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION=true”</p></blockquote><h3 id="3-3-准备-gitlab-仓库"><a href="#3-3-准备-gitlab-仓库" class="headerlink" title="3.3 准备 gitlab 仓库"></a>3.3 准备 gitlab 仓库</h3><p>本文使用仓库地址为 <code>http://10.8.18.168:8888/latelee/ci_test</code>。</p><h3 id="3-4-配置-jenkins-项目"><a href="#3-4-配置-jenkins-项目" class="headerlink" title="3.4 配置 jenkins 项目"></a>3.4 配置 jenkins 项目</h3><h4 id="3-4-1-新建项目"><a href="#3-4-1-新建项目" class="headerlink" title="3.4.1 新建项目"></a>3.4.1 新建项目</h4><p>在 jenkins 首页左侧，点击“新建任务”，输入项目项目，选择第一项“自由风格软件项目”。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/2.png" alt="image-20210828215636723"></p><p>点击“确定”进入配置页面。  </p><h4 id="3-4-2-指定git仓库"><a href="#3-4-2-指定git仓库" class="headerlink" title="3.4.2 指定git仓库"></a>3.4.2 指定git仓库</h4><p>在<strong>源码管理</strong>选项页面中，输入 gitlab 仓库地址，注意，URL 地址后须添加<code>.git</code>后缀。  </p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/3.png" alt="image-20210828215845428"></p><p>点击“添加”-&gt;Jenkins，添加凭据，默认类型为用户名和密码。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/4.png" alt="image-20210828221742298"></p><p>添加后，选择添加的凭据，红色错误提示消失。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/5.png" alt="image-20210828222010281"></p><h4 id="3-4-3-设置触发条件"><a href="#3-4-3-设置触发条件" class="headerlink" title="3.4.3 设置触发条件"></a>3.4.3 设置触发条件</h4><p>在<strong>构建触发器</strong>页面进行触发器的选择。此处有多种方式可选，如定时构建和指定 gitlab 方式。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/6.png" alt="image-20210829110540696"></p><p>勾选“Build when a change is pushed to GitLab.”。注意，该项后面的 URL 地址需要记住，将在 gitlab 中使用。点击“高级”，在“Secret token”处点击“Generate”，生成 token，该 token 亦需要记住。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/7.png" alt="image-20210828222613624"></p><p>进行此设置目的是，当提交代码到 gitlab 仓库时，会自动触发 jenkins 执行 一次构建。触发条件在对应 gitlab 仓库中进行设置。如果不需要自动触发，则可以不触发条件。</p><h4 id="3-4-4-指定构建步骤"><a href="#3-4-4-指定构建步骤" class="headerlink" title="3.4.4 指定构建步骤"></a>3.4.4 指定构建步骤</h4><p>在<strong>构建</strong>页面，点击“增加构建步骤”，选择“执行shell”，输入构建的命令。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/8.png" alt="image-20210829110841729"></p><h4 id="3-4-5-指定构建后的步骤"><a href="#3-4-5-指定构建后的步骤" class="headerlink" title="3.4.5 指定构建后的步骤"></a>3.4.5 指定构建后的步骤</h4><p>在<strong>构建后操作</strong>页面，点击“增加构建后操作步骤”。选择“send build artifacts over SSH”。选择服务器、源目录、目标目录及执行的命令。注意，在本文实践前已经设置好服务器及目标，故只指定源文件和执行命令即可。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/9.png" alt="image-20210829111238088"></p><p>在笔者实践中发现，在“构建环境”、“构建”、“构建后操作”三个页面均可以选择将文件通过 SSH 发送服务器。</p><h3 id="3-5-设置-gitlab-的-webhooks"><a href="#3-5-设置-gitlab-的-webhooks" class="headerlink" title="3.5 设置 gitlab 的 webhooks"></a>3.5 设置 gitlab 的 webhooks</h3><p>在 gitlab 项目<code>http://10.8.18.168:8888/latelee/ci_test</code>页面，    选择“Settings”-&gt;“Webhooks”，输入上小节生成的 URL 和 token。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/10.png" alt="image-20210829105434914"></p><p>点击页面下方“Add webhook”，添加。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/11.png" alt="image-20210829105538566"></p><blockquote><p>注：同一个gitlab仓库，可支持多个 webhook。</p></blockquote><p>点击“Test”，选择“Push events”，进行测试验证。<strong>为保证触发成功，强烈建议在此处先行测试</strong>。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/12.png" alt="image-20210829105744185"></p><p>触发类型有很多种，根据实际情况选择。</p><h3 id="3-4-验证"><a href="#3-4-验证" class="headerlink" title="3.4 验证"></a>3.4 验证</h3><p>提交代码到 gitlab 仓库（此处从略）。稍等片刻，在 jenkins 工程的看到进行了触发。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/13.png" alt="image-20210829111835252"></p><p>输出日志如下：</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/14.png" alt="image-20210829112333720"></p><p>编译、运行、执行ssh远程服务均成功。在远程服务器的<code>/tmp</code>目录出现<code>a.out</code>和<code>log.txt</code>。</p><h2 id="四、其它的配置"><a href="#四、其它的配置" class="headerlink" title="四、其它的配置"></a>四、其它的配置</h2><h3 id="4-1-邮件通知"><a href="#4-1-邮件通知" class="headerlink" title="4.1 邮件通知"></a>4.1 邮件通知</h3><p>jenkins系统设置。见前面文章。此处关注项目配置。</p><p>注意，邮件通知需要根据不同应用情况设置，此处作为示例，只关注是否能在构建时发邮件。至于何时何条件触发，非本文范围。  </p><p>定位到<strong>构建后操作</strong>页面，添加<code>Editable Email Notification</code>。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/15.png" alt="image-20210916091942018"></p><p>在该插件配置处选择高级，在“Always”处输入接收者邮件，其它保持不变（即使用默认的模板）。  </p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/16.png" alt="image-20210916093808632"></p><p>保存即可。</p><h3 id="4-2-未登录时可查看构建信息"><a href="#4-2-未登录时可查看构建信息" class="headerlink" title="4.2 未登录时可查看构建信息"></a>4.2 未登录时可查看构建信息</h3><p>进入“系统管理”-&gt;“全局安全配置”页面，勾选“匿名用户具有可读权限”。如下：</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/17.png" alt="image-20211020160833917"></p><p>此时，无须登录，即可查看项目的构建构建，可根据情况决定是否勾选。  </p><h2 id="五、进阶"><a href="#五、进阶" class="headerlink" title="五、进阶"></a>五、进阶</h2><p>构建的工程位于<code>/var/lib/jenkins/workspace/</code>，可以先在工程目录进行测试，再使用 Jenkins 进行集成。</p><h2 id="六、问题"><a href="#六、问题" class="headerlink" title="六、问题"></a>六、问题</h2><p>在构建阶段直接启动bash执行脚本，能启动，但随后被jenkins停止。终端提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Process leaked file descriptors. See https://www.jenkins.io/redirect/troubleshooting/process-leaked-file-descriptors for more information</span><br></pre></td></tr></table></figure><p>官方解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">To reliably kill processes spawned by a job during a build, Jenkins contains a bit of native code to list up such processes and kill them.</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文涉及一种利用容器部署 gitlab 和 jenkins 服务实现持续集成（CICD）的方法，其目的是为了在实际工作中使用代码托管及自动化操作。  &lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="http://www.latelee.org/category/docker/"/>
    
    
    <category term="docker" scheme="http://www.latelee.org/tag/docker/"/>
    
  </entry>
  
  <entry>
    <title>我的docker随笔36：定制jenkins镜像</title>
    <link href="http://www.latelee.org/docker/docker-36-make-jenkins-docker.html"/>
    <id>http://www.latelee.org/docker/docker-36-make-jenkins-docker.html</id>
    <published>2021-08-26T16:00:00.000Z</published>
    <updated>2022-01-27T09:13:09.537Z</updated>
    
    <content type="html"><![CDATA[<p>本文涉及一种根据实际需求定制 jenkins 镜像的方法及实践。其目的是在官方镜像基础上添加自定义软件、库，以便更加适应项目的开发情况。   </p><span id="more"></span><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>官方镜像基本能实现了常见的持续集成功能，但还存在部分要求不符合实际需要。因此，有必要研究制作自定义的镜像，以加深对对 jenkins 运行机制的理解。  </p><p>官方提供了各版本的脚本和 Dockerfile，可以直接用这些文件生成镜像，笔者认为，可以在官方镜像基础直接修改、新加功能。</p><h2 id="二、技术小结"><a href="#二、技术小结" class="headerlink" title="二、技术小结"></a>二、技术小结</h2><ul><li>根据实际情况选定jenkins版本。在该版本基础上再额外添加自定义功能。</li><li>按需安装软件，如本文的镜像安装了gcc、node、golang等软件。</li><li>如果涉及其它的库，可以直接在 Dockerfile 中拷贝到镜像中。</li></ul><h2 id="三、定制配置"><a href="#三、定制配置" class="headerlink" title="三、定制配置"></a>三、定制配置</h2><h3 id="3-1-运行容器"><a href="#3-1-运行容器" class="headerlink" title="3.1 运行容器"></a>3.1 运行容器</h3><p>笔者所涉 Linux 系统，均为 centos7，并且 gcc 编译器版本必须为 4.8.5。在 jenkins 官方提供的众多版本中，恰好有 centos7，镜像名称为 jenkins/jenkins:centos7。  </p><p>在笔者实践中，是先运行 jenkins 容器，再进入容器中安装软件并测试的，但最终得到的仅有 Dockerfile 及必要的配置文件和脚本。本节记录在容器中安装软件的过程。</p><p>启动并用root权限进入容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name jenkins_build jenkins/jenkins:centos7 bash</span><br><span class="line"></span><br><span class="line">sudo docker exec -it -u root jenkins_build bash</span><br></pre></td></tr></table></figure><p>注：在运行容器（命令<code>docker exec</code>）时，使用<code>-u root</code>指定 root 权限，因为在容器中无法切换到 root 用户，而软件安装又需要该权限，因此，在运行容器时直接指定。</p><h3 id="3-2-安装软件"><a href="#3-2-安装软件" class="headerlink" title="3.2 安装软件"></a>3.2 安装软件</h3><p>安装gcc编译器及编译相关的工具软件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc gcc-c++</span><br><span class="line">yum -y install automake autoconf libtool make</span><br></pre></td></tr></table></figure><p>此外，还可以安装其它软件，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install vim sshpass wget</span><br></pre></td></tr></table></figure><p>一般原则是尽量只安装必要的软件，过多软件会增加体积。  </p><p>由于项目中有前端的框架，因此要安装node等工具：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">安装前端的 node：</span><br><span class="line">curl --silent --location https://rpm.nodesource.com/setup_12.x | bash -</span><br><span class="line">再执行：</span><br><span class="line">yum -y install nodejs</span><br><span class="line"></span><br><span class="line">安装yarn:</span><br><span class="line">curl -sL https://dl.yarnpkg.com/rpm/yarn.repo | tee /etc/yum.repos.d/yarn.repo</span><br><span class="line">yum -y install yarn</span><br></pre></td></tr></table></figure><h3 id="3-3-关闭-CSFR"><a href="#3-3-关闭-CSFR" class="headerlink" title="3.3 关闭 CSFR"></a>3.3 关闭 CSFR</h3><p>从容器拿到<code>/usr/local/bin/jenkins.sh</code>文件，编辑之，找到 exec java 行，在 <code>-Duser.home=&quot;$JENKINS_HOME&quot; </code>后添加：<br><code>-Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION=true</code><br>完整的语句为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec java -Duser.home=&quot;$JENKINS_HOME&quot; -Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION=true &quot;$&#123;java_opts_array[@]&#125;&quot; -jar $&#123;JENKINS_WAR&#125; &quot;$&#123;jenkins_opts_array[@]&#125;&quot; &quot;$@&quot;</span><br></pre></td></tr></table></figure><p>注意，此步骤是为了解决 gitlab+jenkins实现 CICD 过程出现的gitlab 触发 webhooks 认证失败的问题。参见后续文章。</p><h2 id="四、最终成果"><a href="#四、最终成果" class="headerlink" title="四、最终成果"></a>四、最终成果</h2><p>新建myinit.sh文件，内容：</p><pre><code>cat &gt; myinit.sh &lt;&lt;-EOF#!/bin/bash## set golangexport GOROOT=/usr/local/goexport GOBIN=$GOROOT/binexport PATH=$PATH:$GOBINexport GOPATH=/vagrant/golang_linuxexport GOPROXY=https://goproxy.io,directexport MYGO=$GOPATH/golang/src/github.com/latelee## set my localeexport LANG=en_US.utf8export LANGUAGE=en_US.utf8export LC_ALL=en_US.utf8export LANG=zh_CN.utf8export LANGUAGE=zh_CN.utf8export LC_ALL=zh_CN.utf8EOF</code></pre><p>注：上述myinit.sh暂未测试通过，仅作备档。</p><p>Dockerfile 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; Dockerfile &lt;&lt;-EOF</span><br><span class="line">FROM jenkins/jenkins:centos7</span><br><span class="line"></span><br><span class="line">### I changed jenkins.sh file</span><br><span class="line">COPY --chown=jenkins:jenkins jenkins.sh /usr/local/bin/</span><br><span class="line"></span><br><span class="line"># if we want to install tools</span><br><span class="line">USER root</span><br><span class="line"></span><br><span class="line">RUN echo &quot;Late Lee build&quot; &gt; /my.info &amp;&amp; \</span><br><span class="line">    date &gt;&gt; /my.info</span><br><span class="line"></span><br><span class="line">## C++</span><br><span class="line"># install other tools...</span><br><span class="line">RUN yum -y install gcc gcc-c++ automake autoconf libtool make sshpass wget</span><br><span class="line"></span><br><span class="line">## Node</span><br><span class="line">RUN curl --silent --location https://rpm.nodesource.com/setup_12.x | bash - &amp;&amp; \</span><br><span class="line">    yum -y install nodejs</span><br><span class="line">RUN curl -sL https://dl.yarnpkg.com/rpm/yarn.repo | tee /etc/yum.repos.d/yarn.repo &amp;&amp; \</span><br><span class="line">    yum -y install yarn</span><br><span class="line"></span><br><span class="line">## Golang</span><br><span class="line">RUN wget https://studygolang.com/dl/golang/go1.15.6.linux-amd64.tar.gz &amp;&amp; \</span><br><span class="line">    tar zxf go1.15.6.linux-amd64.tar.gz -C /usr/local/ &amp;&amp; \</span><br><span class="line">    rm -rf go1.15.6.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">## Maven</span><br><span class="line"># ...</span><br><span class="line"></span><br><span class="line"># need clean</span><br><span class="line">yum clean all</span><br><span class="line"></span><br><span class="line"># drop back to the regular jenkins user - good practice</span><br><span class="line">USER jenkins</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>由上述 Dockerfile 构建新的镜像，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t latelee/jenkins:centos7_new .</span><br></pre></td></tr></table></figure><h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><p>本文只是将定制的过程步骤罗列出来，安装软件的方式多种多样，如文中直接使用 yum 安装，但有些软件可能要手动编译，比如有些项目可能还需要安装 cppcheck、valgrind 等软件。</p><p>新的用于临时测试的（后面与上面的合并）  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; Dockerfile_new &lt;&lt;-EOF</span><br><span class="line">FROM latelee/jenkins:centos7</span><br><span class="line"></span><br><span class="line">### I changed jenkins.sh file</span><br><span class="line">COPY --chown=jenkins:jenkins --chmod=755 jenkins.sh /usr/local/bin/</span><br><span class="line">COPY --chown=jenkins:jenkins --chmod=755 myinit.sh /usr/local/bin/</span><br><span class="line">ADD usr.tar.bz2 /</span><br><span class="line"></span><br><span class="line">## add maven(note: jdk already in the image)</span><br><span class="line">ADD apache-maven-3.8.2-bin.tar.gz /usr/local/</span><br><span class="line"></span><br><span class="line">ENV MAVEN_HOME /usr/local/apache-maven-3.8.2</span><br><span class="line"></span><br><span class="line">ENV GOROOT /usr/local/go</span><br><span class="line">ENV GOBIN /usr/local/go/bin</span><br><span class="line">ENV GOPROXY https://goproxy.io,direct</span><br><span class="line"></span><br><span class="line"># seems cant pass $MAVEN_HOME here</span><br><span class="line">ENV PATH $PATH:/usr/local/apache-maven-3.8.2/bin:/usr/local/go/bin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ENV LD_LIBRARY_PATH $LD_LIBRARY_PATH:/usr/lib64/mysql/</span><br><span class="line"></span><br><span class="line">USER root</span><br><span class="line"></span><br><span class="line">## set my time</span><br><span class="line">RUN rm -rf /etc/localtime &amp;&amp; \</span><br><span class="line">    ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line"></span><br><span class="line">RUN ln -s /usr/lib64/libsqlite3.so.0 /usr/lib64/libsqlite3.so &amp;&amp; \</span><br><span class="line">trueln -s /usr/lib64/libcurl.so.4 /usr/lib64/libcurl.so &amp;&amp; \</span><br><span class="line">trueln -s /usr/lib64/libcrypto.so.10 /usr/lib64/libcrypto.so &amp;&amp; \</span><br><span class="line">trueln -s /usr/lib64/libuuid.so.1 /usr/lib64/libuuid.so &amp;&amp; \</span><br><span class="line">trueln -s /usr/lib64/libz.so.1 /usr/lib64/libz.so</span><br><span class="line"></span><br><span class="line"># drop back to the regular jenkins user - good practice</span><br><span class="line">USER jenkins</span><br><span class="line"></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker build -t latelee/jenkins:centos7_new -f Dockerfile_new .</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">cp -av --parents /usr/local/curl/ /tmp/dataserver_lib/</span><br><span class="line"></span><br><span class="line">cp -av --parents /usr/include/z* /tmp/dataserver_lib/</span><br><span class="line"></span><br><span class="line">cp -av --parents /usr/include/sqlite3* /tmp/dataserver_lib/</span><br><span class="line"></span><br><span class="line">cp -av --parents /usr/include/openssl/ /tmp/dataserver_lib/</span><br><span class="line"></span><br><span class="line">cp -av --parents /usr/lib64/mysql/ /tmp/dataserver_lib/</span><br><span class="line"></span><br><span class="line">scp -r  curl.tar.bz2 lijj@10.0.153.12:/tmp</span><br><span class="line"></span><br><span class="line">scp -r  include.tar.bz2 lijj@10.0.153.12:/tmp</span><br><span class="line"></span><br><span class="line">scp -r  usr.tar.bz2 lijj@10.0.153.12:/tmp</span><br><span class="line"></span><br><span class="line">LDFLAGS += -L/usr/lib64/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">链接：</span><br><span class="line">ln -s /usr/lib64/libsqlite3.so.0 /usr/lib64/libsqlite3.so</span><br><span class="line">ln -s /usr/lib64/libcurl.so.4 /usr/lib64/libcurl.so</span><br><span class="line">ln -s /usr/lib64/libcrypto.so.10 /usr/lib64/libcrypto.so</span><br><span class="line">ln -s /usr/lib64/libuuid.so.1 /usr/lib64/libuuid.so</span><br><span class="line">ln -s /usr/lib64/libz.so.1 /usr/lib64/libz.so</span><br><span class="line"></span><br><span class="line">echo &quot;/usr/lib64/mysql/&quot; &gt; /etc/ld.so.conf.d/mysql.conf</span><br><span class="line"></span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/lib64/mysql/</span><br></pre></td></tr></table></figure><h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>jenkins 控制台中文乱码，未解决。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文涉及一种根据实际需求定制 jenkins 镜像的方法及实践。其目的是在官方镜像基础上添加自定义软件、库，以便更加适应项目的开发情况。   &lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="http://www.latelee.org/category/docker/"/>
    
    
    <category term="docker" scheme="http://www.latelee.org/tag/docker/"/>
    
  </entry>
  
  <entry>
    <title>我的docker随笔35：jenkins服务部署</title>
    <link href="http://www.latelee.org/docker/docker-35-deploy-jenkins-server.html"/>
    <id>http://www.latelee.org/docker/docker-35-deploy-jenkins-server.html</id>
    <published>2021-08-09T16:00:00.000Z</published>
    <updated>2022-01-27T09:13:09.537Z</updated>
    
    <content type="html"><![CDATA[<p>本文涉及一种在容器中部署 jenkins 服务的方法，后续将其与 gitlab 配合以实现 CICD 功能。其目的是为了在实际工作中使用代码托管及自动化操作。  </p><span id="more"></span><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>因工作需要，需部署  jenkins 服务器进行测试。与网上几分钟即可部署的文章相比，本文更注重个人的实践记录。本文与前面的 gitlab 有一定的关联。</p><h2 id="二、技术小结"><a href="#二、技术小结" class="headerlink" title="二、技术小结"></a>二、技术小结</h2><ul><li>gitlab 有官方的 Docker 镜像。本文直接使用之。</li><li>使用 docker-compose 部署，指定端口。注意挂载 docker.socket文件。</li><li>首次登录会提示输入随机文件，一旦输入并设置成功后，不再提示。</li><li>各种配置慢慢补充。</li></ul><h2 id="三、部署gitlab服务"><a href="#三、部署gitlab服务" class="headerlink" title="三、部署gitlab服务"></a>三、部署gitlab服务</h2><h3 id="3-1-部署脚本"><a href="#3-1-部署脚本" class="headerlink" title="3.1 部署脚本"></a>3.1 部署脚本</h3><p>本文使用 docker-compose 部署，在测试阶段，使用了多个版本。此处是比较简单的版本，用于初次使用。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">jenkins:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">jenkins/jenkins:centos7</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">lljenkins</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="comment"># 使用主机的docker服务(因为要在jenkins容器中运行docker)</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">            <span class="comment"># 使用数据盘的目录作为jenkins的工作目录</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">$PWD/jenkins_home:/var/jenkins_home</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="comment"># 端口映射</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;9999:8080&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;50000:50000&quot;</span></span><br><span class="line">        <span class="attr">networks:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">llgitlab-net</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">    <span class="attr">llgitlab-net:</span></span><br><span class="line">        <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure><p>注意几点：</p><ul><li>脚本中指定了<code>docker.sock</code>的路径，后续可以在jenkins用docker构建。</li><li>jenkins 数据目录在本目录下的<code>jenkins_home</code>目录，其权限修改为1000，命令为<code>sudo chown -R 1000 jenkins_home</code>。</li><li>根据实际环境，选择了 centos7 版本的 jenkins。</li></ul><h3 id="3-2-运行"><a href="#3-2-运行" class="headerlink" title="3.2 运行"></a>3.2 运行</h3><p>运行命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>注：jenkins 的启动比 gitlab 快很多。  </p><p>停止命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose down</span><br></pre></td></tr></table></figure><p>运行过程中会出现初始密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Jenkins initial setup is required. An admin user has been created and a password generated.</span><br><span class="line">Please use the following password to proceed to installation:</span><br><span class="line"></span><br><span class="line">c4365f900e554ff5b8885d8c2975929b</span><br><span class="line"></span><br><span class="line">This may also be found at: /var/jenkins_home/secrets/initialAdminPassword</span><br><span class="line"></span><br><span class="line">*************************************************************</span><br></pre></td></tr></table></figure><h2 id="四、初次配置"><a href="#四、初次配置" class="headerlink" title="四、初次配置"></a>四、初次配置</h2><p>服务启动后，需要进行必要的配置，因此在本文一并给出。</p><h3 id="4-1-登录"><a href="#4-1-登录" class="headerlink" title="4.1 登录"></a>4.1 登录</h3><p>初次登录时，会提示输入管理员密码，如图1所示：</p><p><img src="/docker/docker-35-deploy-jenkins-server/1.png" alt="image-20210804094456510"></p><p>在 docker 启动时出现有密码，也可以直接在页面所示文件中找到。</p><h3 id="4-2-安装插件："><a href="#4-2-安装插件：" class="headerlink" title="4.2 安装插件："></a>4.2 安装插件：</h3><p><img src="/docker/docker-35-deploy-jenkins-server/2.png" alt="image-20210804094542706"><br>选右侧自定义安装，注：默认也勾选了部分插件。</p><p>安装过程图示：</p><p><img src="/docker/docker-35-deploy-jenkins-server/3.png" alt="image-20210804094924177"></p><p>注：笔者在实践中，遇到不可抗拒因素，导致网络不稳定，经常安装不成功，如果尝试多次失败，可以跳过不安装。</p><h2 id="五、一些配置"><a href="#五、一些配置" class="headerlink" title="五、一些配置"></a>五、一些配置</h2><h3 id="5-1-git-仓库地址问题"><a href="#5-1-git-仓库地址问题" class="headerlink" title="5.1 git 仓库地址问题"></a>5.1 git 仓库地址问题</h3><p>配置了项目，构建，提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stderr: error: RPC failed; result=22, HTTP code = 404</span><br></pre></td></tr></table></figure><p>原因及解决：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在设置项目git地址时，必须添加`.git`后缀，否则地址不认。</span><br></pre></td></tr></table></figure><h3 id="5-2-Publish-over-SSH"><a href="#5-2-Publish-over-SSH" class="headerlink" title="5.2 Publish over SSH"></a>5.2 Publish over SSH</h3><p>在插件管理界面中搜索<code>Publish Over SSH</code>，并安装之。</p><p>在配置界面中进行配置。如下：</p><p><img src="/docker/docker-35-deploy-jenkins-server/4.png" alt="image-20210829112839117"></p><p>注：需测试是否能正常连接。</p><p>在具体项目构建后操作添加Send build artifacts over SSH<code>。源文件如果带路径的话，默认情况目标目录也带有。比如源文件为</code>taget/a.out<code>，目标目录为</code>/tmp<code>，则目标文件路径为</code>/tmp/target/a.out`。  </p><h3 id="5-3-邮件通知"><a href="#5-3-邮件通知" class="headerlink" title="5.3 邮件通知"></a>5.3 邮件通知</h3><p>本节使用腾讯企业邮件测试（感谢腾讯为个人域名提供免费的邮箱服务）。此为前提。</p><p>使用插件<code>Email Extension Plugin</code>，在插件管理页面搜索，确认是否安装：</p><p><img src="/docker/docker-35-deploy-jenkins-server/image-20210916003759787.png" alt="image-20210916003759787"></p><p>系统管理-&gt;系统配置。</p><p>设置系统管理员邮件地址：</p><p><img src="/docker/docker-35-deploy-jenkins-server/image-20210916085303466.png" alt="image-20210916085303466"></p><h4 id="第三方邮件通知插件"><a href="#第三方邮件通知插件" class="headerlink" title="第三方邮件通知插件"></a>第三方邮件通知插件</h4><p><img src="/docker/docker-35-deploy-jenkins-server/image-20210916090427313.png" alt="image-20210916090427313"></p><p>触发条件：</p><p><img src="/docker/docker-35-deploy-jenkins-server/image-20210916091126192.png" alt="image-20210916091126192"></p><p>再设置邮件模板。</p><p>修改默认标题（Default Subject），示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$PROJECT_NAME - Build # $BUILD_NUMBER - $BUILD_STATUS!</span><br><span class="line">$PROJECT_NAME - Build # $BUILD_NUMBER - $BUILD_STATUS:</span><br><span class="line">$PROJECT_NAME 项目第 # $BUILD_NUMBER 次构建 - $BUILD_STATUS</span><br></pre></td></tr></table></figure><p>修改默认内容（Default Content），根据网上资料修改的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">$PROJECT_NAME 项目第 # $BUILD_NUMBER 次构建 - $BUILD_STATUS</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;PROJECT_NAME 第 # $BUILD_NUMBER 次构建 - $BUILD_STATUS&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body leftmargin=&quot;8&quot; marginwidth=&quot;0&quot; topmargin=&quot;8&quot; marginheight=&quot;4&quot;</span><br><span class="line">    offset=&quot;0&quot;&gt;</span><br><span class="line">    &lt;table width=&quot;95%&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;  style=&quot;font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif&quot;&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            本邮件由系统自动发出，无需回复！&lt;br/&gt;</span><br><span class="line">            $&#123;PROJECT_NAME &#125; 项目构建信息如下&lt;/br&gt;</span><br><span class="line">            &lt;td&gt;&lt;font color=&quot;#CC0000&quot;&gt;构建结果 - $&#123;BUILD_STATUS&#125;&lt;/font&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;&lt;br /&gt;</span><br><span class="line">            &lt;b&gt;&lt;font color=&quot;#0B610B&quot;&gt;构建信息&lt;/font&gt;&lt;/b&gt;</span><br><span class="line">            &lt;hr size=&quot;2&quot; width=&quot;100%&quot; align=&quot;center&quot; /&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                    &lt;li&gt;项目名称 ： $&#123;PROJECT_NAME&#125;&lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;构建编号 ： 第$&#123;BUILD_NUMBER&#125;次构建&lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;触发原因： $&#123;CAUSE&#125;&lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;构建状态： $&#123;BUILD_STATUS&#125;&lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;构建日志： &lt;a href=&quot;$&#123;BUILD_URL&#125;console&quot;&gt;$&#123;BUILD_URL&#125;console&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;构建  Url ： &lt;a href=&quot;$&#123;BUILD_URL&#125;&quot;&gt;$&#123;BUILD_URL&#125;&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;工作目录 ： &lt;a href=&quot;$&#123;PROJECT_URL&#125;ws&quot;&gt;$&#123;PROJECT_URL&#125;ws&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;项目  Url ： &lt;a href=&quot;$&#123;PROJECT_URL&#125;&quot;&gt;$&#123;PROJECT_URL&#125;&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                &lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">                &lt;font color=&quot;#0B610B&quot;&gt;最近提交(#$SVN_REVISION)&lt;/font&gt;</span><br><span class="line">                &lt;hr size=&quot;2&quot; width=&quot;100%&quot; /&gt;</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                $&#123;CHANGES_SINCE_LAST_SUCCESS, reverse=true, format=&quot;%c&quot;, changesFormat=&quot;&lt;li&gt;%d [%a] %m&lt;/li&gt;&quot;&#125;</span><br><span class="line">                &lt;/ul&gt;</span><br><span class="line">                详细提交: &lt;a href=&quot;$&#123;PROJECT_URL&#125;changes&quot;&gt;$&#123;PROJECT_URL&#125;changes&lt;/a&gt;&lt;br/&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>构建日志：<code>$&#123;BUILD_LOG, maxLines=100&#125;</code></p><h4 id="自带邮件通知插件"><a href="#自带邮件通知插件" class="headerlink" title="自带邮件通知插件"></a>自带邮件通知插件</h4><p>在“邮件通知”处添加 SMTP 服务器，此处为<code>smtp.exmail.qq.com</code>。点击<strong>高级</strong>，设置邮件账号和密码，勾选”SSL协议“、”使用 TLS“，端口设置为465。</p><p><img src="/docker/docker-35-deploy-jenkins-server/image-20210916085725950.png" alt="image-20210916085725950"></p><p>最后进行邮件发送的测试，输入接收者邮箱，点击测试即可。提示<code>Email was successfully sent</code>表示发送成功。</p><p><img src="/docker/docker-35-deploy-jenkins-server/image-20210916085826846.png" alt="image-20210916085826846"></p><p>邮件接收：</p><p><img src="/docker/docker-35-deploy-jenkins-server/image-20210916090144129.png" alt="image-20210916090144129"></p><blockquote><p>注：#10表示是第10次发送，表示点击测试的次数——包括失败的。</p></blockquote><p>发送测试邮件出错及解决方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">com.sun.mail.smtp.SMTPSenderFailedException: 501 mail from address must be same as authorization user</span><br><span class="line">解决：</span><br><span class="line">Jenkins管理员邮箱与此处设置的发送者邮箱保持一致。</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">javax.mail.MessagingException: Got bad greeting from SMTP host: smtp.exmail.qq.com, port: 465, response: [EOF]</span><br><span class="line">原因：勾选`使用SSL协议`。</span><br></pre></td></tr></table></figure><p>某次发送提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sending email for trigger: Always</span><br><span class="line">Not sending mail to unregistered user li@latelee.org because your SCM claimed this was associated with a user ID ?li&#x27; which your security realm does not recognize; you may need changes in your SCM plugin</span><br><span class="line">Sending email to: li@latelee.org</span><br></pre></td></tr></table></figure><p>结论：看信息是发送不成功，但能接收邮件，暂时不管。  </p><p>MORE TODO……</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文涉及一种在容器中部署 jenkins 服务的方法，后续将其与 gitlab 配合以实现 CICD 功能。其目的是为了在实际工作中使用代码托管及自动化操作。  &lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="http://www.latelee.org/category/docker/"/>
    
    
    <category term="docker" scheme="http://www.latelee.org/tag/docker/"/>
    
  </entry>
  
  <entry>
    <title>我的docker随笔34：gitlab服务部署</title>
    <link href="http://www.latelee.org/docker/docker-34-deploy-gitlab-server.html"/>
    <id>http://www.latelee.org/docker/docker-34-deploy-gitlab-server.html</id>
    <published>2021-08-08T16:00:00.000Z</published>
    <updated>2022-01-27T09:13:09.533Z</updated>
    
    <content type="html"><![CDATA[<p>本文涉及一种在容器中部署 gitlab 服务的方法，并结合其自带的 gitlab-runner 实现 CICD 功能。其目的是为了在实际工作中使用代码托管及自动化操作。  </p><span id="more"></span><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>因工作需要，需部署 gitlab 服务器进行数据测试。与网上几分钟即可部署的文章相比，本文更注重个人的实践记录，故不会完整地将过程记录下来。</p><h2 id="二、技术小结"><a href="#二、技术小结" class="headerlink" title="二、技术小结"></a>二、技术小结</h2><ul><li>gitlab 有官方的 Docker 镜像。</li><li>建议将数据和配置目录映射到主机上，方便编辑和备份。</li><li>如果使用非默认端口，需要配置自定义端口。</li><li>在首次登录时，需要设置 root 密码，后面不再出现此提示，因此需记住密码。</li><li>gitlab-runner本文未有深入研究，等后续有时间再着手。</li></ul><h2 id="三、部署gitlab服务"><a href="#三、部署gitlab服务" class="headerlink" title="三、部署gitlab服务"></a>三、部署gitlab服务</h2><h3 id="3-1-部署脚本"><a href="#3-1-部署脚本" class="headerlink" title="3.1 部署脚本"></a>3.1 部署脚本</h3><p>本文使用 docker-compose 部署，在测试阶段，使用了多个版本。</p><p>版本一，使用默认端口，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">llgitlab:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">gitlab/gitlab-ce:13.10.0-ce.0</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">llgitlab</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./gitlab_data/config:/etc/gitlab</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./gitlab_data/logs:/var/log/gitlab</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./gitlab_data/data:/var/opt/gitlab</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;8888:80&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;8443:443&quot;</span></span><br><span class="line">            <span class="comment">#- &quot;2222:22&quot;</span></span><br><span class="line">        <span class="attr">hostname:</span> <span class="string">&quot;10.0.10.11&quot;</span></span><br><span class="line">        <span class="comment">#command: /assets/wrapper</span></span><br><span class="line">        <span class="attr">networks:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">llgitlab-net</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">    <span class="attr">llgitlab-net:</span></span><br><span class="line">        <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure><p>脚本中将配置目录和数据目录映射到主机当前目录的<code>gitlab_data</code>目录，方便后续修改。对外提供<code>8888</code>端口。由于部署环境为内网，故设置<code>hostname</code>为部署机器的<code>IP</code>。</p><p>版本二，修改端口：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">llgitlab:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">gitlab/gitlab-ce:13.10.0-ce.0</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">llgitlab</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./gitlab_data/config:/etc/gitlab</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./gitlab_data/logs:/var/log/gitlab</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./gitlab_data/data:/var/opt/gitlab</span></span><br><span class="line">        <span class="attr">environment:</span></span><br><span class="line">            <span class="attr">TZ:</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line">            <span class="attr">GITLAB_OMNIBUS_CONFIG:</span> <span class="string">|</span></span><br><span class="line"><span class="string">                external_url &#x27;http://10.0.153.12:8888&#x27;</span></span><br><span class="line"><span class="string">                nginx[&#x27;listen_port&#x27;]=8888</span></span><br><span class="line"><span class="string">                gitlab_rails[&#x27;gitlab_shell_ssh_port&#x27;]=8822</span></span><br><span class="line"><span class="string">                gitlab_rails[&#x27;time_zone&#x27;]=&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line"><span class="string"></span>        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;8888:8888&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;8443:443&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;8822:8822&quot;</span></span><br><span class="line">        <span class="attr">hostname:</span> <span class="string">&quot;10.0.153.12&quot;</span></span><br><span class="line">        <span class="attr">networks:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">llgitlab-net</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">    <span class="attr">llgitlab-net:</span></span><br><span class="line">        <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure><p>注意几点：</p><ul><li>git 的访问方式，http默认为80，ssh默认为22，版本一未修改，但主机做了映射，此版本将 gitlab 默认端口修改了，分别为8888和8822，再将其映射到相同的主机端口。</li><li>使用 GITLAB_OMNIBUS_CONFIG 环境变量进行一些参数的修改，相当于修改容器内的<code>/etc/gitlab/gitlab.rb</code>文件（当然，本文已经将目录映射到主机上了）。<code>external_url</code>从名称上看，其必须为一个 url 地址，可以是IP或域名，但不能是单纯的 IP，本文加了端口。  </li><li>当已经存在了本地数据时，使用 GITLAB_OMNIBUS_CONFIG 修改参数，也会生效。比如原先没有修改端口，修改端口后重启容器，即可生效。</li><li>虽然设置了 TZ，容器的时间也为 CST，但查看 gitlab 的日志，依旧使用 UTC 时间。或许是一个特性。</li><li>hostname 不能加端口。</li><li></li></ul><h3 id="3-2-运行"><a href="#3-2-运行" class="headerlink" title="3.2 运行"></a>3.2 运行</h3><p>运行命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>注意：启动耗时较长，大概数分钟（笔者使用性能较强的服务器测试，也要3~4分钟），需耐心等待。</p><p>停止命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose down</span><br></pre></td></tr></table></figure><p>初次登录时，会提示设置管理员<code>root</code>密码，如图1所示：</p><p><img src="/docker/docker-34-deploy-gitlab-server/1.png"></p><p>设置完毕后需重新登录。在首页可以看到注册的提醒。默认开放注册，但需管理员确认，如内部使用，则该功能可去掉。如图2所示。</p><p><img src="/docker/docker-34-deploy-gitlab-server/2.png"></p><p>默认情况下，新用户注册，会有如图3的提示：</p><p><img src="/docker/docker-34-deploy-gitlab-server/3.png"></p><p>至此，已经将 gitlab 部署完毕，且已可正常使用。  如使用其 CICD 功能，则需要继续部署 gitlab-runner。</p><h2 id="四、gitlab-runner"><a href="#四、gitlab-runner" class="headerlink" title="四、gitlab-runner"></a>四、gitlab-runner</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>使用管理员登录 gitlab，并获取token，如图4所示：</p><p><img src="/docker/docker-34-deploy-gitlab-server/4.png"></p><p>图4右侧给出了URL地址以及 token，后续将使用到。  </p><p>准备docker-compose文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">llgitlab:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">gitlab/gitlab-ce:13.10.0-ce.0</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">llgitlab</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./gitlab_data/config:/etc/gitlab</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./gitlab_data/logs:/var/log/gitlab</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./gitlab_data/data:/var/opt/gitlab</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;8888:80&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;8443:443&quot;</span></span><br><span class="line">            <span class="comment">#- &quot;2222:22&quot;</span></span><br><span class="line">        <span class="attr">hostname:</span> <span class="string">&quot;10.0.153.12&quot;</span></span><br><span class="line">        <span class="comment">#command: /assets/wrapper</span></span><br><span class="line">        <span class="attr">networks:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">llgitlab-net</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">llgitlab-runner:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">gitlab/gitlab-runner:alpine-v13.10.0</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">llgitlab-runner</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./gitlab-runner/config:/etc/gitlab-runner</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">        <span class="attr">depends_on:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">llgitlab</span></span><br><span class="line">        <span class="attr">networks:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">llgitlab-net</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">    <span class="attr">llgitlab-net:</span></span><br><span class="line">        <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure><p>注意， gitlab-runner 和 gitlab 版本应相近。</p><p>注意，此时查看gitlab-runner容器，会不断提示 config.toml找不到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Runtime platform                                    arch=amd64 os=linux pid=7 revision=54944146 version=13.10.0</span><br><span class="line">Starting multi-runner from /etc/gitlab-runner/config.toml...  builds=0</span><br><span class="line">Running in system-mode.                            </span><br><span class="line">                                                   </span><br><span class="line">Configuration loaded                                builds=0</span><br><span class="line">listen_address not defined, metrics &amp; debug endpoints disabled  builds=0</span><br><span class="line">[session_server].listen_address not defined, session endpoints disabled  builds=0</span><br><span class="line">ERROR: Failed to load config stat /etc/gitlab-runner/config.toml: no such file or directory  builds=0</span><br><span class="line">ERROR: Failed to load config stat /etc/gitlab-runner/config.toml: no such file or directory  builds=0</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>因为未注册原故。注册方法有2种，一是根据提示一一填写，二是直接指定参数。</p><p>手动注册：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -it -v $PWD/gitlab-runner/config:/etc/gitlab-runner gitlab/gitlab-runner:alpine-v13.10.0 register</span><br><span class="line">之后出现提示，根据提示填写内容</span><br><span class="line">下面是示例</span><br><span class="line">Runtime platform                                    arch=amd64 os=linux pid=7 revision=54944146 version=13.10.0</span><br><span class="line">Running in system-mode.                            </span><br><span class="line">                                                   </span><br><span class="line">Enter the GitLab instance URL (for example, https://gitlab.com/):</span><br><span class="line">http://10.0.153.12:8888/</span><br><span class="line">Enter the registration token:</span><br><span class="line">FXKUC2HtxFuICBC9961024</span><br><span class="line">Enter a description for the runner:</span><br><span class="line">[a2d8dbc3c305]: my-gitlab-runner</span><br><span class="line">Enter tags for the runner (comma-separated):</span><br><span class="line">gitlab</span><br><span class="line">Registering runner... succeeded                     runner=FXKUC2H</span><br><span class="line">Enter an executor: parallels, virtualbox, docker+machine, docker-ssh+machine, custom, docker, docker-ssh, shell, ssh, kubernetes:</span><br><span class="line">docker</span><br><span class="line">Enter the default Docker image (for example, ruby:2.6):</span><br><span class="line">latelee/ubuntu</span><br><span class="line">Runner registered successfully. Feel free to start it, but if it&#x27;s running already the config should be automatically reloaded! </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>直接指定参数注册。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -v $PWD/gitlab-runner/config:/etc/gitlab-runner gitlab/gitlab-runner:alpine-v13.10.0 register \</span><br><span class="line">  --non-interactive \</span><br><span class="line">  --executor &quot;docker&quot; \</span><br><span class="line">  --docker-image latelee/ubuntu \</span><br><span class="line">  --url &quot;http://10.0.153.12:8888/&quot; \</span><br><span class="line">  --registration-token &quot;FXKUC2HtxFuICBC9961024&quot; \</span><br><span class="line">  --description &quot;docker-runner&quot; \</span><br><span class="line">  --tag-list &quot;docker,aws&quot; \</span><br><span class="line">  --run-untagged=&quot;true&quot; \</span><br><span class="line">  --locked=&quot;false&quot; \</span><br><span class="line">  --access-level=&quot;not_protected&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>生成的配置在<code>/etc/gitlab-runner/config.toml</code>文件。  </p><p>说明：</p><ul><li>运行器 executor 选择 docker 即可，镜像使用自建的 latelee/ubuntu， 方便后续添加软件。</li></ul><p>成功后，在 Runners 界面（与图4为同一界面）可以看到已注册的实例，如图5所示。</p><p><img src="/docker/docker-34-deploy-gitlab-server/5.png"></p><p>注意，注册之后，还是可以再编辑文件<code>gitlab-runner/config/config.toml</code>的，但需要重启容器。</p><p>过程记录</p><p>管理员登录，在<code>Runners</code>中找到项目，绑定到指定<code>runner</code>。（存疑：只有一个runner，是否不需要一一绑定项目？太麻烦了）</p><p>设置好 ci 脚本，提交，提示<code>This job is stuck, because the project doesn‘t have any runners online assigned to it. </code>。解决：在<code>Settings</code>-&gt;<code>CI/CD</code>找到对应的<code>runner</code>，将<code>Indicates whether this runner can pick jobs without tags</code>打勾。</p><p>执行 CI 后，提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fatal: repository &#x27;http://10.0.153.12/latelee/ci_test.git/&#x27; not found</span><br><span class="line">ERROR: Job failed: exit code 1</span><br></pre></td></tr></table></figure><p>原因：仓库带端口，但此处没有，何解？</p><h3 id="遗留问题-思考"><a href="#遗留问题-思考" class="headerlink" title="遗留问题/思考"></a>遗留问题/思考</h3><p>如果切换 gitlab，如果更新或添加？——由于是 docker 部署，在测试阶段容易重新启动新的 gitlab 服务。  </p><h2 id="五、进阶配置"><a href="#五、进阶配置" class="headerlink" title="五、进阶配置"></a>五、进阶配置</h2><p>这里列出一些配置，有空再研究</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 这个是针对请求钩子的,还有针对Git的这些</span><br><span class="line">gitlab_rails[&#x27;webhook_timeout&#x27;] = 60 #默认是10s</span><br><span class="line"></span><br><span class="line"># 若是大体都需要求延长的,可以配置全局,后者是进程数</span><br><span class="line">unicorn[&#x27;worker_timeout&#x27;] = 100</span><br><span class="line">unicorn[&#x27;worker_processes&#x27;] = 8</span><br><span class="line"></span><br><span class="line"># gitlab_rails[&#x27;smtp_enable&#x27;] = true</span><br><span class="line"># gitlab_rails[&#x27;smtp_address&#x27;] = &quot;smtp.exmail.qq.com&quot;</span><br><span class="line"># gitlab_rails[&#x27;smtp_port&#x27;] = 465</span><br><span class="line"># gitlab_rails[&#x27;smtp_user_name&#x27;] = &quot;xxxx@xx.com&quot;</span><br><span class="line"># gitlab_rails[&#x27;smtp_password&#x27;] = &quot;password&quot;</span><br><span class="line"># gitlab_rails[&#x27;smtp_authentication&#x27;] = &quot;login&quot;</span><br><span class="line"># gitlab_rails[&#x27;smtp_enable_starttls_auto&#x27;] = true</span><br><span class="line"># gitlab_rails[&#x27;smtp_tls&#x27;] = true</span><br><span class="line"># gitlab_rails[&#x27;gitlab_email_from&#x27;] = &#x27;xxxx@xx.com&#x27;</span><br><span class="line"></span><br><span class="line">gitlab_rails[&#x27;smtp_enable&#x27;] = true</span><br><span class="line">        gitlab_rails[&#x27;smtp_address&#x27;] = &quot;smtpdm.aliyun.com&quot;</span><br><span class="line">        gitlab_rails[&#x27;smtp_port&#x27;] = 465</span><br><span class="line">        gitlab_rails[&#x27;smtp_user_name&#x27;] = &quot;crperx@aliyun.com&quot;</span><br><span class="line">        gitlab_rails[&#x27;smtp_password&#x27;] = &quot;Qwe456jkl?Asd789iop?&quot;</span><br><span class="line">        gitlab_rails[&#x27;smtp_domain&#x27;] = &quot;smtpdm.aliyun.com&quot;</span><br><span class="line">        gitlab_rails[&#x27;smtp_authentication&#x27;] = &quot;login&quot;</span><br><span class="line">        gitlab_rails[&#x27;smtp_enable_starttls_auto&#x27;] = true</span><br><span class="line">        gitlab_rails[&#x27;smtp_tls&#x27;] = true</span><br><span class="line">        gitlab_rails[&#x27;gitlab_email_enabled&#x27;] = true</span><br><span class="line">        gitlab_rails[&#x27;gitlab_email_from&#x27;] = &#x27;crperx@aliyun.com&#x27;</span><br><span class="line">        gitlab_rails[&#x27;gitlab_email_display_name&#x27;] = &#x27;noreply@aliyun.com&#x27;</span><br><span class="line">        gitlab_rails[&#x27;gitlab_shell_ssh_port&#x27;] = 22</span><br><span class="line">        user[&#x27;git_user_email&#x27;] = &quot;crperx@aliyun.com&quot;</span><br><span class="line">        nginx[&#x27;enable&#x27;] = true</span><br><span class="line">        nginx[&#x27;client_max_body_size&#x27;] = &#x27;250m&#x27;</span><br><span class="line">        nginx[&#x27;redirect_http_to_https&#x27;] = true</span><br><span class="line">        nginx[&#x27;ssl_certificate&#x27;] = &quot;/etc/gitlab/ssl/gitlab.crt&quot;</span><br><span class="line">        nginx[&#x27;ssl_certificate_key&#x27;] = &quot;/etc/gitlab/ssl/gitlab.key&quot;</span><br><span class="line">        nginx[&#x27;ssl_ciphers&#x27;] = &quot;ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256&quot;</span><br><span class="line">        nginx[&#x27;ssl_prefer_server_ciphers&#x27;] = &quot;on&quot;</span><br><span class="line">        nginx[&#x27;ssl_protocols&#x27;] = &quot;TLSv1.1 TLSv1.2&quot;</span><br><span class="line">        nginx[&#x27;ssl_session_cache&#x27;] = &quot;builtin:1000  shared:SSL:10m&quot;</span><br><span class="line">        nginx[&#x27;listen_addresses&#x27;] = [&quot;0.0.0.0&quot;]</span><br><span class="line">        nginx[&#x27;http2_enabled&#x27;] = true</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.gitlab.com/runner/register/index.html#docker">https://docs.gitlab.com/runner/register/index.html#docker</a>  </p><p><a href="https://docs.gitlab.com/runner/install/docker.html">https://docs.gitlab.com/runner/install/docker.html</a></p><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>使用默认端口时，gitlab 仓库下载地址示例：</p><p><img src="/docker/docker-34-deploy-gitlab-server/10.png" alt="image-20210715100826319"></p><p>容器内部改了端口并做了映射，相应的下载地址示例：</p><p><img src="/docker/docker-34-deploy-gitlab-server/11.png" alt="image-20210715100243798"></p><h2 id="构建基础镜像"><a href="#构建基础镜像" class="headerlink" title="构建基础镜像"></a>构建基础镜像</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc gcc-c++ kernel-devel make bzip2 -y</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文涉及一种在容器中部署 gitlab 服务的方法，并结合其自带的 gitlab-runner 实现 CICD 功能。其目的是为了在实际工作中使用代码托管及自动化操作。  &lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="http://www.latelee.org/category/docker/"/>
    
    
    <category term="docker" scheme="http://www.latelee.org/tag/docker/"/>
    
  </entry>
  
</feed>
