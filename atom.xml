<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>迟思堂随笔</title>
  
  <subtitle>李迟的技术主页</subtitle>
  <link href="http://www.latelee.org/atom.xml" rel="self"/>
  
  <link href="http://www.latelee.org/"/>
  <updated>2021-10-20T16:10:49.098Z</updated>
  <id>http://www.latelee.org/</id>
  
  <author>
    <name>李迟</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>李迟2021年9月知识总结</title>
    <link href="http://www.latelee.org/my-library/code-for-2021-09.html"/>
    <id>http://www.latelee.org/my-library/code-for-2021-09.html</id>
    <published>2021-09-30T15:40:00.000Z</published>
    <updated>2021-10-20T16:10:49.098Z</updated>
    
    <content type="html"><![CDATA[<p>本文为 2021 年 9 月知识总结。</p><span id="more"></span><h2 id="研发编码"><a href="#研发编码" class="headerlink" title="研发编码"></a>研发编码</h2><h3 id="C-C"><a href="#C-C" class="headerlink" title="C / C++"></a>C / C++</h3><p>无。</p><h3 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h3><p>跟时间转换有关的几个片段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   exTime := &quot;20210901&quot;</span><br><span class="line">   mytime, _ := time.Parse(&quot;20060102&quot;, exTime)</span><br><span class="line">   fmt.Println(mytime.UTC().Unix(), mytime.Local().Unix())</span><br><span class="line">   </span><br><span class="line">   // 用本地时间格式转</span><br><span class="line">   mytime, _ = time.ParseInLocation(&quot;20060102&quot;, exTime, time.Local)</span><br><span class="line">   fmt.Println(mytime.UTC().Unix(), mytime.Local().Unix())</span><br><span class="line">   </span><br><span class="line">   exTime = &quot;2020-09-17T20:00:27&quot;</span><br><span class="line">   // 时间有2个格式，这里都判断一下</span><br><span class="line">mytime, _ := time.Parse(&quot;2006-01-02 15:04:05&quot;, exTime)</span><br><span class="line">themonth := int(mytime.Month())</span><br><span class="line">// 如果不合法，年月日均为1</span><br><span class="line">if mytime.Year() == 1 &amp;&amp; themonth == 1 &amp;&amp; mytime.Day() == 1 &#123;</span><br><span class="line">truemytime, _ = time.Parse(&quot;2006-01-02T15:04:05&quot;, exTime)</span><br><span class="line">truethemonth = int(mytime.Month())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>golang 转换时间时，时间模板的数值是固定的，必须为<code>2006-01-02T15:04:05</code>中的对应数值，但间隔的字符可以变化，如示例中的<code>20060102</code>。指定时间字符串转换为时间戳时，使用<code>ParseInLocation</code>函数，指定<code>time.Local</code>，否则转换出来的值会加上时区（如东八区）。  </p><p>执行外部命令代码片段：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">删除进程：</span><br><span class="line">appname := &quot;./httpforward_back.exe&quot;</span><br><span class="line">port := 9000</span><br><span class="line">exec.Command(&quot;sh&quot;, &quot;-c&quot;, fmt.Sprintf(&quot;pkill -SIGINT %s&quot;, appname[2:])).Output()</span><br><span class="line">启动进程：</span><br><span class="line">cmd := exec.Command(&quot;sh&quot;, &quot;-c&quot;, fmt.Sprintf(&quot;%s -p %d -i \&quot;run in port %d\&quot; &amp;&quot;, appname, port, port))</span><br><span class="line">err := cmd.Start()</span><br></pre></td></tr></table></figure><p>使用函数<code>exec.Command</code>执行命令时，前面2个的参数为<code>sh</code>和<code>-c</code>，如果不使用，则会出错。删除进程的命令使用<code>killall</code>也是可行的，在外网找了一些帖子，有提到用<code>pkill -SIGINT</code>，所以就用了。使用<code>Start</code>函数是启动进程，不会阻塞。如果要执行的命令需要返回值或等待其执行完毕，可使用<code>Run</code>函数。  </p><p>写文件的示例。<br>需求：在程序中自定义 nginx 的配置文件 nginx.conf 内容，根据参数，添加<code>location</code>中不同的 URL 和对应的 端口。<br>知识点：由于有特殊字符，故使用反引号，阅读和处理都方便。字符串组装使用<code>fmt.Sprintf</code>。调用<code>ioutil.WriteFile</code>写文件。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// 定义config字符串，一些不变的内容在此</span><br><span class="line">var config = `</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">truelog_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">truetruetruetruetruetrue&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">truetruetruetruetruetrue&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line">trueaccess_log  /var/opt/rh/rh-nginx116/log/nginx/access.log  main;</span><br><span class="line">truesendfile        on;</span><br><span class="line">truetcp_nopush      on;</span><br><span class="line">truetcp_nodelay     on;</span><br><span class="line">truekeepalive_timeout  65;</span><br><span class="line">trueserver &#123;</span><br><span class="line">truetruelisten       8080 default_server;</span><br><span class="line">truetruelisten       [::]:8080 default_server;</span><br><span class="line">truetrueserver_name  _;</span><br><span class="line">truetrueroot         /opt/app-root/src;</span><br><span class="line">truetrueinclude      /opt/app-root/etc/nginx.default.d/*.conf;</span><br><span class="line"></span><br><span class="line">truetruelocation / &#123;</span><br><span class="line">truetrue&#125;</span><br><span class="line">truetruelocation /foo/test9000 &#123;</span><br><span class="line">truetruetruefastcgi_pass 127.0.0.1:9000;</span><br><span class="line">truetruetruefastcgi_index index.cgi;</span><br><span class="line">truetruetruefastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">truetruetrueinclude fastcgi.conf;</span><br><span class="line">truetrue&#125;</span><br><span class="line">`</span><br><span class="line">    // 这是配置文件的结束符号</span><br><span class="line">trueconfigend := `</span><br><span class="line">    &#125;</span><br><span class="line">&#125;`</span><br><span class="line">    // 格式化 只针对 location 的地址和端口。</span><br><span class="line">    // 添加多个的话，按格式写即可</span><br><span class="line">trueurl := &quot;test9001&quot;</span><br><span class="line">trueport := 9001</span><br><span class="line">truetmpstr := fmt.Sprintf(`</span><br><span class="line">        location /foo/%s &#123;</span><br><span class="line">truetrue    fastcgi_pass 127.0.0.1:%d;</span><br><span class="line">truetrue    fastcgi_index index.cgi;</span><br><span class="line">truetrue    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">truetrue    include fastcgi.conf;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;`, url, port)</span><br><span class="line"></span><br><span class="line">trueconfig = config + tmpstr + configend</span><br><span class="line"></span><br><span class="line">trueklog.Println(&quot;write and reload nginx&quot;)</span><br><span class="line">trueioutil.WriteFile(&quot;/etc/nginx/nginx.conf&quot;, []byte(config), 0666)</span><br></pre></td></tr></table></figure><p>注：上述配置内容并不完整。  </p><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>在 Dockerfile 中设置环境变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ENV MAVEN_HOME /usr/local/apache-maven-3.8.2</span><br><span class="line"></span><br><span class="line">ENV GOROOT /usr/local/go</span><br><span class="line">ENV GOBIN /usr/local/go/bin</span><br><span class="line">ENV GOPROXY https://goproxy.io,direct</span><br><span class="line"></span><br><span class="line"># seems cant pass $MAVEN_HOME here</span><br><span class="line">ENV PATH $PATH:/usr/local/apache-maven-3.8.2/bin:/usr/local/go/bin</span><br></pre></td></tr></table></figure><p>注：在构建镜像中，观察输出日志，会将物理机的环境变量解析进来，如最后一行的 $PATH 会变为物理上的 $PATH 的具体值。如果使用 Dockerfile 定义的环境变量，似乎不生效。  </p><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h3 id="zip压缩"><a href="#zip压缩" class="headerlink" title="zip压缩"></a>zip压缩</h3><p>对于相同文件/目录，不同时间点用 zip 压缩，得到的 zip 文件，md5 值会不相同（时间间隔非常短则无此现象）。使用<code>-X -D</code>可解决，示例：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -qr -X -D c.zip hello/</span><br></pre></td></tr></table></figure><p>参考 <a href="https://stackoverflow.com/questions/19523063/zip-utility-giving-me-different-md5sum-every-time-in-linux">https://stackoverflow.com/questions/19523063/zip-utility-giving-me-different-md5sum-every-time-in-linux</a>     </p><h3 id="编码其它"><a href="#编码其它" class="headerlink" title="编码其它"></a>编码其它</h3><p>有些工程跟踪较麻烦，有些是因为条理性和逻辑性不够好，也有些是因为线索不明导致的。比如一个 C++ 类，某个业务处理示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ret = get(m_path);  // 使用成员变量m_path</span><br><span class="line">search_dir(m_path);  // 使用成员变量m_path</span><br><span class="line">mysort()    // 不带参数，函数内使用了前面赋值了的成员变量m_path，同时设置了成员变量m_file</span><br><span class="line">changedate(m_file) // 这里直接用m_file传参</span><br></pre></td></tr></table></figure><p>该示例的具体处理见上面的注释，从注释看是没问题，但是，单纯从函数调用及参数，是比较难看到逻辑的，需要跟踪每个函数及对应的成员变量才能理清数据流向。<br>对此，个人看法是：<br>如果类中有工具函数的话，不要使用类成员变量。<br>业务函数中，能从成员变量看到主线。或加上注释。    </p><h2 id="研发知识"><a href="#研发知识" class="headerlink" title="研发知识"></a>研发知识</h2><p>参考一些开源项目的 git 提交日志格式，分为“头部 正文 尾部”三部分。根据实际情况，自己整理一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">头部： 给出本次提交的类型及影响范围。如：格式修改 测试 重构 bug修正  （影响范围）</span><br><span class="line">正文： 描述本次提交的变化，可列表。</span><br><span class="line">尾部：一些备注或注意事项</span><br></pre></td></tr></table></figure><p>实际示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">头部         bug修正（时间同步模块）</span><br><span class="line">正文         时间同步模块减小时间差判断的阈值，避免波动。</span><br><span class="line">尾部（附录）   关闭#1</span><br></pre></td></tr></table></figure><h2 id="研发思考"><a href="#研发思考" class="headerlink" title="研发思考"></a>研发思考</h2><h3 id="适当时候做适当事"><a href="#适当时候做适当事" class="headerlink" title="适当时候做适当事"></a>适当时候做适当事</h3><p>当初想入门后台管理系统，选定 vue + golang 路线。查了很多资料，也下载了很多工程源码，发现学不进去。后来才发现是因为工程太复杂，并不适合新手。遂放弃，至今因其它事缘由，一直未能再动手写。<br>本月开始真正搞组织革新，jenkins 倒好，但 Java 只看了一点语法，工程是 springboot 的，在初期连 IDEA 工程也不懂建立，对于 jdk 那些 1.8、16等版本号也没理解。硬着头皮搞了几天才有点眉目。只感叹 IDEA 太强大了，Java 框架太多太成熟了。但就是因为太成熟了反而不喜欢研究，还是习惯 C++。   </p><h2 id="工作记录"><a href="#工作记录" class="headerlink" title="工作记录"></a>工作记录</h2><p>某工程有自定义的日志函数，有操作 sqlite3 数据库，等等。在设备突然断电再启动后，sqlite3 数据库文件被损坏，经查其二进制，竟然在某个偏移量出现了部分的日志。百思不解，一直未解决。实然没招，后使用 cppcheck 和 valgrind 检查，修正一些编码错误/警告。将没有实质用处的函数删除（调用了但没产生作用）。  </p><p>某工程需要兼容 32 位和 64 位，在 64 位系统中用<code>%ld</code>打印 uint64_t 类型变量，正常，在 32 位系统运行则报段错误，使用<code>%lld</code>打印，但在 64 位又出现警告，无奈，将 uint64_t 改为 long long 类型。幸好是在试点阶段发现，否则影响大了。  </p><p>某工程连接的主备系统两个 sftp 服务器，该工程下载 xml 文件并判断哪个系统的文件版本较新即下载之。后发现同一文件的 md5 值不同，导致不断下载。经查，发现该文件在不同时间打包压缩，即使内容无变化，但压缩的 zip 文件 md5 值变化了。经查，可以通过参数保持 md5 一致。因工程是其它小组负责且用 Java  实现，未知如何修改。  </p><p>某工程需下载远程服务器某个目录的文件，设置一 数组变量<code>char remoteFile[128]</code>，在之前一切安好，但最近切换备份系统后，中秋节前一晚，某生产环境出现错误，无法下载，造成堵车，运维同事联系紧急处理。经查，是因为切换后，远程目录文件长度超过 128 字节了，且只超过2~3字符。试点现场采用的服务器IP比较短（如<code>10.0.45.16</code>），未被发现，但有的服务器IP较长（如<code>10.100.168.231</code>），刚好超过几个字符，于是失败。定位原因后，将相关的变量大小改大，解决问题。  </p><p>参与了某路段开通的一些工作。初期，经工具检查发现某项数据不符合要求，与其它同事确认不影响，在试点测试时，另一服务器工具无法正常工作，数据未更新，问题在上线前2天被发现，并因此加班。<br>复盘后得到经验：与既定规则不符合的，多请教同事，并汇报领导（当初未坚持，也未上报）；参数修改，需多方参与评估（其他同事负责的）；生产环境需要有监控手段。     </p><h2 id="本月做的事及计划"><a href="#本月做的事及计划" class="headerlink" title="本月做的事及计划"></a>本月做的事及计划</h2><p>抽时间完成转发工具编写和测试，研究并实现了一些负载均衡算法。  </p><p>近来发现自己表达能力和思考能力下降了，计划看看非技术类的书。</p><h2 id="其它点滴"><a href="#其它点滴" class="headerlink" title="其它点滴"></a>其它点滴</h2><p>本月首次还贷，正式开始房奴生活。个人的开支须更加节约了。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文为 2021 年 9 月知识总结。&lt;/p&gt;</summary>
    
    
    
    <category term="我的程序代码" scheme="http://www.latelee.org/category/my-library/"/>
    
    
    <category term="代码积累" scheme="http://www.latelee.org/tag/%E4%BB%A3%E7%A0%81%E7%A7%AF%E7%B4%AF/"/>
    
    <category term="知识总结" scheme="http://www.latelee.org/tag/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>LiteOS调研</title>
    <link href="http://www.latelee.org/my-study/liteos-search.html"/>
    <id>http://www.latelee.org/my-study/liteos-search.html</id>
    <published>2021-09-27T16:00:00.000Z</published>
    <updated>2021-10-20T16:10:49.106Z</updated>
    
    <content type="html"><![CDATA[<p>LiteOS调研。  </p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><h3 id="附-源码"><a href="#附-源码" class="headerlink" title="附 源码"></a>附 源码</h3><p>旧版本  </p><p>2018.5.7 删除了GD32的移植指南。  可能是重构了工程，版本是V2。之前是V1.1.2版本。    </p><p>新版本  </p><p>参考的在<code>targets\GD32VF103V_EVAL</code></p><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><h4 id="Studio安装"><a href="#Studio安装" class="headerlink" title="Studio安装"></a>Studio安装</h4><p>安装包 HUAWEI-LiteOS-Studio-Setup-x64-xx。实际：<a href="https://gitee.com/LiteOS/LiteOS_Studio/releases/V1.45.9Beta">HUAWEI-LiteOS-Studio V1.45.9 Beta</a>  。  </p><p>中文包下载脚本 <a href="https://liteos.gitee.io/liteos_studio/scripts/extension_download.bat">https://liteos.gitee.io/liteos_studio/scripts/extension_download.bat</a><br>先安装studio，在里面选插件，再选中下载的插件，安装，官方有步骤。  </p><p>安装 stm32 插件。（用 qemu 模拟也要安装之）   </p><p>安装 base 插件。   </p><h4 id="gcc编译器"><a href="#gcc编译器" class="headerlink" title="gcc编译器"></a>gcc编译器</h4><p>安装arm-none-eabi软件。下载<a href="https://liteos.gitee.io/liteos_studio/scripts/GNU_Arm_Embedded_Toolchain_download.bat%E3%80%82">https://liteos.gitee.io/liteos_studio/scripts/GNU_Arm_Embedded_Toolchain_download.bat。</a><br>注：默认下载目录为<code>C:\Users\&lt;用户名&gt;\.huawei-liteos-studio</code>，因后续工程亦需要此目录，故直接使用，如没有，创建之。  </p><h4 id="make工具"><a href="#make工具" class="headerlink" title="make工具"></a>make工具</h4><p>下载 <a href="https://liteos.gitee.io/liteos_studio/scripts/x_pack_windows_build_tools_download.bat">https://liteos.gitee.io/liteos_studio/scripts/x_pack_windows_build_tools_download.bat</a> </p><p>注：不能使用其它的make工具，否则编译不成功。  </p><h4 id="QEMU工具"><a href="#QEMU工具" class="headerlink" title="QEMU工具"></a>QEMU工具</h4><p><a href="https://qemu.weilnetz.de/w64/2021/">https://qemu.weilnetz.de/w64/2021/</a><br>文件名：qemu-w64-setup-20210810.exe<br>需核查 sha512 值。<br>双击exe安装。</p><h2 id="入门实例"><a href="#入门实例" class="headerlink" title="入门实例"></a>入门实例</h2><p>参考：<a href="https://liteos.gitee.io/liteos_studio/#/project_stm32">https://liteos.gitee.io/liteos_studio/#/project_stm32</a>  里面有注意事项。<br>注意要联网。   </p><h3 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h3><p><img src="/my-study/liteos-search/image-20210930154123068.png" alt="image-20210930154123068"></p><p>之后自动下载。提示：<br><img src="/my-study/liteos-search/image-20210930154147598.png" alt="image-20210930154147598"></p><p>下载完后自动打开工程。如无，手动打开。  </p><p><strong>自注： 似乎是把 liteos 整个源码下载了。与默认的仓库文件相比，一些配置修改了。</strong>  </p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>点击齿轮图标<img src="/my-study/liteos-search/image-20210930155319439.png" alt="image-20210930155319439">，快捷键F4配置工程。  </p><p><img src="/my-study/liteos-search/image-20210930155813140.png" alt="image-20210930155813140"></p><p><img src="/my-study/liteos-search/image-20210930162507159.png" alt="image-20210930162507159"></p><p><img src="/my-study/liteos-search/image-20210930162516870.png" alt="image-20210930162516870"></p><p><img src="/my-study/liteos-search/image-20210930162526416.png" alt="image-20210930162526416"></p><p>注：如果默认没有的目标板，也可以手动添加，一般基于某些芯片修改。<br>注：工程源码映射那个地方，暂未搞明白。  </p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>按编译图标，快捷键为F7，成功提示：</p><p>编译成功提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arm-none-eabi-objdump -d d:/project/LiteOS/demo/out/realview-pbx-a9/Huawei_LiteOS.elf &gt;d:/project/LiteOS/demo/out/realview-pbx-a9/Huawei_LiteOS.asm</span><br><span class="line">arm-none-eabi-size d:/project/LiteOS/demo/out/realview-pbx-a9/Huawei_LiteOS.elf</span><br><span class="line">   text    data     bss     dec     hex filename</span><br><span class="line"> 158366     508   53184  212058   33c5a d:/project/LiteOS/demo/out/realview-pbx-a9/Huawei_LiteOS.elf</span><br><span class="line">########################################################################################################</span><br><span class="line">########                      LiteOS build successfully!                                        ########</span><br><span class="line">########################################################################################################</span><br></pre></td></tr></table></figure><p>make 不对应，出错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; Executing task: LiteOSTool: Build &lt;</span><br><span class="line"></span><br><span class="line">&#x27;tr&#x27; 不是内部或外部命令，也不是可运行的程序</span><br><span class="line">或批处理文件。</span><br><span class="line">此时不应有 -lt。</span><br><span class="line">&#x27;tr&#x27; 不是内部或外部命令，也不是可运行的程序</span><br><span class="line">或批处理文件。</span><br><span class="line">此时不应有 -gt。</span><br><span class="line">命令语法不正确。</span><br><span class="line">命令语法不正确。</span><br><span class="line">make: *** [Makefile:38: d:/project/LiteOS/demo/out/realview-pbx-a9] Error 1</span><br><span class="line">make: *** Waiting for unfinished jobs....</span><br><span class="line">make: *** [Makefile:41: d:/project/LiteOS/demo/out/realview-pbx-a9/obj] Error 1</span><br><span class="line">d:/project/LiteOS/demo/kernel/init/los_init.c</span><br><span class="line">此时不应有 dir。</span><br><span class="line">make: *** [Makefile:60: LITEOS_BUILD] Error 255</span><br></pre></td></tr></table></figure><p>注：make使用 mingw 提供的，不符合。  </p><h3 id="烧录"><a href="#烧录" class="headerlink" title="烧录"></a>烧录</h3><p>在工程配置烧录器页面选择<strong>烧录文件</strong>。</p><p><img src="/my-study/liteos-search/image-20210930165840818.png" alt="image-20210930165840818"></p><p>启动信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Executing task: qemu-system-arm.exe -machine &quot;realview-pbx-a9&quot; -smp 4 -m 512M -kernel &quot;d:\project\LiteOS\demo\out\realview-pbx-a9\Huawei_LiteOS.bin&quot; -serial mon:stdio -nographic &lt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">********Hello Huawei LiteOS********</span><br><span class="line"></span><br><span class="line">LiteOS Kernel Version : 5.1.0</span><br><span class="line">Processor   : Cortex-A9 * 4</span><br><span class="line">Run Mode    : SMP</span><br><span class="line">GIC Rev     : GICv1</span><br><span class="line">build time  : Sep 30 2021 17:05:17</span><br><span class="line"></span><br><span class="line">**********************************</span><br><span class="line"></span><br><span class="line">main core booting up...</span><br><span class="line">OsAppInit</span><br><span class="line">releasing 3 secondary cores</span><br><span class="line">cpu 0 entering scheduler</span><br><span class="line">cpu 1 entering scheduler</span><br><span class="line">cpu 3 entering scheduler</span><br><span class="line">cpu 2 entering scheduler</span><br><span class="line">app init!</span><br><span class="line"></span><br><span class="line">Huawei LiteOS # help    ## 注：这是内建的命令</span><br><span class="line">*******************shell commands:*************************</span><br><span class="line"></span><br><span class="line">date          free          help          hwi           memcheck      stack         swtmr         systeminfo</span><br><span class="line">task          uname         watch</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>安装：<a href="https://liteos.gitee.io/liteos_studio/#/install">https://liteos.gitee.io/liteos_studio/#/install</a>　　<br>qemu示例：<a href="https://juejin.cn/post/6906386181001314317">https://juejin.cn/post/6906386181001314317</a>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;LiteOS调研。  &lt;/p&gt;</summary>
    
    
    
    <category term="技术杂铺" scheme="http://www.latelee.org/category/my-study/"/>
    
    
  </entry>
  
  <entry>
    <title>兆易创新GD32芯片调研</title>
    <link href="http://www.latelee.org/my-study/gd32mcu-search.html"/>
    <id>http://www.latelee.org/my-study/gd32mcu-search.html</id>
    <published>2021-09-27T16:00:00.000Z</published>
    <updated>2021-10-20T16:10:49.106Z</updated>
    
    <content type="html"><![CDATA[<p>兆易创新GD32芯片调研，具体型号：GD32F450ZGT6。  </p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>官网：<a href="http://www.gd32mcu.com/">http://www.gd32mcu.com/</a>  </p><p>GD32F450 系列，基于Arm® Cortex®-M4内核的32位通用微控制器(MCU)  。ARMv7 架构，32位，哈佛结构，可以使用相互独立的总线来读取指令和加载/存储数据。<strong>指令代码和数据都位于相同的存储器地址空间,但在不同的地址范围</strong>。<strong>程序存储器，数据存储器，寄存器和IO端口都在同一个线性的4GB的地址空间之内</strong>。这是CortexR-M4的最大地址范围，因为它的地址总线宽度是32位。此外，为了降低不同客户在相同应用时的软件复杂度，存储映射是按Cortex-M4处理器提供的规则预先定义的。在存储器映射表中，<strong>一部分地址空间</strong>由Arm RCortex-M4的<strong>系统外设所占用</strong>，且不可更改。此外，其余部分地址空间可由芯片供应商定义使用。  </p><p>特性：  </p><p><img src="/my-study/gd32mcu-search/image-20210928155014233.png" alt="image-20210928155014233"></p><p>资料：  </p><p>芯片手册（英文）：<a href="http://www.gd32mcu.com/cn/download/5?kw=GD32F4">http://www.gd32mcu.com/cn/download/5?kw=GD32F4</a>  </p><p>用户手册（中英，看这个基本可以）：<a href="http://www.gd32mcu.com/cn/download/6?kw=GD32F4">http://www.gd32mcu.com/cn/download/6?kw=GD32F4</a>  </p><h3 id="与STM32的兼容性"><a href="#与STM32的兼容性" class="headerlink" title="与STM32的兼容性"></a>与STM32的兼容性</h3><p>网上资料，GD32F450ZGT6 可替换 STM32F407ZGT6。  </p><p>GD和ST对比。  </p><p><img src="/my-study/gd32mcu-search/image-20210928155226706.png" alt="image-20210928155226706"></p><h2 id="开发相关"><a href="#开发相关" class="headerlink" title="开发相关"></a>开发相关</h2><p>预研的：</p><p><a href="https://github.com/LITEOS/LiteOS_Kernel/blob/master/doc/LiteOS_Migration_Guide_gdf450_Keil.md">https://github.com/LITEOS/LiteOS_Kernel/blob/master/doc/LiteOS_Migration_Guide_gdf450_Keil.md</a></p><p><a href="https://www.cirmall.com/bbs/thread-95132-1-1.html">https://www.cirmall.com/bbs/thread-95132-1-1.html</a><br><a href="https://www.cirmall.com/bbs/thread-94857-1-1.html">https://www.cirmall.com/bbs/thread-94857-1-1.html</a><br><a href="https://bbs.huaweicloud.com/blogs/174493">https://bbs.huaweicloud.com/blogs/174493</a>  </p><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><h3 id="库"><a href="#库" class="headerlink" title="库"></a>库</h3><p><a href="http://www.gd32mcu.com/cn/download/7?kw=GD32F4">http://www.gd32mcu.com/cn/download/7?kw=GD32F4</a>  </p><p>具体：GD32F4xx Firmware Library  </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.eet-china.com/mp/a66006.html">https://www.eet-china.com/mp/a66006.html</a>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;兆易创新GD32芯片调研，具体型号：GD32F450ZGT6。  &lt;/p&gt;</summary>
    
    
    
    <category term="技术杂铺" scheme="http://www.latelee.org/category/my-study/"/>
    
    
  </entry>
  
  <entry>
    <title>jekyll使用</title>
    <link href="http://www.latelee.org/pkc/jekyll-usage.html"/>
    <id>http://www.latelee.org/pkc/jekyll-usage.html</id>
    <published>2021-09-25T16:00:00.000Z</published>
    <updated>2021-10-20T16:10:49.078Z</updated>
    
    <content type="html"><![CDATA[<p>jekyll 命令使用。</p><span id="more"></span><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载：<a href="https://rubyinstaller.org/downloads/%EF%BC%8C%E6%96%87%E4%BB%B6%EF%BC%9Arubyinstaller-devkit-xx%E3%80%82">https://rubyinstaller.org/downloads/，文件：rubyinstaller-devkit-xx。</a>  </p><p>双击安装。  </p><p>输入<code>ruby -v</code>确认。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/</span><br><span class="line">gem install jekyll</span><br><span class="line">gem install jekyll-paginate</span><br><span class="line">gem install bundler</span><br><span class="line">jekyll -v</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 jekyll 目录运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bundle exec jekyll b</span><br></pre></td></tr></table></figure><h2 id="问题及解决"><a href="#问题及解决" class="headerlink" title="问题及解决"></a>问题及解决</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find_spec_for_exe&#x27;: can&#x27;t find gem bundler (&gt;= 0.a) (Gem::GemNotFoundException)</span><br><span class="line">解决：</span><br><span class="line">bundler版本不一致，将Gemfile.lock中的BUNDLED WITH修改为新安装的版本。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">提示：Could not locate Gemfile</span><br><span class="line">初始化：bundle init</span><br><span class="line">注：效果不好。</span><br></pre></td></tr></table></figure><p>已有Gemfile文件，但里面的版本较旧，移到其它电脑，重新安装，但版本较新。Gemfile不适应。执行<code>jekyll new my-awesome-site</code>生成一个简单网站示例，从中拿到Gemfile，替换之。  </p><p>安装指定版本的bundle：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install bundler -v 1.16.1</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;jekyll 命令使用。&lt;/p&gt;</summary>
    
    
    
    <category term="个人知识中心" scheme="http://www.latelee.org/category/pkc/"/>
    
    
    <category term="工具使用" scheme="http://www.latelee.org/tag/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>nginx负载均衡实验笔记</title>
    <link href="http://www.latelee.org/my-study/nginx-load-balnace-note.html"/>
    <id>http://www.latelee.org/my-study/nginx-load-balnace-note.html</id>
    <published>2021-09-23T17:00:00.000Z</published>
    <updated>2021-10-20T16:10:49.110Z</updated>
    
    <content type="html"><![CDATA[<p>本文是nginx负载均衡实验的一些笔记。</p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>前面已经完成了转发的程序，也尝试了一些负载均衡算法，本文对 nginx 的负载均衡做一些简单的测试，有部分实验是为了解答笔者与同事交流时产生的疑惑。  </p><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>本文所用程序，使用笔者实现的转发程序，实际上任何能响应 post 请求的程序均可。  </p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>本文使用镜像<code>centos/nginx-116-centos7</code>进行测试。<br>启动命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name nginx -p 8080:8080 -v $PWD/bin:/home/latelee/bin centos/nginx-116-centos7 bash</span><br></pre></td></tr></table></figure><p>为了配置 nginx，需 root 权限，故使用如下命令进入容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker exec -u root -it nginx bash</span><br></pre></td></tr></table></figure><p>后端服务运行命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/home/latelee/bin/httpforward_back.exe -p 9001 -i &quot;hello in 9001&quot;</span><br><span class="line">/home/latelee/bin/httpforward_back.exe -p 9002 -i &quot;hello in 9002&quot;</span><br><span class="line">/home/latelee/bin/httpforward_back.exe -p 9003 -i &quot;hello in 9003&quot;</span><br></pre></td></tr></table></figure><p>重启 nginx 命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><p>nginx 配置文件如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/nginx/nginx.conf &lt;&lt;-EOF </span><br><span class="line">worker_processes auto;</span><br><span class="line">error_log /var/opt/rh/rh-nginx116/log/nginx/error.log;</span><br><span class="line">pid /var/opt/rh/rh-nginx116/run/nginx/nginx.pid;</span><br><span class="line"></span><br><span class="line"># Load dynamic modules. See /opt/rh/rh-nginx116/root/usr/share/doc/README.dynamic.</span><br><span class="line">include /opt/rh/rh-nginx116/root/usr/share/nginx/modules/*.conf;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    log_format  main  &#x27;[$time_local] $remote_addr: &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; [$upstream_addr $upstream_status $upstream_response_time ms $request_time ms]&#x27;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/opt/rh/rh-nginx116/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    tcp_nopush      on;</span><br><span class="line">    tcp_nodelay     on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    types_hash_max_size 2048;</span><br><span class="line">    proxy_connect_timeout 10;</span><br><span class="line"></span><br><span class="line">    include       /etc/opt/rh/rh-nginx116/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    # Load modular configuration files from the /etc/nginx/conf.d directory.</span><br><span class="line">    # See http://nginx.org/en/docs/ngx_core_module.html#include</span><br><span class="line">    # for more information.</span><br><span class="line">    include /opt/app-root/etc/nginx.d/*.conf;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       8080 default_server;</span><br><span class="line">        listen       [::]:8080 default_server;</span><br><span class="line">        server_name  _;</span><br><span class="line">        root         /opt/app-root/src;</span><br><span class="line"></span><br><span class="line">        # Load configuration files for the default server block.</span><br><span class="line">        include      /opt/app-root/etc/nginx.default.d/*.conf;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://foobar;</span><br><span class="line">            proxy_set_header Host $proxy_host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        ]</span><br><span class="line">        </span><br><span class="line">        location /fee/sleep &#123;</span><br><span class="line">            proxy_pass http://foobar;</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    upstream foobar &#123;</span><br><span class="line">      server 127.0.0.1:9001;</span><br><span class="line">      server 127.0.0.1:9002;</span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">    #upstream foobar &#123;</span><br><span class="line">    #  server 127.0.0.1:9001 weight=3;</span><br><span class="line">    #  server 127.0.0.1:9002 weight=1;</span><br><span class="line">    #]</span><br><span class="line">    </span><br><span class="line">    #upstream foobar &#123;</span><br><span class="line">    #    ip_hash;</span><br><span class="line">    #    server 127.0.0.1:9001;</span><br><span class="line">    #    server 127.0.0.1:9002;</span><br><span class="line">    #    server 127.0.0.1:9003;</span><br><span class="line">    #]</span><br><span class="line">]</span><br><span class="line">EOF</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该配置文件主要设置了上游服务<code>foobar</code>的IP和端口。再进行具体 URL 的映射，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">        proxy_pass http://foobar; </span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">    location /fee/sleep &#123;</span><br><span class="line">        proxy_pass http://foobar; </span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><p>下面主要针对<code>upstream foobar</code>部分进行修改，达到使用不同算法的实验目的。  </p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>本文实验环境如下：<br>虚拟机 Linux 运行容器。<br>虚拟机 Windows 发送 POST 请求。  </p><p>为了进行实验，需启动若干个终端进入容器，如：修改配置并重启 nginx，执行程序，观察日志，等等。<br>查看访问日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f /var/opt/rh/rh-nginx116/log/nginx/access.log</span><br></pre></td></tr></table></figure><p>另外，在另一终端执行如下请求命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://192.168.28.11:8080/ -X POST -F  &quot;file=@sample.json&quot;</span><br></pre></td></tr></table></figure><h3 id="默认轮询"><a href="#默认轮询" class="headerlink" title="默认轮询"></a>默认轮询</h3><p>配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream foobar &#123;</span><br><span class="line">  server 127.0.0.1:9001;</span><br><span class="line">  server 127.0.0.1:9002;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[21/Sep/2021:04:47:26 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.000 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:04:47:27 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9001 200 0.001 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:04:47:29 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9001 200 0.002 ms 0.003 ms]</span><br><span class="line">[21/Sep/2021:04:47:31 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.001 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:04:47:34 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.001 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:04:47:35 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9001 200 0.001 ms 0.001 ms]</span><br></pre></td></tr></table></figure><p>结论： 9001 和 9002 依次出现。  </p><h3 id="加权轮询"><a href="#加权轮询" class="headerlink" title="加权轮询"></a>加权轮询</h3><p>配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream foobar &#123;</span><br><span class="line">  server 127.0.0.1:9001 weight=4;</span><br><span class="line">  server 127.0.0.1:9002 weight=1;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[21/Sep/2021:04:52:17 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9001 200 0.000 ms 0.000 ms]</span><br><span class="line">[21/Sep/2021:04:52:18 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9001 200 0.001 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:04:52:18 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9001 200 0.000 ms 0.000 ms]</span><br><span class="line">[21/Sep/2021:04:52:19 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9001 200 0.001 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:04:52:20 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.001 ms 0.001 ms]</span><br></pre></td></tr></table></figure><p>结论： 9001 和 9002 依次出现 4 次和 1 次。<br><strong>注：经测试发现，nginx 加权轮询本身就是平滑加权轮询，此处为了演示，特意将权重值扩大。</strong>  </p><h3 id="平滑加权轮询"><a href="#平滑加权轮询" class="headerlink" title="平滑加权轮询"></a>平滑加权轮询</h3><p>配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream foobar &#123;</span><br><span class="line">  server 127.0.0.1:9001 weight=2;</span><br><span class="line">  server 127.0.0.1:9002 weight=5;</span><br><span class="line">  server 127.0.0.1:9003 weight=3;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">第一轮：</span><br><span class="line">[21/Sep/2021:05:00:39 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.001 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:05:00:39 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.001 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:05:00:40 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9003 200 0.001 ms 0.000 ms]</span><br><span class="line">[21/Sep/2021:05:00:41 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9003 200 0.000 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:05:00:42 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9001 200 0.008 ms 0.009 ms]</span><br><span class="line">[21/Sep/2021:05:00:43 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.001 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:05:00:44 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.001 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:05:00:44 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9001 200 0.000 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:05:00:45 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.000 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:05:00:46 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9003 200 0.001 ms 0.001 ms]</span><br><span class="line"></span><br><span class="line">第二轮</span><br><span class="line">[21/Sep/2021:05:03:24 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.001 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:05:03:25 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9001 200 0.001 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:05:03:26 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.000 ms 0.000 ms]</span><br><span class="line">[21/Sep/2021:05:03:27 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9003 200 0.000 ms 0.000 ms]</span><br><span class="line">[21/Sep/2021:05:03:28 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.000 ms 0.000 ms]</span><br><span class="line">[21/Sep/2021:05:03:29 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.001 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:05:03:30 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9003 200 0.002 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:05:03:31 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9001 200 0.001 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:05:03:31 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.000 ms 0.000 ms]</span><br><span class="line">[21/Sep/2021:05:03:32 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.001 ms 0.001 ms]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结论： 从权重上看，9001、9002 和 9003 保持配置中的值，即依次出现 2、5、3 次。从顺序上看，权重大的服务器并没有集中出现，三者轮询相对较均匀。从2轮实验结果看，每一次的轮询，某个服务器出现的顺序并不相同。  </p><p>与前面自实现平滑算法对比如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">自实现：</span><br><span class="line">2 3 1 2 2 3 2 1 3 2 </span><br><span class="line">nginx的：</span><br><span class="line">2 2 3 3 1 2 2 1 2 3</span><br><span class="line">2 1 2 3 2 2 3 1 2 2</span><br></pre></td></tr></table></figure><p>可以看到，二者还是有区别的。  </p><h3 id="ip-hash-轮询"><a href="#ip-hash-轮询" class="headerlink" title="ip_hash 轮询"></a>ip_hash 轮询</h3><p>配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream foobar &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server 127.0.0.1:9001;</span><br><span class="line">    server 127.0.0.1:9002;</span><br><span class="line">    server 127.0.0.1:9003;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>为模拟不同的 IP 访问，在虚拟机、物理机以及其它的容器中发送 POST 请求，观察日志。如下：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[21/Sep/2021:06:59:55 +0000] 127.0.0.1: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.29.0&quot; [127.0.0.1:9003 200 0.002 ms 0.042 ms]</span><br><span class="line">[21/Sep/2021:06:59:55 +0000] 127.0.0.1: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.29.0&quot; [127.0.0.1:9003 200 0.001 ms 0.041 ms]</span><br><span class="line">[21/Sep/2021:06:59:56 +0000] 127.0.0.1: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.29.0&quot; [127.0.0.1:9003 200 0.001 ms 0.041 ms]</span><br><span class="line">[21/Sep/2021:07:02:20 +0000] 172.17.0.1: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.29.0&quot; [127.0.0.1:9002 200 0.001 ms 0.041 ms]</span><br><span class="line">[21/Sep/2021:07:02:23 +0000] 172.17.0.1: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.29.0&quot; [127.0.0.1:9002 200 0.001 ms 0.044 ms]</span><br><span class="line">[21/Sep/2021:07:03:20 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.001 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:07:03:21 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.001 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:07:03:22 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.000 ms 0.000 ms]</span><br><span class="line">[21/Sep/2021:07:03:22 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9002 200 0.001 ms 0.001 ms]</span><br><span class="line">[21/Sep/2021:07:03:54 +0000] 172.17.0.3: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.29.0&quot; [127.0.0.1:9002 200 0.000 ms 0.042 ms]</span><br><span class="line">[21/Sep/2021:07:04:07 +0000] 172.17.0.3: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.29.0&quot; [127.0.0.1:9002 200 0.002 ms 0.042 ms]</span><br><span class="line">[21/Sep/2021:07:04:08 +0000] 172.17.0.3: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.29.0&quot; [127.0.0.1:9002 200 0.002 ms 0.044 ms]</span><br><span class="line">[21/Sep/2021:07:04:42 +0000] 192.168.28.11: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.29.0&quot; [127.0.0.1:9002 200 0.001 ms 0.042 ms]</span><br><span class="line">[21/Sep/2021:07:04:49 +0000] 192.168.28.11: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.29.0&quot; [127.0.0.1:9002 200 0.001 ms 0.042 ms]</span><br><span class="line">[21/Sep/2021:07:04:50 +0000] 192.168.28.11: &quot;POST / HTTP/1.1&quot; 200 &quot;-&quot; &quot;curl/7.29.0&quot; [127.0.0.1:9002 200 0.002 ms 0.043 ms]</span><br></pre></td></tr></table></figure><p>结论：其中<code>127.0.0.1</code>为 nginx 所在容器的本地 IP，<code>172.17.0.3</code>是另一容器，<code>192.168.28.5</code>是物理机，<code>192.168.28.11</code>是虚拟机。从日志中看，每个源 IP 均由相同端口的服务响应。但不知为何，9001 端口服务没有被轮询到。  </p><h3 id="后端服务未启动访问"><a href="#后端服务未启动访问" class="headerlink" title="后端服务未启动访问"></a>后端服务未启动访问</h3><p>模拟场合：所有的后端服务均未启动，但在 nginx 配置文件中指定了后端服务。<br>nginx 访问日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[21/Sep/2021:06:43:48 +0000] 192.168.28.5: &quot;POST / HTTP/1.1&quot; 502 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9003, 127.0.0.1:9002, 127.0.0.1:9001 502, 502, 502 0.000, 0.000, 0.001 ms 0.001 ms]</span><br></pre></td></tr></table></figure><p>curl 请求返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://192.168.28.11:8080/ -X POST -F  &quot;file=@sample.json&quot;</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100   493  100   157  100   336  78500   164k --:--:-- --:--:-- --:--:--  481k&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;502 Bad Gateway&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;502 Bad Gateway&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx/1.16.1&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>结论：返回 502，注意，访问日志中提示了所有的后端服务均返回 502，猜测 nginx已经做了一次轮询。  </p><h3 id="在后端服务处理过程中，突然停止该服务"><a href="#在后端服务处理过程中，突然停止该服务" class="headerlink" title="在后端服务处理过程中，突然停止该服务"></a>在后端服务处理过程中，突然停止该服务</h3><p>模拟场合：某服务在处理请求中突然停止服务（如出现段错误或断电）。<br>为了模拟该情况，特意实现一个 sleep 请求，该请求中延时 4 秒，以方便停止服务。<br>nginx 访问日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[21/Sep/2021:06:49:18 +0000] 192.168.28.5: &quot;POST /fee/sleep HTTP/1.1&quot; 502 &quot;-&quot; &quot;curl/7.73.0&quot; [127.0.0.1:9001 502 3.035 ms 3.035 ms]</span><br></pre></td></tr></table></figure><p>可以看到，其响应处理耗时 3 秒多，因为笔者在大概 3 秒时才停止后端服务。  </p><p>curl 请求返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://192.168.28.11:8080/fee/sleep -X POST -F  &quot;file=@sample.json&quot;</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100   493  100   157  100   336     40     85  0:00:03  0:00:03 --:--:--   125&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;502 Bad Gateway&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;502 Bad Gateway&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx/1.16.1&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>结论：对于请求者而言，返回信息与上一实验相同，但在访问日志看到，只有 9001 才提示 502，但还有其它后端服务在运行，因此，再请求时，能返回正常。  </p><h3 id="在处理请求中重新配置-nginx"><a href="#在处理请求中重新配置-nginx" class="headerlink" title="在处理请求中重新配置 nginx"></a>在处理请求中重新配置 nginx</h3><p>模拟场合：在多台后端服务中，需停止部分并升级，再启动，再升级其它的服务。<br>先将两台服务器权重扩大，如 9001 为 10， 9002 为 1，保证请求大部分转发到 9001 端口。在请求处理中，修改 nginx 配置，去掉 9001 服务，再重启 nginx。观察。  </p><p>结论：nginx 等待 9001 服务处理完请求，后续请求不再转发该服务。因此确保在处理中的请求一定能处理完毕。    </p><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><p>不能在<code>upstream</code>里面的 IP 地址加上 URL 后缀。否则提示  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx: [emerg] invalid host in upstream &quot;127.0.0.1:9001/foobar&quot; in /etc/opt/rh/rh-nginx116/nginx/nginx.conf:54</span><br></pre></td></tr></table></figure><p>可以在<code>location</code>地址添加对应的 URL，如<code>location /foobar</code>。  </p><p>为方便观察请求日志，需要设置 nginx 日志，本文配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log_format  main  &#x27;[$time_local] $remote_addr: &quot;$request&quot; &#x27;</span><br><span class="line">                  &#x27;$status &quot;$http_referer&quot; &#x27;</span><br><span class="line">                  &#x27;&quot;$http_user_agent&quot; [$upstream_addr $upstream_status $upstream_response_time ms $request_time ms]&#x27;;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>许久前，在看分布式的视频时，里面介绍了负载均衡，雪花算法，一致性哈希算法，等，让笔者大开眼界，趁着中秋佳节无法外出，集中夜晚时间研究研究，从自实现的基于请求内容的转发工具，到 nginx 的负载均衡算法，基本过了一次。至于其它的知识，暂时未有计划。  </p><p>2021.9.23 凌晨</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是nginx负载均衡实验的一些笔记。&lt;/p&gt;</summary>
    
    
    
    <category term="技术杂铺" scheme="http://www.latelee.org/category/my-study/"/>
    
    
    <category term="架构学习" scheme="http://www.latelee.org/tag/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：使用gin框架实现转发功能：一些负载均衡算法的实现</title>
    <link href="http://www.latelee.org/golang/golang-notes-print-structure.html"/>
    <id>http://www.latelee.org/golang/golang-notes-print-structure.html</id>
    <published>2021-09-22T14:01:00.000Z</published>
    <updated>2021-10-20T16:10:49.022Z</updated>
    
    <content type="html"><![CDATA[<p>近段时间需要实现一个转发 post 请求到指定后端服务的小工具，由于一直想学习 gin 框架，所以就使用这个框架进行尝试，预计会产生几篇文章。本文研究一些负载均衡算法的实现。    </p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文实现的负载均衡纯粹是为了笔者的一个念想，并不具有实际指导意义。  </p><p>本文假定有一个后端服务 URL 的数组，因此，在实现上，仅是输出数组的索引值。权重数组每个索引值对应一个后端服务。比如”1 3 3”，表示有3台服务器，第1台权重为1，第2、3台权重均为3。    </p><h2 id="算法实现及测试结果"><a href="#算法实现及测试结果" class="headerlink" title="算法实现及测试结果"></a>算法实现及测试结果</h2><p>负载均衡有很多类型，如：随机、加权随机；简单轮询、加权轮询、平滑加权轮询，等。本文仅实现几种轮询算法，并且按请求次序递增，不使用随机数。  </p><h3 id="简单轮询算法"><a href="#简单轮询算法" class="headerlink" title="简单轮询算法"></a>简单轮询算法</h3><p>算法描述：  </p><p>按请求先后轮询服务器。接收到第一次请求，转发到第1台服务器，第二次请求，转发到第2台服务器，依次类推，如果轮询到最后一台服务器，再转发第一台。  </p><p>代码：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var lb_index int = 0</span><br><span class="line"></span><br><span class="line">// 简单轮询</span><br><span class="line">func getOneServerUrlForLB_RR(exTime string) (url string) &#123;</span><br><span class="line"></span><br><span class="line">    url = &quot;&quot;</span><br><span class="line">    count := conf.TotalPort //len(conf.BackInfo)</span><br><span class="line"></span><br><span class="line">    if lb_index &gt;= count &#123;</span><br><span class="line">        lb_index = 0</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(&quot;indx: &quot;, lb_index, count)</span><br><span class="line">    url = fmt.Sprintf(&quot;http://127.0.0.1:%d&quot;, conf.BackPorts[lb_index])</span><br><span class="line">    fmt.Println(&quot;got url: &quot;, url)</span><br><span class="line"></span><br><span class="line">    lb_index += 1</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加权轮询算法"><a href="#加权轮询算法" class="headerlink" title="加权轮询算法"></a>加权轮询算法</h3><p>一个权重的示意：</p><p>3台机器（分别为A、B、C），权重分别为5，3，2。排列（注：按设置的权重先后列出）：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   5       3    2</span><br><span class="line">1       5     8   10</span><br><span class="line">| ----- | --- | -- |</span><br><span class="line">   A       B     C</span><br></pre></td></tr></table></figure><p>某一区间大，表示该服务器的权重大。<br>设一数，其值在1~10之间，即范围在权重总和之内，依次与5、3、2对比，如小则在该区间，如大，则减去前一数，再比对。看落到哪个区域。<br>举例：<br>设该数为3，与5对比，小，则落到第1区间，即选择服务器 A。<br>设该数为7，与5对比，大，取下一区间，即减去5，得2，与3对比，小，则落到第2区间，即选择服务器 B。<br>设该数为9，与5对比，大，减去5得4，与3对比，大，减去3得1，与2对比，小，第3区间，即选择服务器 C。  </p><p>注意，我们关注的是某个区间出现的次数，并不关注是哪一个索引。以轮询 10 次为例，只要保证A、B、C服务器分别访问了5、3、2次即可。最简单的算法，就是将这次 10 次依次分配到A、B、C服务器。  </p><p>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">测试用，假定有3组IP，每组分配好权重，根据请求顺序，按权重分配</span></span><br><span class="line"><span class="comment">可以认为，IP总数为权重总值，只是部分重复了，所以请求循环的次数就是权重总值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 因为测试，所以直接赋值，测试的总数不超过 conf.TotalPort</span></span><br><span class="line"><span class="comment">// conf.Weights 示例：[3]int&#123;2, 5, 3&#125;， 数组索引0表示第1个后端，1表示第2个后端</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIndex_WRR</span><span class="params">(offset <span class="keyword">int</span>, totalWeight <span class="keyword">int</span>)</span> <span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不指定，使用随机</span></span><br><span class="line">    <span class="keyword">if</span> offset == <span class="number">-1</span> &#123;</span><br><span class="line">        rand.Seed(time.Now().UnixNano())</span><br><span class="line">        offset = rand.Int() % totalWeight</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fmt.Println(&quot;total: &quot;, totalWeight, offset)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注：这里关注的是某个索引值的次数，与顺序无关</span></span><br><span class="line">    <span class="keyword">for</span> index, w := <span class="keyword">range</span> conf.Weights &#123;</span><br><span class="line">        <span class="keyword">if</span> offset &lt; w &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">        offset -= w</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getOneServerUrlForLB_WRR</span><span class="params">(exTime <span class="keyword">string</span>)</span> <span class="params">(url <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    url = <span class="string">&quot;&quot;</span></span><br><span class="line">    count := conf.TotalPort</span><br><span class="line"></span><br><span class="line">    totalWeight := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, w := <span class="keyword">range</span> conf.Weights &#123;</span><br><span class="line">        totalWeight += w</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    count = totalWeight <span class="comment">// 注：按权重总数轮询</span></span><br><span class="line">    <span class="keyword">if</span> lb_index &gt;= count &#123;</span><br><span class="line">        lb_index = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    new_lb_index := getIndex_WRR(lb_index, totalWeight)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lb_index == <span class="number">100</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;indx: &quot;</span>, lb_index, new_lb_index, count)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d &quot;</span>, new_lb_index)</span><br><span class="line"></span><br><span class="line">    url = fmt.Sprintf(<span class="string">&quot;http://127.0.0.1:%d&quot;</span>, conf.BackPorts[new_lb_index])</span><br><span class="line">    fmt.Println(<span class="string">&quot;got url: &quot;</span>, url)</span><br><span class="line"></span><br><span class="line">    lb_index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./httpforward.exe -w &quot;5 3 2&quot;</span><br><span class="line">0 0 0 0 0 1 1 1 2 2 0 0 0 0 0 1 1 1 2 2</span><br><span class="line"></span><br><span class="line">./httpforward.exe -w &quot;1 3 3&quot;</span><br><span class="line">0 1 1 1 2 2 2 0 1 1 1 2 2 2</span><br><span class="line"></span><br><span class="line">./httpforward.exe -w &quot;5 3 1&quot;</span><br><span class="line">0 0 0 0 0 1 1 1 2 0 0 0 0 0 1 1 1 2</span><br></pre></td></tr></table></figure><p>为了数据可靠，轮询了2遍，下同。  </p><h3 id="平滑加权轮询算法"><a href="#平滑加权轮询算法" class="headerlink" title="平滑加权轮询算法"></a>平滑加权轮询算法</h3><p>上述算法并不考虑服务器处理在效率，比如前面5次均在A服务器，其它服务器均为空闲状态，由此引出平滑加权轮询算法。笔者暂未参透该算法的证明过程，因此本文不涉及。  </p><p>算法：<br>设置如下变量：<br>总权重值：totalWeight，其值固定。<br>固定权重数组：Weights，其值固定。<br>当前权重数组 CurrentWeights，其值可变<br>当前权重数组最大值 maxWeight，CurrentWeights数组的最大值。  </p><p>0、某次请求到来。<br>1、判断当前权重数组（对应下表<strong>当前权重1</strong>）值是否全为0，如是，则用固定权重初始化之。<br>2、查获当前权重数组，获取最大值，对应的索引，即为需要返回的服务器。<br>3、将第2步的索引对应的值，减去权重总和，其它索引的值保持不变。（对应下表<strong>当前权重2</strong>）<br>4、 将第3步得到的当前权重数组的每个值，加上对应的固定权重值。<br>5、回到第1步，重复。  </p><p>假定有3台服务器A、B、C，其权重依次为 5、1、1，权重总和为7。演算过程如下：     </p><p>初始时，当前权重为[0,0,0]，则用固定权重[5,1,1]初始化之。<br>此时，最大值为5，索引为0，返回服务器A。<br>将[5,1,1]的索引0值减去权重总和7，得到[-2,1,1]。<br>将[-2,1,1]加上[5,1,1]，得到新的当前权重[3,2,2]。<br>此时，最大值为3，索引为0，返回服务器A。<br>将[3,2,2]的索引0值减去权重总和7，得到[-4,2,2]。<br>将[-4,2,2]加上[5,1,1]，得到新的当前权重[1,3,3]。<br>（下略）  </p><p>总体过程如下表：  </p><table><thead><tr><th>请求次数</th><th>当前权重1</th><th>返回服务器</th><th>当前权重2</th></tr></thead><tbody><tr><td>0</td><td>[0, 0,0]</td><td>－－</td><td>初始化为[5, 1, 1]</td></tr><tr><td>1</td><td>[5, 1, 1]</td><td>A</td><td>[-2, 1, 1]</td></tr><tr><td>2</td><td>[3, 2, 2]</td><td>A</td><td>[-4, 2, 2]</td></tr><tr><td>3</td><td>[1, 3, 3]</td><td>B</td><td>[1, -4, 3]</td></tr><tr><td>4</td><td>[6, -3, 4]</td><td>A</td><td>[-1, -3, 4]</td></tr><tr><td>5</td><td>[4, -2, 5]</td><td>C</td><td>[4, -2, -2]</td></tr><tr><td>6</td><td>[9, -1, -1]</td><td>A</td><td>[2, -1, -1]</td></tr><tr><td>7</td><td>[7, 0, 0]</td><td>A</td><td>[0, 0, 0]</td></tr><tr><td>8</td><td>[5, 1, 1]</td><td>A</td><td>[-2, 1, 1]</td></tr></tbody></table><p>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 平滑加权</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIndex_SWRR</span><span class="params">(offset <span class="keyword">int</span>, totalWeight <span class="keyword">int</span>)</span> <span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    initflag := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0.判断是否全为0</span></span><br><span class="line">    <span class="keyword">for</span> _, w := <span class="keyword">range</span> conf.CurrentWeights &#123;</span><br><span class="line">        <span class="keyword">if</span> w == <span class="number">0</span> &#123;</span><br><span class="line">            initflag++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全为0，则需要初始化</span></span><br><span class="line">    <span class="keyword">if</span> initflag == <span class="built_in">len</span>(conf.CurrentWeights) &#123;</span><br><span class="line">        <span class="keyword">for</span> idx, w := <span class="keyword">range</span> conf.Weights &#123;</span><br><span class="line">            conf.CurrentWeights[idx] = w</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 查询当前权重表最大者，并取该索引，即为所需结果</span></span><br><span class="line">    maxWeight := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> idx, w := <span class="keyword">range</span> conf.CurrentWeights &#123;</span><br><span class="line">        <span class="keyword">if</span> w &gt; maxWeight &#123;</span><br><span class="line">            maxWeight = w</span><br><span class="line">            index = idx</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 最大的那个权重，其值减去总权重</span></span><br><span class="line">    conf.CurrentWeights[index] = maxWeight - totalWeight</span><br><span class="line">    <span class="comment">// fmt.Println(&quot;current222: &quot;, conf.CurrentWeights)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 新的当前权重，所对应的值加上初始权重</span></span><br><span class="line">    <span class="comment">// 为下次循环计算打下基础</span></span><br><span class="line">    <span class="keyword">for</span> idx, w := <span class="keyword">range</span> conf.Weights &#123;</span><br><span class="line">        conf.CurrentWeights[idx] += w</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getOneServerUrlForLB_SWRR</span><span class="params">(exTime <span class="keyword">string</span>)</span> <span class="params">(url <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    url = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    totalWeight := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, w := <span class="keyword">range</span> conf.Weights &#123;</span><br><span class="line">        totalWeight += w</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注：按权重总数轮询</span></span><br><span class="line">    <span class="keyword">if</span> lb_index &gt;= totalWeight &#123;</span><br><span class="line">        lb_index = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    new_lb_index := getIndex_SWRR(lb_index, totalWeight)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lb_index == <span class="number">100</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;indx1: &quot;</span>, lb_index, new_lb_index, totalWeight)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d &quot;</span>, new_lb_index)</span><br><span class="line">    url = fmt.Sprintf(<span class="string">&quot;http://127.0.0.1:%d&quot;</span>, conf.BackPorts[new_lb_index])</span><br><span class="line">    <span class="comment">//fmt.Println(&quot;got url: &quot;, url)</span></span><br><span class="line"></span><br><span class="line">    lb_index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">./httpforward.exe -w &quot;5 1 1&quot;</span><br><span class="line">0 0 1 0 2 0 0 0 0 1 0 2 0 0 </span><br><span class="line"></span><br><span class="line">./httpforward.exe -w &quot;1 3 3&quot;</span><br><span class="line">1 2 0 1 2 1 2 1 2 0 1 2 1 2</span><br><span class="line"></span><br><span class="line">./httpforward.exe -w &quot;5 3 1&quot;</span><br><span class="line">0 1 0 2 0 1 0 1 0 0 1 0 2 0 1 0 1 0 </span><br><span class="line"></span><br><span class="line">./httpforward.exe -w &quot;2 5 3&quot;</span><br><span class="line">1 2 0 1 1 2 1 0 2 1 1 2 0 1 1 2 1 0 2 1</span><br></pre></td></tr></table></figure><p>从结果上看，权重保持着比例，但响应的服务器分布较平衡。  </p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文主要根据网络的相关资料整理并用 golang 代码实现负载均衡部分算法。  </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/wsw-seu/p/11336634.html">https://www.cnblogs.com/wsw-seu/p/11336634.html</a><br><a href="https://juejin.cn/post/6844903793012768781">https://juejin.cn/post/6844903793012768781</a>  </p><p>李迟 2021.9.22 晚</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;近段时间需要实现一个转发 post 请求到指定后端服务的小工具，由于一直想学习 gin 框架，所以就使用这个框架进行尝试，预计会产生几篇文章。本文研究一些负载均衡算法的实现。    &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：使用gin框架实现转发功能：利用nginx转发</title>
    <link href="http://www.latelee.org/golang/golang-notes-print-structure.html"/>
    <id>http://www.latelee.org/golang/golang-notes-print-structure.html</id>
    <published>2021-09-19T18:01:00.000Z</published>
    <updated>2021-10-20T16:10:49.022Z</updated>
    
    <content type="html"><![CDATA[<p>近段时间需要实现一个转发 post 请求到指定后端服务的小工具，由于一直想学习 gin 框架，所以就使用这个框架进行尝试，预计会产生几篇文章。本文研究如何利用 nginx 容器和后端服务进行转发工具的测试。    </p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>转发的工具实现起来比较简单，但为了验证，还需要使用其它工具配合，本文自编后端程序，并使用 nginx 实现多个后端程序的转发。<br>为方便理解，下面给出示例图。<br>不使用 nginx 实现转发如下图所示：<br><img src="/golang/golang-notes-print-structure/1.png"></p><p>使用 nginx 实现转发如下图所示：<br><img src="/golang/golang-notes-print-structure/2.png"></p><p>注意图中 URL 的变化。  </p><h2 id="后端服务"><a href="#后端服务" class="headerlink" title="后端服务"></a>后端服务</h2><p>前面文章已经实现了简单的后端服务响应函数，此处不再列出。需要注意的是，因本系列转发和后端均用同一套代码，如果要在程序中启动后端服务，必须修改后端服务可执行文件名称，参考前文代码。  </p><h2 id="nginx容器启动及重启"><a href="#nginx容器启动及重启" class="headerlink" title="nginx容器启动及重启"></a>nginx容器启动及重启</h2><p>本文使用镜像<code>centos/nginx-116-centos7</code>进行测试。简单启动如下：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name nginx -p 8080:8080 -v $PWD:/opt/bin centos/nginx-116-centos7 bash</span><br></pre></td></tr></table></figure><p>实践中使用<code>docker-compose</code>启动，docker-compose.yml文件如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;2&#x27;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  nginx:</span><br><span class="line">    image: centos/nginx-116-centos7</span><br><span class="line">    container_name: nginx</span><br><span class="line">    command: /bin/bash -c &quot;/home/latelee/bin/run.sh&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - $PWD/bin:/home/latelee/bin</span><br><span class="line">      - $PWD/nginx/log:/var/opt/rh/rh-nginx116/log/nginx</span><br><span class="line">      - $PWD/nginx/etc:/etc/nginx</span><br><span class="line">      - /etc/localtime:/etc/localtime</span><br><span class="line">    #environment:</span><br><span class="line">    #  - ORACLE_HOME=/work/instantclient_12_1</span><br><span class="line">    #  - TNS_ADMIN=$ORACLE_HOME</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:8080</span><br><span class="line">      - 8090:8090</span><br></pre></td></tr></table></figure><p>注：后端服务程序（和启动脚本）以及 nginx 配置文件均放到主机目录，因为这样更容易更新。</p><p>为了在容器启动时运行自定义的命令，需要关闭 nginx 服务的后台执行，启动脚本 run.sh 内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">echo &quot;run...&quot;</span><br><span class="line">cd /home/latelee/bin</span><br><span class="line"></span><br><span class="line">nginx -g &quot;daemon off;&quot;&amp;</span><br><span class="line"></span><br><span class="line">sleep 1</span><br><span class="line">./httpforward.exe -p 8090 </span><br></pre></td></tr></table></figure><p>关于在容器中启动 nginx 的方法，官方 docker 有介绍：   </p><blockquote><p>If you add a custom CMD in the Dockerfile, be sure to include -g daemon off; in the CMD in order for nginx to stay in the foreground, so that Docker can track the process properly (otherwise your container will stop immediately after starting)!  </p></blockquote><p>大意是说，当我们自定义启动命令时，必须添加<code>-g daemon off</code>，否则自定义命令启动完毕后，容器就会自动退出。  </p><p>启动容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>查看日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose logs -f</span><br></pre></td></tr></table></figure><p>默认情况下 nginx 已经启动了。如果修改了配置。可以重启容器，也可以在容器内重启，重启命令为<code>nginx -s reload</code>。<code>nginx -s</code>仅支持4个参数：<code>stop, quit, reopen, reload</code>，官方文档将其称为信号（signal）。如果执行<code>nginx -s stop</code>停止 nginx，再次重启，会提示<code>nginx: [error] open() &quot;/var/opt/rh/rh-nginx116/run/nginx/nginx.pid&quot; failed (2: No such file or directory)</code>。因此，修改 nginx 配置后，使用<code>reload</code>即可。  </p><h2 id="nginx-转发的一些测试"><a href="#nginx-转发的一些测试" class="headerlink" title="nginx 转发的一些测试"></a>nginx 转发的一些测试</h2><p>在笔者环境中，不论在容器内，还是在物理机，nginx 配置文件为<code>/etc/nginx/nginx.conf</code>（注：实际，nginx 还会读取<code>/etc/nginx/conf.d</code>目录，但不在本文讨论范围），修改该文件后，必须执行<code>nginx -s reload</code>重启 nginx。<br>对于 location 的配置，一般如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location /fee/9000 &#123;</span><br><span class="line">        proxy_pass http://127.0.0.1:9000;</span><br><span class="line">        proxy_set_header Host $proxy_host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送到 nginx 服务器的请求，如果 URL 为<code>/fee/9000</code>，则转发到本地的 9000 端口的服务。（注：<code>/fee/9000</code>还可以继续添加后缀 URL，但不是本次讨论的范围），其它转发类似。<br>经测试，直接用<code>proxy_pass</code>字段指定后端服务地址即可。如下：    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /fee/9000 &#123;</span><br><span class="line">        proxy_pass http://127.0.0.1:9000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试中发现，当使用上述转发规则时，后端程序必须实现<code>/fee/9000</code>的响应，即在容器中能正常请求<code>http://127.0.0.1:9000/fee/9000</code>。如果不实现，会提示 404。而本文的后端不能响应带后缀的URL。    </p><p>经查，在后端程序 URL 后添加斜杠<code>/</code>可解决问题，如下：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /fee/9000 &#123;</span><br><span class="line">        proxy_pass http://127.0.0.1:9000/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两者对比如下：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">不加斜杠：http://127.0.0.1:8080/fee/9000  --&gt; http://127.0.0.1:9000/fee/9000</span><br><span class="line">添加斜杠：http://127.0.0.1:8080/fee/9000  --&gt; http://127.0.0.1:9000/</span><br><span class="line"></span><br><span class="line">添加斜杠的扩展：http://127.0.0.1:8080/fee/9000/foo  --&gt; http://127.0.0.1:9000/foo</span><br></pre></td></tr></table></figure><p>对于笔者的应用，请求后端程序的URL必须是<code>http://127.0.0.1:9000/</code>的形式，不能再额外添加后缀，由于对 nginx 研究未深，暂不展开讨论。  </p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>请求命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://192.168.28.11:8090/fee/test -X POST -F  &quot;file=@sample.json&quot;</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100   434  100    98  100   336   3920  13440 --:--:-- --:--:-- --:--:-- 18083&#123;&quot;code&quot;:0,&quot;data&quot;:&#123;&quot;result&quot;:&quot;ok in back end server, port: 9001 info: run in port 9001&quot;&#125;,&quot;msg&quot;:&quot;ok&quot;&#125;</span><br></pre></td></tr></table></figure><p>转发工具：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx    | got url:  http://127.0.0.1:8080/fee/9001</span><br><span class="line">nginx    | [GIN] 2021/09/14 - 01:32:17 | 200 |   10.002826ms |    192.168.28.5 | POST     &quot;/fee/test&quot;</span><br></pre></td></tr></table></figure><p>nginx 日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">==&gt; nginx/log/access.log &lt;==</span><br><span class="line">127.0.0.1 - - [14/Sep/2021:01:32:17 +0800] &quot;POST /fee/9001 HTTP/1.1&quot; 200 98 &quot;-&quot; &quot;Go-http-client/1.1&quot; &quot;-&quot;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文中，自编的转发工具要管理和配置后端程序以及 nginx，即启动若干后端程序，根据规则分配端口号（从9000开始）和 URL，将其写到 nginx 配置文件，最后重启 nginx 服务。——当然，这些都是使用较简单的方法。<br>在启动后端程序中，由于笔者使用相同的代码，因此花了一些时间排查问题。<br>在测试 nginx 转发 URL 时，也花了较多的时间（前后大概2个深夜的时间）。  </p><p>在后续中，笔者将研究如何自实现负载均衡算法。——计划做此事已了大半年，趁此机会抽点时间搞下。  </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>关于转发 URL 的讨论 <a href="https://stackoverflow.com/questions/42997684/nginx-on-docker-doesnt-work-with-location-url">https://stackoverflow.com/questions/42997684/nginx-on-docker-doesnt-work-with-location-url</a><br>nginx镜像：  <a href="https://hub.docker.com/_/nginx">https://hub.docker.com/_/nginx</a>  </p><p>李迟 2021.9.19 凌晨</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;近段时间需要实现一个转发 post 请求到指定后端服务的小工具，由于一直想学习 gin 框架，所以就使用这个框架进行尝试，预计会产生几篇文章。本文研究如何利用 nginx 容器和后端服务进行转发工具的测试。    &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：使用gin框架实现转发功能：管理后端服务启动</title>
    <link href="http://www.latelee.org/golang/golang-notes-gin-httpforward1.html"/>
    <id>http://www.latelee.org/golang/golang-notes-gin-httpforward1.html</id>
    <published>2021-09-18T15:51:00.000Z</published>
    <updated>2021-10-20T16:10:49.022Z</updated>
    
    <content type="html"><![CDATA[<p>近段时间需要实现一个转发 post 请求到指定后端服务的小工具，由于一直想学习 gin 框架，所以就使用这个框架进行尝试，预计会产生几篇文章。本文研究如何管理后端服务。  </p><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在启动 gin 服务前，先启动所有的后端服务进程，并且分配好端口，为简单起见，本文根据请求时间带的月份来转发，后端服务端口从 9000 开始。因此，需启动 13 个服务，端口从 9000 到 9012，如请求时间为9月份，则转发到 9009 端口的服务，对于非法月份，则统一转发到 9000 端口。   </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>添加<code>/</code>的响应，主要是为了后续方便使用 nginx。  </li><li>分配好端口，启动后端服务。</li><li>根据请求时间选择一个后端 URL。  </li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="主要接口代码"><a href="#主要接口代码" class="headerlink" title="主要接口代码"></a>主要接口代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">func RunWebServer(args []string) &#123;</span><br><span class="line">    runWebOnlyPost()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func runWebOnlyPost() &#123;</span><br><span class="line">    </span><br><span class="line">    // 先执行其它业务，再到http</span><br><span class="line">    restartAll()</span><br><span class="line"></span><br><span class="line">truerouter := gin.New()</span><br><span class="line">truerouter.Use(gin.Logger())</span><br><span class="line">truerouter.Use(gin.Recovery())</span><br><span class="line"></span><br><span class="line">truetestRouter(router)</span><br><span class="line"></span><br><span class="line">trueklog.Println(&quot;Server started at &quot;, conf.Port)</span><br><span class="line">truerouter.Run(&quot;:&quot; + conf.Port)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func testRouter(r *gin.Engine) &#123;</span><br><span class="line">truefmt.Println(&quot;test post...&quot;)</span><br><span class="line">    </span><br><span class="line">    r.POST(&quot;/foobar/test&quot;, foobar_test)</span><br><span class="line">    r.POST(&quot;/foobar/test_back&quot;, foobar_test_back)</span><br><span class="line">    // 注：此处直接响应端口的访问，因为实际中使用nginx转发的</span><br><span class="line">truer.POST(&quot;/&quot;, fee_test_back)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上一版本基础上添加<code>restartAll</code>函数。下面给出实现。  </p><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><p><code>restartAll</code>函数实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">停止后端服务（如有），</span><br><span class="line">启动后端服务，同时分配端口</span><br><span class="line">*/</span><br><span class="line">func restartAll() &#123;</span><br><span class="line">true// 通过端口限定，仅作测试</span><br><span class="line">truethePort, _ := strconv.Atoi(conf.Port)</span><br><span class="line">trueif thePort &gt;= 9000 &#123;</span><br><span class="line">truetruereturn</span><br><span class="line">true&#125;</span><br><span class="line">trueklog.Println(&quot;restartAll...&quot;)</span><br><span class="line"></span><br><span class="line">trueappname := &quot;./httpforward_back&quot;</span><br><span class="line"></span><br><span class="line">trueklog.Printf(&quot;try to kill backend server %s\n&quot;, appname[2:])</span><br><span class="line">true// exec.Command(&quot;sh&quot;, &quot;-c&quot;, fmt.Sprintf(&quot;pkill -SIGINT %s&quot;, appname[2:])).Output()</span><br><span class="line">trueexec.Command(&quot;sh&quot;, &quot;-c&quot;, fmt.Sprintf(&quot;killall %s&quot;, appname[2:])).Output()</span><br><span class="line"></span><br><span class="line">true// os.Exit(0)</span><br><span class="line">true// 假定有12个端口，即12个后端服务，但额外有一个防止出错的端口</span><br><span class="line">truestartport := 9000</span><br><span class="line">trueconf.BackPorts = []int&#123;&#125;</span><br><span class="line">truefor i := 0; i &lt; 13; i++ &#123;</span><br><span class="line">truetrueport := startport + i</span><br><span class="line">truetrueklog.Println(&quot;run in port: &quot;, port)</span><br><span class="line">truetrueconf.BackPorts = append(conf.BackPorts, port)</span><br><span class="line">truetrue// note：使用系自带的接口，只启动，不等待，必须用&#x27;sh -c&#x27;格式，且不能合并</span><br><span class="line">truetruecmd := exec.Command(&quot;sh&quot;, &quot;-c&quot;, fmt.Sprintf(&quot;%s -p %d -i \&quot;run in port %d\&quot; &amp;&quot;, appname, port, port))</span><br><span class="line">truetrueerr := cmd.Start()</span><br><span class="line">truetrueif err != nil &#123;</span><br><span class="line">truetruetrueklog.Printf(&quot;!! NOTE !! server on port %d start failed: %v\n&quot;, port, err.Error())</span><br><span class="line">truetrue&#125;</span><br><span class="line">true&#125;</span><br><span class="line">truefmt.Printf(&quot;run %d backend server ok\n&quot;, len(conf.BackPorts))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>转发实现函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">func foobar_test(ctx *gin.Context) &#123;</span><br><span class="line"></span><br><span class="line">true// 2种方式都可，但 ctx.Request.FormFile 可以得到文件句柄，可直接拷贝</span><br><span class="line">true//file, err := ctx.FormFile(&quot;file&quot;)</span><br><span class="line">truefile, header, err := ctx.Request.FormFile(&quot;file&quot;)</span><br><span class="line">trueif err != nil &#123;</span><br><span class="line">truetruectx.JSON(http.StatusBadRequest, gin.H&#123;</span><br><span class="line">truetruetrue&quot;error&quot;: err,</span><br><span class="line">truetrue&#125;)</span><br><span class="line">truetruereturn</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">true// 拿到文件和长度，后面使用到</span><br><span class="line">truevar jsonfilename string = header.Filename</span><br><span class="line">truemysize := header.Size</span><br><span class="line">truefmt.Printf(&quot;filename: %s size: %d\n&quot;, jsonfilename, mysize)</span><br><span class="line"></span><br><span class="line">trueif err != nil &#123;</span><br><span class="line">truetruectx.JSON(http.StatusBadRequest, gin.H&#123;</span><br><span class="line">truetruetrue&quot;error&quot;: err,</span><br><span class="line">truetrue&#125;)</span><br><span class="line">truetruereturn</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">true// 处理json文件</span><br><span class="line">truejsonbuf := make([]byte, mysize)</span><br><span class="line">true_, err = file.Read(jsonbuf)</span><br><span class="line">true// 注：读取了文件，要回到文件头，否则就没有内容了，因此这里用seek</span><br><span class="line">truefile.Seek(0, 0)</span><br><span class="line"></span><br><span class="line">truevar data map[string]interface&#123;&#125;</span><br><span class="line">trueerr = json.Unmarshal(jsonbuf, &amp;data)</span><br><span class="line">true//fmt.Println(&quot;unmarshal: &quot;, err, data)</span><br><span class="line"></span><br><span class="line">truevar exTime string</span><br><span class="line">trueexTime1 := data[&quot;exTime&quot;]</span><br><span class="line">true// 如果出口时间没有，出错</span><br><span class="line">trueif exTime1 == nil &#123;</span><br><span class="line">truetruefmt.Println(&quot;exTime not found!&quot;)</span><br><span class="line"></span><br><span class="line">truetruectx.JSON(</span><br><span class="line">truetruetruehttp.StatusOK,</span><br><span class="line">truetruetruegin.H&#123;</span><br><span class="line">truetruetruetrue&quot;code&quot;: -1,</span><br><span class="line">truetruetruetrue&quot;msg&quot;:  &quot;failed&quot;,</span><br><span class="line">truetruetruetrue&quot;data&quot;: gin.H&#123;</span><br><span class="line">truetruetruetruetrue&quot;result&quot;: &quot;exTime not found&quot;,</span><br><span class="line">truetruetruetrue&#125;,</span><br><span class="line">truetruetrue&#125;,</span><br><span class="line">truetrue)</span><br><span class="line">truetruereturn</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">trueexTime = exTime1.(string)</span><br><span class="line">true// exTime不合法</span><br><span class="line">trueif len(exTime) == 0 &#123;</span><br><span class="line">truetruectx.JSON(</span><br><span class="line">truetruetruehttp.StatusOK,</span><br><span class="line">truetruetruegin.H&#123;</span><br><span class="line">truetruetruetrue&quot;code&quot;: -1,</span><br><span class="line">truetruetruetrue&quot;msg&quot;:  &quot;failed&quot;,</span><br><span class="line">truetruetruetrue&quot;data&quot;: gin.H&#123;</span><br><span class="line">truetruetruetruetrue&quot;result&quot;: &quot;exTime is empty&quot;,</span><br><span class="line">truetruetruetrue&#125;,</span><br><span class="line">truetruetrue&#125;,</span><br><span class="line">truetrue)</span><br><span class="line"></span><br><span class="line">truetruereturn</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">truefmt.Printf(&quot;exTime: %s\n&quot;, exTime)</span><br><span class="line"></span><br><span class="line">true// 此处选择一个URL</span><br><span class="line"></span><br><span class="line">trueurl := getOneServerUrl(exTime)</span><br><span class="line">true// 返回空，可能后端服务未启动或内部错误</span><br><span class="line">trueif len(url) == 0 &#123;</span><br><span class="line">truetruectx.JSON(</span><br><span class="line">truetruetruehttp.StatusOK,</span><br><span class="line">truetruetruegin.H&#123;</span><br><span class="line">truetruetruetrue&quot;code&quot;: -1,</span><br><span class="line">truetruetruetrue&quot;msg&quot;:  &quot;failed&quot;,</span><br><span class="line">truetruetruetrue&quot;data&quot;: gin.H&#123;</span><br><span class="line">truetruetruetruetrue&quot;result&quot;: &quot;ant get backend server url&quot;,</span><br><span class="line">truetruetruetrue&#125;,</span><br><span class="line">truetruetrue&#125;,</span><br><span class="line">truetrue)</span><br><span class="line"></span><br><span class="line">truetruereturn</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">trueresp, err := post_data_gin(url, jsonfilename, file)</span><br><span class="line">true// 返回空，可能后端服务未启动或内部错误</span><br><span class="line">trueif len(resp) == 0 &#123;</span><br><span class="line">truetruectx.JSON(</span><br><span class="line">truetruetruehttp.StatusOK,</span><br><span class="line">truetruetruegin.H&#123;</span><br><span class="line">truetruetruetrue&quot;code&quot;: -1,</span><br><span class="line">truetruetruetrue&quot;msg&quot;:  &quot;failed&quot;,</span><br><span class="line">truetruetruetrue&quot;data&quot;: gin.H&#123;</span><br><span class="line">truetruetruetruetrue&quot;result&quot;: fmt.Sprintf(&quot;backend server error: %s&quot;, err.Error()), //&quot;backend server error: &quot; + err.Error(),</span><br><span class="line">truetruetruetrue&#125;,</span><br><span class="line">truetruetrue&#125;,</span><br><span class="line">truetrue)</span><br><span class="line"></span><br><span class="line">truetruereturn</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">true// 解析返回字符切片，得到map，当成json，赋值给gin</span><br><span class="line">truevar data1 map[string]interface&#123;&#125;</span><br><span class="line">trueerr = json.Unmarshal(resp, &amp;data1)</span><br><span class="line">true//fmt.Println(&quot;muti unmarshal: &quot;, err, data1)</span><br><span class="line"></span><br><span class="line">truectx.JSON(http.StatusOK, data1)</span><br><span class="line"></span><br><span class="line">truereturn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getOneServerUrl</code>函数实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">// 根据时间选择一个后端服务器URL</span><br><span class="line">func getOneServerUrl(exTime string) (url string) &#123;</span><br><span class="line">trueurl = &quot;&quot;</span><br><span class="line">trueif len(exTime) == 0 &#123;</span><br><span class="line">truetruereturn</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">true// 时间有2个格式，这里都判断一下</span><br><span class="line">truemytime, _ := time.Parse(&quot;2006-01-02T15:04:05&quot;, exTime)</span><br><span class="line">truethemonth := int(mytime.Month())</span><br><span class="line">true// 如果不合法，年月日均为1</span><br><span class="line">trueif mytime.Year() == 1 &amp;&amp; themonth == 1 &amp;&amp; mytime.Day() == 1 &#123;</span><br><span class="line">truetruemytime, _ = time.Parse(&quot;2006-01-02 15:04:05&quot;, exTime)</span><br><span class="line">truetrue// 还是不合法</span><br><span class="line">truetrueif mytime.Year() == 1 &amp;&amp; themonth == 1 &amp;&amp; mytime.Day() == 1 &#123;</span><br><span class="line">truetruetruethemonth = 0</span><br><span class="line">truetrue&#125; else &#123;</span><br><span class="line">truetruetruethemonth = int(mytime.Month())</span><br><span class="line">truetrue&#125;</span><br><span class="line">true&#125;</span><br><span class="line">trueif themonth &gt;= len(conf.BackPorts) &#123;</span><br><span class="line">truetruethemonth = 0</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">trueurl = fmt.Sprintf(&quot;http://127.0.0.1:%d&quot;, conf.BackPorts[themonth])</span><br><span class="line">truefmt.Println(&quot;got url: &quot;, url)</span><br><span class="line"></span><br><span class="line">truereturn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> 模拟后台的仅获取file字段的json，不作其它处理</span><br><span class="line"> curl http://127.0.0.1:84/foobar/test_back -X POST -F  &quot;file=@sample.json&quot;</span><br><span class="line">*/</span><br><span class="line">func foobar_test_back(ctx *gin.Context) &#123;</span><br><span class="line">true// 2种方式都可，但 ctx.Request.FormFile 可以得到文件句柄，可直接拷贝</span><br><span class="line">true//file, err := ctx.FormFile(&quot;file&quot;)</span><br><span class="line">truefile, header, err := ctx.Request.FormFile(&quot;file&quot;)</span><br><span class="line">trueif err != nil &#123;</span><br><span class="line">truetruectx.JSON(</span><br><span class="line">truetruetruehttp.StatusBadRequest,</span><br><span class="line">truetruetruegin.H&#123;</span><br><span class="line">truetruetruetrue&quot;code&quot;: -1,</span><br><span class="line">truetruetruetrue&quot;msg&quot;:  &quot;failed&quot;,</span><br><span class="line">truetruetruetrue&quot;data&quot;: gin.H&#123;</span><br><span class="line">truetruetruetruetrue&quot;result&quot;: &quot;failed in back end server, port:&quot; + conf.Port,</span><br><span class="line">truetruetruetrue&#125;,</span><br><span class="line">truetruetrue&#125;,</span><br><span class="line">truetrue)</span><br><span class="line"></span><br><span class="line">truetruereturn</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">true// 拿到文件和长度，后面使用到</span><br><span class="line">truevar myfile string = header.Filename</span><br><span class="line">truemysize := header.Size</span><br><span class="line">truefmt.Printf(&quot;filename: %s size: %d\n&quot;, myfile, mysize)</span><br><span class="line"></span><br><span class="line">trueif mysize &lt;= 0 &#123;</span><br><span class="line">truetruectx.JSON(</span><br><span class="line">truetruetruehttp.StatusBadRequest,</span><br><span class="line">truetruetruegin.H&#123;</span><br><span class="line">truetruetruetrue&quot;code&quot;: -1,</span><br><span class="line">truetruetruetrue&quot;msg&quot;:  &quot;failed&quot;,</span><br><span class="line">truetruetruetrue&quot;data&quot;: gin.H&#123;</span><br><span class="line">truetruetruetruetrue&quot;result&quot;: &quot;failed in back end server, json size 0, port: &quot; + conf.Port,</span><br><span class="line">truetruetruetrue&#125;,</span><br><span class="line">truetruetrue&#125;,</span><br><span class="line">truetrue)</span><br><span class="line"></span><br><span class="line">truetruereturn</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">true// 此处可保存文件</span><br><span class="line"></span><br><span class="line">true/////////////////////////////////////////</span><br><span class="line">true// 处理json文件</span><br><span class="line">truejsonbuf := make([]byte, mysize)</span><br><span class="line">true_, err = file.Read(jsonbuf)</span><br><span class="line">true// 注：读取了文件，要回到文件头，否则就没有内容了，因此这里用seek</span><br><span class="line">truefile.Seek(0, 0)</span><br><span class="line">true//fmt.Printf(&quot;read %d %v\n%v\n&quot;, n, err, string(jsonbuf));</span><br><span class="line"></span><br><span class="line">truevar data map[string]interface&#123;&#125;</span><br><span class="line">trueerr = json.Unmarshal(jsonbuf, &amp;data)</span><br><span class="line">true//fmt.Println(&quot;unmarshal: &quot;, err, data)</span><br><span class="line"></span><br><span class="line">truevar exTime string</span><br><span class="line">trueexTime1 := data[&quot;exTime&quot;]</span><br><span class="line">true// 如果出口时间没有，出错</span><br><span class="line">trueif exTime1 == nil &#123;</span><br><span class="line">truetruefmt.Println(&quot;exTime not found!&quot;)</span><br><span class="line"></span><br><span class="line">truetruectx.JSON(</span><br><span class="line">truetruetruehttp.StatusOK,</span><br><span class="line">truetruetruegin.H&#123;</span><br><span class="line">truetruetruetrue&quot;queryState&quot;:   0, // 0表示失败</span><br><span class="line">truetruetruetrue&quot;massage&quot;:      &quot;exTime not found&quot;,</span><br><span class="line">truetruetruetrue&quot;provinceFees&quot;: gin.H&#123;&#125;,</span><br><span class="line">truetruetrue&#125;,</span><br><span class="line">truetrue)</span><br><span class="line"></span><br><span class="line">truetruereturn</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">trueexTime = exTime1.(string)</span><br><span class="line">truefmt.Println(&quot;extime: &quot;, exTime)</span><br><span class="line">true/////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">true//保存成功返回正确的Json数据</span><br><span class="line">truectx.JSON(</span><br><span class="line">truetruehttp.StatusOK,</span><br><span class="line">truetruegin.H&#123;</span><br><span class="line">truetruetrue&quot;code&quot;: 0,</span><br><span class="line">truetruetrue&quot;msg&quot;:  &quot;ok&quot;,</span><br><span class="line">truetruetrue&quot;data&quot;: gin.H&#123;</span><br><span class="line">truetruetruetrue&quot;result&quot;: &quot;ok in back end server, port: &quot; + conf.Port + &quot; info: &quot; + conf.BackInfo,</span><br><span class="line">truetruetrue&#125;,</span><br><span class="line">truetrue&#125;,</span><br><span class="line">true)</span><br><span class="line"></span><br><span class="line">truereturn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>本文使用 sample.json 文件测试，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">true&quot;enID&quot;: &quot;ID250&quot;,</span><br><span class="line">true&quot;exID&quot;: &quot;ID251&quot;,</span><br><span class="line">    &quot;exTime&quot;: &quot;2020-09-17T20:00:27&quot;,</span><br><span class="line">true&quot;type&quot;: 1,</span><br><span class="line">true&quot;money&quot;: 250.44,</span><br><span class="line">true&quot;distance&quot;: 274050</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为简单起见，将可执行文件拷贝一份，命名为<code>httpforward_back</code>。</p><p>先运行 84 端口服务，会自动启动所有的后端进程。打印如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># ./httpforward.exe -p 84</span><br><span class="line">[2021-09-09 14:56:40.691 restart.go:26] restartAll...</span><br><span class="line">[2021-09-09 14:56:40.691 restart.go:38] try to kill backend server httpforward_back</span><br><span class="line">[2021-09-09 14:56:40.700 restart.go:55] run in port:  9000</span><br><span class="line">[2021-09-09 14:56:40.707 restart.go:55] run in port:  9001</span><br><span class="line">[2021-09-09 14:56:40.712 restart.go:55] run in port:  9002</span><br><span class="line">[2021-09-09 14:56:40.729 restart.go:55] run in port:  9003</span><br><span class="line">[2021-09-09 14:56:40.732 restart.go:55] run in port:  9004</span><br><span class="line">[2021-09-09 14:56:40.761 restart.go:55] run in port:  9005</span><br><span class="line">[2021-09-09 14:56:40.768 restart.go:55] run in port:  9006</span><br><span class="line">[2021-09-09 14:56:40.783 restart.go:55] run in port:  9007</span><br><span class="line">[2021-09-09 14:56:40.803 restart.go:55] run in port:  9008</span><br><span class="line">[2021-09-09 14:56:40.807 restart.go:55] run in port:  9009</span><br><span class="line">[2021-09-09 14:56:40.809 restart.go:55] run in port:  9010</span><br><span class="line">[2021-09-09 14:56:40.811 restart.go:55] run in port:  9011</span><br><span class="line">[2021-09-09 14:56:40.849 restart.go:55] run in port:  9012</span><br><span class="line">run 13 backend server ok</span><br><span class="line">[GIN-debug] [WARNING] Running in &quot;debug&quot; mode. Switch to &quot;release&quot; mode in production.</span><br><span class="line"> - using env:   export GIN_MODE=release</span><br><span class="line"> - using code:  gin.SetMode(gin.ReleaseMode)</span><br><span class="line"></span><br><span class="line">test post...</span><br><span class="line">[GIN-debug] POST   /foobar/test                 --&gt; goweb/cmd/gin.fee_test (3 handlers)</span><br><span class="line">[GIN-debug] POST   /foobar/test_back            --&gt; goweb/cmd/gin.fee_test_back (3 handlers)</span><br><span class="line">[GIN-debug] POST   /                         --&gt; goweb/cmd/gin.fee_test_back (3 handlers)</span><br><span class="line">[2021-09-09 14:56:40.885 busy.go:77] Server started at  84</span><br><span class="line">[GIN-debug] Listening and serving HTTP on :84</span><br></pre></td></tr></table></figure><p>启动一终端，执行测试命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:84/foobar/ -X POST -F  &quot;file=@sample.json&quot;</span><br></pre></td></tr></table></figure><p>可以修改<code>sample.json</code>文件的<code>exTime</code>观察转发的端口和返回值 </p><p>84 服务打印：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">filename: sample.json size: 133</span><br><span class="line">exTime: 2020-09-17T20:00:27</span><br><span class="line">got url:  http://127.0.0.1:9009</span><br><span class="line">[GIN] 2021/09/09 - 14:56:44 | 200 |    3.664936ms |    192.168.28.5 | POST     &quot;/foobar/test&quot;</span><br><span class="line"></span><br><span class="line">filename: sample.json size: 133</span><br><span class="line">exTime: 2020-12-17T20:00:27</span><br><span class="line">got url:  http://127.0.0.1:9012</span><br><span class="line">[GIN] 2021/09/09 - 15:04:30 | 200 |    2.465313ms |    192.168.28.5 | POST     &quot;/foobar/test&quot;</span><br></pre></td></tr></table></figure><p>测试命令返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100   434  100    98  100   336  16333  56000 --:--:-- --:--:-- --:--:-- 72333&#123;&quot;code&quot;:0,&quot;data&quot;:&#123;&quot;result&quot;:&quot;ok in back end server, port: 9009 info: run in port 9009&quot;&#125;,&quot;msg&quot;:&quot;ok&quot;&#125;</span><br><span class="line"></span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100   434  100    98  100   336   5764  19764 --:--:-- --:--:-- --:--:-- 27125&#123;&quot;code&quot;:0,&quot;data&quot;:&#123;&quot;result&quot;:&quot;ok in back end server, port: 9012 info: run in port 9012&quot;&#125;,&quot;msg&quot;:&quot;ok&quot;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也可直接向后端服务请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://127.0.0.1:85/foobar/test_back -X POST -F  &quot;file=@sample.json&quot;</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100   361  100    63  100   298  63000   291k --:--:-- --:--:-- --:--:--  352k&#123;&quot;code&quot;:0,&quot;data&quot;:&#123;&quot;result&quot;:&quot;ok in back end server&quot;&#125;,&quot;msg&quot;:&quot;ok&quot;&#125;</span><br></pre></td></tr></table></figure><p>2021.9.18 夜</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;近段时间需要实现一个转发 post 请求到指定后端服务的小工具，由于一直想学习 gin 框架，所以就使用这个框架进行尝试，预计会产生几篇文章。本文研究如何管理后端服务。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：使用gin框架实现转发功能：上传文件并转发</title>
    <link href="http://www.latelee.org/golang/golang-notes-gin-httpforward1.html"/>
    <id>http://www.latelee.org/golang/golang-notes-gin-httpforward1.html</id>
    <published>2021-09-17T14:40:00.000Z</published>
    <updated>2021-10-20T16:10:49.022Z</updated>
    
    <content type="html"><![CDATA[<p>近段时间需要实现一个转发 post 请求到指定后端服务的小工具，由于一直想学习 gin 框架，所以就使用这个框架进行尝试，预计会产生几篇文章。本文先研究如何在 gin 框架中实现上传和转发功能。  </p><span id="more"></span><h2 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h2><p>一后台 web 服务，有众多历史版本，本身运行无问题，但后来需求变更，需将不同的历史版本单独运行，并指定不同端口。对外相当于有众多的服务。在请求 post 中带有日期时间，需要根据该日期时间将请求转发到不同的端口的后端服务。注意，post 请求是直接使用文件的形式，对文件名称有特定要求。  </p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>nginx可以根据端口来转发，但本文是根据请求的内容转发的，因此需要实现一个转发工具。即先读取外部请求的文件内容，解析得到时间，再根据时间，转发到不同的端口服务中。要解决的问题：<br>如何做到既解析 post 请求，又要将该请求原封不动地发到后端服务？后端服务返回的数据，如何原封不动地返回请求者？<br>如何管理后端服务？如果使用额外的脚本，则添加了运维部署的步骤，略有麻烦。故考虑在转发工具中实现。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>使用工具进行 post 请求，并且指定文件名。可用 postman 或 curl，本文使用后者。  </li></ul><p>转发函数：    </p><ul><li>利用 ctx.Request.FormFile 得到文件名称、文件内容，此时，可以使用 gin 提供的 SaveUploadedFile 函数保存文件，也可以调用  io.Copy 保存。前者省事。  </li><li>调用再次转发函数。  </li><li>将再次转发函数返回值转换成 json 形式，返回 post 请求工具。  </li></ul><p>再次转发函数：  </p><ul><li>利用 multipart 包创建文件，将上一步得到的文件拷贝进去。  </li><li>再用 http 库发送请求。注意需要设置格式。  </li><li>最后读取请求的返回值，再返回，注意，内容为字节形式。  </li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="主要接口代码"><a href="#主要接口代码" class="headerlink" title="主要接口代码"></a>主要接口代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func RunWebServer(args []string) &#123;</span><br><span class="line">    runWebOnlyPost()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func runWebOnlyPost() &#123;</span><br><span class="line">truerouter := gin.New()</span><br><span class="line">truerouter.Use(gin.Logger())</span><br><span class="line">truerouter.Use(gin.Recovery())</span><br><span class="line"></span><br><span class="line">truetestRouter(router)</span><br><span class="line"></span><br><span class="line">trueklog.Println(&quot;Server started at &quot;, conf.Port)</span><br><span class="line">truerouter.Run(&quot;:&quot; + conf.Port)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func testRouter(r *gin.Engine) &#123;</span><br><span class="line">truefmt.Println(&quot;test post...&quot;)</span><br><span class="line">    </span><br><span class="line">    r.POST(&quot;/foobar/test&quot;, foobar_test)</span><br><span class="line">    r.POST(&quot;/foobar/test_back&quot;, foobar_test_back) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line"> curl http://127.0.0.1:84/foobar/test -X POST -F  &quot;file=@sample.json&quot;</span><br><span class="line"> </span><br><span class="line"> 临时：</span><br><span class="line"> file读取了一次，再读就没有内容了，字节数为0</span><br><span class="line">*/</span><br><span class="line">func foobar_test(ctx *gin.Context) &#123;</span><br><span class="line">    </span><br><span class="line">    // 2种方式都可，但 ctx.Request.FormFile 可以得到文件句柄，可直接拷贝</span><br><span class="line">    //file, err := ctx.FormFile(&quot;file&quot;)</span><br><span class="line">    file, header, err := ctx.Request.FormFile(&quot;file&quot;)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        ctx.JSON(http.StatusBadRequest, gin.H&#123;</span><br><span class="line">        &quot;error&quot;: err,</span><br><span class="line">        &#125;)</span><br><span class="line">        return</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    //fmt.Printf(&quot;Request: %+v\n&quot;, ctx.Request);</span><br><span class="line">    //fmt.Printf(&quot;Formfile: %+v | %+v |||  %v %v\n&quot;, file, header, err, reflect.TypeOf(file));</span><br><span class="line">    </span><br><span class="line">    // 拿到文件和长度，后面使用到</span><br><span class="line">    var jsonfilename string = header.Filename</span><br><span class="line">    mysize := header.Size</span><br><span class="line">    fmt.Printf(&quot;filename: %s size: %d\n&quot;, jsonfilename, mysize);</span><br><span class="line">    </span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        ctx.JSON(http.StatusBadRequest, gin.H&#123;</span><br><span class="line">        &quot;error&quot;: err,</span><br><span class="line">        &#125;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 处理json文件 </span><br><span class="line">    // 注：如果读取了文件，再转发，就没有内容了，所以这里不读取</span><br><span class="line">    </span><br><span class="line">    // 指向后端的服务URL</span><br><span class="line">    url := &quot;http://127.0.0.1:85/foobar/test_back&quot;</span><br><span class="line">    resp := post_data_gin(url, jsonfilename, file);</span><br><span class="line"></span><br><span class="line">    // 解析返回字符切片，得到map，当成json，赋值给gin</span><br><span class="line">    var data1 map[string]interface&#123;&#125;</span><br><span class="line">    err = json.Unmarshal(resp, &amp;data1)</span><br><span class="line">    //fmt.Println(&quot;muti unmarshal: &quot;, err, data1)</span><br><span class="line">    </span><br><span class="line">    ctx.JSON(http.StatusOK, data1)</span><br><span class="line">    </span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> 模拟后台的仅获取file字段的json，不作其它处理</span><br><span class="line"> curl http://127.0.0.1:84/foobar/test_back -X POST -F  &quot;file=@sample.json&quot;</span><br><span class="line">*/</span><br><span class="line">func foobar_test_back(ctx *gin.Context) &#123;</span><br><span class="line">    </span><br><span class="line">    // 2种方式都可，但 ctx.Request.FormFile 可以得到文件句柄，可直接拷贝</span><br><span class="line">    //file, err := ctx.FormFile(&quot;file&quot;)</span><br><span class="line">    _, header, err := ctx.Request.FormFile(&quot;file&quot;)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        ctx.JSON(</span><br><span class="line">            http.StatusBadRequest,</span><br><span class="line">            gin.H&#123;</span><br><span class="line">                &quot;code&quot;: -1,</span><br><span class="line">                &quot;msg&quot;:  &quot;failed&quot;,</span><br><span class="line">                &quot;data&quot;: gin.H&#123;</span><br><span class="line">                    &quot;result&quot;: &quot;failed in back end server&quot;,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 拿到文件和长度，后面使用到</span><br><span class="line">    var myfile string = header.Filename</span><br><span class="line">    mysize := header.Size</span><br><span class="line">    fmt.Printf(&quot;filename: %s size: %d\n&quot;, myfile, mysize);</span><br><span class="line">    </span><br><span class="line">    if mysize &lt;= 0 &#123;</span><br><span class="line">        ctx.JSON(</span><br><span class="line">            http.StatusBadRequest,</span><br><span class="line">            gin.H&#123;</span><br><span class="line">                &quot;code&quot;: -1,</span><br><span class="line">                &quot;msg&quot;:  &quot;failed&quot;,</span><br><span class="line">                &quot;data&quot;: gin.H&#123;</span><br><span class="line">                    &quot;result&quot;: &quot;failed in back end server, json size 0&quot;,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 此处可保存文件</span><br><span class="line"></span><br><span class="line">    //保存成功返回正确的Json数据</span><br><span class="line">    ctx.JSON(</span><br><span class="line">truetruehttp.StatusOK,</span><br><span class="line">truetruegin.H&#123;</span><br><span class="line">truetruetrue&quot;code&quot;: 0,</span><br><span class="line">truetruetrue&quot;msg&quot;:  &quot;ok&quot;,</span><br><span class="line">truetruetrue&quot;data&quot;: gin.H&#123;</span><br><span class="line">truetruetruetrue&quot;result&quot;: &quot;ok in back end server&quot;,</span><br><span class="line">truetruetrue&#125;,</span><br><span class="line">truetrue&#125;,</span><br><span class="line">true)</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为测试方便，文中实现的 gin 框架程序在运行时可指定端口。因此，代码中实现了2个 url 的响应函数。  </p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>本文使用 sample.json 文件测试，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">true&quot;enID&quot;: &quot;ID250&quot;,</span><br><span class="line">true&quot;exID&quot;: &quot;ID251&quot;,</span><br><span class="line">    &quot;exTime&quot;: &quot;2020-09-17T20:00:27&quot;,</span><br><span class="line">true&quot;type&quot;: 1,</span><br><span class="line">true&quot;money&quot;: 250.44,</span><br><span class="line">true&quot;distance&quot;: 274050</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先运行 84 端口服务（称为 84 服务），此为对外的服务。再运行 85 端口服务（称为 85 服务），此为模拟后端的服务。<br>启动一终端，执行测试命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:84/foobar/ -X POST -F  &quot;file=@sample.json&quot;</span><br></pre></td></tr></table></figure><p>84 服务打印：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[2021-08-25 23:51:19.424 busy.go:79] Server started at  84</span><br><span class="line">[GIN-debug] Listening and serving HTTP on :84</span><br><span class="line">filename: sample.json size: 95</span><br><span class="line">io copy: 95 &lt;nil&gt;</span><br><span class="line">[GIN] 2021/08/25 - 23:53:59 | 200 |      3.0002ms |       127.0.0.1 | POST     &quot;/foobar/test&quot;</span><br></pre></td></tr></table></figure><p>85 服务打印：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[GIN-debug] Listening and serving HTTP on :85</span><br><span class="line">filename: sample.json size: 95</span><br><span class="line">[GIN] 2021/08/25 - 23:53:59 | 200 |            0s |       127.0.0.1 | POST     &quot;/foobar/test_back&quot;</span><br></pre></td></tr></table></figure><p>测试命令返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100   361  100    63  100   298  31500   145k --:--:-- --:--:-- --:--:--  352k&#123;&quot;code&quot;:0,&quot;data&quot;:&#123;&quot;result&quot;:&quot;ok in back end server&quot;&#125;,&quot;msg&quot;:&quot;ok&quot;&#125;</span><br></pre></td></tr></table></figure><p>也可直接向后端服务请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://127.0.0.1:85/fee/test_back -X POST -F  &quot;file=@sample.json&quot;</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100   361  100    63  100   298  63000   291k --:--:-- --:--:-- --:--:--  352k&#123;&quot;code&quot;:0,&quot;data&quot;:&#123;&quot;result&quot;:&quot;ok in back end server&quot;&#125;,&quot;msg&quot;:&quot;ok&quot;&#125;</span><br></pre></td></tr></table></figure><p>2021.9.17 夜</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;近段时间需要实现一个转发 post 请求到指定后端服务的小工具，由于一直想学习 gin 框架，所以就使用这个框架进行尝试，预计会产生几篇文章。本文先研究如何在 gin 框架中实现上传和转发功能。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>新公司入职这一年</title>
    <link href="http://www.latelee.org/the-life/one-year-in-new-company%EF%BC%8D2021.html"/>
    <id>http://www.latelee.org/the-life/one-year-in-new-company%EF%BC%8D2021.html</id>
    <published>2021-09-16T15:50:59.000Z</published>
    <updated>2021-10-20T16:10:49.194Z</updated>
    
    <content type="html"><![CDATA[<p>自去年8月正式入职至今天，整整一年了。值此之际，写一写入职一年来的事。<br>一年前，有很多家事、小孩事等烦心事，对未来也忧心忡忡，现在，看着会叫爸爸的李大锤越来越顽皮，心里石头也放下了。<br>这一年，体验过几次民族大道的午夜，也见过几次民族大道的夕阳。路过繁华闹市，也路过冷清小巷。  </p><span id="more"></span><h2 id="偶然机遇"><a href="#偶然机遇" class="headerlink" title="偶然机遇"></a>偶然机遇</h2><p>2017年5月初，与覃博士约在万象城喝咖啡，喝着戒了多年的咖啡，与覃博进行会谈。以我水平，技术上没有任何问题。——这点自信我是有的。当时我要求的薪酬是10K，这个价格我还是小心翼翼地提出来，毕竟在广西这种小地方呆久了，不敢开太高。那时因为家事，一度曾去深圳发展，又一度下定决心在南宁不到处跑了，毕业7年了，还是逃不出南宁。经过几次交流，虽然薪酬没有达到我的期望值，但给了我希望，因为这是一个初创的公司，我相信有我发挥的地方。——后来才知道，当时还没办理营业执照，公司还未装修完。  </p><p>辗转到了7月中旬，我还在继续陪小孩，以减少老婆的工作量。但还是每天去一次公司当监工，在此过程，学习了很多知识，也见识了各种扯皮。还好最终顺利结束，机房、空调、灯、桌椅等验收通过。  </p><p>营业执照是8月8日那天审批通过的，也宣示公司正式成立了。  </p><h2 id="技术管理"><a href="#技术管理" class="headerlink" title="技术管理"></a>技术管理</h2><p>新公司一切都是新的，成立那天，只有CEO、CTO、一名行政，以及一个我。然后慢慢制定考勤制度、机房制度，再到招聘，申请域名，申请企业邮箱，申请备案，等。我几乎都参与了。这些，我都有了解或熟悉，真是冥冥中有天意。但我也不是一下子全部展示出来，像面试的流程，技巧，也是慢慢让领导看到我的能力。以至于后来，C开发、JAVA开发、测试人员、嵌入式人员，都由我面试，直到后面人员到位，我才专注于某些方面的面试。  </p><p>这一年来，面试过的人，根据记录，大约有50多个，各式的人也遇到过，有不授受单休的；有关注天使轮，产品盈利点的；有对公司管理方式和产品指手画脚的；也遇到过很多年轻人，在深圳工作三年回南宁发展要价10K的。  </p><p>虽然我没有正式当过领导，但以前也是经过半年的磨练，在带人、沟通方面有了很大提高。</p><h2 id="基础设施"><a href="#基础设施" class="headerlink" title="基础设施"></a>基础设施</h2><p>综合看，这一年时间来，在管理人、公司杂事和技术构建中，都花费不少时间。但这都是必须付出的。  </p><p>这一年，经历了物理机部署到docker部署应用的全面进化。建立以gitlab+jenkins为核心的CICD系统。建立了编程规范、技术管理规范等制度流程。</p><p>未来争取将自己从杂事中抽身出来，专注于核心的事务。</p><h2 id="个人技能"><a href="#个人技能" class="headerlink" title="个人技能"></a>个人技能</h2><p>说实话，这一年来的技能没有提升多少，嵌入式Linux基本上已经不搞了，偶尔指导同事而已。但是docker是新学的，也发现docker的确能带来很多的便利。现在docker基本上可以说上手了，各种应用没问题。但是k8s却用得不多，因为时间关系，没有太专注于k8s。而微服务架构这方面，还不能说入门，只是有个概念。</p><p>从公司职位划分来说，我负责公司运维系统，但直到现在，后台服务人手还是不够，基础功能未完善，还要继续充当开发人员角色。</p><h2 id="个人生活"><a href="#个人生活" class="headerlink" title="个人生活"></a>个人生活</h2><p>每周上六天班，每周有三天加班到晚上10点，工作强度能接受，只是时间跨度大，与老婆孩子呆在一起的时间少。当然，呆的时间长了，或多或少都有矛盾，从这点看，加班还是有好处的。</p><p>也正是因为工作时间长，加上要带小孩，个人业余时间被压缩得很少，这一年，文章写得少了，视频也不录了，淘宝店铺也不更新，网友的问题也少回复了。当然，外快也就没有了。</p><p>有一段时间，早上大锤醒得早，就带他到楼顶晒太阳，看房东小孩养的小乌龟，玩一会就要去上班了。晚上加班回来，老婆孩子已经熟睡了。<br>这一年，当大锤生病时，得请假和老婆带着他一起去医院，老婆抱小孩，我排队、拿药。</p><p>这一年，每次大锤打预防针时，得提前去社区医院排队，我抱小孩，老婆拿包。因为这样，不影响上班时间。</p><p>这一年，看着他酣睡的小脸蛋，看着他蹒跚学步，这都是幸福的事。而当听到他第一次叫爸时，我觉得什么辛苦都值得。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>感谢老东家，将近6年的工作经历，无论是核心技能还是职场经验，都让我学到了不少东西，这些东西，不是薪水所能比拟的。但人是要生活——而不是生存的，所以我选择离开。</p><p>感谢新公司CEO，感谢他的赏识，也感谢提供舞台让我发挥，给我技术成就感和物质成就感带来希望。</p><p>机会是留给有准备的人的。是金子的，总会发亮。<br>——我想，是时候了。</p><p>李迟 2018.8.9 深夜</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;自去年8月正式入职至今天，整整一年了。值此之际，写一写入职一年来的事。&lt;br&gt;一年前，有很多家事、小孩事等烦心事，对未来也忧心忡忡，现在，看着会叫爸爸的李大锤越来越顽皮，心里石头也放下了。&lt;br&gt;这一年，体验过几次民族大道的午夜，也见过几次民族大道的夕阳。路过繁华闹市，也路过冷清小巷。  &lt;/p&gt;</summary>
    
    
    
    <category term="生活掠影" scheme="http://www.latelee.org/category/the-life/"/>
    
    
    <category term="个人总结" scheme="http://www.latelee.org/tag/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>李迟2021年8月知识总结</title>
    <link href="http://www.latelee.org/my-library/code-for-2021-08.html"/>
    <id>http://www.latelee.org/my-library/code-for-2021-08.html</id>
    <published>2021-08-31T15:40:00.000Z</published>
    <updated>2021-10-20T16:10:49.098Z</updated>
    
    <content type="html"><![CDATA[<p>本文为 2021 年 8 月知识总结。</p><span id="more"></span><h2 id="编码总结"><a href="#编码总结" class="headerlink" title="编码总结"></a>编码总结</h2><h3 id="C-C"><a href="#C-C" class="headerlink" title="C / C++"></a>C / C++</h3><p>产生随机数示例二则。<br>产生给出范围，并指定数量的随机数。即给定数组（实为向量），其内可预先定义有数值，也可以为空，产生随机数时，需保留原定义的数值（如有），且新的随机数不能与已有的数值相同，已有的值包括原定义的和新产生的。如已有数值 250，则该函数不能再生成 250 这个数。      </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 产生[a~b)之间 n 个随机数，且随机数不同</span><br><span class="line">// 注：包含a本身，但不包含b，当指定数量 n 大于[a~b)范围时，使用范围值</span><br><span class="line">// result可预先设置一些固定的值，即随机数一定包含那些值</span><br><span class="line">int genRandom(std::vector&lt;int&gt;&amp; result, int a, int b, int n)</span><br><span class="line">&#123;</span><br><span class="line">    int total = b - a;</span><br><span class="line">    if (n &gt; total) n = total;</span><br><span class="line"></span><br><span class="line">    int i = 0;</span><br><span class="line">    bool found = false;</span><br><span class="line">    // 注：使用tmp临时保存，如直接用result，得到的容量会多一些</span><br><span class="line">    std::vector&lt;int&gt; tmp;</span><br><span class="line">    tmp.resize(n);</span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        //公式：a + rand() % n，其中n为整数的范围，a为起始值</span><br><span class="line">        tmp[i] =  a + rand() % total;</span><br><span class="line">        // 将生成的值取已有的值对比，如不同，才保存</span><br><span class="line">        found = false;</span><br><span class="line">        for (int j = 0; j &lt; (int)result.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (tmp[i] == result[j])</span><br><span class="line">            &#123;</span><br><span class="line">                found = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!found)</span><br><span class="line">        &#123;</span><br><span class="line">            result.push_back(tmp[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &gt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅产生指定范围内的一个随机数。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int genRandom(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    int total = b - a;</span><br><span class="line"></span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    </span><br><span class="line">    return a + rand() % total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串分割示例。<br>自动去掉字符串前后空格，自动去掉不合法的分隔方式。如：<code>|| 11 |22|33||</code>，原字符串前后分隔符多余，而第字符串有空格。本函数能解析出<code>11、22、33</code>三个有效字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">std::string&amp; trim(std::string &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">    if (s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s.erase(0, s.find_first_not_of(&quot; &quot;));</span><br><span class="line">    s.erase(s.find_last_not_of(&quot; &quot;) + 1);</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line">void splitString(std::vector &lt;std::string&gt; &amp;elems, const std::string &amp; s, const std::string &amp; delim)</span><br><span class="line">&#123;</span><br><span class="line">    // std::vector &lt; std::string &gt; elems;</span><br><span class="line">    size_t pos = 0;</span><br><span class="line">    size_t len = s.length();</span><br><span class="line">    size_t delim_len = delim.length();</span><br><span class="line"></span><br><span class="line">    std::string tmp;</span><br><span class="line">    if (delim_len == 0)</span><br><span class="line">        return;</span><br><span class="line">    while (pos &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        int find_pos = s.find(delim, pos);</span><br><span class="line">        if (find_pos &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = s.substr(pos, len - pos);</span><br><span class="line">            tmp = trim(tmp);</span><br><span class="line">            if(!tmp.empty()) elems.push_back(tmp);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = s.substr(pos, find_pos - pos);</span><br><span class="line">        tmp = trim(tmp);</span><br><span class="line">        if(!tmp.empty()) elems.push_back(tmp);</span><br><span class="line">        pos = find_pos + delim_len;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义打印日志添加 printf 格式检查：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void LogInfo(const char * fmt, ...)  __attribute__((format(printf, 1, 2)));</span><br></pre></td></tr></table></figure><p>添加后，可以防止<code>LogInfo</code>参数类型不匹配或缺少参数情况的发生。</p><h3 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h3><p>着手实现转发功能。</p><h3 id="delphi"><a href="#delphi" class="headerlink" title="delphi"></a>delphi</h3><p>在调试发现提示查询某天日志时，数据库出错。SQL Server 提示<code>[SQL Server]从 varchar 数据类型到 datetime 数据类型的转换产生一个超出范围的值。</code>。oracle 提示<code>ORA-01847: 月份中日的值必须介于 1 和当月最后一日之间</code>。经查，是如下代码出现问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">year:=YearOf(DateTimePicker1.Date);</span><br><span class="line">month:=MonthOfTheYear(DateTimePicker1.Date);</span><br><span class="line">day:=DayOfTheMonth(DateTimePicker1.Date);</span><br><span class="line">datastr:=format(&#x27;%.4d-&#x27;,[year])+format(&#x27;%.2d-&#x27;,[month])+format(&#x27;%.2d&#x27;,[day]);</span><br><span class="line"></span><br><span class="line">datastr1:=format(&#x27;%.4d-&#x27;,[year])+format(&#x27;%.2d-&#x27;,[month])+format(&#x27;%.2d&#x27;,[day-1]);</span><br><span class="line">datastr2:=format(&#x27;%.4d-&#x27;,[year])+format(&#x27;%.2d-&#x27;,[month])+format(&#x27;%.2d&#x27;,[day+1]);</span><br></pre></td></tr></table></figure><p>代码片段先获取当前日期的年、月、日数值，再通过将算术加减计算前一天和后一天，并组装成字符串。当在月初1号或月尾30（或31）时，就出现问题，此时当前日期、前一天、后一天这三个日期值为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2021-08-01 2021-08-00 2021-08-02  </span><br><span class="line">2021-08-31 2021-08-30 2021-08-32  </span><br></pre></td></tr></table></figure><p>可以看到出现了<code>00</code>和<code>32</code>的非法值。日期不能直接用算术的方式加减。而是使用 TDateTime 类型的变量进行加减。如下：</p><pre><code>var tdate, tdate1, tdate2: TDateTime;    tdate := DateTimePicker1.DateTime;    tdate1 := tdate-1;    tdate2 := tdate+1;        // 调用YearOf MonthOfTheYear DayOfTheMonth 函数</code></pre><h3 id="编码其它"><a href="#编码其它" class="headerlink" title="编码其它"></a>编码其它</h3><p>本月对 delphi 工程进行了一次维护，效率较低且无甚好解决方案。一是必须在虚拟机 xp 中使用固定 IDE 进行界面编辑和工程编译；二是 xp 的 IDE 不好用；三是资料较少（年代久远）；四是工程大部分用法为旧式，一时难以理解；五是历经廿载的积累及若干代工程师的维护，在搜索代码时，不时能看到1998、2008、2016、2019字样，一种厚重的历史感扑面而来。在前辈面前不敢造次，改代码时战战兢兢，生怕行差踏错。由于其有较高的使用价值，因此依然要学习并掌握。  </p><h2 id="一般知识"><a href="#一般知识" class="headerlink" title="一般知识"></a>一般知识</h2><h2 id="研发思考"><a href="#研发思考" class="headerlink" title="研发思考"></a>研发思考</h2><p>继续搞 CMMI 5，着重数据，有很多数据还没理解，根据模板填，不知含义。文档工作量比编码还大。    </p><h2 id="本月学习及计划"><a href="#本月学习及计划" class="headerlink" title="本月学习及计划"></a>本月学习及计划</h2><p>没有集中学习。计划抽时间搞一下请求转发方面的东西。  </p><h2 id="其它点滴"><a href="#其它点滴" class="headerlink" title="其它点滴"></a>其它点滴</h2><p>休息严重不足。<br>为了开收入证明，跑了 2 趟集团总部，从南宁东南方向到西北方向，单程1小时间。均为中午时分跑。<br>为评职称，到前前前前单位盖章，单程耗时50分钟。到当前外包单位盖章，单程耗时30分钟。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文为 2021 年 8 月知识总结。&lt;/p&gt;</summary>
    
    
    
    <category term="我的程序代码" scheme="http://www.latelee.org/category/my-library/"/>
    
    
    <category term="代码积累" scheme="http://www.latelee.org/tag/%E4%BB%A3%E7%A0%81%E7%A7%AF%E7%B4%AF/"/>
    
    <category term="知识总结" scheme="http://www.latelee.org/tag/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>cppcheck 和 valgrind 编译及使用</title>
    <link href="http://www.latelee.org/toolslib/compile-cppcheck-and-valgrind.html"/>
    <id>http://www.latelee.org/toolslib/compile-cppcheck-and-valgrind.html</id>
    <published>2021-08-28T14:14:00.000Z</published>
    <updated>2021-10-20T16:10:49.094Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍cppcheck 和 valgrind 编译及使用。</p><span id="more"></span><h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><p>下载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http://cppcheck.net/ 版本 2.5</span><br><span class="line">具体地址：  </span><br><span class="line">https://codeload.github.com/danmar/cppcheck/tar.gz/2.5</span><br><span class="line"></span><br><span class="line">https://www.valgrind.org/downloads/ 版本：3.17.0</span><br><span class="line">具体地址：  </span><br><span class="line">https://sourceware.org/pub/valgrind/valgrind-3.17.0.tar.bz2</span><br></pre></td></tr></table></figure><h2 id="二、编译"><a href="#二、编译" class="headerlink" title="二、编译"></a>二、编译</h2><p>cppcheck 编译步骤如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tar xf cppcheck-2.5.tar.gz </span><br><span class="line">cd cppcheck-2.5/</span><br><span class="line">make -j</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">cmake --build .</span><br><span class="line">cd ../../</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Makefile322: *** FILESDIR must be set!</span><br><span class="line"></span><br><span class="line">分析：</span><br><span class="line">BIN=$(DESTDIR)$(PREFIX)/bin</span><br><span class="line"></span><br><span class="line">修改：</span><br><span class="line">FILESDIR=/usr/local/share/Cppcheck</span><br><span class="line">PREFIX=/usr/local</span><br></pre></td></tr></table></figure><p>valgrind 编译步骤如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar xf valgrind-3.17.0.tar.bz2 </span><br><span class="line">cd valgrind-3.17.0</span><br><span class="line">./autogen.sh    注：缺少这步会出现 valgrind: failed to start tool &#x27;memcheck&#x27; for platform &#x27;amd64-linux&#x27;: No such file or directory</span><br><span class="line">./configure --prefix=/tmp/valgrind</span><br><span class="line">make -j</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h2><p>cppcheck使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cppcheck ./ --enable=all --suppress=&#x27;*:src/uuid/*&#x27; --suppress=&#x27;*:src/crypto/*&#x27;  --suppress=&#x27;*:src/xml/*&#x27; --suppress=&#x27;*:src/zip/*&#x27; --suppress=variableScope  2&gt;&amp;1 | tee check_result.txt</span><br><span class="line"></span><br><span class="line">cppcheck --enable=all 2&gt;&amp;1 | tee check_result.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>valgrind 使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">valgrind --log-file=./valgrind_report.txt --leak-check=full --show-leak-kinds=all --show-reachable=no --track-origins=yes ./a.out</span><br><span class="line"></span><br><span class="line">valgrind --tool=memcheck --leak-check=full ./test</span><br><span class="line"></span><br><span class="line">valgrind --leak-check=full ls -l</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>李迟 2021.8.28 周六 凌晨</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍cppcheck 和 valgrind 编译及使用。&lt;/p&gt;</summary>
    
    
    
    <category term="工具编译使用" scheme="http://www.latelee.org/category/toolslib/"/>
    
    
  </entry>
  
  <entry>
    <title>我的docker随笔37：使用gitlab和jenkins实现CICD</title>
    <link href="http://www.latelee.org/docker/docker-37-using-gitlab-jenkins-for-cicd.html"/>
    <id>http://www.latelee.org/docker/docker-37-using-gitlab-jenkins-for-cicd.html</id>
    <published>2021-08-27T16:00:00.000Z</published>
    <updated>2021-10-20T16:10:49.170Z</updated>
    
    <content type="html"><![CDATA[<p>本文涉及一种利用容器部署 gitlab 和 jenkins 服务实现持续集成（CICD）的方法，其目的是为了在实际工作中使用代码托管及自动化操作。  </p><span id="more"></span><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>因工作需要，需部署  gitlab 和 jenkins 服务器进行 CICD 测试，换个高大上的名称，叫“组织革新”。本文记录个人的实践，但不涉及部署的具体步骤。  </p><h2 id="二、技术小结"><a href="#二、技术小结" class="headerlink" title="二、技术小结"></a>二、技术小结</h2><ul><li>不同工程，配置不同，本文使用 C++ 工程为例进行实验。</li><li>在配置 jenkins 时，建议经常使用页面下方的“应用”，随时保存设置好的参数，以防不测。</li></ul><h2 id="三、gitlab和jenkins联调"><a href="#三、gitlab和jenkins联调" class="headerlink" title="三、gitlab和jenkins联调"></a>三、gitlab和jenkins联调</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>实现CICD分几个阶段：使用 gitlab 托管代码，使用 jenkins 进行编译、打包以及发布。两个服务器各有项目对应，同时要进行必要的配置。不同项目，配置方式不尽相同。本节的配置原则上按顺序进行，因此会到 gitlab 和 jenkins 之间来回切换，故先行说明。</p><h3 id="3-2-前置条件"><a href="#3-2-前置条件" class="headerlink" title="3.2 前置条件"></a>3.2 前置条件</h3><h4 id="3-2-1-允许本地网络请求"><a href="#3-2-1-允许本地网络请求" class="headerlink" title="3.2.1 允许本地网络请求"></a>3.2.1 允许本地网络请求</h4><p>使用 root 用户登录 gitlab 服务器，在管理员配置选项选择<strong>网络(Setting)**页面，在</strong>外发请求（Outbound requests）<strong>中，选择“</strong>允许Webhook和服务对本地网络的请求(Allow requests to the local network from web hooks and services)**”，保存。如图1所示。</p><p>进行该设置的目的是因为本文的 gitlab 和 jenkins 服务均在同一物理服务器上使用 docker 部署。如果不设置，则在 gitlab 中设置 webhooks 时会提示<code>Url is blocked: Requests to the local network are not allowed</code>。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/1.png" alt="image-20210828022642996"></p><p><strong>说明：如果jenkins和gitlab不在同一服务器，则不需要进行此设置。</strong></p><h4 id="3-2-2-关闭-CSFR"><a href="#3-2-2-关闭-CSFR" class="headerlink" title="3.2.2 关闭 CSFR"></a>3.2.2 关闭 CSFR</h4><p>进入 jenkins 容器，找到<code>/usr/local/bin/jenkins.sh</code>文件，找到 exec java 行，在<code>-Duser.home=&quot;$JENKINS_HOME&quot;</code>后添加<code> -Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION=true</code>，完整的一行语句如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec java -Duser.home=&quot;$JENKINS_HOME&quot; -Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION=true &quot;$&#123;java_opts_array[@]&#125;&quot; -jar $&#123;JENKINS_WAR&#125; &quot;$&#123;jenkins_opts_array[@]&#125;&quot; &quot;$@</span><br></pre></td></tr></table></figure><blockquote><p>说明：在笔者定制的 jenkins 镜像中已经进行该修改了。</p></blockquote><p>进行该设置，是因为高版本 Jenkins 无法在界面关闭跨站请求伪造保护（CSRF），因为在 gitlab 进行 webhooks 时会认证失败。提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hook executed successfully but returned HTTP 403</span><br></pre></td></tr></table></figure><p>关闭之后，再次进行 CSFR 页面，提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This configuration is unavailable because the System property hudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION is set to true.</span><br></pre></td></tr></table></figure><p>说明修改成功。</p><blockquote><p>对于物理机部署的 jenkins，则在 /etc/sysconfig/jenkins 文件中找到 JENKINS_JAVA_OPTIONS， 设置如下：</p><p>JENKINS_JAVA_OPTIONS=”-Djava.awt.headless=true -Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION=true”</p></blockquote><h3 id="3-3-准备-gitlab-仓库"><a href="#3-3-准备-gitlab-仓库" class="headerlink" title="3.3 准备 gitlab 仓库"></a>3.3 准备 gitlab 仓库</h3><p>本文使用仓库地址为 <code>http://10.8.18.168:8888/latelee/ci_test</code>。</p><h3 id="3-4-配置-jenkins-项目"><a href="#3-4-配置-jenkins-项目" class="headerlink" title="3.4 配置 jenkins 项目"></a>3.4 配置 jenkins 项目</h3><h4 id="3-4-1-新建项目"><a href="#3-4-1-新建项目" class="headerlink" title="3.4.1 新建项目"></a>3.4.1 新建项目</h4><p>在 jenkins 首页左侧，点击“新建任务”，输入项目项目，选择第一项“自由风格软件项目”。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/2.png" alt="image-20210828215636723"></p><p>点击“确定”进入配置页面。  </p><h4 id="3-4-2-指定git仓库"><a href="#3-4-2-指定git仓库" class="headerlink" title="3.4.2 指定git仓库"></a>3.4.2 指定git仓库</h4><p>在<strong>源码管理</strong>选项页面中，输入 gitlab 仓库地址，注意，URL 地址后须添加<code>.git</code>后缀。  </p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/3.png" alt="image-20210828215845428"></p><p>点击“添加”-&gt;Jenkins，添加凭据，默认类型为用户名和密码。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/4.png" alt="image-20210828221742298"></p><p>添加后，选择添加的凭据，红色错误提示消失。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/5.png" alt="image-20210828222010281"></p><h4 id="3-4-3-设置触发条件"><a href="#3-4-3-设置触发条件" class="headerlink" title="3.4.3 设置触发条件"></a>3.4.3 设置触发条件</h4><p>在<strong>构建触发器</strong>页面进行触发器的选择。此处有多种方式可选，如定时构建和指定 gitlab 方式。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/6.png" alt="image-20210829110540696"></p><p>勾选“Build when a change is pushed to GitLab.”。注意，该项后面的 URL 地址需要记住，在 gitlab 中将使用。点击“高级”，在“Secret token”处点击“Generate”，生成 token，该 token 亦需要记住。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/7.png" alt="image-20210828222613624"></p><p>进行此设置目的是，当提交代码到 gitlab 仓库时，会自动触发 jenkins 执行 一次构建。触发条件在对应 gitlab 仓库中进行设置。如果不需要自动触发，则可以不触发条件。</p><h4 id="3-4-4-指定构建步骤"><a href="#3-4-4-指定构建步骤" class="headerlink" title="3.4.4 指定构建步骤"></a>3.4.4 指定构建步骤</h4><p>在<strong>构建</strong>页面，点击“增加构建步骤”，选择“执行shell”，输入构建的命令。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/8.png" alt="image-20210829110841729"></p><h4 id="3-4-5-指定构建后的步骤"><a href="#3-4-5-指定构建后的步骤" class="headerlink" title="3.4.5 指定构建后的步骤"></a>3.4.5 指定构建后的步骤</h4><p>在<strong>构建后操作</strong>页面，点击“增加构建后操作步骤”。选择“send build artifacts over SSH”。选择服务器、源目录、目标目录及执行的命令。注意，在本文实践前已经设置好服务器及目标，故只指定源文件和执行命令即可。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/9.png" alt="image-20210829111238088"></p><p>在笔者实践中发现，在“构建环境”、“构建”、“构建后操作”三个页面均可以选择将文件通过 SSH 发送服务器。</p><h3 id="3-5-设置-gitlab-的-webhooks"><a href="#3-5-设置-gitlab-的-webhooks" class="headerlink" title="3.5 设置 gitlab 的 webhooks"></a>3.5 设置 gitlab 的 webhooks</h3><p>在 gitlab 项目<code>http://10.8.18.168:8888/latelee/ci_test</code>页面，    选择“Settings”-&gt;“Webhooks”，输入上小节生成的 URL 和 token。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/10.png" alt="image-20210829105434914"></p><p>点击页面下方“Add webhook”，添加。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/11.png" alt="image-20210829105538566"></p><blockquote><p>注：同一个gitlab仓库，可支持多个 webhook。</p></blockquote><p>点击“Test”，选择“Push events”，进行测试验证。<strong>为保证触发成功，强烈建议在此处先行测试</strong>。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/12.png" alt="image-20210829105744185"></p><p>触发类型有很多种，根据实际情况选择。</p><h3 id="3-4-验证"><a href="#3-4-验证" class="headerlink" title="3.4 验证"></a>3.4 验证</h3><p>提交代码到 gitlab 仓库（此处从略）。稍等片刻，在 jenkins 工程的看到进行了触发。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/13.png" alt="image-20210829111835252"></p><p>输出日志如下：</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/14.png" alt="image-20210829112333720"></p><p>编译、运行、执行ssh远程服务均成功。在远程服务器的<code>/tmp</code>目录出现<code>a.out</code>和<code>log.txt</code>。</p><h2 id="四、其它的配置"><a href="#四、其它的配置" class="headerlink" title="四、其它的配置"></a>四、其它的配置</h2><h3 id="4-1-邮件通知"><a href="#4-1-邮件通知" class="headerlink" title="4.1 邮件通知"></a>4.1 邮件通知</h3><p>jenkins系统设置。见前面文章。此处关注项目配置。</p><p>注意，邮件通知需要根据不同应用情况设置，此处作为示例，只关注是否能在构建时发邮件。至于何时何条件触发，非本文范围。  </p><p>定位到<strong>构建后操作</strong>页面，添加<code>Editable Email Notification</code>。</p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/image-20210916091942018.png" alt="image-20210916091942018"></p><p>在该插件配置处选择高级，在“Always”处输入接收者邮件，其它保持不变（即使用默认的模板）。  </p><p><img src="/docker/docker-37-using-gitlab-jenkins-for-cicd/image-20210916093808632.png" alt="image-20210916093808632"></p><p>保存即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文涉及一种利用容器部署 gitlab 和 jenkins 服务实现持续集成（CICD）的方法，其目的是为了在实际工作中使用代码托管及自动化操作。  &lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="http://www.latelee.org/category/docker/"/>
    
    
    <category term="docker" scheme="http://www.latelee.org/tag/docker/"/>
    
  </entry>
  
  <entry>
    <title>我的docker随笔36：定制jenkins镜像</title>
    <link href="http://www.latelee.org/docker/docker-36-make-jenkins-docker.html"/>
    <id>http://www.latelee.org/docker/docker-36-make-jenkins-docker.html</id>
    <published>2021-08-26T16:00:00.000Z</published>
    <updated>2021-10-20T16:10:49.170Z</updated>
    
    <content type="html"><![CDATA[<p>本文涉及一种根据实际需求定制 jenkins 镜像的方法及实践。其目的是在官方镜像基础上添加自定义软件、库，以便更加适应项目的开发情况。   </p><span id="more"></span><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>官方镜像基本能实现了常见的持续集成功能，但还有一些不符合要求，因此，有必要研究制作自定义的镜像。  </p><p>官方提供了各版本的脚本和 Dockerfile，可以直接用这些文件生成镜像，笔者认为，可以在官方镜像基础直接修改、新加功能。</p><h2 id="二、技术小结"><a href="#二、技术小结" class="headerlink" title="二、技术小结"></a>二、技术小结</h2><ul><li>根据实际情况选定jenkins版本。在该版本基础上再额外添加自定义功能。</li><li>按需安装软件，如本文的镜像安装了gcc、node、golang等软件。</li><li>如果涉及其它的库，可以直接在 Dockerfile 中拷贝到镜像中。</li></ul><h2 id="三、定制配置"><a href="#三、定制配置" class="headerlink" title="三、定制配置"></a>三、定制配置</h2><p>笔者所涉 Linux 系统，均为 centos7，并且 gcc 编译器版本必须为 4.8.5。在 jenkins 官方提供的众多版本中，恰好有 centos7，镜像名称为 jenkins/jenkins:centos7。  </p><p>在笔者实践中，是先在jenkins 容器中安装、测试软件的，但最终得到的仅有 Dockerfile 及必要的配置文件/脚本。本节记录在容器中安装的过程。</p><p>启动并用root权限进入容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name jenkins_build jenkins/jenkins:centos7 bash</span><br><span class="line"></span><br><span class="line">sudo docker exec -it -u root jenkins_build bash</span><br></pre></td></tr></table></figure><p>安装软件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc gcc-c++</span><br><span class="line"></span><br><span class="line">yum -y install automake autoconf libtool make sshpass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">前端的 node：</span><br><span class="line">curl --silent --location https://rpm.nodesource.com/setup_12.x | bash -</span><br><span class="line">再执行：</span><br><span class="line">yum -y install nodejs</span><br><span class="line"></span><br><span class="line">yarn:</span><br><span class="line">curl -sL https://dl.yarnpkg.com/rpm/yarn.repo | tee /etc/yum.repos.d/yarn.repo</span><br><span class="line">yum -y install yarn</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从容器拿到<code>/usr/local/bin/jenkins.sh</code>文件，编辑之，找到 exec java 行，在 <code>-Duser.home=&quot;$JENKINS_HOME&quot; </code>后添加：<br><code>-Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION=true</code><br>完整的语句为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec java -Duser.home=&quot;$JENKINS_HOME&quot; -Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION=true &quot;$&#123;java_opts_array[@]&#125;&quot; -jar $&#123;JENKINS_WAR&#125; &quot;$&#123;jenkins_opts_array[@]&#125;&quot; &quot;$@&quot;</span><br></pre></td></tr></table></figure><h2 id="四、最终成果"><a href="#四、最终成果" class="headerlink" title="四、最终成果"></a>四、最终成果</h2><p>新建myinit.sh文件，内容：</p><pre><code>cat &gt; myinit.sh &lt;&lt;-EOF#!/bin/bash## set golangexport GOROOT=/usr/local/goexport GOBIN=$GOROOT/binexport PATH=$PATH:$GOBINexport GOPATH=/vagrant/golang_linuxexport GOPROXY=https://goproxy.io,directexport MYGO=$GOPATH/golang/src/github.com/latelee## set my localeexport LANG=en_US.utf8export LANGUAGE=en_US.utf8export LC_ALL=en_US.utf8export LANG=zh_CN.utf8export LANGUAGE=zh_CN.utf8export LC_ALL=zh_CN.utf8EOF</code></pre><p>注：上述myinit.sh暂未测试通过，仅作备档。</p><p>Dockerfile 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; Dockerfile &lt;&lt;-EOF</span><br><span class="line">FROM jenkins/jenkins:centos7</span><br><span class="line"></span><br><span class="line">### I changed jenkins.sh file</span><br><span class="line">COPY --chown=jenkins:jenkins jenkins.sh /usr/local/bin/</span><br><span class="line"></span><br><span class="line"># if we want to install tools</span><br><span class="line">USER root</span><br><span class="line"></span><br><span class="line">RUN echo &quot;Late Lee build&quot; &gt; /my.info &amp;&amp; \</span><br><span class="line">    date &gt;&gt; /my.info</span><br><span class="line"></span><br><span class="line">## C++</span><br><span class="line"># install other tools...</span><br><span class="line">RUN yum -y install gcc gcc-c++ automake autoconf libtool make sshpass wget</span><br><span class="line"></span><br><span class="line">## Node</span><br><span class="line">RUN curl --silent --location https://rpm.nodesource.com/setup_12.x | bash - &amp;&amp; \</span><br><span class="line">    yum -y install nodejs</span><br><span class="line">RUN curl -sL https://dl.yarnpkg.com/rpm/yarn.repo | tee /etc/yum.repos.d/yarn.repo &amp;&amp; \</span><br><span class="line">    yum -y install yarn</span><br><span class="line"></span><br><span class="line">## Golang</span><br><span class="line">RUN wget https://studygolang.com/dl/golang/go1.15.6.linux-amd64.tar.gz &amp;&amp; \</span><br><span class="line">    tar zxf go1.15.6.linux-amd64.tar.gz -C /usr/local/ &amp;&amp; \</span><br><span class="line">    rm -rf go1.15.6.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">## Maven</span><br><span class="line"></span><br><span class="line"># need clean  yum clean all  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># drop back to the regular jenkins user - good practice</span><br><span class="line">USER jenkins</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>新的用于临时测试的（后面与上面的合并）  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; Dockerfile_new &lt;&lt;-EOF</span><br><span class="line">FROM latelee/jenkins:centos7</span><br><span class="line"></span><br><span class="line">### I changed jenkins.sh file</span><br><span class="line">COPY --chown=jenkins:jenkins --chmod=755 jenkins.sh /usr/local/bin/</span><br><span class="line">COPY --chown=jenkins:jenkins --chmod=755 myinit.sh /usr/local/bin/</span><br><span class="line">ADD usr.tar.bz2 /</span><br><span class="line"></span><br><span class="line">## add maven(note: jdk already in the image)</span><br><span class="line">ADD apache-maven-3.8.2-bin.tar.gz /usr/local/</span><br><span class="line"></span><br><span class="line">ENV MAVEN_HOME /usr/local/apache-maven-3.8.2</span><br><span class="line"></span><br><span class="line">ENV GOROOT /usr/local/go</span><br><span class="line">ENV GOBIN /usr/local/go/bin</span><br><span class="line">ENV GOPROXY https://goproxy.io,direct</span><br><span class="line"></span><br><span class="line"># seems cant pass $MAVEN_HOME here</span><br><span class="line">ENV PATH $PATH:/usr/local/apache-maven-3.8.2/bin:/usr/local/go/bin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ENV LD_LIBRARY_PATH $LD_LIBRARY_PATH:/usr/lib64/mysql/</span><br><span class="line"></span><br><span class="line">USER root</span><br><span class="line"></span><br><span class="line">## set my time</span><br><span class="line">RUN rm -rf /etc/localtime &amp;&amp; \</span><br><span class="line">    ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line"></span><br><span class="line">RUN ln -s /usr/lib64/libsqlite3.so.0 /usr/lib64/libsqlite3.so &amp;&amp; \</span><br><span class="line">trueln -s /usr/lib64/libcurl.so.4 /usr/lib64/libcurl.so &amp;&amp; \</span><br><span class="line">trueln -s /usr/lib64/libcrypto.so.10 /usr/lib64/libcrypto.so &amp;&amp; \</span><br><span class="line">trueln -s /usr/lib64/libuuid.so.1 /usr/lib64/libuuid.so &amp;&amp; \</span><br><span class="line">trueln -s /usr/lib64/libz.so.1 /usr/lib64/libz.so</span><br><span class="line"></span><br><span class="line"># drop back to the regular jenkins user - good practice</span><br><span class="line">USER jenkins</span><br><span class="line"></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker build -t latelee/jenkins:centos7_new -f Dockerfile_new .</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>构建：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t latelee/jenkins:centos7 .</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">cp -av --parents /usr/local/curl/ /tmp/dataserver_lib/</span><br><span class="line"></span><br><span class="line">cp -av --parents /usr/include/z* /tmp/dataserver_lib/</span><br><span class="line"></span><br><span class="line">cp -av --parents /usr/include/sqlite3* /tmp/dataserver_lib/</span><br><span class="line"></span><br><span class="line">cp -av --parents /usr/include/openssl/ /tmp/dataserver_lib/</span><br><span class="line"></span><br><span class="line">cp -av --parents /usr/lib64/mysql/ /tmp/dataserver_lib/</span><br><span class="line"></span><br><span class="line">scp -r  curl.tar.bz2 lijj@10.0.153.12:/tmp</span><br><span class="line"></span><br><span class="line">scp -r  include.tar.bz2 lijj@10.0.153.12:/tmp</span><br><span class="line"></span><br><span class="line">scp -r  usr.tar.bz2 lijj@10.0.153.12:/tmp</span><br><span class="line"></span><br><span class="line">LDFLAGS += -L/usr/lib64/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">链接：</span><br><span class="line">ln -s /usr/lib64/libsqlite3.so.0 /usr/lib64/libsqlite3.so</span><br><span class="line">ln -s /usr/lib64/libcurl.so.4 /usr/lib64/libcurl.so</span><br><span class="line">ln -s /usr/lib64/libcrypto.so.10 /usr/lib64/libcrypto.so</span><br><span class="line">ln -s /usr/lib64/libuuid.so.1 /usr/lib64/libuuid.so</span><br><span class="line">ln -s /usr/lib64/libz.so.1 /usr/lib64/libz.so</span><br><span class="line"></span><br><span class="line">echo &quot;/usr/lib64/mysql/&quot; &gt; /etc/ld.so.conf.d/mysql.conf</span><br><span class="line"></span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/lib64/mysql/</span><br></pre></td></tr></table></figure><h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>jenkins 控制台中文乱码，未解决。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文涉及一种根据实际需求定制 jenkins 镜像的方法及实践。其目的是在官方镜像基础上添加自定义软件、库，以便更加适应项目的开发情况。   &lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="http://www.latelee.org/category/docker/"/>
    
    
    <category term="docker" scheme="http://www.latelee.org/tag/docker/"/>
    
  </entry>
  
  <entry>
    <title>我的docker随笔35：jenkins服务部署</title>
    <link href="http://www.latelee.org/docker/docker-35-deploy-jenkins-server.html"/>
    <id>http://www.latelee.org/docker/docker-35-deploy-jenkins-server.html</id>
    <published>2021-08-09T16:00:00.000Z</published>
    <updated>2021-10-20T16:10:49.170Z</updated>
    
    <content type="html"><![CDATA[<p>本文涉及一种在容器中部署 jenkins 服务的方法，后续将其与 gitlab 配合以实现 CICD 功能。其目的是为了在实际工作中使用代码托管及自动化操作。  </p><span id="more"></span><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>因工作需要，需部署  jenkins 服务器进行测试。与网上几分钟即可部署的文章相比，本文更注重个人的实践记录。本文与前面的 gitlab 有一定的关联。</p><h2 id="二、技术小结"><a href="#二、技术小结" class="headerlink" title="二、技术小结"></a>二、技术小结</h2><ul><li>gitlab 有官方的 Docker 镜像。本文直接使用之。</li><li>使用 docker-compose 部署，指定端口。注意挂载 docker.socket文件。</li><li>首次登录会提示输入随机文件，一旦输入并设置成功后，不再提示。</li><li>各种配置慢慢补充。</li></ul><h2 id="三、部署gitlab服务"><a href="#三、部署gitlab服务" class="headerlink" title="三、部署gitlab服务"></a>三、部署gitlab服务</h2><h3 id="3-1-部署脚本"><a href="#3-1-部署脚本" class="headerlink" title="3.1 部署脚本"></a>3.1 部署脚本</h3><p>本文使用 docker-compose 部署，在测试阶段，使用了多个版本。此处是比较简单的版本，用于初次使用。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">jenkins:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">jenkins/jenkins:centos7</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">lljenkins</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="comment"># 使用主机的docker服务(因为要在jenkins容器中运行docker)</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">            <span class="comment"># 使用数据盘的目录作为jenkins的工作目录</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">$PWD/jenkins_home:/var/jenkins_home</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="comment"># 端口映射</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;9999:8080&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;50000:50000&quot;</span></span><br><span class="line">        <span class="attr">networks:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">llgitlab-net</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">    <span class="attr">llgitlab-net:</span></span><br><span class="line">        <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure><p>注意几点：</p><ul><li>脚本中指定了<code>docker.sock</code>的路径，后续可以在jenkins用docker构建。</li><li>jenkins 数据目录在本目录下的<code>jenkins_home</code>目录，其权限修改为1000，命令为<code>sudo chown -R 1000 jenkins_home</code>。</li><li>根据实际环境，选择了 centos7 版本的 jenkins。</li></ul><h3 id="3-2-运行"><a href="#3-2-运行" class="headerlink" title="3.2 运行"></a>3.2 运行</h3><p>运行命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>注：jenkins 的启动比 gitlab 快很多。  </p><p>停止命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose down</span><br></pre></td></tr></table></figure><p>运行过程中会出现初始密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Jenkins initial setup is required. An admin user has been created and a password generated.</span><br><span class="line">Please use the following password to proceed to installation:</span><br><span class="line"></span><br><span class="line">c4365f900e554ff5b8885d8c2975929b</span><br><span class="line"></span><br><span class="line">This may also be found at: /var/jenkins_home/secrets/initialAdminPassword</span><br><span class="line"></span><br><span class="line">*************************************************************</span><br></pre></td></tr></table></figure><h2 id="四、初次配置"><a href="#四、初次配置" class="headerlink" title="四、初次配置"></a>四、初次配置</h2><p>服务启动后，需要进行必要的配置，因此在本文一并给出。</p><h3 id="4-1-登录"><a href="#4-1-登录" class="headerlink" title="4.1 登录"></a>4.1 登录</h3><p>初次登录时，会提示输入管理员密码，如图1所示：</p><p><img src="/docker/docker-35-deploy-jenkins-server/1.png" alt="image-20210804094456510"></p><p>在 docker 启动时出现有密码，也可以直接在页面所示文件中找到。</p><h3 id="4-2-安装插件："><a href="#4-2-安装插件：" class="headerlink" title="4.2 安装插件："></a>4.2 安装插件：</h3><p><img src="/docker/docker-35-deploy-jenkins-server/2.png" alt="image-20210804094542706"><br>选右侧自定义安装，注：默认也勾选了部分插件。</p><p>安装过程图示：</p><p><img src="/docker/docker-35-deploy-jenkins-server/3.png" alt="image-20210804094924177"></p><p>注：笔者在实践中，遇到不可抗拒因素，导致网络不稳定，经常安装不成功，如果尝试多次失败，可以跳过不安装。</p><h2 id="五、一些配置"><a href="#五、一些配置" class="headerlink" title="五、一些配置"></a>五、一些配置</h2><h3 id="5-1-git-仓库地址问题"><a href="#5-1-git-仓库地址问题" class="headerlink" title="5.1 git 仓库地址问题"></a>5.1 git 仓库地址问题</h3><p>配置了项目，构建，提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stderr: error: RPC failed; result=22, HTTP code = 404</span><br></pre></td></tr></table></figure><p>原因及解决：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在设置项目git地址时，必须添加`.git`后缀，否则地址不认。</span><br></pre></td></tr></table></figure><h3 id="5-2-Publish-over-SSH"><a href="#5-2-Publish-over-SSH" class="headerlink" title="5.2 Publish over SSH"></a>5.2 Publish over SSH</h3><p><img src="/docker/docker-35-deploy-jenkins-server/4.png" alt="image-20210829112839117"></p><p>在具体项目构建后操作添加Send build artifacts over SSH<code>。源文件如果带路径的话，默认情况目标目录也带有。比如源文件为</code>taget/a.out<code>，目标目录为</code>/tmp<code>，则目标文件路径为</code>/tmp/target/a.out`。  </p><h3 id="5-3-邮件通知"><a href="#5-3-邮件通知" class="headerlink" title="5.3 邮件通知"></a>5.3 邮件通知</h3><p>本节使用腾讯企业邮件测试（感谢腾讯为个人域名提供免费的邮箱服务）。此为前提。</p><p>使用插件<code>Email Extension Plugin</code>，确定是否安装：</p><p><img src="/docker/docker-35-deploy-jenkins-server/image-20210916003759787.png" alt="image-20210916003759787"></p><p>系统管理-&gt;系统配置。</p><p>设置系统管理员邮件地址：</p><p><img src="/docker/docker-35-deploy-jenkins-server/image-20210916085303466.png" alt="image-20210916085303466"></p><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><p><img src="/docker/docker-35-deploy-jenkins-server/image-20210916090427313.png" alt="image-20210916090427313"></p><p>触发条件：</p><p><img src="/docker/docker-35-deploy-jenkins-server/image-20210916091126192.png" alt="image-20210916091126192"></p><h4 id="自带邮件通知插件"><a href="#自带邮件通知插件" class="headerlink" title="自带邮件通知插件"></a>自带邮件通知插件</h4><p>在“邮件通知”处添加 SMTP 服务器，此处为<code>smtp.exmail.qq.com</code>。点击<strong>高级</strong>，设置邮件账号和密码，勾选”SSL协议“、”使用 TLS“，端口设置为465。</p><p><img src="/docker/docker-35-deploy-jenkins-server/image-20210916085725950.png" alt="image-20210916085725950"></p><p>最后进行邮件发送的测试，输入接收者邮箱，点击测试即可。提示<code>Email was successfully sent</code>表示发送成功。</p><p><img src="/docker/docker-35-deploy-jenkins-server/image-20210916085826846.png" alt="image-20210916085826846"></p><p>邮件接收：</p><p><img src="/docker/docker-35-deploy-jenkins-server/image-20210916090144129.png" alt="image-20210916090144129"></p><blockquote><p>注：#10表示是第10次发送，表示点击测试的次数——包括失败的。</p></blockquote><p>发送测试邮件出错及解决方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">com.sun.mail.smtp.SMTPSenderFailedException: 501 mail from address must be same as authorization user</span><br><span class="line">解决：</span><br><span class="line">Jenkins管理员邮箱与此处设置的发送者邮箱保持一致。</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">javax.mail.MessagingException: Got bad greeting from SMTP host: smtp.exmail.qq.com, port: 465, response: [EOF]</span><br><span class="line">原因：勾选`使用SSL协议`。</span><br></pre></td></tr></table></figure><p>默认标题和模板：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$PROJECT_NAME - Build # $BUILD_NUMBER - $BUILD_STATUS!</span><br><span class="line"></span><br><span class="line">$PROJECT_NAME - Build # $BUILD_NUMBER - $BUILD_STATUS:</span><br><span class="line"></span><br><span class="line">Check console output at $BUILD_URL to view the results.</span><br></pre></td></tr></table></figure><p>根据网上资料修改的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">$PROJECT_NAME 项目第 # $BUILD_NUMBER 次构建 - $BUILD_STATUS</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;PROJECT_NAME 第 # $BUILD_NUMBER 次构建 - $BUILD_STATUS&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body leftmargin=&quot;8&quot; marginwidth=&quot;0&quot; topmargin=&quot;8&quot; marginheight=&quot;4&quot;</span><br><span class="line">    offset=&quot;0&quot;&gt;</span><br><span class="line">    &lt;table width=&quot;95%&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;  style=&quot;font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif&quot;&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            本邮件由系统自动发出，无需回复！&lt;br/&gt;</span><br><span class="line">            $&#123;PROJECT_NAME &#125; 项目构建信息如下&lt;/br&gt;</span><br><span class="line">            &lt;td&gt;&lt;font color=&quot;#CC0000&quot;&gt;构建结果 - $&#123;BUILD_STATUS&#125;&lt;/font&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;&lt;br /&gt;</span><br><span class="line">            &lt;b&gt;&lt;font color=&quot;#0B610B&quot;&gt;构建信息&lt;/font&gt;&lt;/b&gt;</span><br><span class="line">            &lt;hr size=&quot;2&quot; width=&quot;100%&quot; align=&quot;center&quot; /&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                    &lt;li&gt;项目名称 ： $&#123;PROJECT_NAME&#125;&lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;构建编号 ： 第$&#123;BUILD_NUMBER&#125;次构建&lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;触发原因： $&#123;CAUSE&#125;&lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;构建状态： $&#123;BUILD_STATUS&#125;&lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;构建日志： &lt;a href=&quot;$&#123;BUILD_URL&#125;console&quot;&gt;$&#123;BUILD_URL&#125;console&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;构建  Url ： &lt;a href=&quot;$&#123;BUILD_URL&#125;&quot;&gt;$&#123;BUILD_URL&#125;&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;工作目录 ： &lt;a href=&quot;$&#123;PROJECT_URL&#125;ws&quot;&gt;$&#123;PROJECT_URL&#125;ws&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;项目  Url ： &lt;a href=&quot;$&#123;PROJECT_URL&#125;&quot;&gt;$&#123;PROJECT_URL&#125;&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                &lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">                &lt;font color=&quot;#0B610B&quot;&gt;最近提交(#$SVN_REVISION)&lt;/font&gt;</span><br><span class="line">                &lt;hr size=&quot;2&quot; width=&quot;100%&quot; /&gt;</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                $&#123;CHANGES_SINCE_LAST_SUCCESS, reverse=true, format=&quot;%c&quot;, changesFormat=&quot;&lt;li&gt;%d [%a] %m&lt;/li&gt;&quot;&#125;</span><br><span class="line">                &lt;/ul&gt;</span><br><span class="line">                详细提交: &lt;a href=&quot;$&#123;PROJECT_URL&#125;changes&quot;&gt;$&#123;PROJECT_URL&#125;changes&lt;/a&gt;&lt;br/&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>构建日志：<code>$&#123;BUILD_LOG, maxLines=100&#125;</code></p><p>某次发送提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sending email for trigger: Always</span><br><span class="line">Not sending mail to unregistered user li@latelee.org because your SCM claimed this was associated with a user ID ?li&#x27; which your security realm does not recognize; you may need changes in your SCM plugin</span><br><span class="line">Sending email to: li@latelee.org</span><br></pre></td></tr></table></figure><p>结论：看信息是发送不成功，但能接收邮件，暂时不管。  </p><p>MORE TODO……</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文涉及一种在容器中部署 jenkins 服务的方法，后续将其与 gitlab 配合以实现 CICD 功能。其目的是为了在实际工作中使用代码托管及自动化操作。  &lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="http://www.latelee.org/category/docker/"/>
    
    
    <category term="docker" scheme="http://www.latelee.org/tag/docker/"/>
    
  </entry>
  
  <entry>
    <title>我的docker随笔34：gitlab服务部署</title>
    <link href="http://www.latelee.org/docker/docker-34-deploy-gitlab-server.html"/>
    <id>http://www.latelee.org/docker/docker-34-deploy-gitlab-server.html</id>
    <published>2021-08-08T16:00:00.000Z</published>
    <updated>2021-10-20T16:10:49.166Z</updated>
    
    <content type="html"><![CDATA[<p>本文涉及一种在容器中部署 gitlab 服务的方法，并结合其自带的 gitlab-runner 实现 CICD 功能。其目的是为了在实际工作中使用代码托管及自动化操作。  </p><span id="more"></span><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>因工作需要，需部署 gitlab 服务器进行数据测试。与网上几分钟即可部署的文章相比，本文更注重个人的实践记录，故不会完整地将过程记录下来。</p><h2 id="二、技术小结"><a href="#二、技术小结" class="headerlink" title="二、技术小结"></a>二、技术小结</h2><ul><li>gitlab 有官方的 Docker 镜像。</li><li>建议将数据和配置目录映射到主机上，方便编辑和备份。</li><li>如果使用非默认端口，需要配置自定义端口。</li><li>在首次登录时，需要设置 root 密码，后面不再出现此提示，因此需记住密码。</li><li>gitlab-runner本文未有深入研究，等后续有时间再着手。</li></ul><h2 id="三、部署gitlab服务"><a href="#三、部署gitlab服务" class="headerlink" title="三、部署gitlab服务"></a>三、部署gitlab服务</h2><h3 id="3-1-部署脚本"><a href="#3-1-部署脚本" class="headerlink" title="3.1 部署脚本"></a>3.1 部署脚本</h3><p>本文使用 docker-compose 部署，在测试阶段，使用了多个版本。</p><p>版本一，使用默认端口，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">llgitlab:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">gitlab/gitlab-ce:13.10.0-ce.0</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">llgitlab</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./gitlab_data/config:/etc/gitlab</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./gitlab_data/logs:/var/log/gitlab</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./gitlab_data/data:/var/opt/gitlab</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;8888:80&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;8443:443&quot;</span></span><br><span class="line">            <span class="comment">#- &quot;2222:22&quot;</span></span><br><span class="line">        <span class="attr">hostname:</span> <span class="string">&quot;10.0.10.11&quot;</span></span><br><span class="line">        <span class="comment">#command: /assets/wrapper</span></span><br><span class="line">        <span class="attr">networks:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">llgitlab-net</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">    <span class="attr">llgitlab-net:</span></span><br><span class="line">        <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure><p>脚本中将配置目录和数据目录映射到主机当前目录的<code>gitlab_data</code>目录，方便后续修改。对外提供<code>8888</code>端口。由于部署环境为内网，故设置<code>hostname</code>为部署机器的<code>IP</code>。</p><p>版本二，修改端口：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">llgitlab:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">gitlab/gitlab-ce:13.10.0-ce.0</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">llgitlab</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./gitlab_data/config:/etc/gitlab</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./gitlab_data/logs:/var/log/gitlab</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./gitlab_data/data:/var/opt/gitlab</span></span><br><span class="line">        <span class="attr">environment:</span></span><br><span class="line">            <span class="attr">TZ:</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line">            <span class="attr">GITLAB_OMNIBUS_CONFIG:</span> <span class="string">|</span></span><br><span class="line"><span class="string">                external_url &#x27;http://10.0.153.12:8888&#x27;</span></span><br><span class="line"><span class="string">                nginx[&#x27;listen_port&#x27;]=8888</span></span><br><span class="line"><span class="string">                gitlab_rails[&#x27;gitlab_shell_ssh_port&#x27;]=8822</span></span><br><span class="line"><span class="string">                gitlab_rails[&#x27;time_zone&#x27;]=&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line"><span class="string"></span>        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;8888:8888&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;8443:443&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;8822:8822&quot;</span></span><br><span class="line">        <span class="attr">hostname:</span> <span class="string">&quot;10.0.153.12&quot;</span></span><br><span class="line">        <span class="attr">networks:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">llgitlab-net</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">    <span class="attr">llgitlab-net:</span></span><br><span class="line">        <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure><p>注意几点：</p><ul><li>git 的访问方式，http默认为80，ssh默认为22，版本一未修改，但主机做了映射，此版本将 gitlab 默认端口修改了，分别为8888和8822，再将其映射到相同的主机端口。</li><li>使用 GITLAB_OMNIBUS_CONFIG 环境变量进行一些参数的修改，相当于修改容器内的<code>/etc/gitlab/gitlab.rb</code>文件（当然，本文已经将目录映射到主机上了）。<code>external_url</code>从名称上看，其必须为一个 url 地址，可以是IP或域名，但不能是单纯的 IP，本文加了端口。  </li><li>当已经存在了本地数据时，使用 GITLAB_OMNIBUS_CONFIG 修改参数，也会生效。比如原先没有修改端口，修改端口后重启容器，即可生效。</li><li>虽然设置了 TZ，容器的时间也为 CST，但查看 gitlab 的日志，依旧使用 UTC 时间。或许是一个特性。</li><li>hostname 不能加端口。</li><li></li></ul><h3 id="3-2-运行"><a href="#3-2-运行" class="headerlink" title="3.2 运行"></a>3.2 运行</h3><p>运行命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>注意：启动耗时较长，大概数分钟（笔者使用性能较强的服务器测试，也要3~4分钟），需耐心等待。</p><p>停止命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose down</span><br></pre></td></tr></table></figure><p>初次登录时，会提示设置管理员<code>root</code>密码，如图1所示：</p><p><img src="/docker/docker-34-deploy-gitlab-server/1.png"></p><p>设置完毕后需重新登录。在首页可以看到注册的提醒。默认开放注册，但需管理员确认，如内部使用，则该功能可去掉。如图2所示。</p><p><img src="/docker/docker-34-deploy-gitlab-server/2.png"></p><p>默认情况下，新用户注册，会有如图3的提示：</p><p><img src="/docker/docker-34-deploy-gitlab-server/3.png"></p><p>至此，已经将 gitlab 部署完毕，且已可正常使用。  如使用其 CICD 功能，则需要继续部署 gitlab-runner。</p><h2 id="四、gitlab-runner"><a href="#四、gitlab-runner" class="headerlink" title="四、gitlab-runner"></a>四、gitlab-runner</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>使用管理员登录 gitlab，并获取token，如图4所示：</p><p><img src="/docker/docker-34-deploy-gitlab-server/4.png"></p><p>图4右侧给出了URL地址以及 token，后续将使用到。  </p><p>准备docker-compose文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">llgitlab:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">gitlab/gitlab-ce:13.10.0-ce.0</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">llgitlab</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./gitlab_data/config:/etc/gitlab</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./gitlab_data/logs:/var/log/gitlab</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./gitlab_data/data:/var/opt/gitlab</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;8888:80&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;8443:443&quot;</span></span><br><span class="line">            <span class="comment">#- &quot;2222:22&quot;</span></span><br><span class="line">        <span class="attr">hostname:</span> <span class="string">&quot;10.0.153.12&quot;</span></span><br><span class="line">        <span class="comment">#command: /assets/wrapper</span></span><br><span class="line">        <span class="attr">networks:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">llgitlab-net</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">llgitlab-runner:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">gitlab/gitlab-runner:alpine-v13.10.0</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">llgitlab-runner</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./gitlab-runner/config:/etc/gitlab-runner</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">        <span class="attr">depends_on:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">llgitlab</span></span><br><span class="line">        <span class="attr">networks:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">llgitlab-net</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">    <span class="attr">llgitlab-net:</span></span><br><span class="line">        <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure><p>注意， gitlab-runner 和 gitlab 版本应相近。</p><p>注意，此时查看gitlab-runner容器，会不断提示 config.toml找不到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Runtime platform                                    arch=amd64 os=linux pid=7 revision=54944146 version=13.10.0</span><br><span class="line">Starting multi-runner from /etc/gitlab-runner/config.toml...  builds=0</span><br><span class="line">Running in system-mode.                            </span><br><span class="line">                                                   </span><br><span class="line">Configuration loaded                                builds=0</span><br><span class="line">listen_address not defined, metrics &amp; debug endpoints disabled  builds=0</span><br><span class="line">[session_server].listen_address not defined, session endpoints disabled  builds=0</span><br><span class="line">ERROR: Failed to load config stat /etc/gitlab-runner/config.toml: no such file or directory  builds=0</span><br><span class="line">ERROR: Failed to load config stat /etc/gitlab-runner/config.toml: no such file or directory  builds=0</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>因为未注册原故。注册方法有2种，一是根据提示一一填写，二是直接指定参数。</p><p>手动注册：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -it -v $PWD/gitlab-runner/config:/etc/gitlab-runner gitlab/gitlab-runner:alpine-v13.10.0 register</span><br><span class="line">之后出现提示，根据提示填写内容</span><br><span class="line">下面是示例</span><br><span class="line">Runtime platform                                    arch=amd64 os=linux pid=7 revision=54944146 version=13.10.0</span><br><span class="line">Running in system-mode.                            </span><br><span class="line">                                                   </span><br><span class="line">Enter the GitLab instance URL (for example, https://gitlab.com/):</span><br><span class="line">http://10.0.153.12:8888/</span><br><span class="line">Enter the registration token:</span><br><span class="line">FXKUC2HtxFuICBC9961024</span><br><span class="line">Enter a description for the runner:</span><br><span class="line">[a2d8dbc3c305]: my-gitlab-runner</span><br><span class="line">Enter tags for the runner (comma-separated):</span><br><span class="line">gitlab</span><br><span class="line">Registering runner... succeeded                     runner=FXKUC2H</span><br><span class="line">Enter an executor: parallels, virtualbox, docker+machine, docker-ssh+machine, custom, docker, docker-ssh, shell, ssh, kubernetes:</span><br><span class="line">docker</span><br><span class="line">Enter the default Docker image (for example, ruby:2.6):</span><br><span class="line">latelee/ubuntu</span><br><span class="line">Runner registered successfully. Feel free to start it, but if it&#x27;s running already the config should be automatically reloaded! </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>直接指定参数注册。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -v $PWD/gitlab-runner/config:/etc/gitlab-runner gitlab/gitlab-runner:alpine-v13.10.0 register \</span><br><span class="line">  --non-interactive \</span><br><span class="line">  --executor &quot;docker&quot; \</span><br><span class="line">  --docker-image latelee/ubuntu \</span><br><span class="line">  --url &quot;http://10.0.153.12:8888/&quot; \</span><br><span class="line">  --registration-token &quot;FXKUC2HtxFuICBC9961024&quot; \</span><br><span class="line">  --description &quot;docker-runner&quot; \</span><br><span class="line">  --tag-list &quot;docker,aws&quot; \</span><br><span class="line">  --run-untagged=&quot;true&quot; \</span><br><span class="line">  --locked=&quot;false&quot; \</span><br><span class="line">  --access-level=&quot;not_protected&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>生成的配置在<code>/etc/gitlab-runner/config.toml</code>文件。  </p><p>说明：</p><ul><li>运行器 executor 选择 docker 即可，镜像使用自建的 latelee/ubuntu， 方便后续添加软件。</li></ul><p>成功后，在 Runners 界面（与图4为同一界面）可以看到已注册的实例，如图5所示。</p><p><img src="/docker/docker-34-deploy-gitlab-server/5.png"></p><p>注意，注册之后，还是可以再编辑文件<code>gitlab-runner/config/config.toml</code>的，但需要重启容器。</p><p>过程记录</p><p>管理员登录，在<code>Runners</code>中找到项目，绑定到指定<code>runner</code>。（存疑：只有一个runner，是否不需要一一绑定项目？太麻烦了）</p><p>设置好 ci 脚本，提交，提示<code>This job is stuck, because the project doesn‘t have any runners online assigned to it. </code>。解决：在<code>Settings</code>-&gt;<code>CI/CD</code>找到对应的<code>runner</code>，将<code>Indicates whether this runner can pick jobs without tags</code>打勾。</p><p>执行 CI 后，提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fatal: repository &#x27;http://10.0.153.12/latelee/ci_test.git/&#x27; not found</span><br><span class="line">ERROR: Job failed: exit code 1</span><br></pre></td></tr></table></figure><p>原因：仓库带端口，但此处没有，何解？</p><h3 id="遗留问题-思考"><a href="#遗留问题-思考" class="headerlink" title="遗留问题/思考"></a>遗留问题/思考</h3><p>如果切换 gitlab，如果更新或添加？——由于是 docker 部署，在测试阶段容易重新启动新的 gitlab 服务。  </p><h2 id="五、进阶配置"><a href="#五、进阶配置" class="headerlink" title="五、进阶配置"></a>五、进阶配置</h2><p>这里列出一些配置，有空再研究</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 这个是针对请求钩子的,还有针对Git的这些</span><br><span class="line">gitlab_rails[&#x27;webhook_timeout&#x27;] = 60 #默认是10s</span><br><span class="line"></span><br><span class="line"># 若是大体都需要求延长的,可以配置全局,后者是进程数</span><br><span class="line">unicorn[&#x27;worker_timeout&#x27;] = 100</span><br><span class="line">unicorn[&#x27;worker_processes&#x27;] = 8</span><br><span class="line"></span><br><span class="line"># gitlab_rails[&#x27;smtp_enable&#x27;] = true</span><br><span class="line"># gitlab_rails[&#x27;smtp_address&#x27;] = &quot;smtp.exmail.qq.com&quot;</span><br><span class="line"># gitlab_rails[&#x27;smtp_port&#x27;] = 465</span><br><span class="line"># gitlab_rails[&#x27;smtp_user_name&#x27;] = &quot;xxxx@xx.com&quot;</span><br><span class="line"># gitlab_rails[&#x27;smtp_password&#x27;] = &quot;password&quot;</span><br><span class="line"># gitlab_rails[&#x27;smtp_authentication&#x27;] = &quot;login&quot;</span><br><span class="line"># gitlab_rails[&#x27;smtp_enable_starttls_auto&#x27;] = true</span><br><span class="line"># gitlab_rails[&#x27;smtp_tls&#x27;] = true</span><br><span class="line"># gitlab_rails[&#x27;gitlab_email_from&#x27;] = &#x27;xxxx@xx.com&#x27;</span><br><span class="line"></span><br><span class="line">gitlab_rails[&#x27;smtp_enable&#x27;] = true</span><br><span class="line">        gitlab_rails[&#x27;smtp_address&#x27;] = &quot;smtpdm.aliyun.com&quot;</span><br><span class="line">        gitlab_rails[&#x27;smtp_port&#x27;] = 465</span><br><span class="line">        gitlab_rails[&#x27;smtp_user_name&#x27;] = &quot;crperx@aliyun.com&quot;</span><br><span class="line">        gitlab_rails[&#x27;smtp_password&#x27;] = &quot;Qwe456jkl?Asd789iop?&quot;</span><br><span class="line">        gitlab_rails[&#x27;smtp_domain&#x27;] = &quot;smtpdm.aliyun.com&quot;</span><br><span class="line">        gitlab_rails[&#x27;smtp_authentication&#x27;] = &quot;login&quot;</span><br><span class="line">        gitlab_rails[&#x27;smtp_enable_starttls_auto&#x27;] = true</span><br><span class="line">        gitlab_rails[&#x27;smtp_tls&#x27;] = true</span><br><span class="line">        gitlab_rails[&#x27;gitlab_email_enabled&#x27;] = true</span><br><span class="line">        gitlab_rails[&#x27;gitlab_email_from&#x27;] = &#x27;crperx@aliyun.com&#x27;</span><br><span class="line">        gitlab_rails[&#x27;gitlab_email_display_name&#x27;] = &#x27;noreply@aliyun.com&#x27;</span><br><span class="line">        gitlab_rails[&#x27;gitlab_shell_ssh_port&#x27;] = 22</span><br><span class="line">        user[&#x27;git_user_email&#x27;] = &quot;crperx@aliyun.com&quot;</span><br><span class="line">        nginx[&#x27;enable&#x27;] = true</span><br><span class="line">        nginx[&#x27;client_max_body_size&#x27;] = &#x27;250m&#x27;</span><br><span class="line">        nginx[&#x27;redirect_http_to_https&#x27;] = true</span><br><span class="line">        nginx[&#x27;ssl_certificate&#x27;] = &quot;/etc/gitlab/ssl/gitlab.crt&quot;</span><br><span class="line">        nginx[&#x27;ssl_certificate_key&#x27;] = &quot;/etc/gitlab/ssl/gitlab.key&quot;</span><br><span class="line">        nginx[&#x27;ssl_ciphers&#x27;] = &quot;ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256&quot;</span><br><span class="line">        nginx[&#x27;ssl_prefer_server_ciphers&#x27;] = &quot;on&quot;</span><br><span class="line">        nginx[&#x27;ssl_protocols&#x27;] = &quot;TLSv1.1 TLSv1.2&quot;</span><br><span class="line">        nginx[&#x27;ssl_session_cache&#x27;] = &quot;builtin:1000  shared:SSL:10m&quot;</span><br><span class="line">        nginx[&#x27;listen_addresses&#x27;] = [&quot;0.0.0.0&quot;]</span><br><span class="line">        nginx[&#x27;http2_enabled&#x27;] = true</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.gitlab.com/runner/register/index.html#docker">https://docs.gitlab.com/runner/register/index.html#docker</a>  </p><p><a href="https://docs.gitlab.com/runner/install/docker.html">https://docs.gitlab.com/runner/install/docker.html</a></p><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>使用默认端口时，gitlab 仓库下载地址示例：</p><p><img src="/docker/docker-34-deploy-gitlab-server/10.png" alt="image-20210715100826319"></p><p>容器内部改了端口并做了映射，相应的下载地址示例：</p><p><img src="/docker/docker-34-deploy-gitlab-server/11.png" alt="image-20210715100243798"></p><h2 id="构建基础镜像"><a href="#构建基础镜像" class="headerlink" title="构建基础镜像"></a>构建基础镜像</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc gcc-c++ kernel-devel make bzip2 -y</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文涉及一种在容器中部署 gitlab 服务的方法，并结合其自带的 gitlab-runner 实现 CICD 功能。其目的是为了在实际工作中使用代码托管及自动化操作。  &lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="http://www.latelee.org/category/docker/"/>
    
    
    <category term="docker" scheme="http://www.latelee.org/tag/docker/"/>
    
  </entry>
  
  <entry>
    <title>李迟2021年7月知识总结</title>
    <link href="http://www.latelee.org/my-library/code-for-2021-07.html"/>
    <id>http://www.latelee.org/my-library/code-for-2021-07.html</id>
    <published>2021-07-30T16:00:00.000Z</published>
    <updated>2021-10-20T16:10:49.098Z</updated>
    
    <content type="html"><![CDATA[<p>本文为 2021 年 7 月知识总结。</p><span id="more"></span><h2 id="编码总结"><a href="#编码总结" class="headerlink" title="编码总结"></a>编码总结</h2><h3 id="C-C"><a href="#C-C" class="headerlink" title="C / C++"></a>C / C++</h3><p>读取文件，在得到一行字符串中查找中文：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int readIFile2Map(const char* filename)</span><br><span class="line">&#123;</span><br><span class="line">truestring str;</span><br><span class="line">    ifstream ifs1(filename);</span><br><span class="line"></span><br><span class="line">    if(!ifs1.is_open())&#123;</span><br><span class="line">        printf(&quot;open %s failed\n&quot;, filename);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">trueint flag = 0;</span><br><span class="line">    while(getline(ifs1, str))</span><br><span class="line">    &#123;</span><br><span class="line">        // printf(&quot;str: [%s]\n&quot;, str.c_str());</span><br><span class="line">truetrue// 直接查中文，不知是否一直可行？</span><br><span class="line">truetrueif ((int)str.find(&quot;新增列表，&quot;) &gt; 0) flag = 1;</span><br><span class="line">truetrueif ((int)str.find(&quot;差异列表，&quot;) &gt; 0) flag = 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：当读取的文件格式为UTF8时，C++源码文件亦要UTF8。原则上应保持编码格式一致。细节未深入。</p><p>二维数组引用传递：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test_new.cpp:508:109: 错误：‘diffTypeCount’声明为引用的数组</span><br><span class="line">      std::map&lt;std::string, int&gt; mIntervalDiff, int&amp; diffTypeCount[4], bool needCheck)</span><br><span class="line"></span><br><span class="line">原声明：</span><br><span class="line">void calcDiffSPath(std::map&lt;std::fstd::map&lt;std::string, int&gt; mIntervalDiff, int&amp; diffTypeCount[4], bool needCheck)</span><br><span class="line">现改为：</span><br><span class="line">void calcDiffSPath(std::map&lt;std::fstd::map&lt;std::string, int&gt; mIntervalDiff, int(&amp; diffTypeCount)[4], bool needCheck)</span><br><span class="line">问题解决。</span><br></pre></td></tr></table></figure><h3 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h3><p>切片删除示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">seq := []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;&#125;  </span><br><span class="line">   // 删除第2个索引，即c</span><br><span class="line">   index := 2</span><br><span class="line">   seq = append(seq[:index], seq[index+1:]...)</span><br><span class="line"></span><br><span class="line">// 删除前面4个，即索引0~索引3，a~d</span><br><span class="line">index := 3</span><br><span class="line">   seq = append(seq[:0], seq[index+1:]...)</span><br><span class="line">   </span><br><span class="line">   // 删除最后一个</span><br><span class="line">seq = append(seq[:len(seq)-1])</span><br><span class="line"></span><br><span class="line">结构体切片清空：</span><br><span class="line">fooInfo = []UserInfo&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title></a></h3><h3 id="编码其它"><a href="#编码其它" class="headerlink" title="编码其它"></a>编码其它</h3><h2 id="一般知识"><a href="#一般知识" class="headerlink" title="一般知识"></a>一般知识</h2><h2 id="研发思考"><a href="#研发思考" class="headerlink" title="研发思考"></a>研发思考</h2><p>部门要过CMMI，这个月请老师来培训了CMMI5。后面自己实操，发现除了文档就是文档，代码倒是次要的了。  </p><h2 id="本月学习及计划"><a href="#本月学习及计划" class="headerlink" title="本月学习及计划"></a>本月学习及计划</h2><p>无</p><h2 id="其它点滴"><a href="#其它点滴" class="headerlink" title="其它点滴"></a>其它点滴</h2><p>买房提上日程了，业余写代码时间减少了，陪小孩的时间也少了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文为 2021 年 7 月知识总结。&lt;/p&gt;</summary>
    
    
    
    <category term="我的程序代码" scheme="http://www.latelee.org/category/my-library/"/>
    
    
    <category term="代码积累" scheme="http://www.latelee.org/tag/%E4%BB%A3%E7%A0%81%E7%A7%AF%E7%B4%AF/"/>
    
    <category term="知识总结" scheme="http://www.latelee.org/tag/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>我的docker随笔33：在容器中连接oracle数据库</title>
    <link href="http://www.latelee.org/docker/docker-33-access-oracle-in-docker.html"/>
    <id>http://www.latelee.org/docker/docker-33-access-oracle-in-docker.html</id>
    <published>2021-07-13T16:00:00.000Z</published>
    <updated>2021-10-20T16:10:49.166Z</updated>
    
    <content type="html"><![CDATA[<p>本文涉及一种在容器中连接 oracle 数据库的方法和步骤，最后给出测试结果。至于使用程序的方式连接，则是后续要实施的工作。</p><span id="more"></span><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>之前在 Windows 实现了连接 oracle 数据库，本次尝试在 docker 容器中连接数据库，这样，正在用 Golang 开发软件就可在 Windows 和 Linux 上运行了，部署和使用都方便。  </p><h2 id="二、技术小结"><a href="#二、技术小结" class="headerlink" title="二、技术小结"></a>二、技术小结</h2><ul><li>下载 oci 压缩包</li><li>解压 oci 包，并设置连接参数</li><li>进入容器连接数据库</li></ul><h2 id="三、实践过程"><a href="#三、实践过程" class="headerlink" title="三、实践过程"></a>三、实践过程</h2><h3 id="3-1-linux-OCI下载"><a href="#3-1-linux-OCI下载" class="headerlink" title="3.1 linux OCI下载"></a>3.1 linux OCI下载</h3><p>登录官方下载地址：<a href="https://www.oracle.com/database/technologies/instant-client/linux-x86-64-downloads.html">https://www.oracle.com/database/technologies/instant-client/linux-x86-64-downloads.html</a> ， 需登录才能下载。包名称及校验码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cksum *</span></span><br><span class="line">109893216 63352239 instantclient-basic-linux.x64-12.1.0.2.0.zip</span><br><span class="line">1824795072 1289004 instantclient-odbc-linux.x64-12.1.0.2.0.zip</span><br><span class="line">1047596065 667174 instantclient-sdk-linux.x64-12.1.0.2.0.zip</span><br><span class="line">2255047856 861284 instantclient-sqlplus-linux.x64-12.1.0.2.0.zip</span><br></pre></td></tr></table></figure><h3 id="3-2-oci安装"><a href="#3-2-oci安装" class="headerlink" title="3.2 oci安装"></a>3.2 oci安装</h3><p>将 oci 压缩包拷贝到<code>/home/latelee/tools/oracle/</code>，解压：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unzip instantclient-basic-linux.x64-12.1.0.2.0.zip</span><br><span class="line">unzip instantclient-odbc-linux.x64-12.1.0.2.0.zip</span><br><span class="line">unzip instantclient-sdk-linux.x64-12.1.0.2.0.zip</span><br><span class="line">unzip instantclient-sqlplus-linux.x64-12.1.0.2.0.zip</span><br></pre></td></tr></table></figure><p>解压后得到目录目录为<code>instantclient_12_1</code>，在该目录创建文件<code>tnsnames.ora</code>，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">foo =</span><br><span class="line">  (DESCRIPTION =</span><br><span class="line">    (ADDRESS_LIST =</span><br><span class="line">      (ADDRESS = (PROTOCOL = TCP)(HOST = 172.18.18.18)(PORT = 1521))</span><br><span class="line">    )</span><br><span class="line">    (CONNECT_DATA =</span><br><span class="line">      (SERVICE_NAME = mydb)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">oracle_test =</span><br><span class="line">  (DESCRIPTION =</span><br><span class="line">    (ADDRESS_LIST =</span><br><span class="line">      (ADDRESS = (PROTOCOL = TCP)(HOST = 172.18.18.18)(PORT = 1521))</span><br><span class="line">    )</span><br><span class="line">    (CONNECT_DATA =</span><br><span class="line">      (SERVICE_NAME = ORCLCDB)</span><br><span class="line">    )</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>注：根据实际情况修改 oracle_test(表示链接名）、HOST(主机)、PORT(端口)、SERVICE_NAME(数据库服务名)三字段值。  </p><p>文中将 oci 存储到目录<code>/home/latelee/tools/oracle/instantclient_12_1</code>，是为了方便多个容器映射使用。当然也可以将 oci 的文件放到 docker 镜像中，但笔者认为不太好，故不采用。  </p><h3 id="3-2-在容器中验证"><a href="#3-2-在容器中验证" class="headerlink" title="3.2 在容器中验证"></a>3.2 在容器中验证</h3><p>在主机中拷贝依赖库，本文中使用的<code>sqlplus</code>依赖于动态库<code>libaio.so.1</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /lib64/libaio.so.1.0.1 /home/latelee/tools/oracle/instantclient_12_1</span><br><span class="line">cd /home/latelee/tools/oracle/instantclient_12_1</span><br><span class="line">sudo ln -s libaio.so.1 libaio.so.1.0.1 </span><br></pre></td></tr></table></figure><p>注意，也可将动态库单独拷贝至一 lib 目录，再进行映射，本文图方便直接放到 oci 目录了。  </p><p>使用 <code>latelee/ubuntu</code> 进行实验。进入容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm -v /home/latelee/tools/oracle/instantclient_12_1:/work/instantclient_12_1 --name foo latelee/ubuntu bash</span><br></pre></td></tr></table></figure><p>在容器中设置环境变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export ORACLE_HOME=/work/instantclient_12_1</span><br><span class="line">export TNS_ADMIN=$ORACLE_HOME</span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/work/instantclient_12_1</span><br></pre></td></tr></table></figure><p>在容器中进入<code>/work/instantclient_12_1</code>目录，执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sqlplus my_db/123456@oracle_test </span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connected to:</span><br><span class="line">Oracle Database 19c Enterprise Edition Release 19.0.0.0.0 - Production</span><br></pre></td></tr></table></figure><p>表示连接成功。</p><p>后续将使用 golang 实现程序方式的连接。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文涉及一种在容器中连接 oracle 数据库的方法和步骤，最后给出测试结果。至于使用程序的方式连接，则是后续要实施的工作。&lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="http://www.latelee.org/category/docker/"/>
    
    
    <category term="docker" scheme="http://www.latelee.org/tag/docker/"/>
    
  </entry>
  
  <entry>
    <title>用封装的栈回溯类捕获段错误</title>
    <link href="http://www.latelee.org/my-library/catch-segmentfault-using-backtrace.html"/>
    <id>http://www.latelee.org/my-library/catch-segmentfault-using-backtrace.html</id>
    <published>2021-07-07T16:00:00.000Z</published>
    <updated>2021-10-20T16:10:49.098Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍使用自封装的 backtrace 类对段错误进行捕获，以方便分析运行错误的方法。并给出实现和测试代码。</p><span id="more"></span><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们写程序难免会运行出错，常在河边，哪能不湿鞋。出错不可怕，怕的是无法定位问题，像段错误，在服务端、嵌入式等领域，很多时候都无迹可寻，我们可以用 coredump 进行事后分析，但还是略显麻烦。</p><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>本节介绍<code>CBackTracer</code>类的设计。</p><ul><li>利用<code>backtrace</code>和<code>backtrace_symbols</code>可以获取函数符号和地址。</li><li>可以指定获取的函数数量，本文暂定为10，如果回溯的函数数量少于指定的，则按实际数量显示。</li><li>得到地址后，使用<code>addr2line</code>命令解析出对应的文件行号。由于该命令需要程序名称，因此需要调用者提供程序名称，与信号值一并传递。</li><li>由于<code>sigaction</code>的回调函数不能使用类内的函数，因为单独编写之。</li></ul><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>实现代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">// 头文件 backtraceplus.h</span><br><span class="line">#ifndef BACKTRACEPLUS_H</span><br><span class="line">#define BACKTRACEPLUS_H</span><br><span class="line"></span><br><span class="line">class CBackTracer &#123;</span><br><span class="line">public:</span><br><span class="line">    CBackTracer() &#123;&#125;</span><br><span class="line">    CBackTracer(const char* name, int sig); // argv[0] SIGSEGV</span><br><span class="line">    ~CBackTracer() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    void Setup(const char* name, int sig);</span><br><span class="line">private:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 实现文件 backtraceplus.cpp</span><br><span class="line">#include &lt;execinfo.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;backtraceplus.h&quot;</span><br><span class="line"></span><br><span class="line">// 程序名，用于输出函数行号</span><br><span class="line">static char g_exeName[256] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">// 不能作为了类成员</span><br><span class="line">void fault_trap(int sig, siginfo_t * siginfo, void *myact)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Catch SegmentFault!!\n&quot;);</span><br><span class="line"></span><br><span class="line">    void *array[10] = &#123; 0 &#125;;</span><br><span class="line">    int num = backtrace(array, 10);</span><br><span class="line">    char **calls = backtrace_symbols(array, num);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        char *symbol = calls[i];</span><br><span class="line"></span><br><span class="line">        char addr[64] = &#123; 0 &#125;;</span><br><span class="line">        char *p = strstr(symbol, &quot;[0x&quot;);</span><br><span class="line">        snprintf(addr, sizeof(addr), p + 1);</span><br><span class="line">        *(addr + strlen(addr) - 1) = 0;</span><br><span class="line"></span><br><span class="line">        char cmd[64] = &#123; 0 &#125;;</span><br><span class="line">        snprintf(cmd, sizeof(cmd), &quot;addr2line %s -s -e %s&quot;, addr, g_exeName);</span><br><span class="line"></span><br><span class="line">        FILE *fp = popen(cmd, &quot;r&quot;);</span><br><span class="line"></span><br><span class="line">        char buf[256] = &#123; 0 &#125;;</span><br><span class="line">        fread(buf, sizeof(buf), sizeof(char), fp);</span><br><span class="line"></span><br><span class="line">        printf(&quot;%s %s&quot;, symbol, buf);</span><br><span class="line"></span><br><span class="line">        pclose(fp);</span><br><span class="line">        fp = NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CBackTracer::CBackTracer(const char* name, int sig)</span><br><span class="line">&#123;</span><br><span class="line">    Setup(name, sig);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CBackTracer::Setup(const char* name, int sig)</span><br><span class="line">&#123;</span><br><span class="line">    strncpy(g_exeName, name, sizeof(g_exeName));</span><br><span class="line"></span><br><span class="line">    struct sigaction act;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = SA_SIGINFO;</span><br><span class="line">    act.sa_sigaction = fault_trap;</span><br><span class="line">    sigaction(sig, &amp;act, NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>测试代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;execinfo.h&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;backtraceplus.h&quot;</span><br><span class="line"></span><br><span class="line">void badcall(void)</span><br><span class="line">&#123;</span><br><span class="line">    int a = 250;</span><br><span class="line">    printf(&quot;fault: %s\n&quot;, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void foobar(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;in %s, call bad\n&quot;, __func__);</span><br><span class="line">    </span><br><span class="line">    badcall();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myfunc(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;in %s\n&quot;, __func__);</span><br><span class="line"></span><br><span class="line">    foobar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;test of backtrace...\n&quot;);</span><br><span class="line">    </span><br><span class="line">    //CBackTracer mybt(argv[0], SIGSEGV);</span><br><span class="line">    </span><br><span class="line">    CBackTracer mybt;</span><br><span class="line">    mybt.Setup(argv[0], SIGSEGV);</span><br><span class="line"></span><br><span class="line">    myfunc();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out </span><br><span class="line">test of backtrace...</span><br><span class="line">in myfunc</span><br><span class="line">in foobar, call bad</span><br><span class="line">fault: Catch SegmentFault!!</span><br><span class="line">./a.out(_Z10fault_trapiP9siginfo_tPv+0x57) [0x40159f] backtraceplus.cpp:23</span><br><span class="line">/usr/lib64/libc.so.6(+0x363b0) [0x7f9baac973b0] ??:0</span><br><span class="line">/usr/lib64/libc.so.6(_IO_vfprintf+0x4a79) [0x7f9baacae029] ??:0</span><br><span class="line">/usr/lib64/libc.so.6(_IO_printf+0x99) [0x7f9baacb4459] ??:0</span><br><span class="line">./a.out(_Z7badcallv+0x23) [0x401800] main.cpp:23</span><br><span class="line">./a.out(_Z6foobarv+0x21) [0x401823] main.cpp:31</span><br><span class="line">./a.out(_Z6myfuncv+0x1d) [0x401882] main.cpp:46</span><br><span class="line">./a.out(main+0x50) [0x4018d4] main.cpp:59</span><br><span class="line">/usr/lib64/libc.so.6(__libc_start_main+0xf5) [0x7f9baac83505] ??:0</span><br><span class="line">./a.out() [0x401169] ??:?</span><br></pre></td></tr></table></figure><p>注：已经能捕获到段错误，由于系统库没有源码，因此<code>libc.so.6</code>文件最后显示的是<code>??:0</code>，但我们的测试程序<code>a.out</code>可以显示行号。根据行号，可以逐步排查问题。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文的示例有几个依赖条件：系统需安装有<code>addr2line</code>命令，程序需使用调试版本，不能<code>strip</code>，否则无法分析出程序函数位置。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍使用自封装的 backtrace 类对段错误进行捕获，以方便分析运行错误的方法。并给出实现和测试代码。&lt;/p&gt;</summary>
    
    
    
    <category term="我的程序代码" scheme="http://www.latelee.org/category/my-library/"/>
    
    
    <category term="工程库代码" scheme="http://www.latelee.org/tag/%E5%B7%A5%E7%A8%8B%E5%BA%93%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>李迟2021年6月知识总结</title>
    <link href="http://www.latelee.org/my-library/code-for-2021-06.html"/>
    <id>http://www.latelee.org/my-library/code-for-2021-06.html</id>
    <published>2021-06-29T16:00:00.000Z</published>
    <updated>2021-10-20T16:10:49.098Z</updated>
    
    <content type="html"><![CDATA[<p>本文为 2021 年 6 月知识总结。</p><span id="more"></span><h2 id="编码总结"><a href="#编码总结" class="headerlink" title="编码总结"></a>编码总结</h2><h3 id="C-C"><a href="#C-C" class="headerlink" title="C / C++"></a>C / C++</h3><p>使用<code>sscanf</code>检查不确定的输入参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">char</span> name[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> type = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> threadnum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> total = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 注：先检查多的，再检查少的</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="built_in">sscanf</span>(cmd, <span class="string">&quot;%s %d %d %d&quot;</span>, name, &amp;type, &amp;threadnum, &amp;total); </span><br><span class="line"><span class="keyword">if</span> (num != <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">truenum = <span class="built_in">sscanf</span>(cmd, <span class="string">&quot;%s %d %d&quot;</span>, name, &amp;type, &amp;threadnum);</span><br><span class="line">true<span class="keyword">if</span> (num != <span class="number">3</span>)</span><br><span class="line">true&#123;</span><br><span class="line">truetrue<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：实践中检查参数，建议使用<code>main(argc, argv[])</code>的形式，好修改。</p><h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><p>修改容器的root密码</p><p>场景：下载 centos 镜像，运行之，默认为普通用户，无法切换到 root——因为不知道密码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker exec -id -u root &lt;容器名或ID&gt; bash</span><br></pre></td></tr></table></figure><p>此时进入的容器即为 root 权限。再用<code>passwd root</code>设置密码。此时另起终端进入容器，即可用<code>su root</code>切换权限。当然，也可直接用上述命令进行<code>root</code>权限方面的操作。  </p><h3 id="python脚本创建docker镜像"><a href="#python脚本创建docker镜像" class="headerlink" title="python脚本创建docker镜像"></a>python脚本创建docker镜像</h3><p>知识点：执行命令，执行命令并获取返回值，字符串为空的判断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">SRC_PATH = &#x27;/home/latelee/docker-test/demo&#x27;</span><br><span class="line">DOCKER_ADDRESS = &quot;registry.cn-hangzhou.aliyuncs.com/latleee&quot;</span><br><span class="line">DOCKER_IMAGE_NAME = &quot;busybox&quot;</span><br><span class="line">DOCKER_TAG = &quot;latest&quot;</span><br><span class="line"></span><br><span class="line">def buidDocker():</span><br><span class="line">    # 可切换到目标目录</span><br><span class="line">    #os.chdir(SRC_PATH)</span><br><span class="line"></span><br><span class="line">    # 查询已存在的镜像并删除之，注：用popen获取返回的镜像ID</span><br><span class="line">    cmd = &quot;docker images | grep &quot; + DOCKER_IMAGE_NAME + &quot; | awk &#x27;&#123;print $3&#125;&#x27;&quot;</span><br><span class="line">    imageid = os.popen(cmd).read()</span><br><span class="line">    #print(&quot;cmd %s %s&quot; % (cmd, imageid))</span><br><span class="line"></span><br><span class="line">    if len(imageid) != 0:</span><br><span class="line">        print(&quot;found docker image, remove it&quot;)</span><br><span class="line">        cmd = &#x27;docker rmi &#x27; + imageid</span><br><span class="line">        os.system(cmd)</span><br><span class="line"></span><br><span class="line">    print(&quot;start build  docker in %s&quot; % (SRC_PATH))</span><br><span class="line"></span><br><span class="line">    # 使用绝对路径</span><br><span class="line">    cmd = &quot;docker build -t &quot; + DOCKER_ADDRESS + &quot;/&quot; + DOCKER_IMAGE_NAME + &quot; &quot; + SRC_PATH</span><br><span class="line">    # 前述切换目录，则可用此命令</span><br><span class="line">    #cmd = &quot;docker build -t &quot; + DOCKER_ADDRESS + &quot;/&quot; + DOCKER_IMAGE_NAME + &quot; .&quot;</span><br><span class="line">    #print(&quot;build cmd: %s &quot; % (cmd))</span><br><span class="line">    ret = os.system(cmd)</span><br><span class="line"></span><br><span class="line">    if ret == 0:</span><br><span class="line">        print(&#x27;build docker ok&#x27;)</span><br><span class="line">    else:</span><br><span class="line">        print(&#x27;build docker failed&#x27;)</span><br></pre></td></tr></table></figure><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p>查询 sqlite3 数据库所有表名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> sqlite_master <span class="keyword">where</span> type<span class="operator">=</span><span class="string">&#x27;table&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> name</span><br></pre></td></tr></table></figure><h3 id="编码其它"><a href="#编码其它" class="headerlink" title="编码其它"></a>编码其它</h3><h4 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h4><p>继续总结 Makefile 知识：  </p><p>某工程需编译为 32 位程序和 64 位程序，因为有2套目标系统。原来的工程使用 eclipse 编辑和编译。接手后改为 Makefile 编译，为方便个人使用，研究如何在 Makefile 中自适应 2 种不同位数的系统。</p><p>在 shell 脚本中可如下方法判断系统位数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BITS=`getconf LONG_BIT`</span><br><span class="line">BITS=&quot;  --$BITS&quot;bit</span><br></pre></td></tr></table></figure><p>根据所在系统，上述输出结果为<code>32bit</code>或<code>64bit</code>，此字符串可用于生成版本号头文件。  </p><p>在 Makefile 中如下使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ARCH = $(shell getconf LONG_BIT)</span><br><span class="line"></span><br><span class="line">DEFS    += -DARCH=$(ARCH)</span><br><span class="line"></span><br><span class="line">ifeq ($(ARCH), 32)</span><br><span class="line">CFLAGS += -I/usr/local/sqlite/sqlite-x86/include/</span><br><span class="line">LDFLAGS += -L/usr/local/sqlite/sqlite-x86/lib/ -L/usr/local/uuid/uuid-x86/</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><p>这样就能根据不同的系统使用不同的库目录。</p><p>另外，目标系统中，32 位为 debian 系统，64 位为 centos 系统，本想用 Docker 实现同一虚拟机的编译，但因为版本不好找，放弃之。再者，工程有大量不再使用但未删除的代码，大部分变量、函数近似，只是相差几个字符或日期，如<code>foo</code>、<code>foo_I</code>、<code>foo_2020</code>，导致一定的阅读障碍——刚刚看过的代码段，切换了文件，又看到相同的，过一会，还能看到相同的。目前暂不敢动。  </p><h4 id="版权"><a href="#版权" class="headerlink" title="版权"></a>版权</h4><p>github上有个外国网友在一个几年前的项目上咨询协议，因为当时代码是没有版权声明的——现在大部分代码都没有，看了些帖子，大意是没有声明版权的话，默认是私有不开源的。考虑之后，还是要将自己仓库加上声明的。对其它人友好，对后续维护亦友好。目前暂定是 BSP 协议，限制比较少。  </p><p>BSD：允许商用、私用（共开亦可）。带原有的版权文件，修改后的代码不用做说明。不能用作者名字做推广。</p><h2 id="一般知识"><a href="#一般知识" class="headerlink" title="一般知识"></a>一般知识</h2><h2 id="研发思考"><a href="#研发思考" class="headerlink" title="研发思考"></a>研发思考</h2><p>写代码久了，发现自己不敢突破，不追求编程技巧，而是追求可维护性、可读性。有时候，发现一些问题后自然会去重构，但重构后发现达不到预期，因为有些隐藏得很深的业务点，自己并没有掌握了解，贸然修改，只会浪费时间。所以，只要不出问题，不会主动去改，但像代码风格命名这种影响编程效率的，不在此列。在修改过程中，则根据实际情况**部分重构  **。</p><p>领域设计：先对某领域有一定认知，进行总结概括，理清逻辑，再进行设计。个人见解：应该不合适，编码多年，接触了不同领域的行业，但自己那套学习知识的方法和编写的代码，或多或少都能应用上。——因为会总结积累，从而形成自己的知识库，以应对不同的领域/业务。而且更重要的一个原因，自己并没有在一个领域中深耕。可能自己对<strong>业务</strong>研究不深，沉淀不够，才得出以上结论。  </p><h2 id="本月学习及计划"><a href="#本月学习及计划" class="headerlink" title="本月学习及计划"></a>本月学习及计划</h2><p>无</p><h2 id="其它点滴"><a href="#其它点滴" class="headerlink" title="其它点滴"></a>其它点滴</h2><p>自体检出结果，打完2针疫苗，外包人员取消餐补后，家里那位问什么时候买房，又和老爸老妈小吵一次，工作和生活都没动力了。但并没有耽误公司的事，晚上加了几次小班，上周末加了一整天的班（早上8点到公司至下午6点离开），在百年献礼中也算出了一点微不足道的力。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文为 2021 年 6 月知识总结。&lt;/p&gt;</summary>
    
    
    
    <category term="我的程序代码" scheme="http://www.latelee.org/category/my-library/"/>
    
    
    <category term="代码积累" scheme="http://www.latelee.org/tag/%E4%BB%A3%E7%A0%81%E7%A7%AF%E7%B4%AF/"/>
    
    <category term="知识总结" scheme="http://www.latelee.org/tag/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：利用反射reflect构建通用打印结构体接口</title>
    <link href="http://www.latelee.org/golang/golang-notes-print-structure.html"/>
    <id>http://www.latelee.org/golang/golang-notes-print-structure.html</id>
    <published>2021-06-28T16:01:00.000Z</published>
    <updated>2021-10-20T16:10:49.022Z</updated>
    
    <content type="html"><![CDATA[<p>本文针对 Golang 的结构体字段的打印进行一些研究。其中涉及到一些反射的知识。  </p><span id="more"></span><h2 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h2><p>总结一些实践情况，结构体字段值的输出还是比较常见的，至少笔者目前常用。比如输出某些数据表的数据（代码中会转换为结构体），对比不同版本数据表的数据，对比某些不同版本但格式相同的 json 文件，等。为了优化代码，减少开发维护工作量，需寻找一种高效的方法。打印结构体。需求如下：  </p><ul><li>格式化，目前需迎合 markdown 表格格式。  </li><li>接口可通用于数组、map等结构，原则上直接传递某个变量，即可自行输出格式化后的所需内容。  </li><li>可输出到终端，或文件。  </li></ul><h2 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h2><p>本文使用的测试数据如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">type TestObj struct &#123;</span><br><span class="line">    Name  string</span><br><span class="line">    Value uint64</span><br><span class="line">    Size  int32</span><br><span class="line">    Guard float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var objects []TestObj</span><br><span class="line"></span><br><span class="line">    object1 := TestObj&#123;</span><br><span class="line">        Name:  &quot;Jim | Kent&quot;,</span><br><span class="line">        Value: 128,</span><br><span class="line">        Size:  256,</span><br><span class="line">        Guard: 56.4,</span><br><span class="line">    &#125;</span><br><span class="line">    object2 := TestObj&#123;</span><br><span class="line">        Name:  &quot;James1&quot;,</span><br><span class="line">        Value: 128,</span><br><span class="line">        Size:  259,</span><br><span class="line">        Guard: 56.4,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    objects = append(objects, object1)</span><br><span class="line">    objects = append(objects, object2)</span><br><span class="line">    </span><br><span class="line">    var myMap map[string]TestObj</span><br><span class="line">    myMap = make(map[string]TestObj)</span><br><span class="line">    myMap[&quot;obj3&quot;] = TestObj&#123;&quot;Jim Kent&quot;, 103, 201, 102.56&#125;</span><br><span class="line">    myMap[&quot;obj1&quot;] = TestObj&#123;&quot;Kent&quot;, 101, 201, 102.56&#125;</span><br><span class="line">    myMap[&quot;obj2&quot;] = TestObj&#123;&quot;Kent&quot;, 102, 201, 102.56&#125;</span><br></pre></td></tr></table></figure><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>对于可识别渲染 markdown 的平台来说，输出的如下结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print by line - slice default  </span><br><span class="line">total: 2  </span><br><span class="line"></span><br><span class="line">| Name          | Value | Size | Guard |</span><br><span class="line">| ------------- | ----- | ---- | ----- |</span><br><span class="line">| Jim &lt;br&gt; Kent | 128   | 256  | 56.4  |</span><br><span class="line">| James1        | 128   | 259  | 56.4  |</span><br></pre></td></tr></table></figure><p>就能正常显示表格形式。如下：</p><p>print by line - slice default<br>total: 2  </p><table><thead><tr><th>Name</th><th>Value</th><th>Size</th><th>Guard</th></tr></thead><tbody><tr><td>Jim <br> Kent</td><td>128</td><td>256</td><td>56.4</td></tr><tr><td>James1</td><td>128</td><td>259</td><td>56.4</td></tr></tbody></table><h2 id="简单版本"><a href="#简单版本" class="headerlink" title="简单版本"></a>简单版本</h2><p>遍历结构体数据，并打印之：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for a, b := range objects &#123;</span><br><span class="line">    fmt.Printf(&quot;%v %v\n&quot;, a, b)</span><br><span class="line">    // fmt.Printf(&quot;%v %+v\n&quot;, a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要格式化，需显式给出结构体字段和格式化形式。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for a, b := range objects &#123;</span><br><span class="line">    fmt.Printf(&quot;%d: %v | %v | %v | %v\n&quot;, a, b.Name, b.Value, b.Size, b.Guard)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上结果分别如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 &#123;Jim | Kent 128 256 56.4&#125;</span><br><span class="line">1 &#123;James1 128 259 56.4&#125;</span><br><span class="line"></span><br><span class="line">0: Jim | Kent | 128 | 256 | 56.4</span><br><span class="line">1: James1 | 128 | 259 | 56.4</span><br></pre></td></tr></table></figure><p>由于此版本非吾所用，因此只具大致形式。  </p><p>可以看到，前者简单，不用理会结构体内容，直接使用<code>%v</code>即可打印，如需要输出结构体字段名，则用<code>%+v</code>。但其形式固定的，类似<code>&#123;xx xx xx&#125;</code>这样。后者使用竖线<code>|</code>将各字段隔开，需一一写出字段（当然也可忽略部分字段）。  </p><h2 id="reflect版本"><a href="#reflect版本" class="headerlink" title="reflect版本"></a>reflect版本</h2><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">func checkSkipNames(a string, b []string) bool &#123;</span><br><span class="line">    for _, item := range b &#123;</span><br><span class="line">        if item == a &#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 结构体的字段名称</span><br><span class="line">func GetStructName(myref reflect.Value, names []string) (buffer string) &#123;</span><br><span class="line">    // 注：有可能传递string数组，此时没有“标题”一说，返回</span><br><span class="line">    if myref.Type().Name() == &quot;string&quot; &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    for i := 0; i &lt; myref.NumField(); i++ &#123;</span><br><span class="line">        if ok := checkSkipNames(myref.Type().Field(i).Name, names); ok &#123;</span><br><span class="line">            continue</span><br><span class="line">        &#125;</span><br><span class="line">        buffer += fmt.Sprintf(&quot;| %v &quot;, myref.Type().Field(i).Name)</span><br><span class="line">    &#125;</span><br><span class="line">    buffer += fmt.Sprintf(&quot;|\n&quot;)</span><br><span class="line">    for i := 0; i &lt; myref.NumField(); i++ &#123;</span><br><span class="line">        if ok := checkSkipNames(myref.Type().Field(i).Name, names); ok &#123;</span><br><span class="line">            continue</span><br><span class="line">        &#125;</span><br><span class="line">        buffer += fmt.Sprintf(&quot;| --- &quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    buffer += fmt.Sprintf(&quot;|\n&quot;)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将 | 替换为 &lt;br&gt;</span><br><span class="line">func replaceI(text string) (ret string) &#123;</span><br><span class="line">    // 下面2种方法都可以</span><br><span class="line">    // reg := regexp.MustCompile(`\|`)</span><br><span class="line">    // ret = reg.ReplaceAllString(text, `$&#123;1&#125;&lt;br/&gt;`)</span><br><span class="line">    ret = strings.Replace(text, &quot;|&quot;, &quot;&lt;br&gt;&quot;, -1)</span><br><span class="line">    // fmt.Printf(&quot;!!! %q\n&quot;, ret)</span><br><span class="line">    return ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 结构体的值</span><br><span class="line">func GetStructValue(myref reflect.Value, names []string) (buffer string) &#123;</span><br><span class="line">    // 注：有可能传递string数组，此时没有“字段”一说，返回原本的内容</span><br><span class="line">    if myref.Type().Name() == &quot;string&quot; &#123;</span><br><span class="line">        return myref.Interface().(string)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; myref.NumField(); i++ &#123;</span><br><span class="line">        if ok := checkSkipNames(myref.Type().Field(i).Name, names); ok &#123;</span><br><span class="line">            continue</span><br><span class="line">        &#125;</span><br><span class="line">        // 判断是否包含|，有则替换，其必须是string类型，其它保持原有的</span><br><span class="line">        t := myref.Field(i).Type().Name()</span><br><span class="line">        if t == &quot;string&quot; &#123;</span><br><span class="line">            var str string = myref.Field(i).Interface().(string)</span><br><span class="line">            str = replaceI(str)</span><br><span class="line">            buffer += fmt.Sprintf(&quot;| %v &quot;, str)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            buffer += fmt.Sprintf(&quot;| %v &quot;, myref.Field(i).Interface())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer += fmt.Sprintf(&quot;|\n&quot;)</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func PrintStructTable(data interface&#123;&#125;, title string, skipNames ...string) &#123;</span><br><span class="line">    var w io.Writer</span><br><span class="line">    w = os.Stdout // set to stdout</span><br><span class="line">    buffer, num := PrintStructTable2Buffer(data, title, skipNames...)</span><br><span class="line">    fmt.Fprintf(w, &quot;total: %v\n&quot;, num)</span><br><span class="line">    fmt.Fprintf(w, &quot;%v\n&quot;, buffer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">功能：指定结构体data，其可为slice map 单独结构体</span><br><span class="line">     指定自定义标题，为空则使用结构体字段</span><br><span class="line">     指定忽略的字段名称（即结构体字段的变量）</span><br><span class="line">     按结构体定义的顺序列出，如自定义标题，则必须保证一致。</span><br><span class="line">*/</span><br><span class="line">func PrintStructTable2Buffer(data interface&#123;&#125;, title string, skipNames ...string) (buffer string, num int) &#123;</span><br><span class="line">    buffer = &quot;&quot;</span><br><span class="line"></span><br><span class="line">    t := reflect.TypeOf(data)</span><br><span class="line">    v := reflect.ValueOf(data)</span><br><span class="line"></span><br><span class="line">    var skipNamess []string</span><br><span class="line">    for _, item := range skipNames &#123;</span><br><span class="line">        skipNamess = append(skipNamess, item)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 打印结构体字段标志</span><br><span class="line">    innertitle := false</span><br><span class="line">    printHead := false</span><br><span class="line">    if len(title) == 0 &#123;</span><br><span class="line">        innertitle = true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 不同类型的，其索引方式不同，故一一判断使用</span><br><span class="line">    switch t.Kind() &#123;</span><br><span class="line">    case reflect.Slice, reflect.Array:</span><br><span class="line">        num = v.Len()</span><br><span class="line">        if innertitle &#123;</span><br><span class="line">            buffer += GetStructName(v.Index(0), skipNamess)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            buffer += fmt.Sprintln(title)</span><br><span class="line">        &#125;</span><br><span class="line">        for i := 0; i &lt; v.Len(); i++ &#123;</span><br><span class="line">            buffer += GetStructValue(v.Index(i), skipNamess)</span><br><span class="line">        &#125;</span><br><span class="line">    case reflect.Map:</span><br><span class="line">        num = v.Len()</span><br><span class="line">        iter := v.MapRange()</span><br><span class="line">        for iter.Next() &#123;</span><br><span class="line">            if !printHead &#123;</span><br><span class="line">                if innertitle &#123;</span><br><span class="line">                    buffer += GetStructName(iter.Value(), skipNamess)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    buffer += fmt.Sprintln(title)</span><br><span class="line">                &#125;</span><br><span class="line">                printHead = true</span><br><span class="line">            &#125;</span><br><span class="line">            buffer += GetStructValue(iter.Value(), skipNamess)</span><br><span class="line">        &#125;</span><br><span class="line">    default:</span><br><span class="line">        num = 1 // 单独结构体不能用Len，单独赋值</span><br><span class="line">        if !printHead &#123;</span><br><span class="line">            if innertitle &#123;</span><br><span class="line">                buffer += GetStructName(v, skipNamess)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                buffer += fmt.Sprintln(title)</span><br><span class="line">            &#125;</span><br><span class="line">            printHead = true</span><br><span class="line">        &#125;</span><br><span class="line">        buffer += GetStructValue(v, skipNamess)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码提供的对外接口为<code>PrintStructTable2Buffer</code>和<code>PrintStructTable</code>，因为默认格式为<code>markdown</code>表格形式，故加上<code>Table</code>。前者输出到缓冲区的（可继续写到文件中），后者直接输出终端。真正实现的接口为<code>PrintStructTable2Buffer</code>，其提供了自定义标题，和忽略的字段参数，如果不指定标题，必须将<code>title</code>置为空，因为最后的参数是可变参数，只能有一个，如不写，则输出所有字段。</p><p>至于内部实现，因为需要根据用户输入忽略某些字段，因此定义<code>checkSkipNames</code>检查参数，利用<code>GetStructName</code>获取结构体名称，<code>GetStructValue</code>获取结构体的值。不管获取字段还是值，均使用传递的<code>interface&#123;&#125;</code>，不需额外传递结构体本身。<br>注意，由于默认使用竖线分隔，如果字段值本身有竖线，则使用<code>&lt;br&gt;</code>替换——即让该字段的值换行。  </p><p>测试代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 数组，默认形式</span><br><span class="line">fmt.Println(&quot;print by line - slice default&quot;)</span><br><span class="line">buf, num := PrintStructTable2Buffer(objects, &quot;&quot;)</span><br><span class="line">fmt.Println(&quot;total:&quot;, num)</span><br><span class="line">fmt.Println(buf)</span><br><span class="line"></span><br><span class="line">// 数组，自定义标题 </span><br><span class="line">fmt.Println(&quot;print by line - slice&quot;)</span><br><span class="line">buf, num = PrintStructTable2Buffer(objects, &quot;| Name | Value | Size | Guard |\n| --- | --- | --- | ++++ |&quot;)</span><br><span class="line">fmt.Println(&quot;total:&quot;, num)</span><br><span class="line">fmt.Println(buf)</span><br><span class="line">// 单个对象 </span><br><span class="line">fmt.Println(&quot;print by line - single object&quot;)</span><br><span class="line">buf, num = PrintStructTable2Buffer(object1, &quot;| Name | Value  | Guard |\n| +++ | +++ | +++ |&quot;, &quot;Size&quot;)</span><br><span class="line">fmt.Println(&quot;total:&quot;, num)</span><br><span class="line">fmt.Println(buf)</span><br><span class="line">// map</span><br><span class="line">fmt.Println(&quot;print by line - map&quot;)</span><br><span class="line">buf, num = PrintStructTable2Buffer(myMap, &quot;aaa&quot;)</span><br><span class="line">fmt.Println(buf)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">print by line - slice default</span><br><span class="line">total: 2</span><br><span class="line">| Name | Value | Size | Guard |</span><br><span class="line">| --- | --- | --- | --- |</span><br><span class="line">| Jim &lt;br&gt; Kent | 128 | 256 | 56.4 |</span><br><span class="line">| James1 | 128 | 259 | 56.4 |</span><br><span class="line"></span><br><span class="line">print by line - slice</span><br><span class="line">total: 2</span><br><span class="line">| Name | Value | Size | Guard |</span><br><span class="line">| --- | --- | --- | ++++ |</span><br><span class="line">| Jim &lt;br&gt; Kent | 128 | 256 | 56.4 |</span><br><span class="line">| James1 | 128 | 259 | 56.4 |</span><br><span class="line"></span><br><span class="line">print by line - single object</span><br><span class="line">total: 1</span><br><span class="line">| Name | Value  | Guard |</span><br><span class="line">| +++ | +++ | +++ |</span><br><span class="line">| Jim &lt;br&gt; Kent | 128 | 56.4 |</span><br><span class="line"></span><br><span class="line">print by line - map</span><br><span class="line">aaa</span><br><span class="line">| Jim Kent | 103 | 201 | 102.56 |</span><br><span class="line">| Kent | 101 | 201 | 102.56 |</span><br><span class="line">| Kent | 102 | 201 | 102.56 |</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>观察结果，可达到预期目的。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文针对 Golang 的结构体字段的打印进行一些研究。其中涉及到一些反射的知识。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：反射reflect的一些研究及代码汇总</title>
    <link href="http://www.latelee.org/golang/golang-notes-cmdtool0.html"/>
    <id>http://www.latelee.org/golang/golang-notes-cmdtool0.html</id>
    <published>2021-06-28T16:01:00.000Z</published>
    <updated>2021-10-20T16:10:49.022Z</updated>
    
    <content type="html"><![CDATA[<p>本文汇总一些工程中使用到的和 reflect 有关的代码示例。由于是代码片段，不一定保证完整。  </p><span id="more"></span><h3 id="解析json"><a href="#解析json" class="headerlink" title="解析json"></a>解析json</h3><p>本节介绍解析json的一些方法。json 可来自文件，也可来自字符串，无论哪种，都是先转换成<code>[]byte</code>，再调用<code>json.Unmarshal</code>解析。<br>有时候并不关注完整的 json 格式，我们可以只取其中一部分字段，因此，可使用<code>map[string]interface&#123;&#125;</code>来接收解析结果（注意如是数组，则须使用数组形式）。  </p><h4 id="从json文件解析其字段"><a href="#从json文件解析其字段" class="headerlink" title="从json文件解析其字段"></a>从json文件解析其字段</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.Open(filename)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    fmt.Printf(&quot;open file %s error: %s\n&quot;, filename, err)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">defer file.Close()</span><br><span class="line"></span><br><span class="line">read := io.Reader(file)</span><br><span class="line"></span><br><span class="line">data, _ := ioutil.ReadAll(read)</span><br><span class="line">var v []map[string]interface&#123;&#125;</span><br><span class="line">err = json.Unmarshal(data, &amp;v)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    fmt.Printf(&quot;Unmarshal error: %s\n&quot;, err)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 假定filename里面有很多的json数组，一一遍历</span><br><span class="line">for _, idx := range v &#123;</span><br><span class="line">    fmt.Println(idx[&quot;foo&quot;])</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="从json字符串解析"><a href="#从json字符串解析" class="headerlink" title="从json字符串解析"></a>从json字符串解析</h4><p>一个简单的示例，从字符串组装，到解析，到提取其中某个字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func TestJsonSimple(t *testing.T) &#123;</span><br><span class="line">// 原始json字符串不能格式化，必须转换成[]byte</span><br><span class="line">orgJsonString :=</span><br><span class="line">`&#123;&quot;enID&quot;:&quot;ID250&quot;,&quot;exID&quot;:&quot;ID251&quot;,&quot;type&quot;:1,&quot;money&quot;:250.44,&quot;distance&quot;:274050&#125;`</span><br><span class="line"></span><br><span class="line">    // 虽然不知道具体结构体，但知道json只有一个，不是数组</span><br><span class="line">    var data map[string]interface&#123;&#125;</span><br><span class="line">true// 解析</span><br><span class="line">    err := json.Unmarshal([]byte(orgJsonString), &amp;data)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Println(err.Error())</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;%#v\n&quot;, data);</span><br><span class="line">    fmt.Println(data[&quot;money&quot;]) // 并不关心其它字段，只抽取所需的</span><br><span class="line">    fmt.Println(data[&quot;money1&quot;]) // 不存在，返回nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map[string]interface &#123;&#125;&#123;&quot;distance&quot;:274050, &quot;enID&quot;:&quot;ID250&quot;, &quot;exID&quot;:&quot;ID251&quot;, &quot;money&quot;:250.44, &quot;type&quot;:1&#125;</span><br><span class="line">250.44</span><br><span class="line">&lt;nil&gt;</span><br></pre></td></tr></table></figure><p>json中嵌套数组，并获取数组内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">func showInterface(origin interface&#123;&#125;) &#123;</span><br><span class="line">    switch reflect.TypeOf(origin).Kind() &#123;</span><br><span class="line">    case reflect.Slice, reflect.Array:</span><br><span class="line">        s := reflect.ValueOf(origin)</span><br><span class="line">        for i := 0; i &lt; s.Len(); i++ &#123;</span><br><span class="line">            fmt.Printf(&quot;%d: %v\n&quot;, i, s.Index(i))</span><br><span class="line">        &#125;</span><br><span class="line">    case reflect.String:</span><br><span class="line">        s := reflect.ValueOf(origin)</span><br><span class="line">        fmt.Printf(&quot;only string %v\n&quot;, s.String())</span><br><span class="line">    case reflect.Int:</span><br><span class="line">        s := reflect.ValueOf(origin)</span><br><span class="line">        fmt.Printf(&quot;only int %v\n&quot;, s.Int())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestJsonArray(t *testing.T) &#123;</span><br><span class="line">    orgJsonString :=</span><br><span class="line">`&#123;&quot;enID&quot;:&quot;ID500&quot;,&quot;exID&quot;:&quot;ID501&quot;,&quot;type&quot;:2,&quot;money&quot;:27.00,&quot;distance&quot;:28322,&quot;splitInfo&quot;:[&#123;&quot;index&quot;:1,&quot;pTag&quot;:&quot;11&quot;,&quot;pMoney&quot;:700&#125;,&#123;&quot;index&quot;:2,&quot;pTag&quot;:&quot;12&quot;,&quot;pMoney&quot;:2000&#125;]&#125;`</span><br><span class="line"></span><br><span class="line">    // 解析</span><br><span class="line">    var data map[string]interface&#123;&#125;</span><br><span class="line">trueerr := json.Unmarshal([]byte(orgJsonString), &amp;data)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Println(err.Error())</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;org json:\n%#v\n\n&quot;, data);</span><br><span class="line">    showInterface(data[&quot;enID&quot;])</span><br><span class="line">    showInterface(data[&quot;splitInfo&quot;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>data[&quot;splitInfo&quot;]</code>是一个<code>interface</code>，此刻并不知道具体的内容，因此无法再获取内部的字段或长度。可以利用<code>reflect.TypeOf</code>获取类型，如是数组，需要遍历。详见代码。<br>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">org json:</span><br><span class="line">map[string]interface &#123;&#125;&#123;&quot;distance&quot;:28322, &quot;enID&quot;:&quot;ID500&quot;, &quot;exID&quot;:&quot;ID501&quot;, &quot;money&quot;:27, &quot;splitInfo&quot;:[]interface &#123;&#125;&#123;map[string]interface &#123;&#125;&#123;&quot;index&quot;:1, &quot;pMoney&quot;:700, &quot;pTag&quot;:&quot;11&quot;&#125;, map[string]interface &#123;&#125;&#123;&quot;index&quot;:2, &quot;pMoney&quot;:2000, &quot;pTag&quot;:&quot;12&quot;&#125;&#125;, &quot;type&quot;:2&#125;</span><br><span class="line"></span><br><span class="line">only string ID500</span><br><span class="line">0: map[index:1 pMoney:700 pTag:11]</span><br><span class="line">1: map[index:2 pMoney:2000 pTag:12]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接上，如果只需要获取<code>data[&quot;splitInfo&quot;]</code>的长度。注意，此处是知道该字段是数组，但不知道其内容（或不关注内容），可直接用<code>reflect.ValueOf</code>求出长度，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mylen := reflect.ValueOf(data[&quot;splitInfo&quot;]).Len()</span><br><span class="line">fmt.Println(&quot;splitInfo len: &quot;, mylen)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文汇总一些工程中使用到的和 reflect 有关的代码示例。由于是代码片段，不一定保证完整。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>“命令终端”的实现4-优化之解耦</title>
    <link href="http://www.latelee.org/my-study/my-terminal-4.html"/>
    <id>http://www.latelee.org/my-study/my-terminal-4.html</id>
    <published>2021-06-26T16:00:00.000Z</published>
    <updated>2021-10-20T16:10:49.106Z</updated>
    
    <content type="html"><![CDATA[<p>这段时间一直在做测试的工程（不是测试的工作），为了应付不同的测试场景，代码使用了解释器风格，至于实现，则使用了多年前写的命令终端代码。那会刚毕业不久，写的代码还是有提升空间。现在重新拾起，打破一般认知中的看不懂6个月前写的代码的刻板印象。</p><span id="more"></span><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><p>原来的工程使用C代码编写，并不严格区分测试代码和实现代码，其中最大的问题是将命令列表做成全局变量并依赖于外部的定义，这样耦合程序非常高。因此需要分离出来。  </p><p>原工程的文件命名也不太好，如<code>common.h</code>这样的文件，在与其它工程整合时容易冲突，此次一并修改了。</p><h2 id="命令解耦"><a href="#命令解耦" class="headerlink" title="命令解耦"></a>命令解耦</h2><p>依赖定义全局的命令列表，但只是指针，添加注册命令接口，由外部使用者调用。将默认的帮助命令调整至内部实现，外部直接使用。代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static cmd_tbl_t* cmd_table;</span><br><span class="line">static int cmd_table_len = 0;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> register command</span><br><span class="line">*/</span><br><span class="line">void register_command(cmd_tbl_t* table, int len)</span><br><span class="line">&#123;</span><br><span class="line">    cmd_table = table;</span><br><span class="line">    cmd_table_len = len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int do_help_default(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    _do_help_default(cmd_table, argc, argv);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在原有测试代码基础上，添加初始化命令函数，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/* 定义命令列表 */</span><br><span class="line">cmd_tbl_t my_cmd_table[] = </span><br><span class="line">&#123;</span><br><span class="line">    // do_help_default为默认函数，可重新实现</span><br><span class="line">    &#123;&quot;help&quot;, CONFIG_SYS_MAXARGS, do_help_default, &quot;print help info.&quot;&#125;,</span><br><span class="line">    &#123;&quot;print&quot;, 2, do_print, &quot;print the env.&quot;&#125;,</span><br><span class="line">    &#123;&quot;exit&quot;, 1, do_exit, &quot;exit...&quot;&#125;,</span><br><span class="line">    &#123;&quot;quit&quot;, 1, do_exit, &quot;exit...&quot;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 初始化，注册命令</span><br><span class="line">void cmd_init()</span><br><span class="line">&#123;</span><br><span class="line">    int len = sizeof(my_cmd_table) / sizeof(my_cmd_table[0]);</span><br><span class="line">    register_command(my_cmd_table, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，在主体函数开始处调用<code>cmd_init();</code>即可。如此一来，结构清晰，逻辑也清晰。  </p><h2 id="历史命令优化"><a href="#历史命令优化" class="headerlink" title="历史命令优化"></a>历史命令优化</h2><p>命令终端支持历史命令，由<code>HIST_MAX</code>决定数量。默认为 10 个。历史命令使用<code>hist_list</code>存储，添加命令函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cread_add_to_hist</span><span class="params">(<span class="keyword">char</span> *line)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(hist_list[hist_add_idx], line);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (++hist_add_idx &gt;= HIST_MAX)</span><br><span class="line">        hist_add_idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hist_add_idx &gt; hist_max)</span><br><span class="line">        hist_max = hist_add_idx;</span><br><span class="line"></span><br><span class="line">    hist_num++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现很简单，先添加（因为索引从0开始），再累加并与最大值比较。达到最大值后，替换存储的第0个命令。在实际执行中，有时会出现上下命令相同的情况，此时无须再次保存，以节省空间。</p><p>修改后代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cread_add_to_hist</span><span class="params">(<span class="keyword">char</span> *line)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否为相同的命令（第0条命令没有相同的说法）</span></span><br><span class="line">    <span class="keyword">if</span> (hist_add_idx &gt; <span class="number">1</span> &amp;&amp; !<span class="built_in">strcmp</span>(hist_list[hist_add_idx<span class="number">-1</span>], line)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(hist_list[hist_add_idx], line);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (++hist_add_idx &gt;= HIST_MAX)</span><br><span class="line">        hist_add_idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hist_add_idx &gt; hist_max)</span><br><span class="line">        hist_max = hist_add_idx;</span><br><span class="line"></span><br><span class="line">    hist_num++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非命令行模式"><a href="#非命令行模式" class="headerlink" title="非命令行模式"></a>非命令行模式</h2><p>截至目前，“命令终端”只有命令行模式，即执行程序初始化后，只会进入命令提示符界面，等待用户输入命令，再解析、执行。有时候，某些场景需要直接执行命令，即自动执行用户输入的命令，亦即将用户命令作为程序的参数。比如，将：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NotAShell&gt; print abc</span><br><span class="line">NotAShell&gt; print 100 200 </span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./a_all.out &quot;print abc; print 100 200;&quot;</span><br></pre></td></tr></table></figure><p>的形式，直接执行一次程序即可得到结果，不用手工输入命令。  </p><p>实现源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">// 去掉前后空格——中间的不去掉</span><br><span class="line">std::string&amp; trim(std::string &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">trueif (str.empty())</span><br><span class="line">true&#123;</span><br><span class="line">truetruereturn str;</span><br><span class="line">true&#125;</span><br><span class="line">truestr.erase(0, str.find_first_not_of(&quot; &quot;)); //去除左边空格</span><br><span class="line">truestr.erase(str.find_last_not_of(&quot; &quot;) + 1);//去除右边空格</span><br><span class="line">truereturn str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 分割string，能自动去掉分隔符前后的空格</span><br><span class="line">std::vector &lt;std::string&gt; splitString(const std::string &amp; s, const std::string &amp; delim)</span><br><span class="line">&#123;</span><br><span class="line">    std::vector &lt;std::string&gt; elems;</span><br><span class="line">    std::string tmp;</span><br><span class="line">    size_t pos = 0;</span><br><span class="line">    size_t len = s.length();</span><br><span class="line">    size_t delim_len = delim.length();</span><br><span class="line">    if (delim_len == 0)</span><br><span class="line">        return elems;</span><br><span class="line">    while (pos &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        int find_pos = s.find(delim, pos);</span><br><span class="line">        if (find_pos &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = s.substr(pos, len - pos);</span><br><span class="line">            elems.push_back(trim(tmp));</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = s.substr(pos, find_pos - pos);</span><br><span class="line">        elems.push_back(trim(tmp));</span><br><span class="line">        pos = find_pos + delim_len;</span><br><span class="line">    &#125;</span><br><span class="line">    return elems;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/////////////////////////</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">本函数功能：</span><br><span class="line">用于测试组装命令的场景。</span><br><span class="line">使用如下：</span><br><span class="line">./a_all.out &quot;print abc; print 100 200;&quot;</span><br><span class="line">即只有一个参数。为了复用已有命令终端，将参数分析还原为argc argv形式，再调用</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">int readline_cmd_allone(int argc, char ** argv)</span><br><span class="line">&#123;</span><br><span class="line">    if (argc &lt; 2) return -1;</span><br><span class="line"></span><br><span class="line">// 命令参数最大为10个</span><br><span class="line">#define MAX_ARGC 10</span><br><span class="line">    std::vector&lt;std::string&gt; v = splitString(argv[1], &quot;;&quot;);</span><br><span class="line">truecmd_tbl_t *ptable = NULL;</span><br><span class="line">    char* myargv[MAX_ARGC] = &#123;NULL&#125;;</span><br><span class="line">    int myargc = 0;</span><br><span class="line">truefor(unsigned int i=0; i&lt;v.size(); i++)</span><br><span class="line">true&#123;</span><br><span class="line">        // printf(&quot;split: [%s] %d\n&quot;, v[i].c_str(), v[i].empty());</span><br><span class="line">truetrueif(v[i].empty())</span><br><span class="line">truetrue&#123;</span><br><span class="line">truetruetruecontinue;</span><br><span class="line">truetrue&#125;</span><br><span class="line">        char cmd[128];</span><br><span class="line">truetruememcpy(cmd, v[i].c_str(), 128);</span><br><span class="line"></span><br><span class="line">truetrue// 是否再转成argv的形式？？</span><br><span class="line">truetrue</span><br><span class="line">        std::vector&lt;std::string&gt; vv = splitString(cmd, &quot; &quot;);</span><br><span class="line">        myargc = (int)vv.size();</span><br><span class="line">        myargc = myargc &gt; MAX_ARGC ? MAX_ARGC : myargc;</span><br><span class="line">        for (int j = 0; j &lt; myargc; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            myargv[j] = (char*)vv[j].c_str();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // for (int j = 0; j &lt; myargc; j++)</span><br><span class="line">        // &#123;</span><br><span class="line">        //     printf(&quot;myargv[%d]: %s\n&quot;, j, myargv[j]);</span><br><span class="line">        // &#125;</span><br><span class="line"></span><br><span class="line">        ptable = find_table(myargv[0]);</span><br><span class="line">truetrueif (ptable == NULL)</span><br><span class="line">truetrue&#123;</span><br><span class="line">truetruetrueprintf(&quot;cmd name: [%s] not found\n&quot;, myargv[0]);</span><br><span class="line">truetruetruecontinue;</span><br><span class="line">truetrue&#125;</span><br><span class="line">truetrueprintf(&quot;name: %s\n&quot;, ptable-&gt;name);</span><br><span class="line"></span><br><span class="line">truetrueptable-&gt;cmd(myargc, myargv);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数变更如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    char* p;</span><br><span class="line">truechar* cmdname = *argv;</span><br><span class="line">    if ((p = strrchr (cmdname, &#x27;/&#x27;)) != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">truetruecmdname = p + 1;</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">trueif (strcmp(cmdname, &quot;a.out&quot;) == 0)</span><br><span class="line">    &#123;</span><br><span class="line">truetrueif (readline_cmd(argc, argv) != 0)</span><br><span class="line">truetruetruereturn -1;</span><br><span class="line"></span><br><span class="line">truetruereturn 0;</span><br><span class="line">true&#125;</span><br><span class="line">    else if (strcmp(cmdname, &quot;a_all.out&quot;) == 0)</span><br><span class="line">    &#123;</span><br><span class="line">truetrueif (readline_cmd_allone(argc, argv) != 0)</span><br><span class="line">truetruetruereturn -1;</span><br><span class="line"></span><br><span class="line">truetruereturn 0;</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码以<code>a.out</code>和<code>a_all.out</code>为执行文件名称作为示例。不管哪种形式，都可以直接复用已有的模块。笔者实际使用的场景，是一个用于自测的程序，有时，需要手动修改参数进行测试，有时需要将程序放到后台执行（因为耗时较长）。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这段时间一直在做测试的工程（不是测试的工作），为了应付不同的测试场景，代码使用了解释器风格，至于实现，则使用了多年前写的命令终端代码。那会刚毕业不久，写的代码还是有提升空间。现在重新拾起，打破一般认知中的看不懂6个月前写的代码的刻板印象。&lt;/p&gt;</summary>
    
    
    
    <category term="技术杂铺" scheme="http://www.latelee.org/category/my-study/"/>
    
    
  </entry>
  
  <entry>
    <title>Golang实践录：工程框架实践：汇总</title>
    <link href="http://www.latelee.org/golang/golang-notes-cmdtool0.html"/>
    <id>http://www.latelee.org/golang/golang-notes-cmdtool0.html</id>
    <published>2021-06-06T16:01:00.000Z</published>
    <updated>2021-10-20T16:10:49.022Z</updated>
    
    <content type="html"><![CDATA[<p>面</p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;面&lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>李迟2021年5月知识总结</title>
    <link href="http://www.latelee.org/my-library/code-for-2021-05.html"/>
    <id>http://www.latelee.org/my-library/code-for-2021-05.html</id>
    <published>2021-05-29T16:00:00.000Z</published>
    <updated>2021-10-20T16:10:49.098Z</updated>
    
    <content type="html"><![CDATA[<p>本文为 2021 年 5 月知识总结。</p><span id="more"></span><h2 id="编码总结"><a href="#编码总结" class="headerlink" title="编码总结"></a>编码总结</h2><h3 id="web静态服务器"><a href="#web静态服务器" class="headerlink" title="web静态服务器"></a>web静态服务器</h3><p>测试前端时，可直接在浏览器中进行调试，当需要有数据交互时，可搭建简单后台服务，golang 语言创建 web 服务，并指定 Directory目录：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router := gin.New()</span><br><span class="line">router.StaticFS(<span class="string">&quot;/&quot;</span>, http.Dir(conf.Directory))</span><br><span class="line">router.Run(<span class="string">&quot;:&quot;</span> + conf.Port)</span><br></pre></td></tr></table></figure><p>由 golang 实现的简单的 web 服务镜像为<code>latelee/webdemo</code>，根目录为<code>/dist</code>，为<code>80</code>。</p><p>NodeJS 语言创建 web 服务并指定 staticPath 目录：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line">app.use(koastatic(path.join( __dirname, staticPath)));</span><br><span class="line">app.use(router.g_router.routes());</span><br><span class="line">g_webServer = app.listen(&#123;</span><br><span class="line">        <span class="attr">host</span>:SVR_HOST,</span><br><span class="line">        <span class="attr">port</span>:SVR_PORT,</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h2 id="前端后台一点笔记"><a href="#前端后台一点笔记" class="headerlink" title="前端后台一点笔记"></a>前端后台一点笔记</h2><p>html文件，或由渲染工具（ hexo、vuepress 等）渲染得到的 html 文件，需托管于 web 服务器，如 apache、nginx 或 tomcat 这些现成服务器，不同服务器，其根目录不同，体积亦不同。上面实现的也是 web 服务器，但体积会小很多，并且可以直接和后台服务融合。当然，对于模块分工明确的场景，前端页面和后台服务必须位于不同服务器/地区，则另当别论。    </p><h3 id="编码其它"><a href="#编码其它" class="headerlink" title="编码其它"></a>编码其它</h3><p>继续总结 Makefile 知识：<br>上月仅实践了过滤指定文件的做法。本月研究过滤目录的做法，方法较简单，在 find 中直接用<code>grep -v</code>过滤不需要的目录即可。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SRC_DIRS = .</span><br><span class="line">SRCS := $(shell find $(SRC_DIRS) -maxdepth 2 -name &#x27;*.cpp&#x27; -or -name &#x27;*.c&#x27; | grep -v dir_notneed)</span><br></pre></td></tr></table></figure><p>由于考虑到通用性，之前的 Makefile 均直接使用 find 查看源码的方法，因此，会编译指定目录所有源文件。当然也可手动指定源文件方法，略显麻烦而已。<br>如果先查找目录，再查找源文件，由于<code>find</code>找到的目录包含<code>SRC_DIRS</code>自身，再用<code>find</code>找到，还是会找到过滤目录的文件，目前未想到好办法。  </p><p>又看了一些编码规则（其实是 vue），加之接手了几个祖传代码（保留着大量2015年写的不再使用的函数），对其中提到的点比较认同。比如命名，代码首先给自己看，其次用于团队交流（有的项目始终是一个人维护）。 要点：<br>考虑视觉效果，如大写，固定前缀，空行，注释位置，等。<br>避免不常用缩写，缩写团队内达成一致。如返回值，有的写<code>ret</code>，有的写<code>res</code>。  </p><p>扩展：在软件使用上减少用户认知成本，小的范围，如编码，大家统一一套代码方式。大的范围，如一些对话框的关闭按钮位置，有的左上角，有的右上角；如“确定”、“取消”位置也不固定。不过环境太大，无法统一。  </p><p><strong>大道至简，用简单的方法实现功能/需求，才是最好的方法。</strong> 一些奇技淫巧， 如未必要，除自娱自乐外，有人欣赏，也是不错的，但知音难觅。</p><h2 id="一般知识"><a href="#一般知识" class="headerlink" title="一般知识"></a>一般知识</h2><h2 id="研发思考"><a href="#研发思考" class="headerlink" title="研发思考"></a>研发思考</h2><p>最近看了一些面向对象设计原则，单一职责原则、开闭原则，等。一般举例时，以画图（三角形、圆形）为主。 实际中，并不是如此单纯，对于当前项目。  </p><p>代码模式、设计模式，架构模式。</p><p>业务入侵：有时为了方便调试，或出于某此特殊目的，会将一些特殊值（魔数）赋值某些变量或参数，可能会影响生产环境。比如将ID设置为一个不存在的值，但万一后面会出现在正常业务中，会出问题。  扩展：有些设计时需要考虑后续发展计划，有时又不需要过度设计，这个度不好把握，只能靠经验。实例：比如某省的收费站代号，使用3位数字表示，则最大只能有999个，万一超过，可添加代号位数解决，但如果涉及到根本机制问题，牵一发而动全身，风险大大添加。</p><h2 id="本月学习及计划"><a href="#本月学习及计划" class="headerlink" title="本月学习及计划"></a>本月学习及计划</h2><p>看了一些前端、后台、微服务架构、UML的概念和知识，后续要继续看。</p><p>使用 vuepress 构建了 一个静态网站，已部署内部服务器。  </p><p>兜兜转转，从手写到 bootstrap，到一些框架，到 vue，最后还是决定上 vue，拥抱主流，多学一些，保持大脑正常运转。  </p><h2 id="其它点滴"><a href="#其它点滴" class="headerlink" title="其它点滴"></a>其它点滴</h2><p>熬夜比上月多了一些，一是有很多未接触的东西要学，二是要继续熟悉业务和代码，三是白天晚上时间被其它事占用了。每天感觉刚躺床上又起来了。有时候大锤闹着要我陪睡，则会偷懒多睡一点，但更多是他独立睡。  </p><p>很多个深夜，站在阳台，望着天空，听着对面楼的麻将声和外面的汽车声，我在想，该怎么做才能平衡儿子、丈夫、父亲的角色。我的角色里面需不需要有自己？但我的兴趣爱好，在那些角色面前根本占不了位置。一切的根源其实就是钱，学技术，对工作上心也是为了钱，钱多不多我控制不了，自己勤奋不勤奋，这点能控制。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文为 2021 年 5 月知识总结。&lt;/p&gt;</summary>
    
    
    
    <category term="我的程序代码" scheme="http://www.latelee.org/category/my-library/"/>
    
    
    <category term="代码积累" scheme="http://www.latelee.org/tag/%E4%BB%A3%E7%A0%81%E7%A7%AF%E7%B4%AF/"/>
    
    <category term="知识总结" scheme="http://www.latelee.org/tag/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>我的docker随笔32：sftp服务部署</title>
    <link href="http://www.latelee.org/docker/docker-32-deploy-sftp-server.html"/>
    <id>http://www.latelee.org/docker/docker-32-deploy-sftp-server.html</id>
    <published>2021-05-09T16:00:00.000Z</published>
    <updated>2021-10-20T16:10:49.166Z</updated>
    
    <content type="html"><![CDATA[<p>本文涉及一种在容器中部署 sftp 服务的方法。经验证，可达到预期目标，并能应用在实际工作中。    </p><span id="more"></span><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>因工作需要，需部署 sftp 服务器进行数据测试。</p><h2 id="二、技术小结"><a href="#二、技术小结" class="headerlink" title="二、技术小结"></a>二、技术小结</h2><ul><li><p>dockerhub 上相关镜像，直接拉取可用。  </p></li><li><p>运行时需要注意用户名和<code>home</code>目录，如使用<code>foo</code>用户，则需要挂载到<code>/home/foo</code>目录。  </p></li><li><p>需要手动设置ssh key，否则每次重启都会产生新的key。</p></li><li><p>上传权限问题暂未解决。  </p></li></ul><h2 id="三、实践"><a href="#三、实践" class="headerlink" title="三、实践"></a>三、实践</h2><h3 id="3-1-下载"><a href="#3-1-下载" class="headerlink" title="3.1 下载"></a>3.1 下载</h3><p>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull atmoz/sftp</span><br></pre></td></tr></table></figure><p>测试运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">    -v /tmp/upload:/home/foo/upload \</span><br><span class="line">    --name sftp \</span><br><span class="line">    -p 2222:22 -itd atmoz/sftp \</span><br><span class="line">    foo:pass:1000</span><br></pre></td></tr></table></figure><p>注：挂载 <code>tmp/upload</code>到容器<code>home</code>的同名目录下，账号密码分别为<code>foo</code>、<code>pass</code>，<code>UID</code>与执行此命令的主机用户一样，即<code>1000</code>（可通过<code>/etc/passwd</code>文件查看知）。</p><p>测试连接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sftp -P 2222 foo@localhost</span><br><span class="line">foo@localhost&#x27;s password: </span><br><span class="line">Connected to localhost.</span><br><span class="line"><span class="meta">sftp&gt;</span><span class="bash"> ls</span></span><br><span class="line">upload  </span><br><span class="line"><span class="meta">sftp&gt;</span><span class="bash"> <span class="built_in">cd</span> upload/</span></span><br><span class="line"><span class="meta">sftp&gt;</span><span class="bash"> put webdemo</span></span><br><span class="line">Uploading webdemo to /upload/webdemo</span><br><span class="line">remote open(&quot;/upload/webdemo&quot;): Permission denied</span><br></pre></td></tr></table></figure><p>提示权限不足，在容器中修改 upload 目录权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -it sftp bash</span><br><span class="line">root@35f5c9abeb71:/# cd home/</span><br><span class="line">root@35f5c9abeb71:/home/foo# ls -lh</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x. 2 root root 6 May 10 07:05 upload</span><br><span class="line">root@35f5c9abeb71:/home/foo# chmod 777 upload/ -R</span><br><span class="line">root@35f5c9abeb71:/home/foo# ls -lh</span><br><span class="line">total 0</span><br><span class="line">drwxrwxrwx. 2 root root 21 May 10 07:27 upload</span><br></pre></td></tr></table></figure><p>则可以正常上传</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sftp&gt; put webdemo</span><br><span class="line">Uploading webdemo to /upload/webdemo</span><br><span class="line">webdemo                                       100% 6706KB  53.1MB/s   00:00  </span><br><span class="line">sftp&gt; exit</span><br></pre></td></tr></table></figure><h2 id="四、sftp常用命令"><a href="#四、sftp常用命令" class="headerlink" title="四、sftp常用命令"></a>四、sftp常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">登陆：</span><br><span class="line">sftp -P &lt;端口&gt; &lt;用户名&gt;@&lt;IP&gt;</span><br><span class="line"></span><br><span class="line">?：查看帮助</span><br><span class="line">quit：退出</span><br><span class="line">cd lcd：进入某目录 （注：有l前缀表示是宿主机）</span><br><span class="line">ls lls：查看目录</span><br><span class="line">pwd lpwd：查看当前路径</span><br><span class="line">mdir ：创建目录</span><br><span class="line">put：上传文件（目录：-r）</span><br><span class="line">get：下载文件</span><br></pre></td></tr></table></figure><h2 id="五、指定ssh-key"><a href="#五、指定ssh-key" class="headerlink" title="五、指定ssh key"></a>五、指定ssh key</h2><p>默认情况下，每次重新服务，都会产生新的key，需要用户确认（见附录）。可以手动指定key，解决该问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir ssh</span><br><span class="line">cd ssh</span><br><span class="line">ssh-keygen -t ed25519 -f ssh_host_ed25519_key &lt; /dev/null</span><br><span class="line">ssh-keygen -t rsa -b 4096 -f ssh_host_rsa_key &lt; /dev/null</span><br></pre></td></tr></table></figure><p>在运行添加如下参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-v &lt;host-dir&gt;/ssh_host_ed25519_key:/etc/ssh/ssh_host_ed25519_key \</span><br><span class="line">-v &lt;host-dir&gt;/ssh_host_rsa_key:/etc/ssh/ssh_host_rsa_key \</span><br></pre></td></tr></table></figure><h2 id="六、docker-compose部署"><a href="#六、docker-compose部署" class="headerlink" title="六、docker-compose部署"></a>六、docker-compose部署</h2><p>对应的<code>yaml</code>文件如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">sftp:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">atmoz/sftp</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">sftp</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./upload:/home/aftp/</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./ssh/ssh_host_ed25519_key:/etc/ssh/ssh_host_ed25519_key</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./ssh/ssh_host_rsa_key:/etc/ssh/ssh_host_rsa_key</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;2222:22&quot;</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">aftp:passworld:1000</span></span><br></pre></td></tr></table></figure><p>注：本例中将当前目录的<code>upload</code>目录直接挂载到用户的<code>home</code>目录，不似上述在<code>upload</code>目录。这样客户端连接后的根目录就是宿主机的<code>upload</code>目录，较方便。</p><h2 id="七、参考"><a href="#七、参考" class="headerlink" title="七、参考"></a>七、参考</h2><p>sftp 镜像：<a href="https://hub.docker.com/r/atmoz/sftp">https://hub.docker.com/r/atmoz/sftp</a>  </p><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>网上有文章在运行容器命令时添加<code>--privileged=true</code>参数。  </p><p>首次运行时，用<code>sftp</code>命令连接时，需要确认，提示如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &#x27;[localhost]:2222 ([::1]:2222)&#x27; can&#x27;t be established.</span><br><span class="line">ED25526 key fingerprint is SHA256:FUCkkcufctB3fasdf45sszVCaqRQTY7+Qasjw235A+XwCg.</span><br><span class="line">ED25526 key fingerprint is MD5:17:fu:ck:3d:bb:aa:00:35:79:ac:bc:cc:dc:ec:71:bb.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br><span class="line">Warning: Permanently added &#x27;[localhost]:2222&#x27; (ED25526) to the list of known hosts.</span><br></pre></td></tr></table></figure><p>如果重新启动（这样也算是首次运行），则会提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span><br><span class="line">Someone could be eavesdropping on you right now (man-in-the-middle attack)!</span><br><span class="line">It is also possible that a host key has just been changed.</span><br><span class="line">The fingerprint for the ED25519 key sent by the remote host is</span><br><span class="line">SHA256:FTKtctB6yBQasdfasdfasdf3fasdf7+QSBTLyyasdfasdfasdfCg.</span><br><span class="line">Please contact your system administrator.</span><br><span class="line">Add correct host key in /home/lateee/.ssh/known_hosts to get rid of this message.</span><br><span class="line">Offending ED25526 key in /home/lateee/.ssh/known_hosts:4</span><br></pre></td></tr></table></figure><p>此时，需要编辑<code>/home/lateee/.ssh/known_hosts</code>文件，删除对应的那一行信息（本文中，会带有 2222 字样）。  </p><p>疑问：如果使用程序连接，首次出现上述提示，如何输入<code>yes</code>？待研究。  </p><p>在一次用 docker-compose 运行时，客户端连接出现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sftp -P2222 foo@127.0.0.1</span></span><br><span class="line">Connection closed by 127.0.0.1 port 2222</span><br><span class="line">Couldn&#x27;t read packet: Connection reset by peer</span><br></pre></td></tr></table></figure><p>经查，是因为 sftp 服务器目录在 Windows 系统，改为 Linux 系统，问题解决。（为减少虚拟机空间占用，并方便调试，笔者习惯使用虚拟机的共享目录，在 Linux 中操作 Windows 硬盘。）</p><p>某天运行时，提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose up</span></span><br><span class="line">Creating network &quot;sftp_default&quot; with the default driver</span><br><span class="line">Creating sftp ... done</span><br><span class="line">Attaching to sftp</span><br><span class="line">sftp    | [/usr/local/bin/create-sftp-user] Parsing user data: &quot;aftp:passworld:1000&quot;</span><br><span class="line">sftp    | [/entrypoint] Executing sshd</span><br><span class="line">sftp    | /run/sshd must be owned by root and not group or world-writable.</span><br><span class="line">sftp exited with code 255</span><br></pre></td></tr></table></figure><p>之前工作正常。原因未明。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文涉及一种在容器中部署 sftp 服务的方法。经验证，可达到预期目标，并能应用在实际工作中。    &lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="http://www.latelee.org/category/docker/"/>
    
    
    <category term="docker" scheme="http://www.latelee.org/tag/docker/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：静态资源文件整合：web服务</title>
    <link href="http://www.latelee.org/golang/golang-notes-combine-static-file-1.html"/>
    <id>http://www.latelee.org/golang/golang-notes-combine-static-file-1.html</id>
    <published>2021-05-04T16:01:00.000Z</published>
    <updated>2021-10-20T16:10:49.022Z</updated>
    
    <content type="html"><![CDATA[<p>趁着五一放假，趁着有时间，把欠的一些技术集中研究研究，写写文章，好给自己一个交待。<br>本文研究静态资源文件的在 web 服务器的整合。  </p><span id="more"></span><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>Golang 中的 web 服务框架有很多种，本文选取 gin 实现。gin 实现一个 web 服务仅需几行代码，十分方便。但为了适应更复杂的项目，还需要进行一些改进。<br>web 服务页面的文件，除了 html 外，还有 css、js、图片等文件，为方便管理，将后者放到 static 目录——与前面文章目录保持一致，将前者放到 templates 目录，使用 gin 的 html 模板进行渲染，而且 gin 也支持自定义模板文件，恰好能适合我们的场景。  </p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h3><p>本文使用到的资源文件如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ tree static/</span><br><span class="line">static/</span><br><span class="line">|-- css</span><br><span class="line">|   |-- bootstrap.min.css</span><br><span class="line">|   |-- font-awesome.min.css</span><br><span class="line">|   `-- main.css</span><br><span class="line">|-- favicon.ico</span><br><span class="line">`-- js</span><br><span class="line">    |-- bootstrap.min.js</span><br><span class="line">    |-- jquery-1.8.3.min.js</span><br><span class="line">    |-- jquery-2.0.0.min.js</span><br><span class="line">    `-- main.js</span><br><span class="line"></span><br><span class="line">2 directories, 8 files</span><br><span class="line"></span><br><span class="line">$ tree templates/</span><br><span class="line">templates/</span><br><span class="line">|-- about.html</span><br><span class="line">|-- about.js</span><br><span class="line">|-- index.html</span><br><span class="line">|-- login.html</span><br><span class="line">|-- login.js</span><br><span class="line">`-- nav.js</span><br><span class="line"></span><br><span class="line">0 directories, 6 files</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="通用方式"><a href="#通用方式" class="headerlink" title="通用方式"></a>通用方式</h3><p>为方便对比，先给出通用的 gin 框架，主要代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 直接引用文件形式</span><br><span class="line">func webServerFile() &#123;</span><br><span class="line">    fmt.Println(&quot;gin test...&quot;)</span><br><span class="line">truerouter := gin.Default()</span><br><span class="line">    </span><br><span class="line">    // 似乎这样做，templates下只能有文件，不能有目录</span><br><span class="line">    router.LoadHTMLGlob(&quot;templates/*&quot;)</span><br><span class="line">    </span><br><span class="line">    // 将真实目录做不同前缀，方便引用css js等文件</span><br><span class="line">    // 有些自实现的用html文件或js文件，用html前缀。</span><br><span class="line">    router.StaticFS(&quot;/js&quot;, http.Dir(&quot;static/js&quot;))</span><br><span class="line">    router.StaticFS(&quot;/css&quot;, http.Dir(&quot;static/css&quot;))</span><br><span class="line">    router.StaticFS(&quot;/html&quot;, http.Dir(&quot;templates&quot;))</span><br><span class="line"></span><br><span class="line">    router.GET(&quot;/&quot;, HandleIndex)</span><br><span class="line">    router.GET(&quot;/index&quot;, HandleIndex)</span><br><span class="line">    router.GET(&quot;/about&quot;, HandleAbout)</span><br><span class="line">    router.GET(&quot;/login&quot;, HandleLogin)</span><br><span class="line">    </span><br><span class="line">truerouter.Run(&quot;:8081&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 LoadHTMLGlob 用于加载 html 模板文件，StaticFS 指定静态资源，有两个参数，第一个指定前缀名称（即在 html 或 js 文件中引用时使用的路径，第二个指定真实路径（相对于 web 程序所在目录）。GET 函数用于响应对应的页面，由于响应函数非本文重点，故简单列举如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func HandleIndex(ctx *gin.Context) &#123;</span><br><span class="line">    file := path.Join(gPrefix, &quot;index.html&quot;)</span><br><span class="line">    ctx.HTML(http.StatusOK, file, gin.H&#123;</span><br><span class="line">truetrue&quot;title&quot;:  &quot;Main website&quot;,</span><br><span class="line">true&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：gPrefix 将在下文提及。  </p><h3 id="整合方式"><a href="#整合方式" class="headerlink" title="整合方式"></a>整合方式</h3><p>使用 bindata 方式，与上面示例没有本质区别，只是需要手动设置模板加载规则，指定静态资源文件方式也不同。主要代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 整合文件形式</span><br><span class="line">func webServerBindata() &#123;</span><br><span class="line">    fmt.Println(&quot;gin test.....&quot;)</span><br><span class="line">truerouter := gin.Default()</span><br><span class="line">truet, err := loadTemplate()</span><br><span class="line">trueif err != nil &#123;</span><br><span class="line">truetruepanic(err)</span><br><span class="line">true&#125;</span><br><span class="line">truerouter.SetHTMLTemplate(t)</span><br><span class="line"></span><br><span class="line">    // 下面指定的是静态资源文件，与响应get/post的地址无关系</span><br><span class="line">    fsjs := assetfs.AssetFS&#123;</span><br><span class="line">        Asset:     bindata.Asset,</span><br><span class="line">        AssetDir:  bindata.AssetDir,</span><br><span class="line">        AssetInfo: bindata.AssetInfo,</span><br><span class="line">        Prefix:   &quot;static/js&quot;,</span><br><span class="line">        Fallback: &quot;index.html&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">    router.StaticFS(&quot;/js&quot;, &amp;fsjs)</span><br><span class="line">    </span><br><span class="line">    fscss := assetfs.AssetFS&#123;</span><br><span class="line">        Asset: bindata.Asset, AssetDir: bindata.AssetDir, AssetInfo: bindata.AssetInfo, </span><br><span class="line">        Prefix:   &quot;static/css&quot;,</span><br><span class="line">        Fallback: &quot;index.html&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">    router.StaticFS(&quot;/css&quot;, &amp;fscss)</span><br><span class="line">    </span><br><span class="line">    fshtml := assetfs.AssetFS&#123;</span><br><span class="line">        Asset: bindata.Asset, AssetDir: bindata.AssetDir, AssetInfo: bindata.AssetInfo, </span><br><span class="line">        Prefix:   &quot;templates&quot;,</span><br><span class="line">        Fallback: &quot;index.html&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">    router.StaticFS(&quot;/html&quot;, &amp;fshtml)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    router.StaticFS(&quot;/favicon.ico&quot;, &amp;fshtml)</span><br><span class="line">    </span><br><span class="line">    // 人为添加前缀，因为前面loadTemplate加载的html路径包含有路径前缀，因此加上</span><br><span class="line">    // 如果手动删除，则此处不需要前缀</span><br><span class="line">    //gPrefix = &quot;templates&quot;</span><br><span class="line"></span><br><span class="line">    router.GET(&quot;/&quot;, HandleIndex)</span><br><span class="line">    router.GET(&quot;/index&quot;, HandleIndex)</span><br><span class="line">    router.GET(&quot;/about&quot;, HandleAbout)</span><br><span class="line">    router.GET(&quot;/login&quot;, HandleLogin)</span><br><span class="line"></span><br><span class="line">truerouter.Run(&quot;:8081&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义模板加载函数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func loadTemplate() (*template.Template, error) &#123;</span><br><span class="line">    fmt.Println(&quot;load my template&quot;)</span><br><span class="line">truet := template.New(&quot;&quot;)</span><br><span class="line">    filenames := bindata.AssetNames()</span><br><span class="line">    for _, name := range  filenames &#123;</span><br><span class="line">        if !strings.HasSuffix(name, &quot;.tmpl&quot;) &amp;&amp; !strings.HasSuffix(name, &quot;.html&quot;) &amp;&amp; </span><br><span class="line">           !strings.HasSuffix(name, &quot;.css&quot;) &amp;&amp; !strings.HasSuffix(name, &quot;.js&quot;) &amp;&amp; </span><br><span class="line">           !strings.HasSuffix(name, &quot;.ico&quot;) &#123;</span><br><span class="line">truetruetruecontinue</span><br><span class="line">truetrue&#125;</span><br><span class="line">        //fmt.Println(&quot;got html file: &quot;, name)</span><br><span class="line">        content, err := bindata.Asset(name)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            return nil, err</span><br><span class="line">        &#125;</span><br><span class="line">        t, err = t.New(name).Parse(string(content))</span><br><span class="line">truetrueif err != nil &#123;</span><br><span class="line">truetruetruereturn nil, err</span><br><span class="line">truetrue&#125;</span><br><span class="line">true&#125;</span><br><span class="line">truereturn t, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在生成 bindata.go 时，指定了2处目录，而<code>-prefix</code>选项只能指定一个前缀，于是干脆不加该参数，因此，生成的代码中，前缀也会出现对应的目录，正因为这样，代码才使用了<code>gPrefix = &quot;templates&quot;</code>手动指定前缀。后来手动删除生成代码的前缀，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;s/templates\///g&#x27; bindata/bindata.go</span><br><span class="line">sed -i &#x27;s/static\///g&#x27; bindata/bindata.go</span><br></pre></td></tr></table></figure><p>两者关键代码对比如下图所示（注：左侧为未删除前缀的代码）。<br><img src="/golang/golang-notes-combine-static-file-1/01.png"></p><p>笔者阅读 go-bindata-assetfs 代码尝试添加参数达到目的，未果。  </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://jaycechant.info/2020/go-bindata-golang-static-resources-embedding/">https://jaycechant.info/2020/go-bindata-golang-static-resources-embedding/</a><br><a href="http://blog.hotsun168.com/index.php/archives/18/">http://blog.hotsun168.com/index.php/archives/18/</a><br>1.16 版本新方法：<br><a href="https://www.flysnow.org/2021/02/28/golang-embed-for-web.html">https://www.flysnow.org/2021/02/28/golang-embed-for-web.html</a>  </p><p>2021.5.5 凌晨</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;趁着五一放假，趁着有时间，把欠的一些技术集中研究研究，写写文章，好给自己一个交待。&lt;br&gt;本文研究静态资源文件的在 web 服务器的整合。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：静态资源文件整合：初步使用</title>
    <link href="http://www.latelee.org/golang/golang-notes-combine-static-file-0.html"/>
    <id>http://www.latelee.org/golang/golang-notes-combine-static-file-0.html</id>
    <published>2021-05-04T16:00:00.000Z</published>
    <updated>2021-10-20T16:10:49.022Z</updated>
    
    <content type="html"><![CDATA[<p>趁着五一放假，趁着有时间，把欠的一些技术集中研究研究，写写文章，好给自己一个交待。<br>本文介绍如何在 Golang 中整合静态资源文件，将静态资源文件编译到二进制可执行文件中，这与其它程序的打包可能是一个概念，也可能不是，后续有空研究再补充。  </p><span id="more"></span><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>大概10年前，即2011年，也研究一下这方面的内容，主要针对 C 语言，使用 ARM 板子测试。 那篇文章如下图： </p><p><img src="/golang/golang-notes-combine-static-file-0/1.png"></p><p>当时对技术的兴趣比较浓厚，没想过房子车子的事，现在经常想房子车子，但也被迫对技术感兴趣。因此，使用 Golang 语言重新研究一下。  </p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>经查，有2个类似的工具：go-bindata 和 go-bindata-assetfs。两者可以将文件转换成 golang 语言代码，后者似乎依赖于前者，本着使用的目的，暂未研究细节，看了一下生成的 golang 代码，有对外提供的接口，有文件映射表，有真正存储文件的字节流。  </p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>使用<code>go get</code>命令安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/go-bindata/go-bindata/...</span><br><span class="line">go get -u github.com/elazarl/go-bindata-assetfs/...</span><br></pre></td></tr></table></figure><p>输入对应的命令验证：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go-bindata</span><br><span class="line">go-bindata-assetfs</span><br></pre></td></tr></table></figure><h3 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h3><p>为适合项目目录，本文约定使用 static 目录存放静态资源文件——即需要打包到可执行程序中的文件，生成的代码，存放到 bindata 目录，且其包名亦为 bindata。经研究发现似乎 go-bindata-assetfs 更好一些，因此本文使用该工具，生成命令如下：    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go-bindata-assetfs -o=bindata/bindata.go -pkg=bindata -ignore=&quot;README.md&quot; -prefix=static static/... </span><br></pre></td></tr></table></figure><p><code>-o</code>指定了输出文件，<code>-pkg</code>指定包名（一般与前者保持一致），<code>-ignore</code>指定需忽略的文件，<code>-prefix</code>指定文件路径前缀（本例中，指定了前缀，不需在代码中使用<code>static</code>前缀）。如果不需要如此复杂，可将其生成的文件与包 main 在同一目录，包名亦为 main，可用于简单测试：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go-bindata-assetfs -o=bindata.go -ignore=&quot;README.md&quot; -prefix=static static/...</span><br></pre></td></tr></table></figure><p>为了调试方便——即不需要每次更新文件都要重新编译代码，则可以添加<code>-debug</code>参数，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go-bindata-assetfs -debug -o=bindata.go -ignore=&quot;README.md&quot; -prefix=static static/...</span><br></pre></td></tr></table></figure><p>添加<code>-debug</code>选项后，当修改了原资源文件后，重新运行程序，获取的内容会发生变化，不需要重新生成，方便调试。内部实现原理：在调用 bindataRead 读取文件时，添加文件的绝对路径。如果是非 debug 版本，则不加路径。    </p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>资源文件目录 static 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ tree static/</span><br><span class="line">static/</span><br><span class="line">|-- conf</span><br><span class="line">|   `-- config.toml</span><br><span class="line">|-- html</span><br><span class="line">|   `-- foo.html</span><br><span class="line">`-- libfoo.so</span><br><span class="line"></span><br><span class="line">2 directories, 3 files</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要使用的接口如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 获取所有的文件名称</span><br><span class="line">filenames := bindata.AssetNames()</span><br><span class="line"></span><br><span class="line">// 读取某一文件的内容</span><br><span class="line">filename = &quot;html/foo.html&quot;</span><br><span class="line">content, err = bindata.Asset(filename)</span><br></pre></td></tr></table></figure><p>指定的文件，以<code>static</code>为根目录，其形式与一般的路径无差异。  </p><p>完整测试代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;strings&quot;</span><br><span class="line">    &quot;io/ioutil&quot;</span><br><span class="line">    </span><br><span class="line">    &quot;bindata_test2/bindata&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(&quot;bindata test..&quot;);</span><br><span class="line">    </span><br><span class="line">    // 遍历所有文件，打印文件名，并输出html的内容</span><br><span class="line">    filenames := bindata.AssetNames()</span><br><span class="line">    for _, item := range  filenames &#123;</span><br><span class="line">        fmt.Println(&quot;got file: &quot;, item)</span><br><span class="line"></span><br><span class="line">        if !strings.HasSuffix(item, &quot;.tmpl&quot;) &amp;&amp; !strings.HasSuffix(item, &quot;.html&quot;) &#123;</span><br><span class="line">truetruetruecontinue</span><br><span class="line">truetrue&#125;</span><br><span class="line">        </span><br><span class="line">        content, err := bindata.Asset(item)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            fmt.Printf(&quot;not found file %s: %s\n&quot;, item, err.Error())</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(string(content))</span><br><span class="line">        fmt.Println(&quot;-----------------------------------\n&quot;)</span><br><span class="line">        </span><br><span class="line">true&#125;</span><br><span class="line">    </span><br><span class="line">    // 单独测试</span><br><span class="line">    filename := &quot;assets/foo.html&quot;</span><br><span class="line">    content, err := bindata.Asset(filename)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Printf(&quot;not found file %s: %s\n&quot;, filename, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    filename = &quot;foo.html&quot;</span><br><span class="line">    content, err = bindata.Asset(filename)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Printf(&quot;not found file %s: %s\n&quot;, filename, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    filename = &quot;html/foo.html&quot;</span><br><span class="line">    content, err = bindata.Asset(filename)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Printf(&quot;not found file %s: %s\n&quot;, filename, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    // content 为二进制buf，怎么用？</span><br><span class="line">    </span><br><span class="line">    filename = &quot;conf/config.toml&quot;</span><br><span class="line">    content, err = bindata.Asset(filename)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Printf(&quot;not found file %s: %s\n&quot;, filename, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(string(content))</span><br><span class="line">    </span><br><span class="line">    // 读取so并保存</span><br><span class="line">    filename = &quot;libfoo.so&quot;</span><br><span class="line">    content, err = bindata.Asset(filename)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Printf(&quot;not found file %s: %s\n&quot;, filename, err.Error())</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //filename = &quot;libfoo.so&quot;</span><br><span class="line">    err = ioutil.WriteFile(filename, content, 0755)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Println(&quot;write file error: &quot;, err)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;write file %s ok\n&quot;, filename)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 libfoo.so 文件为例，原文件和保存的文件对比如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ md5sum.exe static/libfoo.so libfoo.so</span><br><span class="line">9416ab261b2867d9acbb563690116885 *static/libfoo.so</span><br><span class="line">9416ab261b2867d9acbb563690116885 *libfoo.so</span><br></pre></td></tr></table></figure><p>两者内容是相同的。  </p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>本文所述方法，有一定范围内可以使用，对于大型项目或多人协作项目，不建议使用。<br>针对该方法，笔者认为可以进行的事有：<br>1、将 web 服务有关的 css、js、html 等整合到可执行二进制文件中，方便部署。在笔者即将实现的 web 服务中，由于功能唯一，又是内部使用，且还只是由笔者个人实现，因此对技术栈拥有完全自主的决定权，通俗地讲，同事和上头不管技术细节，能实现功能即可，为了方便自己，故如此设计。<br>2、动态库整合，如果涉及动态库文件的使用，则可以将动态库打包到可执行文件，在运行时读取并保存到指定目录，再加载。此法将二者绑定一起，无法做到只更新动态库文件，因此需慎重。<br>3、配置文件整合，对于需配置文件的程序而言，在部署时需自带配置文件，或默认首次运行时生成。对于后者，有的直接在代码中固定配置，根据情况写到指定目录，使用本文，则直接将配置文件打包到二进制文件，如不存在，则再写到指定目录。<br>4、其它待探索发现并实施。  </p><p>李迟 2021.5.5 </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;趁着五一放假，趁着有时间，把欠的一些技术集中研究研究，写写文章，好给自己一个交待。&lt;br&gt;本文介绍如何在 Golang 中整合静态资源文件，将静态资源文件编译到二进制可执行文件中，这与其它程序的打包可能是一个概念，也可能不是，后续有空研究再补充。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：调用C++函数的优化</title>
    <link href="http://www.latelee.org/golang/golang-notes-call-cpulsplus-function2.html"/>
    <id>http://www.latelee.org/golang/golang-notes-call-cpulsplus-function2.html</id>
    <published>2021-05-01T16:01:00.000Z</published>
    <updated>2021-10-20T16:10:49.022Z</updated>
    
    <content type="html"><![CDATA[<p>趁着五一放假，趁着有时间，把欠的一些技术集中研究研究，写写文章，好给自己一个交待。<br>本文继续介绍如何在 Golang 中调用 C++ 函数。  </p><span id="more"></span><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>前面文章介绍的方式，在运行时需要指定动态库位置，或将动态库放置系统目录，对笔者而言，还是略有麻烦，本文将使用<code>dl</code>系列函数，在运行时加载动态库，这样就去掉了路径的依赖。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>为减少篇幅，仅摘录必要的源码。  </p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>在动态库版本源码基础上，额外添加封装动态库头文件 c_callso.h：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">int cso_init(char* soname);</span><br><span class="line"></span><br><span class="line">int cso_uninit();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 结构体指针，传入传出</span><br><span class="line">int CSetPointA(Point* point, Point* point1);</span><br><span class="line"></span><br><span class="line">// 调用内部的类</span><br><span class="line">//int FooCall(void);</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>对应实现文件主要代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;dlfcn.h&gt;</span><br><span class="line"></span><br><span class="line">void* g_sohandle = NULL;</span><br><span class="line">    </span><br><span class="line">int cso_init(char* soname)</span><br><span class="line">&#123;</span><br><span class="line">    g_sohandle = dlopen(soname, RTLD_LAZY);</span><br><span class="line">    if (g_sohandle == NULL) return -1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int cso_uninit()</span><br><span class="line">&#123;</span><br><span class="line">    if (g_sohandle != NULL) dlclose(g_sohandle);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int CSetPointA(Point* point, Point* point1)</span><br><span class="line">&#123;</span><br><span class="line">    typedef int (*ptr)(Point*, Point*);</span><br><span class="line"></span><br><span class="line">    printf(&quot;in c file call so\n&quot;);</span><br><span class="line"></span><br><span class="line">    ptr fptr = (ptr)dlsym(g_sohandle, &quot;FooSetPointA&quot;);</span><br><span class="line"></span><br><span class="line">    return (*fptr)(point, point1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，CSetPointA 函数就是对接 FooSetPointA 函数的，仅做简单的封装。  </p><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><p>Golang 测试完整代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">#cgo LDFLAGS: -ldl</span><br><span class="line"></span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &quot;c_callso.h&quot;</span><br><span class="line">#include &quot;c_callso.c&quot;</span><br><span class="line">*/</span><br><span class="line">import &quot;C&quot;</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;unsafe&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    csoname = &quot;./libfoo.so1&quot;</span><br><span class="line">    //csoname = &quot;./aXi3n0fr1.rd&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func so_test() &#123;</span><br><span class="line">    fmt.Println(&quot;go c++ so test&quot;)</span><br><span class="line">    </span><br><span class="line">    soname := C.CString(csoname)</span><br><span class="line">    ret := C.cso_init(soname)</span><br><span class="line">    if ret != 0 &#123;</span><br><span class="line">        fmt.Println(&quot;cso_init failed &quot;, ret)</span><br><span class="line">        return </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    defer C.free(unsafe.Pointer(soname))</span><br><span class="line">    defer C.cso_uninit()</span><br><span class="line"></span><br><span class="line">    // C形式 结构体</span><br><span class="line">    var myPoint, myPoint1 C.Point</span><br><span class="line">    myPoint.x = 100;</span><br><span class="line">    myPoint.y = 200;</span><br><span class="line">    myPoint.pinname = C.CString(&quot;Hello &quot;) // 指针形式</span><br><span class="line"></span><br><span class="line">    defer C.free(unsafe.Pointer(myPoint.pinname))</span><br><span class="line"></span><br><span class="line">    // 固定长度数组，麻烦点</span><br><span class="line">    arr := [16]C.char&#123;&#125;</span><br><span class="line">    mystr := &quot;Hell &quot;</span><br><span class="line">    for i := 0; i &lt; len(mystr) &amp;&amp; i &lt; 15; i++ &#123;</span><br><span class="line">        arr[i] = C.char(mystr[i])</span><br><span class="line">    &#125;</span><br><span class="line">    myPoint.inname = arr // 数组形式</span><br><span class="line"></span><br><span class="line">    fmt.Println(&quot;Golang | org struct &quot;, myPoint, &quot;single: &quot;, myPoint.x, myPoint.y, myPoint.pinname)</span><br><span class="line">    </span><br><span class="line">    // 结构体指针 传入传出</span><br><span class="line">    ret = C.CSetPointA(&amp;myPoint, &amp;myPoint1)</span><br><span class="line">    </span><br><span class="line">    // 注：C++中使用字符串数组形式，转成string</span><br><span class="line">    var carr []byte</span><br><span class="line">    //carr = C.GoBytes(myPoint1.name, 100)</span><br><span class="line">    </span><br><span class="line">    for i := range myPoint1.name &#123;</span><br><span class="line">        if myPoint1.name[i] != 0 &#123;</span><br><span class="line">            carr = append(carr, byte(myPoint1.name[i]))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    gostr := string(carr) // 转成go的string</span><br><span class="line">    fmt.Println(&quot;Golang | c++ call ret: &quot;, ret, myPoint1.x, gostr, myPoint1.name)</span><br><span class="line"></span><br><span class="line">    // 注：直接用指针形式转换，此处的指针值，与在C中申请的值，是一致的</span><br><span class="line">    // 注：如果指针没有分配内存，返回string为空，用unsafe.Pointer返回&lt;nil&gt;</span><br><span class="line">    gostr = C.GoString(myPoint1.pname)</span><br><span class="line">    defer C.free(unsafe.Pointer(myPoint1.pname))</span><br><span class="line">    </span><br><span class="line">    fmt.Println(&quot;Golang | out pointer:&quot;, gostr, unsafe.Pointer(myPoint1.pname))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    so_test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与前面文章示例不同的地方，主要是调用了 C.cso_init 初始化动态库，最终调用 cso_uninit 释放。  </p><h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><p>运行时，只需要保持动态库的位置和名称与 Golang 中指定的一致即可，无须设置 LD_LIBRARY_PATH 环境变量。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">go c++ so test</span><br><span class="line">Golang | org struct  &#123;100 200 [72 101 108 108 32 0 0 0 0 0 0 0 0 0 0 0] 0xe2fc10 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] &lt;nil&gt;&#125; single:  100 200 0xe2fc10</span><br><span class="line">in c file call so</span><br><span class="line">C++ | got buf: Hell </span><br><span class="line">C++ | pname: Hello </span><br><span class="line">C++ | ptr: 0xe2fc30</span><br><span class="line">Golang | c++ call ret:  0 101 name in c++ [110 97 109 101 32 105 110 32 99 43 43 0 0 0 0 0]</span><br><span class="line">Golang | out pointer: Hell  | name in c++ malloc 0xe2fc30</span><br></pre></td></tr></table></figure><h2 id="实践总结"><a href="#实践总结" class="headerlink" title="实践总结"></a>实践总结</h2><p>动态库初始化函数<code>cso_init</code>等保留，动态库对外提供的业务接口，尽量少，这样减少 golang 和 C++ 之间的代码接口数量。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文的方法，却增加了源码级别的复杂度，不一定都符合要求，因此仅作参考。<br>Linux 的动态库，其名称一般为 <code>libXXX.so</code>，但经测试，任意名称也是可以的。    </p><p>李迟 2021.5.2 </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;趁着五一放假，趁着有时间，把欠的一些技术集中研究研究，写写文章，好给自己一个交待。&lt;br&gt;本文继续介绍如何在 Golang 中调用 C++ 函数。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang实践录：调用C++函数</title>
    <link href="http://www.latelee.org/golang/golang-notes-call-cpulsplus-function.html"/>
    <id>http://www.latelee.org/golang/golang-notes-call-cpulsplus-function.html</id>
    <published>2021-05-01T16:00:00.000Z</published>
    <updated>2021-10-20T16:10:49.022Z</updated>
    
    <content type="html"><![CDATA[<p>趁着五一放假，趁着有时间，把欠的一些技术集中研究研究，写写文章，好给自己一个交待。<br>本文介绍如何在 Golang 中调用 C++ 函数。  </p><span id="more"></span><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>因工作需求，需要将一个工具由终端行的运行方式迁移到 web 上，核心代码由 c++ 动态库实现，另一部门的同事使用 Java 实现了一个版本，部门同事安排我做部署，由于服务器是离线的，且由专人管理，JDK 和 Tomcat 安装稍麻烦，个人操作自由度不够，——一是没有研究过 Java，二来部署麻烦。因此，决定使用 Golang 实现。预计展开的内容有：Golang 调用 C++ 动态库；Golang Web 服务及整合 html/css资源；(大)前端框架使用。  </p><p>本文主要研究 C++ 动态库及函数的调用。  </p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>Golang 只支持 C 语言的编译，对于 C++ 的编译，有2种方法：<br>1、不使用类，在 C++ 代码头文件添加<code>extern &quot;C&quot; &#123;</code>，将函数声明为 C 格式。<br>2、如出现类的情况，再用另外的文件将其封装成 C 格式函数。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="C-C-代码"><a href="#C-C-代码" class="headerlink" title="C/C++代码"></a>C/C++代码</h3><p>没有类的文件，但后缀名为cpp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// bar.h文件：</span><br><span class="line">#ifndef BAR_H</span><br><span class="line">#define BAR_H</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">int bar();</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">// bar.cpp文件：</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;bar.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int bar()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;C | hell bar\n&quot;);</span><br><span class="line">    </span><br><span class="line">    #ifdef MACRO_TEST</span><br><span class="line">    printf(&quot;C | macro...\n&quot;);</span><br><span class="line">    #endif</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有类的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// foo.h for class</span><br><span class="line"></span><br><span class="line">#ifndef FOO_H</span><br><span class="line">#define FOO_H</span><br><span class="line"></span><br><span class="line">class CFoo</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CFoo(int value): m_value(value)&#123;&#125;;</span><br><span class="line">    ~CFoo()&#123;&#125;;</span><br><span class="line">    void Bar();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int m_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">// foo.cpp</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;foo.h&quot;</span><br><span class="line"></span><br><span class="line">void CFoo::Bar(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;C++ Class | %s(): num: %d\n&quot;, __func__, m_value);</span><br><span class="line">  //std::cout&lt;&lt;this-&gt;a&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>封装代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">// foo.h</span><br><span class="line">#ifndef OUT_H</span><br><span class="line">#define OUT_H</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">typedef  struct Point&#123;</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">    char inname[16]; // 传入buff</span><br><span class="line">    char* pinname; // 传入指针</span><br><span class="line">    char name[16]; // 传出buff</span><br><span class="line">    char* pname; // 传出指针</span><br><span class="line">&#125;Point;</span><br><span class="line"></span><br><span class="line">// 普通类型赋值</span><br><span class="line">int FooSetValue(int a, unsigned int b, float c, char* str);</span><br><span class="line"></span><br><span class="line">void PrintString(char* str);</span><br><span class="line"></span><br><span class="line">// 结构体</span><br><span class="line">int FooSetPointC(Point point);</span><br><span class="line">// 结构体指针</span><br><span class="line">int FooSetPoint(Point* point);</span><br><span class="line">// 结构体指针，传入传出</span><br><span class="line">int FooSetPointA(Point* point, Point* point1);</span><br><span class="line"></span><br><span class="line">// 调用内部的类</span><br><span class="line">int FooCall(int num);</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">// out.cpp</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;out.h&quot;</span><br><span class="line">#include &quot;foo.h&quot;</span><br><span class="line"></span><br><span class="line">int FooSetValue(int a, unsigned int b, float c, char* str)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;C++ | base type: %d %d %.4f %s\n&quot;, a, b, c, str);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">void PrintString(char* str)</span><br><span class="line">&#123;</span><br><span class="line">trueprintf(&quot;C++ | string = %s\n&quot;, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int FooSetPointC(Point point)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;C++ | the point in c for value: %d %d \n&quot;,  point.x, point.y);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int FooSetPoint(Point* point)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;C++ | the point in c: %d %d \n&quot;,  point-&gt;x, point-&gt;y);</span><br><span class="line">    </span><br><span class="line">    point-&gt;x = 250;</span><br><span class="line">    point-&gt;y = 500;</span><br><span class="line">    strcpy(point-&gt;name, &quot;name in c++&quot;);</span><br><span class="line">    return 24;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int FooSetPointA(Point* point, Point* point1)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;C++ | got buf: %s\n&quot;, point-&gt;inname);</span><br><span class="line"></span><br><span class="line">    if (point-&gt;pinname != NULL) printf(&quot;C++ | pname: %s\n&quot;, point-&gt;pinname);</span><br><span class="line"></span><br><span class="line">    point1-&gt;x = point-&gt;x+1;</span><br><span class="line">    point1-&gt;y = point-&gt;y+1;</span><br><span class="line">    strcpy(point1-&gt;name, &quot;name in c++&quot;);</span><br><span class="line">    </span><br><span class="line">    point1-&gt;pname = new char[16];</span><br><span class="line">    sprintf(point1-&gt;pname, &quot;%s | name in c++ malloc&quot;, point-&gt;inname);</span><br><span class="line">    //strcpy(point1-&gt;pname, &quot;name in c++ malloc &quot;);</span><br><span class="line">    printf(&quot;C++ | ptr: %p\n&quot;, point1-&gt;pname);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int FooCall(int num)</span><br><span class="line">&#123;</span><br><span class="line">    CFoo * ret = new CFoo(num);</span><br><span class="line">    ret-&gt;Bar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用 Makefile 将上面文件编译为 libfoo.so 动态库。  </p><h3 id="动态库调用"><a href="#动态库调用" class="headerlink" title="动态库调用"></a>动态库调用</h3><p>完整测试代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">#cgo CFLAGS: -I.</span><br><span class="line">#cgo LDFLAGS: -L. -lfoo</span><br><span class="line"></span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;out.h&quot;</span><br><span class="line">*/</span><br><span class="line">import &quot;C&quot;</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;unsafe&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func so_test() &#123;</span><br><span class="line">    fmt.Println(&quot;go c++ so test&quot;)</span><br><span class="line"></span><br><span class="line">    // 简单函数调用</span><br><span class="line">    cstr := C.CString(&quot;call C func&quot;)</span><br><span class="line">    defer C.free(unsafe.Pointer(cstr))</span><br><span class="line">    var i C.int</span><br><span class="line">    i = 100</span><br><span class="line">    C.FooSetValue(i, C.uint(250), C.float(3.14159), cstr)</span><br><span class="line">    C.PrintString(cstr);</span><br><span class="line"></span><br><span class="line">    // C形式 结构体</span><br><span class="line">    var myPoint, myPoint1 C.Point</span><br><span class="line">    myPoint.x = 100;</span><br><span class="line">    myPoint.y = 200;</span><br><span class="line">    myPoint.pinname = C.CString(&quot;Hello &quot;) // 指针形式</span><br><span class="line"></span><br><span class="line">    defer C.free(unsafe.Pointer(myPoint.pinname))</span><br><span class="line"></span><br><span class="line">    // 固定长度数组，麻烦点</span><br><span class="line">    arr := [16]C.char&#123;&#125;</span><br><span class="line">    mystr := &quot;Hell &quot;</span><br><span class="line">    for i := 0; i &lt; len(mystr) &amp;&amp; i &lt; 15; i++ &#123;</span><br><span class="line">        arr[i] = C.char(mystr[i])</span><br><span class="line">    &#125;</span><br><span class="line">    myPoint.inname = arr // 数组形式</span><br><span class="line"></span><br><span class="line">    fmt.Println(&quot;Golang | org struct &quot;, myPoint, &quot;single: &quot;, myPoint.x, myPoint.y, myPoint.pinname)</span><br><span class="line">    </span><br><span class="line">    // 结构体传值</span><br><span class="line">    C.FooSetPointC(myPoint)</span><br><span class="line">    </span><br><span class="line">    // 结构体指针 传入传出</span><br><span class="line">    ret := C.FooSetPointA(&amp;myPoint, &amp;myPoint1)</span><br><span class="line">    </span><br><span class="line">    // 注：C++中使用字符串数组形式，转成string</span><br><span class="line">    var carr []byte</span><br><span class="line">    //carr = C.GoBytes(myPoint1.name, 16)</span><br><span class="line">    </span><br><span class="line">    for i := range myPoint1.name &#123;</span><br><span class="line">        if myPoint1.name[i] != 0 &#123;</span><br><span class="line">            carr = append(carr, byte(myPoint1.name[i]))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    gostr := string(carr) // 转成go的string</span><br><span class="line">    fmt.Println(&quot;Golang | c++ call ret: &quot;, ret, myPoint1.x, gostr, myPoint1.name)</span><br><span class="line"></span><br><span class="line">    // 注：直接用指针形式转换，此处的指针值，与在C中申请的值，是一致的</span><br><span class="line">    // 注：如果指针没有分配内存，返回string为空，用unsafe.Pointer返回&lt;nil&gt;</span><br><span class="line">    gostr = C.GoString(myPoint1.pname)</span><br><span class="line">    defer C.free(unsafe.Pointer(myPoint1.pname))</span><br><span class="line">    </span><br><span class="line">    fmt.Println(&quot;Golang | out pointer:&quot;, gostr, unsafe.Pointer(myPoint1.pname))</span><br><span class="line"></span><br><span class="line">    C.FooCall(250)</span><br><span class="line">    C.FooCall(C.int(250))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    so_test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码要点如下：<br>1、需设置编译参数 LDFLAGS，指定库位置和名称，本例中是当前目录的 libfoo.so。<br>2、需包含相应的头文件，stdlib.h 为 free 函数所在文件。<br>3、内嵌的 C 源码在包的前面，且<code>import &quot;C&quot;</code>后需空一行。<br>4、传递到 C 函数的内存，使用<code>C.CString</code>申请，C 申请的内存使用<code>C.GoString</code>获取，均需要手动释放。  </p><h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><p>在运行前，需要设置动态库路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$PWD</span><br></pre></td></tr></table></figure><p>否则运行时无法找到动态库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test: error while loading shared libraries: libfoo.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">go c++ so test</span><br><span class="line">C++ | base type: 100 250 3.1416 call C func</span><br><span class="line">C++ | string = call C func</span><br><span class="line">Golang | org struct  &#123;100 200 [72 101 108 108 32 0 0 0 0 0 0 0 0 0 0 0] 0x25b2a30 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] &lt;nil&gt;&#125; single:  100 200 0x25b2a30</span><br><span class="line">C++ | the point in c for value: 100 200 </span><br><span class="line">C++ | got buf: Hell </span><br><span class="line">C++ | pname: Hello </span><br><span class="line">C++ | ptr: 0x25b2a50</span><br><span class="line">Golang | c++ call ret:  0 101 name in c++ [110 97 109 101 32 105 110 32 99 43 43 0 0 0 0 0]</span><br><span class="line">Golang | out pointer: Hell  | name in c++ malloc 0x25b2a50</span><br><span class="line">C++ Class | Bar(): num: 250</span><br><span class="line">C++ Class | Bar(): num: 250</span><br></pre></td></tr></table></figure><p>从上述结果中可看出，C 中申请的内存，其指针与在 Go 中获取的指针是一样的，即 0x25b2a50。结构体中的 nil 是因为字段 pname 未赋值。  </p><h3 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h3><p>前面的动态库代码，不能全部内嵌到 Go 代码中，因此选取其中的 bar.h/cpp，测试代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">#cgo CFLAGS: -I. -DMACRO_TEST</span><br><span class="line"></span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;bar.h&quot;</span><br><span class="line">#include &quot;bar.cpp&quot;</span><br><span class="line">*/</span><br><span class="line">import &quot;C&quot;</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;  </span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func cpp_test() &#123;</span><br><span class="line">    fmt.Println(&quot;go c++ so test&quot;)</span><br><span class="line">    C.bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    cpp_test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码要点：<br>1、可用 CFLAGS 指定头文件，添加宏定义等。<br>2、将所有的 C 源码包含到代码中。（存疑：似乎应该是头文件，在编译过程中自动找对应的实现文件，这里包含进来，相当于所有源码都在 Go 代码中）  </p><h3 id="结果分析-1"><a href="#结果分析-1" class="headerlink" title="结果分析"></a>结果分析</h3><p>运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go c++ so test</span><br><span class="line">C | hell bar</span><br><span class="line">C | macro...</span><br></pre></td></tr></table></figure><p>使用此方法，如果修改 C 代码，还需更新包含 C 代码的 go 文件，否则不会被编译。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面对2种形式的调用进行了实践，在功能和使用上各有千秋，对于简单的 C 语言代码（包含C++形式的简单函数），直接使用内嵌的形式会更高效。<br>本文使用的动态库例子，在运行前还需要设置运行路径，当然可以将动态库放到系统目录的，但笔者认为不是正道，下面将去掉动态库路径的依赖。  </p><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>Go 编译时，如果包含有类的文件，编译失败，出错信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">In file included from ./bar.cpp:2:0,</span><br><span class="line">                 from ./main_one.go:17:</span><br><span class="line">./foo.h:6:1: error: unknown type name &#x27;class&#x27;</span><br><span class="line"> class CFoo</span><br><span class="line"> ^</span><br><span class="line">./foo.h:7:1: error: expected &#x27;=&#x27;, &#x27;,&#x27;, &#x27;;&#x27;, &#x27;asm&#x27; or &#x27;__attribute__&#x27; before &#x27;&#123;&#x27; token</span><br><span class="line"> &#123;</span><br><span class="line"> ^</span><br><span class="line">In file included from ./main_one.go:17:0:</span><br><span class="line">./bar.cpp: In function &#x27;FooCall1&#x27;:</span><br><span class="line">./bar.cpp:18:5: error: unknown type name &#x27;CFoo&#x27;</span><br><span class="line">     CFoo * ret = new CFoo(num);</span><br><span class="line">     ^</span><br><span class="line">./bar.cpp:18:18: error: &#x27;new&#x27; undeclared (first use in this function)</span><br><span class="line">     CFoo * ret = new CFoo(num);</span><br><span class="line">                  ^</span><br><span class="line">./bar.cpp:18:18: note: each undeclared identifier is reported only once for each function it appears in</span><br><span class="line">./bar.cpp:18:22: error: expected &#x27;,&#x27; or &#x27;;&#x27; before &#x27;CFoo&#x27;</span><br><span class="line">     CFoo * ret = new CFoo(num);</span><br><span class="line">                      ^</span><br><span class="line">./bar.cpp:19:8: error: request for member &#x27;Bar&#x27; in something not a structure or union</span><br><span class="line">     ret-&gt;Bar();</span><br></pre></td></tr></table></figure><p>李迟 2021.5.2 </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;趁着五一放假，趁着有时间，把欠的一些技术集中研究研究，写写文章，好给自己一个交待。&lt;br&gt;本文介绍如何在 Golang 中调用 C++ 函数。  &lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://www.latelee.org/category/golang/"/>
    
    
    <category term="golang" scheme="http://www.latelee.org/tag/golang/"/>
    
  </entry>
  
</feed>
